schema {
  subscription: RootSubscriptionType
  mutation: RootMutationType
  query: RootQueryType
}

type RootQueryType {
  configuration: ConsoleConfiguration

  externalToken: String

  builds(after: String, first: Int, before: String, last: Int): BuildConnection

  build(id: ID!): Build

  buildInfo: BuildInfo

  user(email: String!): User

  group(name: String!): Group

  users(after: String, first: Int, before: String, last: Int, q: String): UserConnection

  serviceAccounts(after: String, first: Int, before: String, last: Int, q: String): UserConnection

  loginInfo(redirect: String): LoginInfo

  me: User

  invite(id: String!): Invite

  groups(after: String, first: Int, before: String, last: Int, q: String): GroupConnection

  groupMembers(after: String, first: Int, before: String, last: Int, groupId: ID!): GroupMemberConnection

  role: Role

  roles(after: String, first: Int, before: String, last: Int, q: String): RoleConnection

  notifications(after: String, first: Int, before: String, last: Int, all: Boolean): NotificationConnection

  temporaryToken: String

  accessTokens(after: String, first: Int, before: String, last: Int): AccessTokenConnection

  accessToken(id: ID!): AccessToken

  persona(id: ID!): Persona

  personas(after: String, first: Int, before: String, last: Int): PersonaConnection

  refreshTokens(after: String, first: Int, before: String, last: Int): RefreshTokenConnection

  refresh(token: String!): User

  dashboards(repo: String!): [Dashboard]

  dashboard(repo: String!, name: String!, step: String, offset: Int, labels: [LabelInput]): Dashboard

  metric(query: String!, offset: Int, step: String, clusterId: ID): [MetricResponse]

  logs(query: String!, start: Long, end: Long, limit: Int!, clusterId: ID): [LogStream]

  scalingRecommendation(kind: AutoscalingTarget!, namespace: String!, name: String!): VerticalPodAutoscaler

  configMap(serviceId: ID, namespace: String!, name: String!): ConfigMap

  secret(serviceId: ID, namespace: String!, name: String!): Secret

  configMaps(namespace: String!): [ConfigMap]

  secrets(namespace: String!): [Secret]

  pluralCluster(namespace: String!, name: String!, serviceId: ID): PluralCluster

  pluralServiceDeployment(namespace: String!, name: String!, serviceId: ID): PluralServiceDeployment

  pluralGitRepository(namespace: String!, name: String!, serviceId: ID): PluralGitRepository

  unstructuredResource(group: String, version: String!, kind: String!, namespace: String, name: String!, serviceId: ID): KubernetesUnstructured

  service(namespace: String!, name: String!, serviceId: ID): Service

  clusterInfo: ClusterInfo

  deployment(namespace: String!, name: String!, serviceId: ID): Deployment

  statefulSet(namespace: String!, name: String!, serviceId: ID): StatefulSet

  daemonSet(namespace: String!, name: String!, serviceId: ID): DaemonSet

  ingress(namespace: String!, name: String!, serviceId: ID): Ingress

  nodes: [Node]

  node(name: String!, clusterId: ID): Node

  cronJob(namespace: String!, name: String!, serviceId: ID): CronJob

  job(namespace: String!, name: String!, serviceId: ID): Job

  certificate(namespace: String!, name: String!, serviceId: ID): Certificate

  pod(namespace: String!, name: String!, serviceId: ID, clusterId: ID): Pod

  pods(after: String, first: Int, before: String, last: Int, namespace: String, namespaces: [String], clusterId: ID): PodConnection

  wireguardPeers: [WireguardPeer]

  myWireguardPeers: [WireguardPeer]

  wireguardPeer(name: String!): WireguardPeer

  cachedPods(namespaces: [String]): [Pod]

  namespaces(clusterId: ID): [Namespace]

  logFilters(namespace: String!): [LogFilter]

  nodeMetrics(clusterId: ID): [NodeMetric]

  nodeMetric(name: String!, clusterId: ID): NodeMetric

  canary(namespace: String!, name: String!, serviceId: ID): Canary

  argoRollout(namespace: String!, name: String!, serviceId: ID): ArgoRollout

  upgradePlan(namespace: String!, name: String!, serviceId: ID): UpgradePlan

  configurationOverlays(namespace: String!): [ConfigurationOverlay]

  audits(after: String, first: Int, before: String, last: Int, repo: String): AuditConnection

  auditMetrics: [AuditMetric]

  ai(prompt: String!): String

  account: Account

  installations(after: String, first: Int, before: String, last: Int): InstallationConnection

  applications: [Application]

  application(name: String!): Application

  repository(name: String!): Repository

  repositories(after: String, first: Int, before: String, last: Int, query: String!): RepositoryConnection

  recipes(after: String, first: Int, before: String, last: Int, id: ID!): RecipeConnection

  context: [RepositoryContext]

  pluralContext: PluralContext

  recipe(id: ID!): Recipe

  stack(name: String!): Stack

  smtp: Smtp

  upgradePolicies: [UpgradePolicy]

  runbook(namespace: String!, name: String!): Runbook

  runbooks(namespace: String!, pinned: Boolean): [Runbook]

  webhooks(after: String, first: Int, before: String, last: Int): WebhookConnection

  postgresDatabases: [Postgresql]

  postgresDatabase(namespace: String!, name: String!): Postgresql

  gitRepository(id: ID, url: String): GitRepository

  gitRepositories(after: String, first: Int, before: String, last: Int): GitRepositoryConnection

  helmRepositories(after: String, first: Int, before: String, last: Int): HelmRepositoryConnection

  helmRepository(url: String!): HelmRepository

  fluxHelmRepositories: [FluxHelmRepository]

  fluxHelmRepository(name: String!, namespace: String!): FluxHelmRepository

  scmConnections(after: String, first: Int, before: String, last: Int): ScmConnectionConnection

  scmConnection(id: ID, name: String): ScmConnection

  prAutomations(after: String, first: Int, before: String, last: Int, catalogId: ID, projectId: ID, q: String): PrAutomationConnection

  prAutomation(id: ID, name: String): PrAutomation

  pullRequests(
    after: String, first: Int, before: String, last: Int, clusterId: ID, serviceId: ID, open: Boolean, q: String
  ): PullRequestConnection

  scmWebhooks(after: String, first: Int, before: String, last: Int): ScmWebhookConnection

  dependencyManagementServices(after: String, first: Int, before: String, last: Int): DependencyManagementServiceConnection

  observer(id: ID, name: String): Observer

  observers(after: String, first: Int, before: String, last: Int, projectId: ID): ObserverConnection

  catalog(id: ID, name: String): Catalog

  catalogs(after: String, first: Int, before: String, last: Int, projectId: ID): CatalogConnection

  "exchanges a kubeconfig token for user info"
  tokenExchange(token: String!): User

  "a relay connection of all clusters visible to the current user"
  clusters(
    after: String, first: Int, before: String, last: Int, q: String, healthy: Boolean, tag: TagInput, tagQuery: TagQuery, backups: Boolean, projectId: ID, parentId: ID
  ): ClusterConnection

  "gets summary information for all healthy\/unhealthy clusters in your fleet"
  clusterStatuses(q: String, tag: TagInput, projectId: ID): [ClusterStatusInfo]

  "gets summary information for upgradeability in your fleet"
  upgradeStatistics(q: String, tag: TagInput, projectId: ID): UpgradeStatistics

  "lists tags applied to any clusters in the fleet"
  tags(tag: String): [String]

  "adds the ability to search\/filter through all tag name\/value pairs"
  tagPairs(
    after: String

    first: Int

    before: String

    last: Int

    "the variant of tag you're querying"
    type: TagType

    "only return tags with name==tag"
    tag: String

    "search for tags with q as a substring in name or value"
    q: String
  ): TagConnection

  "a relay connection of all providers visible to the current user"
  clusterProviders(after: String, first: Int, before: String, last: Int): ClusterProviderConnection

  "fetches an individual cluster"
  cluster(id: ID, handle: String): Cluster

  "fetches an individual cluster provider"
  clusterProvider(id: ID, cloud: String, name: String): ClusterProvider

  "list all addons currently resident in the artifacts repo"
  clusterAddOns: [ClusterAddOn]

  "fetch an individual runtime service for more thorough detail views"
  runtimeService(id: ID!): RuntimeService

  serviceDeployments(
    after: String

    first: Int

    before: String

    last: Int

    clusterId: ID

    q: String

    status: ServiceDeploymentStatus

    errored: Boolean

    "a project to filter services w\/in"
    projectId: ID

    "the handle of the cluster for this service"
    cluster: String
  ): ServiceDeploymentConnection

  "Renders a filtered list of services and all their descendents returned as a paginated connection"
  serviceTree(
    after: String

    first: Int

    before: String

    last: Int

    clusterId: ID

    q: String

    status: ServiceDeploymentStatus

    errored: Boolean

    "a project to filter services w\/in"
    projectId: ID
  ): ServiceDeploymentConnection

  serviceStatuses(clusterId: ID, q: String, status: ServiceDeploymentStatus, projectId: ID): [ServiceStatusCount]

  serviceContext(name: String!): ServiceContext

  "renders a full hierarchy of resources recursively owned by this component (useful for CRD views)"
  componentTree(
    "the id of the service component for the tree view"
    id: ID!
  ): ComponentTree

  "request manifests from an agent, to be returned by a future call to fetchManifests"
  requestManifests(id: ID!): ServiceDeployment

  "Fetches the manifests from cache once the agent has given us them, will be null otherwise"
  fetchManifests(id: ID!): [String]

  pipelines(after: String, first: Int, before: String, last: Int, q: String, projectId: ID): PipelineConnection

  pipeline(id: ID!): Pipeline

  pipelineGate(id: ID!): PipelineGate

  pipelineContext(id: ID!): PipelineContext

  clusterBackup(id: ID, clusterId: ID, namespace: String, name: String): ClusterBackup

  clusterBackups(after: String, first: Int, before: String, last: Int, clusterId: ID!): ClusterBackupConnection

  clusterRestores(after: String, first: Int, before: String, last: Int, clusterId: ID!): ClusterRestoreConnection

  objectStores(after: String, first: Int, before: String, last: Int): ObjectStoreConnection

  "the services deployed in the current cluster, to be polled by the deploy operator"
  clusterServices: [ServiceDeployment]

  pagedClusterServices(after: String, first: Int, before: String, last: Int): ServiceDeploymentConnection

  "fetches details of this service deployment, and can be called by the deploy operator"
  serviceDeployment(
    id: ID

    "the handle of the cluster for this service"
    cluster: String

    name: String
  ): ServiceDeployment

  "tells you what cluster a deploy token points to"
  myCluster: Cluster

  clusterGates: [PipelineGate]

  pagedClusterGates(after: String, first: Int, before: String, last: Int): PipelineGateConnection

  clusterGate(id: ID!): PipelineGate

  clusterRestore(id: ID!): ClusterRestore

  notificationSink(name: String, id: ID): NotificationSink

  notificationRouter(name: String, id: ID): NotificationRouter

  notificationSinks(after: String, first: Int, before: String, last: Int, q: String): NotificationSinkConnection

  notificationRouters(after: String, first: Int, before: String, last: Int, q: String): NotificationRouterConnection

  appNotifications(after: String, first: Int, before: String, last: Int): AppNotificationConnection

  unreadAppNotifications: Int

  policyConstraints(
    after: String, first: Int, before: String, last: Int, kind: String, namespace: String, kinds: [String], namespaces: [String], clusters: [ID], violated: Boolean, q: String
  ): PolicyConstraintConnection

  vulnerabilityReports(after: String, first: Int, before: String, last: Int, clusters: [ID], q: String): VulnerabilityReportConnection

  violationStatistics(field: ConstraintViolationField!): [ViolationStatistic]

  policyStatistics(
    aggregate: PolicyAggregate!, kind: String, namespace: String, kinds: [String], namespaces: [String], clusters: [ID], q: String
  ): [PolicyStatistic]

  policyConstraint(id: ID!): PolicyConstraint

  vulnerabilityReport(id: ID!): VulnerabilityReport

  managedNamespaces(after: String, first: Int, before: String, last: Int, projectId: ID): ManagedNamespaceConnection

  globalService(id: ID!): GlobalService

  globalServices(after: String, first: Int, before: String, last: Int, projectId: ID): GlobalServiceConnection

  clusterManagedNamespaces(after: String, first: Int, before: String, last: Int): ManagedNamespaceConnection

  managedNamespace(id: ID, name: String): ManagedNamespace

  customStackRun(id: ID!): CustomStackRun

  clusterStackRuns(after: String, first: Int, before: String, last: Int): StackRunConnection

  stackRun(id: ID!): StackRun

  infrastructureStack(id: ID, name: String): InfrastructureStack

  stackDefinition(id: ID!): StackDefinition

  stackDefinitions(after: String, first: Int, before: String, last: Int): StackDefinitionConnection

  infrastructureStacks(
    after: String, first: Int, before: String, last: Int, q: String, projectId: ID, tagQuery: TagQuery
  ): InfrastructureStackConnection

  observabilityProvider(id: ID, name: String): ObservabilityProvider

  observabilityProviders(after: String, first: Int, before: String, last: Int): ObservabilityProviderConnection

  observabilityWebhook(id: ID, name: String): ObservabilityWebhook

  observabilityWebhooks(after: String, first: Int, before: String, last: Int): ObservabilityWebhookConnection

  deploymentSettings: DeploymentSettings

  projects(after: String, first: Int, before: String, last: Int, q: String): ProjectConnection

  project(id: ID, name: String): Project

  "General api to query the configured LLM for your console"
  aiCompletion(
    "the initial system prompt to use for this completion"
    system: String!

    "the actual user-provided prompt to give to the underlying LLM"
    input: String

    "a list of chat prompts to give to the llm"
    chat: [ChatMessage]
  ): String

  "Use the content of an insight and additional context from its associated object to suggest a fix"
  aiSuggestedFix(
    "the ai insight you want to suggest a fix for"
    insightId: ID!
  ): String

  "gets an individual chat thread, with the ability to sideload chats on top"
  chatThread(id: ID!): ChatThread

  "gets the chat history from prior AI chat sessions"
  chats(after: String, first: Int, before: String, last: Int, threadId: ID): ChatConnection

  clusterInsightComponent(id: ID!): ClusterInsightComponent

  chatThreads(after: String, first: Int, before: String, last: Int): ChatThreadConnection

  aiPins(after: String, first: Int, before: String, last: Int): AiPinConnection

  aiPin(insightId: ID, threadId: ID): AiPin
}

type RootMutationType {
  createBuild(attributes: BuildAttributes!): Build

  restartBuild(id: ID!): Build

  cancelBuild(id: ID!): Build

  approveBuild(id: ID!): Build

  signIn(email: String!, password: String!): User

  logout: User

  loginLink(key: String!): User

  readNotifications: User

  signup(inviteId: String!, attributes: UserAttributes!): User

  oauthCallback(code: String!, redirect: String): User

  createInvite(attributes: InviteAttributes!): Invite

  createServiceAccount(attributes: ServiceAccountAttributes!): User

  updateServiceAccount(id: ID!, attributes: ServiceAccountAttributes!): User

  updateUser(id: ID, attributes: UserAttributes!): User

  deleteUser(id: ID!): User

  impersonateServiceAccount(email: String!): User

  markRead(type: ReadType): User

  createGroup(attributes: GroupAttributes!): Group

  deleteGroup(groupId: ID!): Group

  updateGroup(groupId: ID!, attributes: GroupAttributes!): Group

  createGroupMember(groupId: ID!, userId: ID!): GroupMember

  deleteGroupMember(groupId: ID!, userId: ID!): GroupMember

  createRole(attributes: RoleAttributes!): Role

  updateRole(id: ID!, attributes: RoleAttributes!): Role

  deleteRole(id: ID!): Role

  createAccessToken(scopes: [ScopeAttributes]): AccessToken

  createServiceAccountToken(id: ID!, scopes: [ScopeAttributes]): AccessToken

  deleteAccessToken(token: String!): AccessToken

  createPersona(attributes: PersonaAttributes!): Persona

  updatePersona(id: ID!, attributes: PersonaAttributes!): Persona

  deletePersona(id: ID!): Persona

  deleteCertificate(name: String!, namespace: String!): Boolean

  deletePod(namespace: String!, name: String!, serviceId: ID): Pod

  deleteJob(namespace: String!, name: String!, serviceId: ID): Job

  deleteNode(name: String!): Node

  overlayConfiguration(namespace: String!, context: Map!): Build

  createPeer(userId: ID, email: String, name: String!): WireguardPeer

  deletePeer(name: String!): Boolean

  installRecipe(id: ID!, context: Map!, oidc: Boolean): Build

  installStack(name: String!, context: ContextAttributes!, oidc: Boolean): Build

  updateSmtp(smtp: SmtpInput!): Smtp

  updateConfiguration(repository: String!, content: String!, tool: Tool, message: String): Configuration

  createUpgradePolicy(attributes: UpgradePolicyAttributes!): UpgradePolicy

  deleteUpgradePolicy(id: ID!): UpgradePolicy

  executeRunbook(namespace: String!, name: String!, input: RunbookActionInput!): RunbookActionResponse

  createWebhook(attributes: WebhookAttributes!): Webhook

  deleteWebhook(id: ID!): Webhook

  restorePostgres(namespace: String!, name: String!, timestamp: DateTime!, clone: CloneAttributes): Postgresql

  createGitRepository(attributes: GitAttributes!): GitRepository

  updateGitRepository(id: ID!, attributes: GitAttributes!): GitRepository

  deleteGitRepository(id: ID!): GitRepository

  createScmConnection(attributes: ScmConnectionAttributes!): ScmConnection

  updateScmConnection(id: ID!, attributes: ScmConnectionAttributes!): ScmConnection

  deleteScmConnection(id: ID!): ScmConnection

  createScmWebhook(connectionId: ID!, owner: String!): ScmWebhook

  deleteScmWebhook(id: ID!): ScmWebhook

  "creates a webhook reference in our system but doesn't attempt to create it in your upstream provider"
  createScmWebhookPointer(attributes: ScmWebhookAttributes!): ScmWebhook

  createPrAutomation(attributes: PrAutomationAttributes!): PrAutomation

  updatePrAutomation(id: ID!, attributes: PrAutomationAttributes!): PrAutomation

  deletePrAutomation(id: ID!): PrAutomation

  "creates the service to enable self-hosted renovate in one pass"
  setupRenovate(
    connectionId: ID!

    repos: [String]

    "the name of the owning service"
    name: String

    "the namespace of the owning service"
    namespace: String
  ): ServiceDeployment

  reconfigureRenovate(repos: [String], serviceId: ID!): ServiceDeployment

  createPullRequest(
    "the id of the PR automation instance to use"
    id: ID!

    identifier: String

    branch: String

    context: Json
  ): PullRequest

  "just registers a pointer record to a PR after it was created externally be some other automation"
  createPullRequestPointer(attributes: PullRequestAttributes): PullRequest

  updatePullRequest(id: ID!, attributes: PullRequestUpdateAttributes): PullRequest

  deletePullRequest(id: ID!): PullRequest

  upsertHelmRepository(url: String!, attributes: HelmRepositoryAttributes): HelmRepository

  upsertObserver(attributes: ObserverAttributes): Observer

  deleteObserver(id: ID!): Observer

  upsertCatalog(attributes: CatalogAttributes): Catalog

  deleteCatalog(id: ID!): Catalog

  createCluster(attributes: ClusterAttributes!): Cluster

  updateCluster(id: ID!, attributes: ClusterUpdateAttributes!): Cluster

  deleteCluster(id: ID!): Cluster

  "soft deletes a cluster, by deregistering it in our system but not disturbing any kubernetes objects"
  detachCluster(id: ID!): Cluster

  createClusterProvider(attributes: ClusterProviderAttributes!): ClusterProvider

  updateClusterProvider(id: ID!, attributes: ClusterProviderUpdateAttributes!): ClusterProvider

  deleteClusterProvider(id: ID!): ClusterProvider

  createProviderCredential(attributes: ProviderCredentialAttributes!, name: String!): ProviderCredential

  deleteProviderCredential(id: ID!): ProviderCredential

  installAddOn(name: String!, configuration: [ConfigAttributes], clusterId: ID!, global: GlobalServiceAttributes): ServiceDeployment

  createAgentMigration(attributes: AgentMigrationAttributes!): AgentMigration

  createPinnedCustomResource(attributes: PinnedCustomResourceAttributes!): PinnedCustomResource

  deletePinnedCustomResource(id: ID!): PinnedCustomResource

  createServiceDeployment(
    clusterId: ID

    "the handle of the cluster for this service"
    cluster: String

    attributes: ServiceDeploymentAttributes!
  ): ServiceDeployment

  updateServiceDeployment(
    id: ID

    "the handle of the cluster for this service"
    cluster: String

    name: String

    attributes: ServiceUpdateAttributes!
  ): ServiceDeployment

  deleteServiceDeployment(id: ID!): ServiceDeployment

  "removes a service from storage, but bypasses waiting for the agent to fully drain it from its hosting cluster"
  detachServiceDeployment(id: ID!): ServiceDeployment

  "merges configuration for a service"
  mergeService(id: ID!, configuration: [ConfigAttributes]): ServiceDeployment

  "rewires this service to use the given revision id"
  rollbackService(
    id: ID

    "the handle of the cluster for this service"
    cluster: String

    name: String

    revisionId: ID!
  ): ServiceDeployment

  "clones the spec of the given service to be deployed either into a new namespace or new cluster"
  cloneService(
    serviceId: ID

    "the handle of the cluster for this service"
    cluster: String

    name: String

    clusterId: ID!

    attributes: ServiceCloneAttributes!
  ): ServiceDeployment

  kickService(
    serviceId: ID

    "the handle of the cluster for this service"
    cluster: String

    name: String
  ): ServiceDeployment

  selfManage(values: String!): ServiceDeployment

  "marks a service as being able to proceed to the next stage of a canary rollout"
  proceed(
    id: ID

    "the handle of the cluster for this service"
    cluster: String

    name: String

    promotion: ServicePromotion
  ): ServiceDeployment

  saveServiceContext(name: String!, attributes: ServiceContextAttributes!): ServiceContext

  deleteServiceContext(id: ID!): ServiceContext

  "upserts a pipeline with a given name"
  savePipeline(name: String!, attributes: PipelineAttributes!): Pipeline

  "creates a new pipeline context and binds it to the beginning stage"
  createPipelineContext(pipelineId: ID!, attributes: PipelineContextAttributes!): PipelineContext

  deletePipeline(id: ID!): Pipeline

  "approves an approval pipeline gate"
  approveGate(id: ID!): PipelineGate

  "forces a pipeline gate to be in open state"
  forceGate(id: ID!, state: GateState): PipelineGate

  createObjectStore(attributes: ObjectStoreAttributes!): ObjectStore

  updateObjectStore(id: ID!, attributes: ObjectStoreAttributes!): ObjectStore

  deleteObjectStore(id: ID!): ObjectStore

  configureBackups(clusterId: ID!, storeId: ID!): Cluster

  delinkBackups(clusterId: ID!): Cluster

  createClusterRestore(backupId: ID!): ClusterRestore

  "a regular status ping to be sent by the deploy operator"
  pingCluster(attributes: ClusterPing!): Cluster

  "registers a list of runtime services discovered for the current cluster"
  registerRuntimeServices(services: [RuntimeServiceAttributes], serviceId: ID): Int

  "agent api to persist upgrade insights for its cluster"
  saveUpgradeInsights(insights: [UpgradeInsightAttributes]): [UpgradeInsight]

  upsertVirtualCluster(attributes: ClusterAttributes!, parentId: ID!): Cluster

  deleteVirtualCluster(id: ID!): Cluster

  "updates only the components of a given service, to be sent after deploy operator syncs"
  updateServiceComponents(
    id: ID!, components: [ComponentAttributes], revisionId: ID, sha: String, errors: [ServiceErrorAttributes]
  ): ServiceDeployment

  "save the manifests in cache to be retrieved by the requesting user"
  saveManifests(id: ID!, manifests: [String]): Boolean

  updateGate(id: ID!, attributes: GateUpdateAttributes!): PipelineGate

  "upserts a cluster backup resource"
  createClusterBackup(attributes: BackupAttributes!): ClusterBackup

  updateClusterRestore(id: ID!, attributes: RestoreAttributes!): ClusterRestore

  upsertNotificationSink(attributes: NotificationSinkAttributes!): NotificationSink

  deleteNotificationSink(id: ID!): NotificationSink

  upsertNotificationRouter(attributes: NotificationRouterAttributes!): NotificationRouter

  deleteNotificationRouter(id: ID!): NotificationRouter

  readAppNotifications: Int

  "Shares a one-time-viewable secret to a list of eligible users"
  shareSecret(attributes: SharedSecretAttributes!): SharedSecret

  "Reads and deletes a given shared secret"
  consumeSecret(
    "The high-entropy handle of this secret"
    handle: String!
  ): SharedSecret

  upsertPolicyConstraints(constraints: [PolicyConstraintAttributes]): Int

  upsertVulnerabilities(vulnerabilities: [VulnerabilityReportAttributes]): Int

  createGlobalService(
    serviceId: ID

    "the handle of the cluster for this service"
    cluster: String

    name: String

    attributes: GlobalServiceAttributes!
  ): GlobalService

  updateGlobalService(id: ID!, attributes: GlobalServiceAttributes!): GlobalService

  deleteGlobalService(id: ID!): GlobalService

  syncGlobalService(id: ID!): GlobalService

  createManagedNamespace(attributes: ManagedNamespaceAttributes!): ManagedNamespace

  updateManagedNamespace(id: ID!, attributes: ManagedNamespaceAttributes!): ManagedNamespace

  deleteManagedNamespace(id: ID!): ManagedNamespace

  updateStackRun(id: ID!, attributes: StackRunAttributes!): StackRun

  completeStackRun(id: ID!, attributes: StackRunAttributes!): StackRun

  updateRunStep(id: ID!, attributes: RunStepAttributes!): RunStep

  addRunLogs(stepId: ID!, attributes: RunLogAttributes!): RunLogs

  createStack(attributes: StackAttributes!): InfrastructureStack

  updateStack(id: ID!, attributes: StackAttributes!): InfrastructureStack

  deleteStack(id: ID!): InfrastructureStack

  detachStack(id: ID!): InfrastructureStack

  "refresh the source repo of this stack, and potentially create a fresh run"
  kickStack(id: ID!): StackRun

  "refresh the source repo of this stack, and potentially create a fresh run for this pr"
  kickStackPullRequest(id: ID!): StackRun

  approveStackRun(id: ID!): StackRun

  restartStackRun(id: ID!): StackRun

  createCustomStackRun(attributes: CustomStackRunAttributes!): CustomStackRun

  updateCustomStackRun(id: ID!, attributes: CustomStackRunAttributes!): CustomStackRun

  deleteCustomStackRun(id: ID!): CustomStackRun

  createStackDefinition(attributes: StackDefinitionAttributes!): StackDefinition

  updateStackDefinition(id: ID!, attributes: StackDefinitionAttributes!): StackDefinition

  deleteStackDefinition(id: ID!): StackDefinition

  "Creates a custom run, with the given command list, to execute w\/in the stack's environment"
  onDemandRun(stackId: ID!, commands: [CommandAttributes], context: Json): StackRun

  "start a new run from the newest sha in the stack's run history"
  triggerRun(id: ID!): StackRun

  upsertObservabilityProvider(attributes: ObservabilityProviderAttributes!): ObservabilityProvider

  deleteObservabilityProvider(id: ID!): ObservabilityProvider

  upsertObservabilityWebhook(attributes: ObservabilityWebhookAttributes!): ObservabilityWebhook

  deleteObservabilityWebhook(id: ID!): ObservabilityWebhook

  updateDeploymentSettings(attributes: DeploymentSettingsAttributes!): DeploymentSettings

  enableDeployments: DeploymentSettings

  createProject(attributes: ProjectAttributes!): Project

  updateProject(id: ID!, attributes: ProjectAttributes!): Project

  deleteProject(id: ID!): Project

  createOidcProvider(type: OidcProviderType!, attributes: OidcProviderAttributes!): OidcProvider

  updateOidcProvider(type: OidcProviderType!, id: ID!, attributes: OidcProviderAttributes!): OidcProvider

  deleteOidcProvider(type: OidcProviderType!, id: ID!): OidcProvider

  "a reusable mutation for updating rbac settings on core services"
  updateRbac(
    rbac: RbacAttributes!, serviceId: ID, clusterId: ID, providerId: ID, pipelineId: ID, stackId: ID, projectId: ID
  ): Boolean

  "saves a list of chat messages to your current chat history, can be used at any time"
  saveChats(threadId: ID, messages: [ChatMessage]): [Chat]

  "saves a set of messages and generates a new one transactionally"
  chat(threadId: ID, messages: [ChatMessage]): Chat

  "Wipes your current chat history blank"
  clearChatHistory(
    threadId: ID

    "deletes all chats with seq less than or equal to this integer"
    before: Int
  ): Int

  createThread(attributes: ChatThreadAttributes!): ChatThread

  updateThread(id: ID!, attributes: ChatThreadAttributes!): ChatThread

  deleteThread(id: ID!): ChatThread

  "deletes a chat from a users history"
  deleteChat(id: ID!): Chat

  createPin(attributes: AiPinAttributes!): AiPin

  deletePin(id: ID!): AiPin
}

type RootSubscriptionType {
  applicationDelta: ApplicationDelta

  podDelta: PodDelta

  buildDelta(buildId: ID): BuildDelta

  commandDelta(buildId: ID!): CommandDelta

  notificationDelta: NotificationDelta

  runLogsDelta(stepId: ID!): RunLogsDelta

  "streams chunks of ai text for a given parent scope"
  aiStream(
    "the insight id to use when streaming a fix suggestion"
    insightId: ID

    "the thread id for streaming a chat suggestion"
    threadId: ID
  ): String
}

input PolicyBindingAttributes {
  id: ID
  userId: ID
  groupId: ID
}

input LokiQuery {
  labels: [LokiLabelFilter]
  filter: LokiLineFilter
}

input LokiLabelFilter {
  name: String!

  value: String!

  "whether to apply a regex match for this label"
  regex: Boolean
}

input LokiLineFilter {
  "the string to filter for (eg what is put in our search ui)"
  text: String

  "whether to treat this string as a regex match"
  regex: Boolean
}

type PolicyBinding {
  id: ID
  user: User
  group: Group
}

input RbacAttributes {
  readBindings: [PolicyBindingAttributes]
  writeBindings: [PolicyBindingAttributes]
}

"Supported OIDC-compatible Auth Providers"
enum OidcProviderType {
  PLURAL
}

"Supported methods for fetching an OIDC auth token"
enum OidcAuthMethod {
  POST
  BASIC
}

"Configuration settings for creating a new OIDC provider client"
input OidcProviderAttributes {
  name: String!

  authMethod: OidcAuthMethod

  description: String

  "the redirect uris oidc is whitelisted to use"
  redirectUris: [String]
}

"A representation of a created OIDC provider client"
type OidcProvider {
  id: ID!

  name: String!

  description: String

  authMethod: OidcAuthMethod

  "the redirect uris oidc is whitelisted to use"
  redirectUris: [String]

  "the generated client ID used in configuring OAuth clients"
  clientId: String!

  "the generated client secret, used in configuring an OAuth client"
  clientSecret: String!
}

enum AiProvider {
  OPENAI
  ANTHROPIC
  OLLAMA
  AZURE
  BEDROCK
  VERTEX
}

input ProjectAttributes {
  name: String!
  description: String
  readBindings: [PolicyBindingAttributes]
  writeBindings: [PolicyBindingAttributes]
}

input DeploymentSettingsAttributes {
  artifactRepositoryId: ID

  deployerRepositoryId: ID

  "custom helm values to apply to all agents (useful for things like adding customary annotations\/labels)"
  agentHelmValues: String

  "global configuration for stack execution"
  stacks: StackSettingsAttributes

  "connection details for a prometheus instance to use"
  prometheusConnection: HttpConnectionAttributes

  "connection details for a loki instance to use"
  lokiConnection: HttpConnectionAttributes

  "configuration for smtp message delivery"
  smtp: SmtpSettingsAttributes

  "configuration for LLM provider clients"
  ai: AiSettingsAttributes

  readBindings: [PolicyBindingAttributes]

  writeBindings: [PolicyBindingAttributes]

  gitBindings: [PolicyBindingAttributes]

  createBindings: [PolicyBindingAttributes]
}

input HttpConnectionAttributes {
  host: String!

  "user to connect w\/ for basic auth"
  user: String

  "password to connect w\/ for basic auth"
  password: String
}

input StackSettingsAttributes {
  jobSpec: GateJobAttributes
  connectionId: ID
}

input AiSettingsAttributes {
  enabled: Boolean
  provider: AiProvider
  openai: OpenaiSettingsAttributes
  anthropic: AnthropicSettingsAttributes
  ollama: OllamaAttributes
  azure: AzureOpenaiAttributes
  bedrock: BedrockAiAttributes
  vertex: VertexAiAttributes
}

input OpenaiSettingsAttributes {
  baseUrl: String
  accessToken: String
  model: String
}

input AnthropicSettingsAttributes {
  accessToken: String
  model: String
}

input OllamaAttributes {
  model: String!

  url: String!

  "An http authorization header to use on calls to the Ollama api"
  authorization: String
}

input AzureOpenaiAttributes {
  "the endpoint of your azure openai version, should look like: https:\/\/{endpoint}\/openai\/deployments\/{deployment-id}"
  endpoint: String!

  "the api version you want to use"
  apiVersion: String

  "the exact model you wish to use"
  model: String

  "the azure openai access token to use"
  accessToken: String!
}

input BedrockAiAttributes {
  "the bedrock model id to use"
  modelId: String!

  "aws access key id to use, you can also use IRSA for self-hosted consoles"
  accessKeyId: String

  "aws secret access key to use, you can also use IRSA for self-hosted consoles"
  secretAccessKey: String
}

input VertexAiAttributes {
  "the vertex model id to use"
  model: String

  "optional service account json to auth to the GCP vertex apis"
  serviceAccountJson: String

  "custom vertexai endpoint if for dedicated customer deployments"
  endpoint: String

  "the gcp project id to use"
  project: String!

  "the gcp region the model is hosted in"
  location: String!
}

input SmtpSettingsAttributes {
  server: String!
  port: Int!
  sender: String!
  user: String!
  password: String!
  ssl: Boolean!
}

"A unit of organization to control permissions for a set of objects within your Console instance"
type Project {
  id: ID!

  name: String!

  description: String

  default: Boolean

  "list all alerts discovered for this project"
  alerts(after: String, first: Int, before: String, last: Int): AlertConnection

  "read policy across this project"
  readBindings: [PolicyBinding]

  "write policy across this project"
  writeBindings: [PolicyBinding]

  insertedAt: DateTime

  updatedAt: DateTime
}

"global settings for CD, these specify global read\/write policies and also allow for customization of the repos for CAPI resources and the deploy operator"
type DeploymentSettings {
  id: ID!

  "whether you've yet to enable CD for this instance"
  enabled: Boolean!

  name: String!

  "whether the byok cluster has been brought under self-management"
  selfManaged: Boolean

  "the way we can connect to your loki instance"
  lokiConnection: HttpConnection

  "the way we can connect to your prometheus instance"
  prometheusConnection: HttpConnection

  "custom helm values to apply to all agents (useful for things like adding customary annotations\/labels)"
  agentHelmValues: String

  "global settings for stack configuration"
  stacks: StackSettings

  "smtp server configuration for email notifications"
  smtp: SmtpSettings

  "settings for LLM provider clients"
  ai: AiSettings

  "The console's expected agent version"
  agentVsn: String!

  "the latest known k8s version"
  latestK8sVsn: String!

  "your compliant k8s version"
  compliantK8sVsn: String!

  "the repo to fetch CAPI manifests from, for both providers and clusters"
  artifactRepository: GitRepository

  "the repo to fetch the deploy operators manifests from"
  deployerRepository: GitRepository

  "read policy across all objects"
  readBindings: [PolicyBinding]

  "write policy across all objects"
  writeBindings: [PolicyBinding]

  "policy for managing git repos"
  gitBindings: [PolicyBinding]

  "policy for creation of new objects"
  createBindings: [PolicyBinding]

  insertedAt: DateTime

  updatedAt: DateTime
}

type StackSettings {
  jobSpec: JobGateSpec
  connectionId: ID
}

"the details of how to connect to a http service like prometheus"
type HttpConnection {
  host: String!

  "user to connect w\/ for basic auth"
  user: String
}

"SMTP server configuration for email notifications"
type SmtpSettings {
  server: String!
  port: Int!
  sender: String!
  user: String!
  ssl: Boolean!
}

"Settings for configuring access to common LLM providers"
type AiSettings {
  enabled: Boolean
  provider: AiProvider
  openai: OpenaiSettings
  anthropic: AnthropicSettings
  ollama: OllamaSettings
  azure: AzureOpenaiSettings
  bedrock: BedrockAiSettings
  vertex: VertexAiSettings
}

"OpenAI connection information"
type OpenaiSettings {
  "the base url to use when querying an OpenAI compatible API, leave blank for OpenAI"
  baseUrl: String

  "the openai model version to use"
  model: String
}

"Anthropic connection information"
type AnthropicSettings {
  "the anthropic model version to use"
  model: String
}

"Settings for a self-hosted ollama-based LLM deployment"
type OllamaSettings {
  model: String!

  "the url your ollama deployment is hosted on"
  url: String!
}

"Settings for configuring against Azure OpenAI"
type AzureOpenaiSettings {
  "the endpoint of your azure openai version, should look like: https:\/\/{endpoint}\/openai\/deployments\/{deployment-id}"
  endpoint: String!

  "the api version you want to use"
  apiVersion: String
}

"Settings for usage of AWS Bedrock for LLMs"
type BedrockAiSettings {
  "the bedrock model to use"
  modelId: String!

  "the aws access key to use, can also use IRSA when console is self-hosted"
  accessKeyId: String
}

"Settings for usage of GCP VertexAI for LLMs"
type VertexAiSettings {
  "the vertex ai model to use"
  model: String

  "the gcp project id to use"
  project: String!

  "the gcp region the model"
  location: String!
}

type ProjectConnection {
  pageInfo: PageInfo!
  edges: [ProjectEdge]
}

enum ObservabilityProviderType {
  DATADOG
  NEWRELIC
}

enum ObservabilityWebhookType {
  GRAFANA
}

enum AlertSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
  UNDEFINED
}

enum AlertState {
  FIRING
  RESOLVED
}

input ObservabilityProviderAttributes {
  type: ObservabilityProviderType!
  name: String!
  credentials: ObservabilityProviderCredentialsAttributes!
}

input ObservabilityProviderCredentialsAttributes {
  datadog: DatadogCredentialsAttributes
  newrelic: NewRelicCredentialsAttributes
}

input DatadogCredentialsAttributes {
  apiKey: String!
  appKey: String!
}

input NewRelicCredentialsAttributes {
  apiKey: String!
}

input ObservableMetricAttributes {
  identifier: String!
  providerId: ID!
}

"input data to persist a webhook receiver for an observability provider like grafana or datadog"
input ObservabilityWebhookAttributes {
  type: ObservabilityWebhookType!
  name: String!
  secret: String
}

type ObservabilityProvider {
  id: ID!
  type: ObservabilityProviderType!
  name: String!
  insertedAt: DateTime
  updatedAt: DateTime
}

type ObservableMetric {
  id: ID!
  identifier: String!
  provider: ObservabilityProvider
  insertedAt: DateTime
  updatedAt: DateTime
}

"A webhook receiver for an observability provider like grafana or datadog"
type ObservabilityWebhook {
  id: ID!

  type: ObservabilityWebhookType!

  name: String!

  "the url for this specific webhook"
  url: String!

  insertedAt: DateTime

  updatedAt: DateTime
}

type Alert {
  id: ID!

  provider: ObservabilityWebhookType!

  severity: AlertSeverity!

  state: AlertState!

  title: String

  message: String

  fingerprint: String

  annotations: Map

  url: String

  "key\/value tags to filter clusters"
  tags: [Tag]

  "the cluster this alert was associated with"
  cluster: Cluster

  "the service this alert was associated with"
  service: Service

  "the project this alert was associated with"
  project: Project

  insertedAt: DateTime

  updatedAt: DateTime
}

type ObservabilityProviderConnection {
  pageInfo: PageInfo!
  edges: [ObservabilityProviderEdge]
}

type ObservabilityWebhookConnection {
  pageInfo: PageInfo!
  edges: [ObservabilityWebhookEdge]
}

type AlertConnection {
  pageInfo: PageInfo!
  edges: [AlertEdge]
}

enum StackStatus {
  QUEUED
  PENDING
  RUNNING
  SUCCESSFUL
  FAILED
  CANCELLED
  PENDING_APPROVAL
}

enum StackType {
  TERRAFORM
  ANSIBLE
  CUSTOM
}

enum StepStatus {
  PENDING
  RUNNING
  SUCCESSFUL
  FAILED
}

enum StepStage {
  PLAN
  VERIFY
  APPLY
  INIT
  DESTROY
}

input StackAttributes {
  "the name of the stack"
  name: String!

  "A type for the stack, specifies the tool to use to apply it"
  type: StackType!

  "The repository to source IaC from"
  repositoryId: ID!

  "The cluster on which the terraform will be applied"
  clusterId: ID!

  "reference w\/in the repository where the IaC lives"
  git: GitRefAttributes!

  "optional k8s job configuration for the job that will apply this stack"
  jobSpec: GateJobAttributes

  "version\/image config for the tool you're using"
  configuration: StackConfigurationAttributes

  "whether to require approval"
  approval: Boolean

  "whether you want Plural to manage your terraform state for this stack"
  manageState: Boolean

  "the subdirectory you want to run the stack's commands w\/in"
  workdir: String

  "user id to use for default Plural authentication in this stack"
  actorId: ID

  "the project id this stack will belong to"
  projectId: ID

  "the parent service this stack was created w\/in"
  parentId: ID

  "id of an scm connection to use for pr callbacks"
  connectionId: ID

  "the id of a stack definition to use"
  definitionId: ID

  "a cron to spawn runs for this stack"
  cron: StackCronAttributes

  "arbitrary variables to pass into the stack"
  variables: Json

  readBindings: [PolicyBindingAttributes]

  writeBindings: [PolicyBindingAttributes]

  tags: [TagAttributes]

  files: [StackFileAttributes]

  environment: [StackEnvironmentAttributes]

  observableMetrics: [ObservableMetricAttributes]
}

input StackConfigurationAttributes {
  "optional custom image you might want to use"
  image: String

  "the semver of the tool you wish to use"
  version: String

  "the docker image tag you wish to use if you're customizing the version"
  tag: String

  "the hooks to customize execution for this stack"
  hooks: [StackHookAttributes]
}

input StackHookAttributes {
  "a script hook to run at a stage"
  cmd: String!

  "args for `cmd`"
  args: [String]

  "the stage to run this hook before"
  afterStage: StepStage!
}

input StackCronAttributes {
  "the crontab to use for spawning stack runs"
  crontab: String!

  "whether you want to auto approve any changes spawned by the cron worker"
  autoApprove: Boolean
}

input StackRunAttributes {
  "The status of this run"
  status: StackStatus!

  "the reference to the k8s job running this stack"
  jobRef: NamespacedName

  "The state from this runs plan or apply"
  state: StackStateAttributes

  "Output generated by this run"
  output: [StackOutputAttributes]

  "Any errors detected when trying to run this stack"
  errors: [ServiceErrorAttributes]

  "Why you decided to cancel this run"
  cancellationReason: String
}

input RunStepAttributes {
  status: StepStatus!
}

input RunLogAttributes {
  logs: String!
}

input StackOutputAttributes {
  name: String!
  value: String!
  secret: Boolean
}

input StackEnvironmentAttributes {
  name: String!
  value: String!
  secret: Boolean
}

input StackFileAttributes {
  path: String!
  content: String!
}

input StackStateAttributes {
  plan: String
  state: [StackStateResourceAttributes]
}

input StackStateResourceAttributes {
  "a string identifier for this resource, different tools will have different conventions"
  identifier: String!

  "a string name of the resource type"
  resource: String!

  "the name of the resource within that type"
  name: String!

  "arbitrary configuration used to create the resource"
  configuration: Json

  "identifiers this resource is linked to for graphing in the UI"
  links: [String]
}

input CustomStackRunAttributes {
  "human readable name for this custom run"
  name: String!

  "extended documentation to explain what this will do"
  documentation: String

  "the stack to attach it to"
  stackId: ID

  "the commands for this custom run"
  commands: [CommandAttributes]

  "self-service configuration which will be presented in UI before triggering"
  configuration: [PrConfigurationAttributes]
}

input CommandAttributes {
  cmd: String!
  args: [String]
  dir: String
}

input StackDefinitionAttributes {
  name: String!
  description: String
  steps: [CustomStepAttributes]
  configuration: StackConfigurationAttributes
}

input CustomStepAttributes {
  stage: StepStage
  cmd: String!
  args: [String]
  requireApproval: Boolean
}

type InfrastructureStack {
  id: ID

  "the name of the stack"
  name: String!

  "A type for the stack, specifies the tool to use to apply it"
  type: StackType!

  "reference w\/in the repository where the IaC lives"
  git: GitRef!

  "whether the stack is actively tracking changes in git"
  paused: Boolean

  "The status of the last run of the stack"
  status: StackStatus!

  "optional k8s job configuration for the job that will apply this stack"
  jobSpec: JobGateSpec

  "version\/image config for the tool you're using"
  configuration: StackConfiguration!

  "whether to require approval"
  approval: Boolean

  "whether this stack was previously deleted and is pending cleanup"
  deletedAt: DateTime

  "why this run was cancelled"
  cancellationReason: String

  "the subdirectory you want to run the stack's commands w\/in"
  workdir: String

  "whether you want Plural to manage the state of this stack"
  manageState: Boolean

  "Arbitrary variables to add to a stack run"
  variables: Map

  runs(after: String, first: Int, before: String, last: Int, pullRequestId: ID): StackRunConnection

  pullRequests(after: String, first: Int, before: String, last: Int): PullRequestConnection

  "files bound to a run of this stack"
  files: [StackFile]

  "environment variables for this stack"
  environment: [StackEnvironment]

  "a list of metrics to poll to determine if a stack run should be cancelled"
  observableMetrics: [ObservableMetric]

  "the run that physically destroys the stack"
  deleteRun: StackRun

  "the most recent output for this stack"
  output: [StackOutput]

  "the most recent state of this stack"
  state: StackState

  "The project this stack belongs to"
  project: Project

  "the cluster this stack runs on"
  cluster: Cluster

  "the git repository you're sourcing IaC from"
  repository: GitRepository

  "the stack definition in-use by this stack"
  definition: StackDefinition

  "a cron to spawn runs for this stack"
  cron: StackCron

  "the service this stack was created w\/in"
  parent: ServiceDeployment

  "an insight explaining the state of this stack"
  insight: AiInsight

  "the actor of this stack (defaults to root console user)"
  actor: User

  customStackRuns(after: String, first: Int, before: String, last: Int): CustomStackRunConnection

  "key\/value tags to filter stacks"
  tags: [Tag]

  readBindings: [PolicyBinding]

  writeBindings: [PolicyBinding]

  insertedAt: DateTime

  updatedAt: DateTime
}

type StackCron {
  "the crontab used to independently spawn runs for this stack"
  crontab: String!

  "whether you want any cron-derived runs to automatically approve changes"
  autoApprove: Boolean
}

"grab-bag of state configuration urls for supported tools"
type StateUrls {
  terraform: TerraformStateUrls
}

"Urls for configuring terraform HTTP remote state"
type TerraformStateUrls {
  "GET and POST urls for uploadnig state"
  address: String

  "POST url to lock state"
  lock: String

  "POST url to unlock state"
  unlock: String
}

"temporary credentials for the user attached to this stack"
type PluralCreds {
  "authentication token to use for gql requests"
  token: String

  "the api url of this instance"
  url: String
}

type StackConfiguration {
  "optional custom image you might want to use"
  image: String

  "the semver of the tool you wish to use"
  version: String

  "the docker image tag you wish to use if you're customizing the version"
  tag: String

  "the hooks to customize execution for this stack"
  hooks: [StackHook]
}

type StackHook {
  "a script hook to run at a stage"
  cmd: String!

  "args for `cmd`"
  args: [String]

  "the stage to run this hook before"
  afterStage: StepStage!
}

type StackRun {
  id: ID!

  "The status of this run"
  status: StackStatus!

  "A type for the stack, specifies the tool to use to apply it"
  type: StackType!

  "reference w\/in the repository where the IaC lives"
  git: GitRef!

  "optional k8s job configuration for the job that will apply this stack"
  jobSpec: JobGateSpec

  "version\/image config for the tool you're using"
  configuration: StackConfiguration!

  "whether to require approval"
  approval: Boolean

  "the commit message"
  message: String

  "when this run was approved"
  approvedAt: DateTime

  "the subdirectory you want to run the stack's commands w\/in"
  workdir: String

  "whether you want Plural to manage the state of this stack"
  manageState: Boolean

  "Arbitrary variables to add to a stack run"
  variables: Map

  "explanation for why this run was cancelled"
  cancellationReason: String

  stateUrls: StateUrls

  "the kubernetes job for this run (useful for debugging if issues arise)"
  job: Job

  "temporary plural creds usable for terraform authentication"
  pluralCreds: PluralCreds

  "https url to fetch the latest tarball of stack IaC"
  tarball: String!

  "the pull request this stack belongs to"
  pullRequest: PullRequest

  "the approver of this job"
  approver: User

  "the actor of this run (defaults to root console user)"
  actor: User

  "The steps to perform when running this stack"
  steps: [RunStep]

  "files bound to a run of this stack"
  files: [StackFile]

  "environment variables for this stack"
  environment: [StackEnvironment]

  "the stack attached to this run"
  stack: InfrastructureStack

  "the most recent output for this stack"
  output: [StackOutput]

  "the most recent state of this stack"
  state: StackState

  "a list of errors generated by the deployment operator"
  errors: [ServiceError]

  "an insight explaining the state of this stack run"
  insight: AiInsight

  "the cluster this stack runs on"
  cluster: Cluster

  "the git repository you're sourcing IaC from"
  repository: GitRepository

  insertedAt: DateTime

  updatedAt: DateTime
}

type RunStep {
  id: ID!
  status: StepStatus!
  stage: StepStage!
  name: String!
  cmd: String!
  args: [String!]
  requireApproval: Boolean
  index: Int!
  logs: [RunLogs]
  insertedAt: DateTime
  updatedAt: DateTime
}

type RunLogs {
  id: ID!
  logs: String!
  insertedAt: DateTime
  updatedAt: DateTime
}

type StackOutput {
  name: String!
  value: String!
  secret: Boolean
}

type StackEnvironment {
  name: String!
  value: String!
  secret: Boolean
}

type StackFile {
  path: String!
  content: String!
}

type StackState {
  id: ID!
  plan: String
  state: [StackStateResource]
}

type StackStateResource {
  "a string identifier for this resource, different tools will have different conventions"
  identifier: String!

  "a string name of the resource type"
  resource: String!

  "the name of the resource within that type"
  name: String!

  "arbitrary configuration used to create the resource"
  configuration: Map

  "identifiers this resource is linked to for graphing in the UI"
  links: [String]
}

type CustomStackRun {
  id: ID!

  "Name of the custom stack run"
  name: String!

  "Documentation to explain to users what this will do"
  documentation: String

  "the list of commands that will be executed"
  commands: [StackCommand]

  "self-service configuration fields presented in the UI to configure how this run executes"
  configuration: [PrConfiguration]

  stack: InfrastructureStack

  insertedAt: DateTime

  updatedAt: DateTime
}

type StackDefinition {
  id: ID!
  name: String!
  description: String
  configuration: StackConfiguration!
  steps: [CustomRunStep]
  insertedAt: DateTime
  updatedAt: DateTime
}

type CustomRunStep {
  cmd: String!
  args: [String]
  stage: StepStage!
  requireApproval: Boolean
}

type StackCommand {
  "the executable to call"
  cmd: String!

  "cli args to pass"
  args: [String]

  "working directory for this command (not required)"
  dir: String
}

type InfrastructureStackConnection {
  pageInfo: PageInfo!
  edges: [InfrastructureStackEdge]
}

type StackRunConnection {
  pageInfo: PageInfo!
  edges: [StackRunEdge]
}

type CustomStackRunConnection {
  pageInfo: PageInfo!
  edges: [CustomStackRunEdge]
}

type StackDefinitionConnection {
  pageInfo: PageInfo!
  edges: [StackDefinitionEdge]
}

type RunLogsDelta {
  delta: Delta
  payload: RunLogs
}

"A reference for a globalized service, which targets clusters based on the configured criteria"
input GlobalServiceAttributes {
  "name for this global service"
  name: String!

  "the cluster tags to target"
  tags: [TagAttributes]

  "kubernetes distribution to target"
  distro: ClusterDistro

  "cluster api provider to target"
  providerId: ID

  "a project this global service will sync across"
  projectId: ID

  "the id of the service creating this"
  parentId: ID

  "whether you want the global service to take ownership of existing plural services"
  reparent: Boolean

  template: ServiceTemplateAttributes

  "behavior for all owned resources when this global service is deleted"
  cascade: CascadeAttributes
}

"Attributes for configuring a managed namespace"
input ManagedNamespaceAttributes {
  "the name of this managed namespace (globally unique)"
  name: String!

  "the name of the namespace if `name` doesn't align"
  namespace: String

  "A short description of the purpose of this namespace"
  description: String

  "labels for this namespace"
  labels: Json

  "annotations for this namespace"
  annotations: Json

  "a list of pull secrets to attach to this namespace"
  pullSecrets: [String]

  "a project this managed namespace will sync across"
  projectId: ID

  "the id of the service creating this"
  parentId: ID

  service: ServiceTemplateAttributes

  target: ClusterTargetAttributes

  "behavior for all owned resources when this global service is deleted"
  cascade: CascadeAttributes
}

"Attributes for configuring a service in something like a managed namespace"
input ServiceTemplateAttributes {
  "the name for this service (optional for managed namespaces)"
  name: String

  "the namespace for this service (optional for managed namespaces)"
  namespace: String

  templated: Boolean

  "whether to protect this templated service from deletion"
  protect: Boolean

  "the id of a repository to source manifests for this service"
  repositoryId: ID

  "a list of context ids to add to this service"
  contexts: [ID]

  "a list of secure configuration that will be added to any services created by this template"
  configuration: [ConfigAttributes]

  "dependencies for the service to be spawned"
  dependencies: [ServiceDependencyAttributes]

  "settings to configure git for a service"
  git: GitRefAttributes

  "settings to configure helm for a service"
  helm: HelmConfigAttributes

  "settings for service kustomization"
  kustomize: KustomizeAttributes

  "attributes to configure sync settings for this service"
  syncConfig: SyncConfigAttributes
}

"A spec for targeting clusters"
input ClusterTargetAttributes {
  "the cluster tags to target"
  tags: Json

  "kubernetes distribution to target"
  distro: ClusterDistro
}

"Whether you want to delete or detach owned resources"
input CascadeAttributes {
  delete: Boolean
  detach: Boolean
}

"a rules based mechanism to redeploy a service across a fleet of clusters"
type GlobalService {
  "internal id of this global service"
  id: ID!

  "a human readable name for this global service"
  name: String!

  "a set of tags to select clusters for this global service"
  tags: [Tag]

  "the kubernetes distribution to target with this global service"
  distro: ClusterDistro

  "whether you want to reparent existing plural services under this global service"
  reparent: Boolean

  "behavior for all owned resources when this global service is deleted"
  cascade: Cascade

  "the service which created this global service"
  parent: ServiceDeployment

  "a project this global service is bound to"
  project: Project

  "the service template used to spawn services"
  template: ServiceTemplate

  "the service to replicate across clusters"
  service: ServiceDeployment

  "whether to only apply to clusters with this provider"
  provider: ClusterProvider

  services(after: String, first: Int, before: String, last: Int, q: String): ServiceDeploymentConnection

  insertedAt: DateTime

  updatedAt: DateTime
}

"A representation of a managed namespace, which is k8s namespace configuration + a service spec to define a namespace runtime"
type ManagedNamespace {
  id: ID!

  "the name of this namespace once its placed on a cluster"
  name: String!

  "override the name of the kubernetes namespace if `name` is not usable"
  namespace: String

  "A short description of the purpose of this namespace"
  description: String

  "labels for this namespace"
  labels: Map

  "annotations for this namespace"
  annotations: Map

  "a list of pull secrets to attach to this namespace"
  pullSecrets: [String]

  "The targeting criteria to select clusters this namespace is bound to"
  target: ClusterTarget

  "the timestamp this namespace was deleted at, indicating it's currently draining"
  deletedAt: DateTime

  "behavior for all owned resources when this global service is deleted"
  cascade: Cascade

  "the service which created this managed namespace"
  parent: ServiceDeployment

  "a project this global service is bound to"
  project: Project

  "A template for creating the core service for this namespace"
  service: ServiceTemplate

  services(after: String, first: Int, before: String, last: Int, q: String): ServiceDeploymentConnection

  insertedAt: DateTime

  updatedAt: DateTime
}

"Attributes for configuring a service in something like a managed namespace"
type ServiceTemplate {
  "the name for this service (optional for managed namespaces)"
  name: String

  "the namespace for this service (optional for managed namespaces)"
  namespace: String

  templated: Boolean

  "the id of a repository to source manifests for this service"
  repositoryId: ID

  "a list of context ids to add to this service"
  contexts: [ID]

  repository: GitRepository

  dependencies: [ServiceDependency]

  "possibly secret configuration for all spawned services, don't query this in list endpoints"
  configuration: [ServiceConfiguration]

  "settings to configure git for a service"
  git: GitRef

  "settings to configure helm for a service"
  helm: HelmSpec

  "settings for service kustomization"
  kustomize: Kustomize

  "specification of how the templated service will be synced"
  syncConfig: SyncConfig
}

"A spec for targeting clusters"
type ClusterTarget {
  "the cluster tags to target"
  tags: Map

  "kubernetes distribution to target"
  distro: ClusterDistro
}

"A spec for specifying cascade behavior on an owning resource"
type Cascade {
  "whether to perform a drain-delete for all owned resources"
  delete: Boolean

  "whether to perform a detach-delete for all owned resources"
  detach: Boolean
}

type GlobalServiceConnection {
  pageInfo: PageInfo!
  edges: [GlobalServiceEdge]
}

type ManagedNamespaceConnection {
  pageInfo: PageInfo!
  edges: [ManagedNamespaceEdge]
}

enum ConstraintEnforcement {
  WARN
  DENY
  DRY_RUN
}

enum VulnSeverity {
  UNKNOWN
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum PolicyAggregate {
  CLUSTER
  ENFORCEMENT
  INSTALLED
}

enum ConstraintViolationField {
  NAMESPACE
  KIND
}

"inputs to add constraint data from an OPA gatekeeper constraint CRD"
input PolicyConstraintAttributes {
  name: String!

  description: String

  recommendation: String

  violationCount: Int

  "pointer to the group\/name for the CR"
  ref: ConstraintRefAttributes

  violations: [ViolationAttributes]

  enforcement: ConstraintEnforcement
}

input ConstraintRefAttributes {
  kind: String!
  name: String!
}

input ViolationAttributes {
  group: String
  version: String
  kind: String
  namespace: String
  name: String
  message: String
}

input VulnerabilityReportAttributes {
  artifactUrl: String
  os: VulnOsAttributes
  summary: VulnSummaryAttributes
  artifact: VulnArtifactAttributes
  vulnerabilities: [VulnerabilityAttributes]
  services: [ServiceVulnAttributes]
  namespaces: [NamespaceVulnAttributes]
}

input VulnOsAttributes {
  eosl: Boolean
  family: String
  name: String
}

input VulnSummaryAttributes {
  criticalCount: Int
  highCount: Int
  mediumCount: Int
  lowCount: Int
  unknownCount: Int
  noneCount: Int
}

input VulnArtifactAttributes {
  registry: String
  repository: String
  digest: String
  tag: String
  mime: String
}

input VulnerabilityAttributes {
  resource: String
  fixedVersion: String
  installedVersion: String
  severity: VulnSeverity
  score: Float
  title: String
  description: String
  cvssSource: String
  primaryLink: String
  links: [String]
  target: String
  class: String
  packageType: String
  pkgPath: String
  publishedDate: DateTime
  lastModifiedDate: DateTime
  cvss: CvssAttributes
}

input CvssAttributes {
  v2Vector: String
  v3Vector: String
  v40Vector: String
  v2Score: Float
  v3Score: Float
  v40Score: Float
}

input ServiceVulnAttributes {
  serviceId: ID!
}

input NamespaceVulnAttributes {
  namespace: String!
}

"A OPA Gatekeeper Constraint reference"
type PolicyConstraint {
  id: ID!

  name: String!

  description: String

  recommendation: String

  violationCount: Int

  enforcement: ConstraintEnforcement

  "Fetches the live constraint object from K8s, this is an expensive query and should not be done in list endpoints"
  object: KubernetesUnstructured

  "pointer to the kubernetes resource itself"
  ref: ConstraintRef

  cluster: Cluster

  violations: [Violation]

  insertedAt: DateTime

  updatedAt: DateTime
}

type ConstraintRef {
  kind: String!
  name: String!
}

"A summary of statistics for violations w\/in a specific column"
type ViolationStatistic {
  "the value of this field being aggregated"
  value: String

  "the total number of violations found"
  violations: Int

  "the total number of policy constraints"
  count: Int
}

"Aggregate statistics for policies across your fleet"
type PolicyStatistic {
  "the field you're computing this statistic on"
  aggregate: String

  "the count for this aggregate"
  count: Int
}

"A violation of a given OPA Gatekeeper constraint"
type Violation {
  id: ID!
  group: String
  version: String
  kind: String
  namespace: String
  name: String
  message: String
  insertedAt: DateTime
  updatedAt: DateTime
}

type VulnerabilityReport {
  id: ID!
  artifactUrl: String
  os: VulnOs
  summary: VulnSummary
  artifact: VulnArtifact
  vulnerabilities: [Vulnerability]
  services: [ServiceVuln]
  namespaces: [NamespaceVuln]
  insertedAt: DateTime
  updatedAt: DateTime
}

type VulnOs {
  eosl: Boolean
  family: String
  name: String
}

type VulnSummary {
  criticalCount: Int
  highCount: Int
  mediumCount: Int
  lowCount: Int
  unknownCount: Int
  noneCount: Int
}

type VulnArtifact {
  registry: String
  repository: String
  digest: String
  tag: String
  mime: String
}

type Vulnerability {
  id: ID!
  resource: String
  fixedVersion: String
  installedVersion: String
  severity: VulnSeverity
  score: Float
  title: String
  description: String
  cvssSource: String
  primaryLink: String
  links: [String]
  target: String
  class: String
  packageType: String
  pkgPath: String
  publishedDate: DateTime
  lastModifiedDate: DateTime
  cvss: Cvss
  insertedAt: DateTime
  updatedAt: DateTime
}

type Cvss {
  v2Vector: String
  v3Vector: String
  v40Vector: String
  v2Score: Float
  v3Score: Float
  v40Score: Float
}

type ServiceVuln {
  service: Service
}

type NamespaceVuln {
  namespace: String!
}

type PolicyConstraintConnection {
  pageInfo: PageInfo!
  edges: [PolicyConstraintEdge]
}

type VulnerabilityReportConnection {
  pageInfo: PageInfo!
  edges: [VulnerabilityReportEdge]
}

enum SinkType {
  SLACK
  TEAMS
  PLURAL
}

enum NotificationPriority {
  LOW
  MEDIUM
  HIGH
}

input NotificationSinkAttributes {
  "the name of this sink"
  name: String!

  "the channel type of this sink"
  type: SinkType!

  "configuration for the specific type"
  configuration: SinkConfigurationAttributes!

  "the users\/groups you want this sink to deliver to if it's PLURAL type"
  notificationBindings: [PolicyBindingAttributes]
}

input SinkConfigurationAttributes {
  slack: UrlSinkAttributes
  teams: UrlSinkAttributes
  plural: PluralSinkAttributes
}

input UrlSinkAttributes {
  url: String!
}

input PluralSinkAttributes {
  priority: NotificationPriority!

  "whether to immediately deliver the derived notification via SMTP"
  urgent: Boolean
}

input NotificationRouterAttributes {
  "the name of this router"
  name: String!

  "the events to trigger, or use * for any"
  events: [String!]

  "filters by object type"
  filters: [RouterFilterAttributes]

  "sinks to deliver notifications to"
  routerSinks: [RouterSinkAttributes]
}

input RouterFilterAttributes {
  "a regex for filtering by things like pr url"
  regex: String

  "whether to enable delivery for events associated with this service"
  serviceId: ID

  "whether to enable delivery for events associated with this cluster"
  clusterId: ID

  "whether to enable delivery for events associated with this pipeline"
  pipelineId: ID
}

input RouterSinkAttributes {
  sinkId: ID!
}

input SharedSecretAttributes {
  name: String!

  secret: String!

  "the users\/groups you want this secret to be delivered to"
  notificationBindings: [PolicyBindingAttributes]
}

type NotificationSink {
  id: ID!

  "the name of the sink"
  name: String!

  "the channel type of the sink, eg slack or teams"
  type: SinkType!

  "the users\/groups an in-app notification can be delivered to"
  notificationBindings: [PolicyBinding]

  "type specific sink configuration"
  configuration: SinkConfiguration!

  insertedAt: DateTime

  updatedAt: DateTime
}

type NotificationRouter {
  id: ID!

  "name of this router"
  name: String!

  "events this router subscribes to, use * for all"
  events: [String!]

  "resource-based filters to select events for services, clusters, pipelines"
  filters: [NotificationFilter]

  "sinks to deliver notifications to"
  sinks: [NotificationSink]

  insertedAt: DateTime

  updatedAt: DateTime
}

type AppNotification {
  id: ID!
  priority: NotificationPriority
  text: String
  readAt: DateTime
  insertedAt: DateTime
  updatedAt: DateTime
}

type SharedSecret {
  name: String!
  handle: String!
  secret: String!
  insertedAt: DateTime
  updatedAt: DateTime
}

type NotificationFilter {
  id: ID!
  regex: String
  service: ServiceDeployment
  cluster: Cluster
  pipeline: Pipeline
}

type SinkConfiguration {
  id: ID!
  slack: UrlSinkConfiguration
  teams: UrlSinkConfiguration
  plural: PluralSinkConfiguration
}

type PluralSinkConfiguration {
  priority: NotificationPriority!

  "whether to immediately deliver the derived notification via SMTP"
  urgent: Boolean
}

"A notification sink based off slack incoming webhook urls"
type UrlSinkConfiguration {
  "incoming webhook url to deliver to"
  url: String!
}

type NotificationSinkConnection {
  pageInfo: PageInfo!
  edges: [NotificationSinkEdge]
}

type NotificationRouterConnection {
  pageInfo: PageInfo!
  edges: [NotificationRouterEdge]
}

type AppNotificationConnection {
  pageInfo: PageInfo!
  edges: [AppNotificationEdge]
}

enum RestoreStatus {
  CREATED
  PENDING
  SUCCESSFUL
  FAILED
}

input ObjectStoreAttributes {
  name: String!
  s3: S3StoreAttributes
  gcs: GcsStoreAttributes
  azure: AzureStoreAttributes
}

input BackupAttributes {
  name: String!
  namespace: String!
  garbageCollected: Boolean
  ttl: String
  namespaces: ResourceSelectorAttributes
  resources: ResourceSelectorAttributes
}

input ResourceSelectorAttributes {
  included: [String]
  excluded: [String]
}

input RestoreAttributes {
  status: RestoreStatus!
}

input S3StoreAttributes {
  bucket: String!
  region: String
  endpoint: String
  accessKeyId: String!
  secretAccessKey: String!
}

input GcsStoreAttributes {
  bucket: String!
  region: String
  applicationCredentials: String!
}

input AzureStoreAttributes {
  storageAccount: String!
  container: String!
  subscriptionId: String!
  resourceGroup: String!
  tenantId: String!
  clientId: String!
  clientSecret: String!
}

type ObjectStore {
  id: ID!
  name: String!
  s3: S3Store
  gcs: GcsStore
  azure: AzureStore
  insertedAt: DateTime
  updatedAt: DateTime
}

type ClusterBackup {
  id: ID!
  name: String!
  namespace: String!
  ttl: String
  garbageCollected: Boolean
  namespaces: ResourceSelector
  resources: ResourceSelector
  cluster: Cluster
  insertedAt: DateTime
  updatedAt: DateTime
}

type ResourceSelector {
  included: [String]
  excluded: [String]
}

type ClusterRestore {
  id: ID!
  status: RestoreStatus!
  backup: ClusterBackup
  insertedAt: DateTime
  updatedAt: DateTime
}

type S3Store {
  bucket: String!
  region: String
  endpoint: String
  accessKeyId: String!
}

type GcsStore {
  bucket: String!
  region: String
}

type AzureStore {
  storageAccount: String!
  container: String!
  subscriptionId: String!
  resourceGroup: String!
  tenantId: String!
  clientId: String!
}

type ObjectStoreConnection {
  pageInfo: PageInfo!
  edges: [ObjectStoreEdge]
}

type ClusterBackupConnection {
  pageInfo: PageInfo!
  edges: [ClusterBackupEdge]
}

type ClusterRestoreConnection {
  pageInfo: PageInfo!
  edges: [ClusterRestoreEdge]
}

enum GateState {
  PENDING
  OPEN
  CLOSED
  RUNNING
}

enum GateType {
  APPROVAL
  WINDOW
  JOB
}

"the top level input object for creating\/deleting pipelines"
input PipelineAttributes {
  projectId: ID
  stages: [PipelineStageAttributes]
  edges: [PipelineEdgeAttributes]
  readBindings: [PolicyBindingAttributes]
  writeBindings: [PolicyBindingAttributes]
}

"specification of a stage of a pipeline"
input PipelineStageAttributes {
  name: String!
  services: [StageServiceAttributes]
}

"specification of an edge between two pipeline stages"
input PipelineEdgeAttributes {
  "stage id the edge is from, can also be specified by name"
  fromId: ID

  "stage id the edge is to, can also be specified by name"
  toId: ID

  "the name of the pipeline stage this edge emits from"
  from: String

  "the name of the pipeline stage this edge points to"
  to: String

  "any optional promotion gates you wish to configure"
  gates: [PipelineGateAttributes]
}

"will configure a promotion gate for a pipeline"
input PipelineGateAttributes {
  "the name of this gate"
  name: String!

  "the type of gate this is"
  type: GateType!

  "the handle of a cluster this gate will execute on"
  cluster: String

  "the id of the cluster this gate will execute on"
  clusterId: ID

  "a specification for more complex gate types"
  spec: GateSpecAttributes
}

"attributes needed to create a new pipeline context"
input PipelineContextAttributes {
  context: Json!
}

"the allowed inputs for a deployment agent gate update"
input GateUpdateAttributes {
  state: GateState
  status: GateStatusAttributes
}

input GateStatusAttributes {
  jobRef: NamespacedName
}

input NamespacedName {
  name: String!
  namespace: String!
}

"a more refined spec for parameters needed for complex gates"
input GateSpecAttributes {
  job: GateJobAttributes
}

"spec for a job gate"
input GateJobAttributes {
  namespace: String!

  "if you'd rather define the job spec via straight k8s yaml"
  raw: String

  containers: [ContainerAttributes]

  labels: Json

  annotations: Json

  serviceAccount: String

  "request overrides if you don't want to manually configure individual containers"
  resources: ContainerResourcesAttributes
}

"the attributes for a container"
input ContainerAttributes {
  name: String
  image: String!
  args: [String]
  env: [EnvAttributes]
  envFrom: [EnvFromAttributes]
  resources: ContainerResourcesAttributes
}

input ContainerResourcesAttributes {
  requests: ResourceRequestAttributes
  limits: ResourceRequestAttributes
}

input ResourceRequestAttributes {
  cpu: String
  memory: String
}

input EnvAttributes {
  name: String!
  value: String!
}

input EnvFromAttributes {
  secret: String!
  configMap: String!
}

"the attributes of a service w\/in a specific stage"
input StageServiceAttributes {
  "the cluster handle of this service"
  handle: String

  "the name of this service"
  name: String

  "the name of this service"
  serviceId: ID

  criteria: PromotionCriteriaAttributes
}

"actions to perform if this stage service were promoted"
input PromotionCriteriaAttributes {
  "the handle of the cluster for the source service"
  handle: String

  "the name of the source service"
  name: String

  "the id of the service to promote from"
  sourceId: ID

  "the id of a pr automation to update this service"
  prAutomationId: ID

  "overrides the repository slug for the referenced pr automation"
  repository: String

  "the secrets to copy over in a promotion"
  secrets: [String]
}

"a release pipeline, composed of multiple stages each with potentially multiple services"
type Pipeline {
  id: ID!

  "the name of the pipeline"
  name: String!

  "the stages of this pipeline"
  stages: [PipelineStage]

  status: PipelineStatus

  "the project this pipeline belongs to"
  project: Project

  "read policy for this pipeline"
  readBindings: [PolicyBinding]

  "write policy of this pipeline"
  writeBindings: [PolicyBinding]

  "edges linking two stages w\/in the pipeline in a full DAG"
  edges: [PipelineStageEdge]

  "lists the contexts applied to a pipeline"
  contexts(after: String, first: Int, before: String, last: Int): PipelineContextConnection

  insertedAt: DateTime

  updatedAt: DateTime
}

"A variable context that can be used to generate pull requests as a pipeline progresses"
type PipelineContext {
  id: ID!

  "the context map that will be passed to the pipeline"
  context: Map!

  pipeline: Pipeline

  "a history of pull requests created by this context thus far"
  pullRequests: [PullRequest]

  "a list of pipeline-specific PRs for this context"
  pipelinePullRequests: [PipelinePullRequest]

  insertedAt: DateTime

  updatedAt: DateTime
}

"a pipeline stage, has a list of services and potentially a promotion which might be pending"
type PipelineStage {
  id: ID!

  "the name of this stage (eg dev, prod, staging)"
  name: String!

  "the errors for this stage"
  errors: [ServiceError]

  "the services within this stage"
  services: [StageService]

  "the context that is to be applied to this stage for PR promotions"
  context: PipelineContext

  "a promotion which might be outstanding for this stage"
  promotion: PipelinePromotion

  contextHistory(after: String, first: Int, before: String, last: Int): PipelineContextHistoryConnection

  insertedAt: DateTime

  updatedAt: DateTime
}

"an edge in the pipeline DAG"
type PipelineStageEdge {
  id: ID!

  "when the edge was last promoted, if greater than the promotion objects revised at, was successfully promoted"
  promotedAt: DateTime

  from: PipelineStage!

  to: PipelineStage!

  gates: [PipelineGate]

  pipeline: Pipeline

  insertedAt: DateTime

  updatedAt: DateTime
}

"A gate blocking promotion along a release pipeline"
type PipelineGate {
  id: ID!

  "the name of this gate as seen in the UI"
  name: String!

  "the type of gate this is"
  type: GateType!

  "the current state of this gate"
  state: GateState!

  "more detailed specification for complex gates"
  spec: GateSpec

  "state related to the current status of this job"
  status: GateStatus

  "the kubernetes job running this gate (should only be fetched lazily as this is a heavy operation)"
  job: Job

  "the edge this gate lives on"
  edge: PipelineStageEdge

  "the cluster this gate can run on"
  cluster: Cluster

  "the last user to approve this gate"
  approver: User

  insertedAt: DateTime

  updatedAt: DateTime
}

"detailed gate specifications"
type GateSpec {
  job: JobGateSpec
}

"state delineating the current status of this gate"
type GateStatus {
  jobRef: JobReference
}

"the full specification of a job gate"
type JobGateSpec {
  "the namespace the job will run in"
  namespace: String!

  "a raw kubernetes job resource, overrides any other configuration"
  raw: String

  "list of containers to run in this job"
  containers: [ContainerSpec]

  "any pod labels to apply"
  labels: Map

  "any pod annotations to apply"
  annotations: Map

  "the service account the pod will use"
  serviceAccount: String

  "requests overrides for cases where direct container configuration is unnecessary"
  requests: ContainerResources
}

"a shortform spec for job containers, designed for ease-of-use"
type ContainerSpec {
  image: String!
  args: [String]
  env: [ContainerEnv]
  envFrom: [ContainerEnvFrom]
  resources: ContainerResources
}

"container env variable"
type ContainerEnv {
  name: String!
  value: String!
}

"env from declarations for containers"
type ContainerEnvFrom {
  configMap: String!
  secret: String!
}

"A combined kubernetes pod container resource requests spec"
type ContainerResources {
  requests: ResourceRequest
  limits: ResourceRequest
}

"A kubernetes pod container resource request spec"
type ResourceRequest {
  cpu: String
  memory: String
}

"the configuration of a service within a pipeline stage, including optional promotion criteria"
type StageService {
  id: ID!

  "a pointer to a service"
  service: ServiceDeployment

  "criteria for how a promotion of this service shall be performed"
  criteria: PromotionCriteria

  insertedAt: DateTime

  updatedAt: DateTime
}

"how a promotion for a service will be performed"
type PromotionCriteria {
  id: ID!

  "overrides the repository slug for the referenced pr automation"
  repository: String

  "the source service in a prior stage to promote settings from"
  source: ServiceDeployment

  "whether you want to copy any configuration values from the source service"
  secrets: [String]

  insertedAt: DateTime

  updatedAt: DateTime
}

"a representation of an individual pipeline promotion, which is a list of services\/revisions and timestamps to determine promotion status"
type PipelinePromotion {
  id: ID!

  "the last time this promotion was updated"
  revisedAt: DateTime

  "the last time this promotion was fully promoted, it's no longer pending if promoted_at > revised_at"
  promotedAt: DateTime

  "the services included in this promotion"
  services: [PromotionService]

  insertedAt: DateTime

  updatedAt: DateTime
}

"a service to be potentially promoted"
type PromotionService {
  id: ID!

  "a service to promote"
  service: ServiceDeployment

  "the revision of the service to promote"
  revision: Revision

  insertedAt: DateTime

  updatedAt: DateTime
}

"a report of gate statuses within a pipeline to gauge its health"
type PipelineStatus {
  "if > 0, consider the pipeline pending"
  pending: Int

  "if > 0, consider the pipeline stopped"
  closed: Int

  "if > 0, consider the pipeline runnning"
  running: Int
}

"A pull request created in the course of executing a pipeline"
type PipelinePullRequest {
  id: ID!
  service: ServiceDeployment
  pullRequest: PullRequest
}

"A record of a prior pipeline context attached to a stage"
type PipelineContextHistory {
  id: ID!
  stage: PipelineStage
  context: PipelineContext
  insertedAt: DateTime
  updatedAt: DateTime
}

type PipelineConnection {
  pageInfo: PageInfo!
  edges: [PipelineEdge]
}

type PipelineGateConnection {
  pageInfo: PageInfo!
  edges: [PipelineGateEdge]
}

type PipelineContextConnection {
  pageInfo: PageInfo!
  edges: [PipelineContextEdge]
}

type PipelineContextHistoryConnection {
  pageInfo: PageInfo!
  edges: [PipelineContextHistoryEdge]
}

enum ComponentState {
  RUNNING
  PENDING
  FAILED
  PAUSED
}

enum ServiceDeploymentStatus {
  STALE
  SYNCED
  HEALTHY
  FAILED
  PAUSED
}

enum ServicePromotion {
  IGNORE
  PROCEED
  ROLLBACK
}

input ServiceDeploymentAttributes {
  name: String!

  namespace: String!

  version: String

  docsPath: String

  syncConfig: SyncConfigAttributes

  protect: Boolean

  repositoryId: ID

  dryRun: Boolean

  interval: String

  "if you should apply liquid templating to raw yaml files, defaults to true"
  templated: Boolean

  git: GitRefAttributes

  helm: HelmConfigAttributes

  kustomize: KustomizeAttributes

  parentId: ID

  configuration: [ConfigAttributes]

  dependencies: [ServiceDependencyAttributes]

  readBindings: [PolicyBindingAttributes]

  writeBindings: [PolicyBindingAttributes]

  contextBindings: [ContextBindingAttributes]

  imports: [ServiceImportAttributes]
}

input ServiceImportAttributes {
  stackId: ID!
}

input SyncConfigAttributes {
  createNamespace: Boolean
  enforceNamespace: Boolean
  namespaceMetadata: MetadataAttributes
}

input HelmConfigAttributes {
  values: String

  valuesFiles: [String]

  chart: String

  version: String

  release: String

  url: String

  ignoreHooks: Boolean

  set: HelmValueAttributes

  repository: NamespacedName

  git: GitRefAttributes

  "pointer to a Plural GitRepository"
  repositoryId: ID
}

input MetadataAttributes {
  labels: Json
  annotations: Json
}

input HelmValueAttributes {
  "helm value name, can be deeply nested via dot like `image.tag`"
  name: String

  "value of the attribute"
  value: String
}

input ServiceUpdateAttributes {
  version: String

  protect: Boolean

  dryRun: Boolean

  interval: String

  syncConfig: SyncConfigAttributes

  "if you should apply liquid templating to raw yaml files, defaults to true"
  templated: Boolean

  git: GitRefAttributes

  helm: HelmConfigAttributes

  configuration: [ConfigAttributes]

  kustomize: KustomizeAttributes

  parentId: ID

  dependencies: [ServiceDependencyAttributes]

  readBindings: [PolicyBindingAttributes]

  writeBindings: [PolicyBindingAttributes]

  contextBindings: [ContextBindingAttributes]
}

input ServiceCloneAttributes {
  name: String!
  namespace: String
  configuration: [ConfigAttributes]
}

input GitRefAttributes {
  ref: String!
  folder: String!
  files: [String!]
}

input ConfigAttributes {
  name: String!
  value: String
}

input ComponentAttributes {
  state: ComponentState
  synced: Boolean!
  group: String!
  version: String!
  kind: String!
  namespace: String!
  name: String!
  content: ComponentContentAttributes
}

"the content of a component when visualized in dry run state"
input ComponentContentAttributes {
  "the desired state of a service component as determined from the configured manifests"
  desired: String

  live: String
}

input ServiceErrorAttributes {
  source: String!
  message: String!
}

"A reusable configuration context, useful for plumbing data from external tools like terraform\/pulumi\/etc"
input ServiceContextAttributes {
  configuration: Json
  secrets: [ConfigAttributes]
}

"a binding from a service to a service context"
input ContextBindingAttributes {
  contextId: String!
}

"A named depedency of a service, will prevent applying any manifests until the dependency has become ready"
input ServiceDependencyAttributes {
  name: String!
}

input KustomizeAttributes {
  "the path to the kustomization file to use"
  path: String!
}

"a reference to a service deployed from a git repo into a cluster"
type ServiceDeployment {
  "internal id of this service"
  id: ID!

  "human readable name of this service, must be unique per cluster"
  name: String!

  "kubernetes namespace this service will be deployed to"
  namespace: String!

  "A summary status enum for the health of this service"
  status: ServiceDeploymentStatus!

  "semver of this service"
  version: String!

  "the desired sync interval for this service"
  interval: String

  "description on where in git the service's manifests should be fetched"
  git: GitRef

  "description of how helm charts should be applied"
  helm: HelmSpec

  "how you'd like to perform a canary promotion"
  promotion: ServicePromotion

  "if you should apply liquid templating to raw yaml files, defaults to true"
  templated: Boolean

  "if true, deletion of this service is not allowed"
  protect: Boolean

  "latest git sha we pulled from"
  sha: String

  "https url to fetch the latest tarball of kubernetes manifests"
  tarball: String

  "a n \/ m representation of the number of healthy components of this service"
  componentStatus: String

  "settings for advanced tuning of the sync process"
  syncConfig: SyncConfig

  "kustomize related service metadata"
  kustomize: Kustomize

  "the commit message currently in use"
  message: String

  "the time this service was scheduled for deletion"
  deletedAt: DateTime

  "whether this service should not actively reconcile state and instead simply report pending changes"
  dryRun: Boolean

  "fetches the \/docs directory within this services git tree.  This is a heavy operation and should NOT be used in list queries"
  docs: [GitFile]

  "the git repo of this service"
  repository: GitRepository

  helmRepository: FluxHelmRepository

  "Queries logs for a service out of loki"
  logs(query: LokiQuery!, start: Long, end: Long, limit: Int!): [LogStream]

  "read policy for this service"
  readBindings: [PolicyBinding]

  "write policy of this service"
  writeBindings: [PolicyBinding]

  "the service that owns this service in a service-of-services setup"
  parent: ServiceDeployment

  "a list of errors generated by the deployment operator"
  errors: [ServiceError]

  "the cluster this service is deployed into"
  cluster: Cluster

  "the current revision of this service"
  revision: Revision

  "possibly secret configuration used to template the manifests of this service"
  configuration: [ServiceConfiguration]

  "the kubernetes component of a service"
  components: [ServiceComponent]

  "the global service this service is the source for"
  globalService: GlobalService

  "whether this service is controlled by a global service"
  owner: GlobalService

  "bound contexts for this service"
  contexts: [ServiceContext]

  "the dependencies of this service, actualization will not happen until all are HEALTHY"
  dependencies: [ServiceDependency]

  "imports from stack outputs"
  imports: [ServiceImport]

  "an insight explaining the state of this service"
  insight: AiInsight

  "sideload detected vulnerabilities for this service"
  vulns: ServiceVuln

  "a relay connection of all revisions of this service, these are periodically pruned up to a history limit"
  revisions(after: String, first: Int, before: String, last: Int): RevisionConnection

  "list all alerts discovered for this service"
  alerts(after: String, first: Int, before: String, last: Int): AlertConnection

  componentMetrics(componentId: ID!, start: DateTime, stop: DateTime, step: String): ServiceComponentMetrics

  "whether this service is editable"
  editable: Boolean

  insertedAt: DateTime

  updatedAt: DateTime
}

type ServiceComponentMetrics {
  cpu: [MetricResponse]
  mem: [MetricResponse]
  podCpu: [MetricResponse]
  podMem: [MetricResponse]
}

"a representation of a past revision of a service"
type Revision {
  "id of this revision"
  id: ID!

  "the service's semver"
  version: String!

  "git spec of the prior revision"
  git: GitRef

  "description of how helm charts should be applied"
  helm: HelmSpec

  "the sha this service was pulled from"
  sha: String

  "the commit message for this revision"
  message: String

  insertedAt: DateTime

  updatedAt: DateTime
}

"a representation of where to pull manifests from git"
type GitRef {
  "a general git ref, either a branch name or commit sha understandable by `git checkout <ref>`"
  ref: String!

  "the folder manifests live under"
  folder: String!

  "a list of individual files to include as well"
  files: [String!]
}

type ObjectReference {
  name: String
  namespace: String
}

type HelmSpec {
  "the name of the chart this service is using"
  chart: String

  "the helm repository url to use"
  url: String

  "a helm values file to use with this service, requires auth and so is heavy to query"
  values: String

  release: String

  ignoreHooks: Boolean

  "spec of where to find the chart in git"
  git: GitRef

  "a git repository in Plural to use as a source"
  repositoryId: ID

  "pointer to the flux helm repository resource used for this chart"
  repository: ObjectReference

  "the chart version in use currently"
  version: String

  "a list of helm name\/value pairs to precisely set individual values"
  set: [HelmValue]

  "a list of relative paths to values files to use for helm applies"
  valuesFiles: [String]
}

"a configuration item k\/v pair"
type ServiceConfiguration {
  name: String!
  value: String!
}

"a (possibly nested) helm value pair"
type HelmValue {
  name: String!
  value: String!
}

"metadata needed for configuring kustomize"
type Kustomize {
  path: String!
}

"representation of a kubernetes component deployed by a service"
type ServiceComponent {
  "internal id"
  id: ID!

  "kubernetes component health enum"
  state: ComponentState

  "whether this component has been applied to the k8s api"
  synced: Boolean!

  "api group of this resource"
  group: String

  "api version of this resource"
  version: String

  "api kind of this resource"
  kind: String!

  "kubernetes namespace of this resource"
  namespace: String

  "kubernetes name of this resource"
  name: String!

  "an insight explaining the state of this component"
  insight: AiInsight

  "the live and desired states of this service component"
  content: ComponentContent

  "the service this component belongs to"
  service: ServiceDeployment

  "any api deprecations discovered from this component"
  apiDeprecations: [ApiDeprecation]
}

"dry run content of a service component"
type ComponentContent {
  id: ID!

  live: String

  "the inferred desired state of this component"
  desired: String

  insertedAt: DateTime

  updatedAt: DateTime
}

"a representation of a kubernetes api deprecation"
type ApiDeprecation {
  "the kubernetes version the deprecation was posted"
  deprecatedIn: String

  "the kubernetes version the api version will be removed and unusable in"
  removedIn: String

  "the api you can replace this resource with"
  replacement: String

  "the kubernetes version the replacement api was created in"
  availableIn: String

  "whether you cannot safely upgrade to the next kubernetes version if this deprecation exists"
  blocking: Boolean

  "the component of this deprecation"
  component: ServiceComponent
}

"an error sent from the deploy operator about sync progress"
type ServiceError {
  source: String!
  message: String!
}

"a file fetched from a git repository, eg a docs .md file"
type GitFile {
  path: String!
  content: String!
}

"a rollup count of the statuses of services in a query"
type ServiceStatusCount {
  status: ServiceDeploymentStatus!
  count: Int!
}

"Advanced configuration of how to sync resources"
type SyncConfig {
  "whether the agent should auto-create the namespace for this service"
  createNamespace: Boolean

  "Whether to require all resources are placed in the same namespace"
  enforceNamespace: Boolean

  namespaceMetadata: NamespaceMetadata
}

"metadata fields for created namespaces"
type NamespaceMetadata {
  labels: Map
  annotations: Map
}

"A reusable bundle of configuration designed to make it easy to communicate between tools like tf\/pulumi and k8s"
type ServiceContext {
  id: ID!
  name: String!
  configuration: Map
  secrets: [ServiceConfiguration]
  insertedAt: DateTime
  updatedAt: DateTime
}

"A dependency of a service, the service will not actualize until all dependencies are ready"
type ServiceDependency {
  id: ID!
  status: ServiceDeploymentStatus
  name: String!
  insertedAt: DateTime
  updatedAt: DateTime
}

"Import of stack data into a service's context"
type ServiceImport {
  id: ID!

  "The stack you're importing from"
  stack: InfrastructureStack

  "The outputs of that stack"
  outputs: [StackOutput]

  insertedAt: DateTime

  updatedAt: DateTime
}

"A tree view of the kubernetes object hierarchy beneath a component"
type ComponentTree {
  root: KubernetesUnstructured
  deployments: [Deployment]
  statefulsets: [StatefulSet]
  replicasets: [ReplicaSet]
  daemonsets: [DaemonSet]
  services: [Service]
  ingresses: [Ingress]
  cronjobs: [CronJob]
  configmaps: [ConfigMap]
  secrets: [Secret]
  certificates: [Certificate]
  edges: [ResourceEdge]
}

"an edge representing mapping from kubernetes object metadata.uid -> metadata.uid"
type ResourceEdge {
  from: String!
  to: String!
}

type ServiceDeploymentConnection {
  pageInfo: PageInfo!
  edges: [ServiceDeploymentEdge]
}

type RevisionConnection {
  pageInfo: PageInfo!
  edges: [RevisionEdge]
}

enum ClusterDistro {
  GENERIC
  EKS
  AKS
  GKE
  RKE
  K3S
}

enum UpgradeInsightStatus {
  PASSING
  FAILED
  UNKNOWN
  WARNING
}

enum Conjunction {
  AND
  OR
}

enum TagType {
  CLUSTER
  STACK
}

input ClusterAttributes {
  name: String!

  "a short, unique human readable name used to identify this cluster and does not necessarily map to the cloud resource name"
  handle: String

  providerId: ID

  "a cloud credential to use when provisioning this cluster"
  credentialId: ID

  version: String

  distro: ClusterDistro

  metadata: Json

  protect: Boolean

  kubeconfig: KubeconfigAttributes

  cloudSettings: CloudSettingsAttributes

  "the project id this cluster will belong to"
  projectId: ID

  "status of the upgrade plan for this cluster"
  upgradePlan: UpgradePlanAttributes

  nodePools: [NodePoolAttributes]

  readBindings: [PolicyBindingAttributes]

  writeBindings: [PolicyBindingAttributes]

  tags: [TagAttributes]
}

input KubeconfigAttributes {
  raw: String
}

input TagAttributes {
  name: String!
  value: String!
}

input ClusterPing {
  currentVersion: String!

  kubeletVersion: String

  distro: ClusterDistro

  "scraped k8s objects to use for cluster insights, don't send at all if not w\/in the last scrape interval"
  insightComponents: [ClusterInsightComponentAttributes]
}

input ClusterInsightComponentAttributes {
  group: String
  version: String!
  kind: String!
  namespace: String
  name: String!
}

input ClusterUpdateAttributes {
  name: String

  version: String

  "a short, unique human readable name used to identify this cluster and does not necessarily map to the cloud resource name"
  handle: String

  "if you optionally want to reconfigure the git repository for the cluster service"
  service: ClusterServiceAttributes

  "pass a kubeconfig for this cluster (DEPRECATED)"
  kubeconfig: KubeconfigAttributes

  "status of the upgrade plan for this cluster"
  upgradePlan: UpgradePlanAttributes

  protect: Boolean

  distro: ClusterDistro

  metadata: Json

  nodePools: [NodePoolAttributes]

  tags: [TagAttributes]

  readBindings: [PolicyBindingAttributes]

  writeBindings: [PolicyBindingAttributes]
}

input ClusterServiceAttributes {
  id: ID!
  repositoryId: ID
  git: GitRefAttributes!
}

input UpgradePlanAttributes {
  "whether all compatibilities for a cluster upgrade have been cleared"
  compatibilities: Boolean

  "whether all incompatibilities w\/in runtime components have been cleared"
  incompatibilities: Boolean

  "whether all deprecated apis for a cluster have been cleared"
  deprecations: Boolean
}

input NodePoolAttributes {
  name: String!
  minSize: Int!
  maxSize: Int!
  instanceType: String!
  labels: Json
  taints: [TaintAttributes]
  cloudSettings: NodePoolCloudAttributes
}

input TaintAttributes {
  key: String!
  value: String!
  effect: String!
}

input CloudSettingsAttributes {
  aws: AwsCloudAttributes
  gcp: GcpCloudAttributes
  azure: AzureCloudAttributes
}

input AwsCloudAttributes {
  region: String
}

input GcpCloudAttributes {
  project: String
  network: String
  region: String
}

input AzureCloudAttributes {
  location: String
  subscriptionId: String
  resourceGroup: String
  network: String
}

input NodePoolCloudAttributes {
  aws: AwsNodeCloudAttributes
}

input AwsNodeCloudAttributes {
  launchTemplateId: String
}

input ClusterProviderAttributes {
  name: String!
  namespace: String
  cloud: String
  cloudSettings: CloudProviderSettingsAttributes
}

input ClusterProviderUpdateAttributes {
  "if you optionally want to reconfigure the git repository for the cluster provider"
  service: ClusterServiceAttributes

  cloudSettings: CloudProviderSettingsAttributes
}

input CloudProviderSettingsAttributes {
  aws: AwsSettingsAttributes
  gcp: GcpSettingsAttributes
  azure: AzureSettingsAttributes
}

input ProviderCredentialAttributes {
  namespace: String
  name: String!
  kind: String
}

input AwsSettingsAttributes {
  accessKeyId: String!
  secretAccessKey: String!
}

input GcpSettingsAttributes {
  applicationCredentials: String!
}

input AzureSettingsAttributes {
  tenantId: String!
  subscriptionId: String!
  clientId: ID!
  clientSecret: String!
}

input RuntimeServiceAttributes {
  name: String!

  version: String!

  "the number of instances of this service we've found"
  instanceCount: Int
}

input AgentMigrationAttributes {
  name: String
  ref: String
  configuration: Json
}

input PinnedCustomResourceAttributes {
  name: String!
  displayName: String!
  group: String!
  version: String!
  kind: String!
  namespaced: Boolean
  clusterId: ID
}

input TagInput {
  name: String!
  value: String!
}

input TagQuery {
  op: Conjunction!
  tags: [TagInput]
}

input UpgradeInsightAttributes {
  name: String!

  "the k8s version this insight applies to"
  version: String

  "longform description of this insight"
  description: String

  status: UpgradeInsightStatus

  refreshedAt: DateTime

  transitionedAt: DateTime

  details: [UpgradeInsightDetailAttributes]
}

input UpgradeInsightDetailAttributes {
  status: UpgradeInsightStatus

  "a possibly deprecated API"
  used: String

  "the replacement for this API"
  replacement: String

  "descriptions of the HTTP clients triggering this insight"
  clientInfo: [InsightClientInfoAttributes]

  replacedIn: String

  removedIn: String

  "the latest timestamp this insight has been observed"
  lastUsedAt: DateTime
}

input InsightClientInfoAttributes {
  userAgent: String
  count: String
  lastRequestAt: DateTime
}

"a CAPI provider for a cluster, cloud is inferred from name if not provided manually"
type ClusterProvider {
  "the id of this provider"
  id: ID!

  "a human readable name for the provider, globally unique"
  name: String!

  "the namespace the CAPI resources are deployed into"
  namespace: String!

  "the name of the cloud service for this provider"
  cloud: String!

  "the details of how cluster manifests will be synced from git when created with this provider"
  git: GitRef!

  "the repository used to serve cluster manifests"
  repository: GitRepository

  "the repository for the CAPI service itself if customized"
  providerRepository: GitRepository

  "the service of the CAPI controller itself"
  service: ServiceDeployment

  "a list of credentials eligible for this provider"
  credentials: [ProviderCredential]

  "when the cluster provider was deleted"
  deletedAt: DateTime

  runtimeServices(
    "the kubernetes version you want to check is upgradeable"
    kubeVersion: String
  ): [RuntimeService]

  "the kubernetes versions this provider currently supports"
  supportedVersions: [String]

  "the region names this provider can deploy to"
  regions: [String]

  "whether the current user can edit this resource"
  editable: Boolean

  insertedAt: DateTime

  updatedAt: DateTime
}

type ClusterMetrics {
  cpu: [MetricResponse]
  memory: [MetricResponse]
  cpuRequests: [MetricResponse]
  memoryRequests: [MetricResponse]
  cpuLimits: [MetricResponse]
  memoryLimits: [MetricResponse]
  pods: [MetricResponse]
  cpuUsage: [MetricResponse]
  memoryUsage: [MetricResponse]
}

type ClusterNodeMetrics {
  cpu: [MetricResponse]
  memory: [MetricResponse]
  cpuUsage: [MetricResponse]
  memoryUsage: [MetricResponse]
}

"a representation of a cluster you can deploy to"
type Cluster {
  "internal id of this cluster"
  id: ID!

  "whether this is the management cluster itself"
  self: Boolean

  "human readable name of this cluster, will also translate to cloud k8s name"
  name: String!

  "if true, this cluster cannot be deleted"
  protect: Boolean

  "whether this is actually a virtual cluster"
  virtual: Boolean

  "desired k8s version for the cluster"
  version: String

  "the distribution of kubernetes this cluster is running"
  distro: ClusterDistro

  "arbitrary json metadata to store user-specific state of this cluster (eg IAM roles for add-ons)"
  metadata: Map

  "current k8s version as told to us by the deployment operator"
  currentVersion: String

  "The lowest discovered kubelet version for all nodes in the cluster"
  kubeletVersion: String

  "a short, unique human readable name used to identify this cluster and does not necessarily map to the cloud resource name"
  handle: String

  "whether the deploy operator has been registered for this cluster"
  installed: Boolean

  "the cloud settings for this cluster (for instance its aws region)"
  settings: CloudSettings

  "Checklist of tasks to complete to safely upgrade this cluster"
  upgradePlan: ClusterUpgradePlan

  "the url of the kas server you can access this cluster from"
  kasUrl: String

  "the url this clusters deployment operator will use for gql requests"
  agentUrl: String

  "a auth token to be used by the deploy operator, only readable on create"
  deployToken: String

  "when this cluster was scheduled for deletion"
  deletedAt: DateTime

  "last time the deploy operator pinged this cluster"
  pingedAt: DateTime

  "read policy for this cluster"
  readBindings: [PolicyBinding]

  "write policy for this cluster"
  writeBindings: [PolicyBinding]

  "the project this cluster belongs to"
  project: Project

  "list of node pool specs managed by CAPI"
  nodePools: [NodePool]

  "the provider we use to create this cluster (null if BYOK)"
  provider: ClusterProvider

  "a custom credential to use when provisioning this cluster"
  credential: ProviderCredential

  "the service used to deploy the CAPI resources of this cluster"
  service: ServiceDeployment

  "key\/value tags to filter clusters"
  tags: [Tag]

  "all api deprecations for all services in this cluster"
  apiDeprecations: [ApiDeprecation]

  "any errors which might have occurred during the bootstrap process"
  serviceErrors: [ServiceError]

  "a custom git repository if you want to define your own CAPI manifests"
  repository: GitRepository

  "pr automations that are relevant to managing this cluster"
  prAutomations: [PrAutomation]

  "the active restore for this cluster"
  restore: ClusterRestore

  "the object store connection bound to this cluster for backup\/restore"
  objectStore: ObjectStore

  "the parent of this virtual cluster"
  parentCluster: Cluster

  "an ai insight generated about issues discovered which might impact the health of this cluster"
  insight: AiInsight

  "a set of kubernetes resources used to generate the ai insight for this cluster"
  insightComponents: ClusterInsightComponent

  "list cached nodes for a cluster, this can be stale up to 5m"
  nodes: [Node]

  "list the cached node metrics for a cluster, can also be stale up to 5m"
  nodeMetrics: [NodeMetric]

  "custom resources with dedicated views for this cluster"
  pinnedCustomResources: [PinnedCustomResource]

  "any upgrade insights provided by your cloud provider that have been discovered by our agent"
  upgradeInsights: [UpgradeInsight]

  "A summation of the metrics utilization of the current cluster"
  metricsSummary: ClusterMetricsSummary

  "the status of the cluster as seen from the CAPI operator, since some clusters can be provisioned without CAPI, this can be null"
  status: ClusterStatus

  "a relay connection of all revisions of this cluster, these are periodically pruned up to a history limit"
  revisions(after: String, first: Int, before: String, last: Int): ClusterRevisionConnection

  "lists OPA constraints registered in this cluster"
  policyConstraints(
    after: String

    first: Int

    before: String

    last: Int

    "only show constraints with a violation for the given namespace"
    namespace: String

    "only show constraints with a violation for the given kind"
    kind: String

    kinds: [String]

    namespaces: [String]

    q: String
  ): PolicyConstraintConnection

  "Computes a list of statistics for OPA constraint violations w\/in this cluster"
  violationStatistics(field: ConstraintViolationField!): [ViolationStatistic]

  "list all alerts discovered for this cluster"
  alerts(after: String, first: Int, before: String, last: Int): AlertConnection

  "Queries logs for a cluster out of loki"
  logs(query: LokiQuery!, start: Long, end: Long, limit: Int!): [LogStream]

  clusterMetrics(start: DateTime, stop: DateTime, step: String): ClusterMetrics

  clusterNodeMetrics(node: String!, start: DateTime, stop: DateTime, step: String): ClusterNodeMetrics

  "fetches a list of runtime services found in this cluster, this is an expensive operation that should not be done in list queries"
  runtimeServices: [RuntimeService]

  "whether the current user can edit this cluster"
  editable: Boolean

  insertedAt: DateTime

  updatedAt: DateTime
}

"A consolidated checklist of tasks that need to be completed to upgrade this cluster"
type ClusterUpgradePlan {
  "whether api compatibilities with all addons and kubernetes are satisfied"
  compatibilities: Boolean

  "whether mutual api incompatibilities with all addons and kubernetes have been satisfied"
  incompatibilities: Boolean

  "whether all api deprecations have been cleared for the target version"
  deprecations: Boolean
}

"a historical revision of a cluster, including version, cloud and node group configuration"
type ClusterRevision {
  id: ID!
  version: String
  nodePools: [NodePool]
  insertedAt: DateTime
  updatedAt: DateTime
}

"A summarization of the core cpu and memory metrics for this cluster"
type ClusterMetricsSummary {
  nodes: Int

  "the cpu available in vcpu"
  cpuAvailable: Float

  "the total cpu in use in the cluster measured in vcpu"
  cpuTotal: Float

  "a percentage cpu utilization of the cluster"
  cpuUsed: Int

  "the total number of megabytes available in the cluster"
  memoryAvailable: Float

  "the total number of megabytes in use in the cluster"
  memoryTotal: Float

  "a percentage memory utilization of the cluster"
  memoryUsed: Int
}

"a specification for a node pool to be created in this cluster"
type NodePool {
  "internal id for this node pool"
  id: ID!

  "name of this node pool (must be unique)"
  name: String!

  "minimum number of instances in this node pool"
  minSize: Int!

  "maximum number of instances in this node pool"
  maxSize: Int!

  "the type of node to use (usually cloud-specific)"
  instanceType: String!

  "whether this is a spot pool or not"
  spot: Boolean

  "kubernetes labels to apply to the nodes in this pool, useful for node selectors"
  labels: Map

  "any taints you'd want to apply to a node, for eg preventing scheduling on spot instances"
  taints: [Taint]

  "cloud specific settings for the node groups"
  cloudSettings: NodeCloudSettings

  insertedAt: DateTime

  updatedAt: DateTime
}

"a kubernetes node taint"
type Taint {
  key: String!
  value: String!
  effect: String!
}

"the cloud configuration for a cluster"
type CloudSettings {
  aws: AwsCloudSettings
  gcp: GcpCloudSettings
  azure: AzureCloudSettings
}

"aws specific cloud configuration"
type AwsCloudSettings {
  region: String
}

"gcp specific cluster cloud configuration"
type GcpCloudSettings {
  project: String
  network: String
  region: String
}

"azure-specific cluster cloud configuration"
type AzureCloudSettings {
  location: String
  subscriptionId: String
  resourceGroup: String
  network: String
}

"cloud specific settings for a node pool"
type NodeCloudSettings {
  aws: AwsCloud
}

"aws node customizations"
type AwsCloud {
  "custom launch template for your nodes, useful for Golden AMI setups"
  launchTemplateId: String
}

"a cloud credential that can be used while creating new clusters"
type ProviderCredential {
  id: ID!
  name: String!
  namespace: String!
  kind: String!
  insertedAt: DateTime
  updatedAt: DateTime
}

"the crd status of the cluster as seen by the CAPI operator"
type ClusterStatus {
  phase: String
  controlPlaneReady: Boolean
  failureMessage: String
  failureReason: String
  conditions: [ClusterCondition]
}

"Summary statistics of the upgradeability of your fleet"
type UpgradeStatistics {
  "total number of clusters"
  count: Int

  "the number of clusters currently upgradeable"
  upgradeable: Int

  "the number of clusters currently at the latest version"
  latest: Int

  "the number of clusters compliant w\/ your versioning policy"
  compliant: Int
}

"a single condition struct for various phases of the cluster provisionining process"
type ClusterCondition {
  lastTransitionTime: String
  status: String
  type: String
  message: String
  reason: String
  severity: String
}

"A common kubernetes cluster add-on like cert-manager, istio, etc"
type ClusterAddOn {
  name: String
  version: String
  icon: String
  global: Boolean
  configuration: [AddOnConfiguration]
}

"Input configuration for an add-on you can install"
type AddOnConfiguration {
  "name for this configuration"
  name: String

  "a docstring explaining this configuration"
  documentation: String

  "a type for the configuration (should eventually be coerced back to string)"
  type: String

  "the values for ENUM type conditions"
  values: [String]

  condition: AddOnConfigCondition
}

"a condition that determines whether its configuration is viewable"
type AddOnConfigCondition {
  "the operation for this condition, eg EQ, LT, GT"
  operation: String

  "the field this condition applies to"
  field: String

  "the value to apply the condition with, for binary operators like LT\/GT"
  value: String
}

"a service encapsulating a controller like istio\/ingress-nginx\/etc that is meant to extend the kubernetes api"
type RuntimeService {
  id: ID!

  "add-on name"
  name: String!

  "add-on version, should be semver formatted"
  version: String!

  "the number of instances of this service we've detected"
  instanceCount: Int

  "the full specification of this kubernetes add-on"
  addon: RuntimeAddon

  "the version of the add-on you've currently deployed"
  addonVersion: AddonVersion

  "the plural service it came from"
  service: ServiceDeployment

  insertedAt: DateTime

  updatedAt: DateTime
}

"a full specification of a kubernetes runtime component's requirements"
type RuntimeAddon {
  "an icon to identify this runtime add-on"
  icon: String

  "the url to the add-ons git repository"
  gitUrl: String

  "the add-on's readme, this is a heavy operation that should not be performed w\/in lists"
  readme: String

  "the release page for a runtime service at a version, this is a heavy operation not suitable for lists"
  releaseUrl(version: String!): String

  versions: [AddonVersion]
}

"the specification of a runtime service at a specific version"
type AddonVersion {
  "add-on version, semver formatted"
  version: String

  "kubernetes versions this add-on works with"
  kube: [String]

  "any other add-ons this might require"
  requirements: [VersionReference]

  "any add-ons this might break"
  incompatibilities: [VersionReference]

  "the version of the helm chart to install for this version"
  chartVersion: String

  "the release page for a runtime service at a version, this is a heavy operation not suitable for lists"
  releaseUrl(version: String!): String

  "checks if this is blocking a specific kubernetes upgrade"
  blocking(kubeVersion: String!): Boolean
}

"a shortform reference to an addon by version"
type VersionReference {
  name: String!
  version: String!
}

"a representation of a bulk operation to be performed on all agent services"
type AgentMigration {
  id: ID!
  name: String
  ref: String
  configuration: Map
  completed: Boolean
  insertedAt: DateTime
  updatedAt: DateTime
}

type Tag {
  id: ID!
  name: String!
  value: String!
}

"a cluster info data struct"
type ClusterStatusInfo {
  healthy: Boolean
  count: Int
}

"A reference to a custom resource you want to be displayed in the k8s dashboard"
type PinnedCustomResource {
  id: ID!
  name: String!
  displayName: String!
  group: String!
  version: String!
  kind: String!
  namespaced: Boolean
  cluster: Cluster
}

type UpgradeInsight {
  id: ID!

  name: String!

  "the k8s version this insight applies to"
  version: String

  "longform description of this insight"
  description: String

  status: UpgradeInsightStatus

  refreshedAt: DateTime

  transitionedAt: DateTime

  details: [UpgradeInsightDetail]

  insertedAt: DateTime

  updatedAt: DateTime
}

type UpgradeInsightDetail {
  id: ID!

  status: UpgradeInsightStatus

  "a possibly deprecated API"
  used: String

  "the replacement for this API"
  replacement: String

  "information about the HTTP clients triggering this insight"
  clientInfo: [InsightClientInfo]

  replacedIn: String

  removedIn: String

  lastUsedAt: DateTime

  insertedAt: DateTime

  updatedAt: DateTime
}

type InsightClientInfo {
  userAgent: String
  count: String
  lastRequestAt: DateTime
}

type ClusterConnection {
  pageInfo: PageInfo!
  edges: [ClusterEdge]
}

type ClusterProviderConnection {
  pageInfo: PageInfo!
  edges: [ClusterProviderEdge]
}

type ClusterRevisionConnection {
  pageInfo: PageInfo!
  edges: [ClusterRevisionEdge]
}

type TagConnection {
  pageInfo: PageInfo!
  edges: [TagEdge]
}

enum AuthMethod {
  BASIC
  SSH
}

enum GitHealth {
  PULLABLE
  FAILED
}

enum ScmType {
  GITHUB
  GITLAB
  BITBUCKET
}

enum MatchStrategy {
  ANY
  ALL
  RECURSIVE
}

enum ListMerge {
  OVERWRITE
  APPEND
}

enum HelmAuthProvider {
  BASIC
  BEARER
  GCP
  AZURE
  AWS
}

enum PrRole {
  CLUSTER
  SERVICE
  PIPELINE
  UPDATE
  UPGRADE
}

enum PrStatus {
  OPEN
  MERGED
  CLOSED
}

enum ConfigurationType {
  STRING
  INT
  BOOL
  DOMAIN
  BUCKET
  FILE
  FUNCTION
  PASSWORD
  ENUM
}

enum Operation {
  NOT
  GT
  LT
  EQ
  GTE
  LTE
  PREFIX
  SUFFIX
}

enum ValidationUniqScope {
  PROJECT
  CLUSTER
}

enum ObserverActionType {
  PIPELINE
  PR
}

enum ObserverTargetType {
  OCI
  HELM
  GIT
}

enum ObserverGitTargetType {
  TAGS
}

enum ObserverTargetOrder {
  SEMVER
  LATEST
}

enum ObserverStatus {
  HEALTHY
  FAILED
}

input CatalogAttributes {
  name: String!

  "the name of the author of this catalog, used for attribution only"
  author: String!

  description: String

  "short category name for browsability"
  category: String

  "owning project of the catalog, permissions will propagate down"
  projectId: ID

  "an icon url to use for this catalog"
  icon: String

  "a darkmode icon url to use for this catalog"
  darkIcon: String

  tags: [TagAttributes]

  readBindings: [PolicyBindingAttributes]

  writeBindings: [PolicyBindingAttributes]

  createBindings: [PolicyBindingAttributes]
}

input GitAttributes {
  "the url of this repository"
  url: String!

  "an ssh private key to use with this repo if an ssh url was given"
  privateKey: String

  "a passphrase to decrypt the given private key"
  passphrase: String

  "the http username for authenticated http repos, defaults to apiKey for github"
  username: String

  "the http password for http authenticated repos"
  password: String

  "a manually supplied https path for non standard git setups.  This is auto-inferred in many cases"
  httpsPath: String

  "similar to https_path, a manually supplied url format for custom git.  Should be something like {url}\/tree\/{ref}\/{folder}"
  urlFormat: String

  "id of a scm connection to use for authentication"
  connectionId: ID

  "whether to run plural crypto on this repo"
  decrypt: Boolean
}

input HelmRepositoryAttributes {
  provider: HelmAuthProvider
  auth: HelmAuthAttributes
}

input HelmAuthAttributes {
  basic: HelmBasicAuthAttributes
  bearer: HelmBearerAuthAttributes
  aws: HelmAwsAuthAttributes
  azure: HelmAzureAuthAttributes
  gcp: HelmGcpAuthAttributes
}

input HelmBasicAuthAttributes {
  username: String!
  password: String!
}

input HelmBearerAuthAttributes {
  token: String!
}

input HelmAwsAuthAttributes {
  accessKey: String
  secretAccessKey: String
  assumeRoleArn: String
}

input HelmAzureAuthAttributes {
  clientId: String
  clientSecret: String
  tenantId: String
  subscriptionId: String
}

input HelmGcpAuthAttributes {
  applicationCredentials: String
}

"an object representing a means to authenticate to a source control provider like Github"
input ScmConnectionAttributes {
  name: String!

  type: ScmType!

  "the owning entity in this scm provider, eg a github organization"
  owner: String

  username: String

  token: String

  baseUrl: String

  apiUrl: String

  github: GithubAppAttributes

  "a ssh private key to be used for commit signing"
  signingPrivateKey: String
}

"Requirements to perform Github App authentication"
input GithubAppAttributes {
  "Github App ID"
  appId: String!

  "ID of this github app installation"
  installationId: String!

  "PEM-encoded private key for this app"
  privateKey: String!
}

"A way to create a self-service means of generating PRs against an IaC repo"
input PrAutomationAttributes {
  name: String

  role: PrRole

  "string id for a repository, eg for github, this is {organization}\/{repository-name}"
  identifier: String

  documentation: String

  title: String

  message: String

  branch: String

  updates: PrAutomationUpdateSpecAttributes

  creates: PrAutomationCreateSpecAttributes

  deletes: PrAutomationDeleteSpecAttributes

  "an icon url to use for this catalog"
  icon: String

  "a darkmode icon url to use for this catalog"
  darkIcon: String

  "link to an add-on name if this can update it"
  addon: String

  "link to a cluster if this is to perform an upgrade"
  clusterId: ID

  "link to a service if this can modify its configuration"
  serviceId: ID

  "the scm connection to use for pr generation"
  connectionId: ID

  "the catalog this automation will belong to"
  catalogId: ID

  "the project this automation lives in"
  projectId: ID

  "a git repository to use for create mode prs"
  repositoryId: ID

  configuration: [PrConfigurationAttributes]

  confirmation: PrConfirmationAttributes

  "users who can update this automation"
  writeBindings: [PolicyBindingAttributes]

  "users who can create prs with this automation"
  createBindings: [PolicyBindingAttributes]
}

"Additional details to verify all prerequisites are satisfied before generating this pr"
input PrConfirmationAttributes {
  "optional markdown text to present before pr create"
  text: String

  "itemized checklist to complete before pr create"
  checklist: [PrChecklistAttributes]
}

"a checkbox item to render before creating a pr"
input PrChecklistAttributes {
  "the label for the checkbox"
  label: String!
}

"the a configuration item for creating a new pr"
input PrConfigurationAttributes {
  type: ConfigurationType!
  name: String!
  default: String
  documentation: String
  longform: String
  placeholder: String
  optional: Boolean
  condition: ConditionAttributes
  validation: ConfigurationValidationAttributes
  values: [String]
}

"attributes for declaratively specifying whether a config item is relevant given prior config"
input ConditionAttributes {
  operation: Operation!
  field: String!
  value: String
}

"Validations to apply to this configuration entry prior to PR creation"
input ConfigurationValidationAttributes {
  "regex a string value should match"
  regex: String

  "whether the string is json encoded"
  json: Boolean

  "configuration for name uniqueness"
  uniqBy: UniqByAttributes
}

"How to enforce uniqueness for a field"
input UniqByAttributes {
  "the scope this name is uniq w\/in"
  scope: ValidationUniqScope!
}

"The operations to be performed on the files w\/in the pr"
input PrAutomationUpdateSpecAttributes {
  regexes: [String]

  "list of regex scope replacement templates, useful for ANY strategies"
  regexReplacements: [RegexReplacementAttributes]

  "list of yaml overlay operations to apply to a file"
  yamlOverlays: [YamlOverlayAttributes]

  files: [String]

  replaceTemplate: String

  yq: String

  matchStrategy: MatchStrategy
}

"Operations to create new templated files within this pr"
input PrAutomationCreateSpecAttributes {
  git: GitRefAttributes
  templates: [PrAutomationTemplateAttributes]
}

"Operations to delete files within this pr"
input PrAutomationDeleteSpecAttributes {
  files: [String!]
  folders: [String!]
}

"a fully specified regex\/replace flow"
input RegexReplacementAttributes {
  regex: String!

  replacement: String!

  "the filename to apply this regex on"
  file: String!

  "whether you want to apply liquid templating on the regex before compiling"
  templated: Boolean
}

"templates to apply in this pr"
input PrAutomationTemplateAttributes {
  source: String!

  destination: String!

  "whether the source template is sourced from an external git repo bound to this automation"
  external: Boolean!
}

"a description of a yaml-merge operation on a file"
input YamlOverlayAttributes {
  "the filename to apply this yaml overlay on"
  file: String!

  yaml: String!

  "configure how list merge should be performed"
  listMerge: ListMerge

  "whether you want to apply liquid templating on the yaml before compiling"
  templated: Boolean
}

"attributes for a pull request pointer record"
input PullRequestAttributes {
  url: String!
  title: String!
  creator: String
  labels: [String]
  serviceId: ID
  clusterId: ID
  service: NamespacedName
  cluster: NamespacedName
}

"attributes for a pull request pointer record"
input PullRequestUpdateAttributes {
  title: String!
  labels: [String]
  status: PrStatus!
  serviceId: ID
  clusterId: ID
  service: NamespacedName
  cluster: NamespacedName
}

"The attributes to configure a new webhook for a SCM provider"
input ScmWebhookAttributes {
  "the secret token for authenticating this webhook via hmac signature"
  hmac: String!

  "the type of webhook to create"
  type: ScmType!

  "the owner for this webhook in your SCM, eg a github org or gitlab group"
  owner: String!
}

"An observer is a mechanism to poll an external helm, oci or other datasources and perform a list of actions in response"
input ObserverAttributes {
  name: String!
  crontab: String!
  target: ObserverTargetAttributes!
  actions: [ObserverActionAttributes]
  projectId: ID
}

"A spec for a target to poll"
input ObserverTargetAttributes {
  type: ObserverTargetType

  "present for backwards compat"
  target: ObserverTargetType

  format: String

  order: ObserverTargetOrder!

  helm: ObserverHelmAttributes

  oci: ObserverOciAttributes

  git: ObserverGitAttributes
}

"A spec of an action that can be taken in response to an observed entity"
input ObserverActionAttributes {
  type: ObserverActionType!
  configuration: ObserverActionConfigurationAttributes!
}

"a spec for querying a helm repository in an observer"
input ObserverHelmAttributes {
  url: String!
  chart: String!
  provider: HelmAuthProvider
  auth: HelmAuthAttributes
}

"a spec for querying a helm repository in an observer"
input ObserverOciAttributes {
  url: String!
  provider: HelmAuthProvider
  auth: HelmAuthAttributes
}

input ObserverGitAttributes {
  repositoryId: ID!
  type: ObserverGitTargetType!
}

"configuration for an observer action"
input ObserverActionConfigurationAttributes {
  pr: ObserverPrActionAttributes
  pipeline: ObserverPipelineActionAttributes
}

"Configuration for sending a pr in response to an observer"
input ObserverPrActionAttributes {
  automationId: ID!

  repository: String

  "a template to use for the created branch, use $value to interject the observed value"
  branchTemplate: String

  "the context to apply, use $value to interject the observed value"
  context: Json!
}

"Configuration for setting a pipeline context in an observer"
input ObserverPipelineActionAttributes {
  pipelineId: ID!

  "the context to apply, use $value to interject the observed value"
  context: Json!
}

"a git repository available for deployments"
type GitRepository {
  "internal id of this repository"
  id: ID!

  "the git url of the repository, either https or ssh supported"
  url: String!

  "whether its a http or ssh url"
  authMethod: AuthMethod

  "whether we can currently pull this repo with the provided credentials"
  health: GitHealth

  "the last successsful git pull timestamp"
  pulledAt: DateTime

  "the error message if there were any pull errors"
  error: String

  "the https url for this git repo"
  httpsPath: String

  "a format string to get the http url for a subfolder in a git repo"
  urlFormat: String

  "whether to run plural crypto unlock on this repo"
  decrypt: Boolean

  "named refs like branches\/tags for a repository"
  refs: [String!]

  "whether the current user can edit this repo"
  editable: Boolean

  insertedAt: DateTime

  updatedAt: DateTime
}

"A direct Plural representation of a Helm repository"
type HelmRepository {
  id: ID!
  url: String!
  health: GitHealth
  error: String
  provider: HelmAuthProvider
  pulledAt: DateTime
  insertedAt: DateTime
  updatedAt: DateTime
}

"a Flux crd representation of a Helm repository"
type FluxHelmRepository {
  metadata: Metadata!

  spec: HelmRepositorySpec!

  "the charts found in this repository (heavy operation, don't do in list endpoints)"
  charts: [HelmChartEntry]

  "can fetch the status of a given helm repository"
  status: HelmRepositoryStatus
}

"a specification of how a helm repository is fetched"
type HelmRepositorySpec {
  provider: String
  url: String!
  type: String
}

"the state of this helm repository"
type HelmRepositoryStatus {
  ready: Boolean
  message: String
}

"a chart manifest entry, including all versions"
type HelmChartEntry {
  "the name of the chart"
  name: String

  "all found versions of the chart"
  versions: [HelmChartVersion]
}

"a chart version contained within a helm repository manifest"
type HelmChartVersion {
  "the version of the app contained w\/in this chart"
  appVersion: String

  "the version of the chart itself"
  version: String

  "the name of the chart"
  name: String

  type: String

  "sha digest of this chart's contents"
  digest: String
}

"an object representing the means to connect to SCM apis"
type ScmConnection {
  id: ID!

  name: String!

  type: ScmType!

  username: String

  "base url for git clones for self-hosted versions"
  baseUrl: String

  "base url for HTTP apis for self-hosted versions if different from base url"
  apiUrl: String

  insertedAt: DateTime

  updatedAt: DateTime
}

"a description of how to generate a pr, which can either modify existing files or generate new ones w\/in a repo"
type PrAutomation {
  id: ID!

  "string id for a repository, eg for github, this is {organization}\/{repository-name}"
  identifier: String!

  "the name for this automation"
  name: String!

  "An enum describing the high-level responsibility of this pr, eg creating a cluster or service, or upgrading a cluster"
  role: PrRole

  documentation: String

  title: String!

  message: String!

  updates: PrUpdateSpec

  creates: PrCreateSpec

  deletes: PrDeleteSpec

  "an icon url to use for this catalog"
  icon: String

  "a darkmode icon url to use for this catalog"
  darkIcon: String

  configuration: [PrConfiguration]

  "optional confirmation block to express prerequisites for this PR"
  confirmation: PrConfirmation

  "write policy for this pr automation, also propagates to the notifications list for any created PRs"
  writeBindings: [PolicyBinding]

  "users who can generate prs with this automation"
  createBindings: [PolicyBinding]

  "link to an add-on name if this can update it"
  addon: String

  "the git repository to use for sourcing external templates"
  repository: GitRepository

  "the catalog this pr automation belongs to"
  catalog: Catalog

  "the project this automation lives w\/in"
  project: Project

  "link to a cluster if this is to perform an upgrade"
  cluster: Cluster

  "link to a service if this can update its configuration"
  service: ServiceDeployment

  "the scm connection to use for pr generation"
  connection: ScmConnection

  insertedAt: DateTime

  updatedAt: DateTime
}

"existing file updates that can be performed in a PR"
type PrUpdateSpec {
  regexes: [String]
  regexReplacements: [RegexReplacement]
  yamlOverlays: [YamlOverlay]
  files: [String]
  replaceTemplate: String
  yq: String
  matchStrategy: MatchStrategy
}

"a description of a yaml-merge operation on a file"
type YamlOverlay {
  yaml: String!

  "the filename to apply this yaml overlay on"
  file: String!

  "whether you want to apply liquid templating on the yaml before compiling"
  templated: Boolean

  "configure how list merge should be performed"
  listMerge: ListMerge
}

"templated files used to add new files to a given pr"
type PrCreateSpec {
  "pointer within an external git repository to source templates from"
  git: GitRef

  templates: [PrTemplateSpec]
}

"Files or folders you want to delete in this pr"
type PrDeleteSpec {
  files: [String!]
  folders: [String!]
}

"the details of where to find and place a templated file"
type PrTemplateSpec {
  source: String!
  destination: String!
  external: Boolean!
}

"a fully specified regex\/replace flow"
type RegexReplacement {
  regex: String!

  "the file to apply this replacement on"
  file: String!

  "template string to replace any match with"
  replacement: String!

  "Whether to apply liquid templating before compiling this regex"
  templated: Boolean
}

"the a configuration item for creating a new pr, used for templating the ultimate code changes made"
type PrConfiguration {
  type: ConfigurationType!
  name: String!
  default: String
  documentation: String
  longform: String
  placeholder: String
  optional: Boolean
  values: [String]
  condition: PrConfigurationCondition
}

"declaritive spec for whether a config item is relevant given prior config"
type PrConfigurationCondition {
  "a boolean operation to apply"
  operation: Operation!

  "the prior field to check"
  field: String!

  "a fixed value to check against if its a binary operation"
  value: String
}

"Additional details to verify all prerequisites are satisfied before generating this pr"
type PrConfirmation {
  "optional markdown text to present before pr create"
  text: String

  "itemized checklist to complete before pr create"
  checklist: [PrChecklist]
}

"a checkbox item to render before creating a pr"
type PrChecklist {
  "the label for the checkbox"
  label: String!
}

"A reference to a pull request for your kubernetes related IaC"
type PullRequest {
  id: ID!

  status: PrStatus

  url: String!

  title: String

  creator: String

  labels: [String]

  "the cluster this pr is meant to modify"
  cluster: Cluster

  "the service this pr is meant to modify"
  service: ServiceDeployment

  insertedAt: DateTime

  updatedAt: DateTime
}

type ScmWebhook {
  id: ID!

  type: ScmType!

  owner: String!

  "the url for this specific webhook"
  url: String!

  "the name in your SCM provider for this webhook"
  name: String!

  insertedAt: DateTime

  updatedAt: DateTime
}

"A representation to a service which configures renovate for a scm connection"
type DependencyManagementService {
  id: ID!
  connection: ScmConnection
  service: ServiceDeployment
  insertedAt: DateTime
  updatedAt: DateTime
}

"An observer is a mechanism to poll an external helm, oci or other datasources and perform a list of actions in response"
type Observer {
  id: ID!
  name: String!
  status: ObserverStatus!
  crontab: String!
  lastRunAt: DateTime!
  nextRunAt: DateTime!
  target: ObserverTarget!
  actions: [ObserverAction]
  project: Project
  errors: [ServiceError]
  insertedAt: DateTime
  updatedAt: DateTime
}

"A spec for a target to poll"
type ObserverTarget {
  type: ObserverTargetType!

  "present for backwards compat, use `type` instead"
  target: ObserverTargetType!

  """
  a regex for extracting the target value, useful in cases where a semver is nested
  in a larger release string.  The first capture group is the substring that is used for the value.
  """
  format: String

  "the order in which polled results are applied, defaults to SEMVER"
  order: ObserverTargetOrder!

  helm: ObserverHelmRepo

  oci: ObserverOciRepo

  git: ObserverGitRepo
}

"A spec of an action that can be taken in response to an observed entity"
type ObserverAction {
  type: ObserverActionType!
  configuration: ObserverActionConfiguration!
}

"a spec for querying a helm in an observer"
type ObserverHelmRepo {
  url: String!
  chart: String!
  provider: HelmAuthProvider
}

"a spec for querying a oci repository in an observer"
type ObserverOciRepo {
  url: String!
  provider: HelmAuthProvider
}

"a spec for polling a git repository for recent updates"
type ObserverGitRepo {
  repositoryId: ID!

  "the resource within the git repository you want to poll"
  type: ObserverGitTargetType!
}

"configuration for an observer action"
type ObserverActionConfiguration {
  pr: ObserverPrAction
  pipeline: ObserverPipelineAction
}

"Configuration for sending a pr in response to an observer"
type ObserverPrAction {
  automationId: ID!

  repository: String

  "a template to use for the created branch, use $value to interject the observed value"
  branchTemplate: String

  "the context to apply, use $value to interject the observed value"
  context: Json!
}

"Configuration for setting a pipeline context in an observer"
type ObserverPipelineAction {
  pipelineId: ID!

  "the context to apply, use $value to interject the observed value"
  context: Map!
}

"A catalog is an organized collection of PR Automations used for permissioning and discovery"
type Catalog {
  id: ID!

  name: String!

  "longform description for the purpose of this catalog"
  description: String

  "short category name used for browsing catalogs"
  category: String

  "the name of the author of this catalog"
  author: String

  "an icon url to use for this catalog"
  icon: String

  "a darkmode icon url to use for this catalog"
  darkIcon: String

  project: Project

  "read policy for this catalog"
  readBindings: [PolicyBinding]

  "write policy for this catalog"
  writeBindings: [PolicyBinding]

  "create policy for this catalog, can give permission to just create prs"
  createBindings: [PolicyBinding]

  insertedAt: DateTime

  updatedAt: DateTime
}

type GitRepositoryConnection {
  pageInfo: PageInfo!
  edges: [GitRepositoryEdge]
}

type HelmRepositoryConnection {
  pageInfo: PageInfo!
  edges: [HelmRepositoryEdge]
}

type ScmConnectionConnection {
  pageInfo: PageInfo!
  edges: [ScmConnectionEdge]
}

type PrAutomationConnection {
  pageInfo: PageInfo!
  edges: [PrAutomationEdge]
}

type PullRequestConnection {
  pageInfo: PageInfo!
  edges: [PullRequestEdge]
}

type ScmWebhookConnection {
  pageInfo: PageInfo!
  edges: [ScmWebhookEdge]
}

type DependencyManagementServiceConnection {
  pageInfo: PageInfo!
  edges: [DependencyManagementServiceEdge]
}

type ObserverConnection {
  pageInfo: PageInfo!
  edges: [ObserverEdge]
}

type CatalogConnection {
  pageInfo: PageInfo!
  edges: [CatalogEdge]
}

"A role to pass to an LLM, modeled after OpenAI's chat api roles"
enum AiRole {
  SYSTEM
  ASSISTANT
  USER
}

"enumerable to describe the recency of this insight"
enum InsightFreshness {
  FRESH
  STALE
  EXPIRED
}

"A basic AI chat message input, modeled after OpenAI's api model"
input ChatMessage {
  role: AiRole!
  content: String!
}

"the items you want to reference in this pin"
input AiPinAttributes {
  name: String
  insightId: ID
  threadId: ID
}

"basic user-supplied input for creating an AI chat thread"
input ChatThreadAttributes {
  summary: String!

  "controls whether this thread is autosummarized, set true when users explicitly set summary"
  summarized: Boolean

  "a list of messages to add initially when creating this thread"
  messages: [ChatMessage]

  "an ai insight this thread was created from"
  insightId: ID
}

type Chat {
  id: ID!
  role: AiRole!
  content: String!
  seq: Int!
  thread: ChatThread
  insertedAt: DateTime
  updatedAt: DateTime
}

"A list of chat messages around a specific topic created on demand"
type ChatThread {
  id: ID!
  summary: String!
  default: Boolean!
  lastMessageAt: DateTime
  user: User
  insight: AiInsight
  chats(after: String, first: Int, before: String, last: Int): ChatConnection
  insertedAt: DateTime
  updatedAt: DateTime
}

"A saved item for future ai-based investigation"
type AiPin {
  id: ID!
  name: String
  insight: AiInsight
  thread: ChatThread
  insertedAt: DateTime
  updatedAt: DateTime
}

"A representation of a LLM-derived insight"
type AiInsight {
  id: ID!

  "a deduplication sha for this insight"
  sha: String

  "the text of this insight"
  text: String

  "a shortish summary of this insight"
  summary: String

  freshness: InsightFreshness

  "any errors generated when compiling this insight"
  error: [ServiceError]

  service: ServiceDeployment

  stack: InfrastructureStack

  cluster: Cluster

  stackRun: StackRun

  serviceComponent: ServiceComponent

  clusterInsightComponent: ClusterInsightComponent

  insertedAt: DateTime

  updatedAt: DateTime
}

"A kubernetes object used in the course of generating a cluster insight"
type ClusterInsightComponent {
  id: ID!

  group: String

  version: String!

  kind: String!

  namespace: String

  name: String!

  cluster: Cluster

  "the raw kubernetes resource itself, this is an expensive fetch and should be used sparingly"
  resource: KubernetesUnstructured
}

type ChatConnection {
  pageInfo: PageInfo!
  edges: [ChatEdge]
}

type ChatThreadConnection {
  pageInfo: PageInfo!
  edges: [ChatThreadEdge]
}

type AiPinConnection {
  pageInfo: PageInfo!
  edges: [AiPinEdge]
}

input CloneAttributes {
  s3AccessKeyId: String
  s3SecretAccessKey: String
  s3WalPath: String
  s3Endpoint: String
  uid: String
}

type Postgresql {
  metadata: Metadata!
  spec: PostgresqlSpec!
  status: PostgresqlStatus
  instances: [PostgresInstance]
}

type PostgresqlSpec {
  teamId: String
  users: Map
  resources: Resources
  postgresql: PostgresSettings
  numberOfInstances: Int
  databases: Map
  volume: DatabaseVolume
  pods: [Pod]
}

type DatabaseVolume {
  size: String
}

type PostgresSettings {
  version: String
}

type PostgresInstance {
  uid: String!
}

type PostgresqlStatus {
  clusterStatus: String
}

enum WebhookType {
  PIAZZA
  SLACK
}

enum WebhookHealth {
  HEALTHY
  UNHEALTHY
}

input WebhookAttributes {
  url: String!
}

type Webhook {
  id: ID!
  url: String!
  health: WebhookHealth!
  type: WebhookType!
  insertedAt: DateTime
  updatedAt: DateTime
}

type WebhookConnection {
  pageInfo: PageInfo!
  edges: [WebhookEdge]
}

input RunbookActionInput {
  action: String!
  context: Map!
}

input RunbookContext {
  timeseriesStart: Int
  timeseriesStep: String
}

type Runbook {
  name: String!
  spec: RunbookSpec!
  status: RunbookStatus
  data(context: RunbookContext): [RunbookData]
  executions(after: String, first: Int, before: String, last: Int): RunbookExecutionConnection
}

type RunbookExecution {
  id: ID!
  name: String!
  namespace: String!
  context: Map!
  user: User
  insertedAt: DateTime
  updatedAt: DateTime
}

type RunbookStatus {
  alerts: [RunbookAlertStatus]
}

type RunbookAlertStatus {
  name: String!
  startsAt: String
  fingerprint: String
  annotations: Map
  labels: Map
}

type RunbookSpec {
  name: String!
  description: String
  display: Map
  datasources: [RunbookDatasource]
  actions: [RunbookAction]
}

type RunbookAction {
  name: String!
  type: String!
  configuration: ConfigurationAction
}

type RunbookDatasource {
  name: String!
  type: String!
  prometheus: PrometheusDatasource
  kubernetes: KubernetesDatasource
}

type PrometheusDatasource {
  query: String!
  format: String
  legend: String
}

type KubernetesDatasource {
  resource: String!
  name: String!
}

type RunbookData {
  name: String!
  source: RunbookDatasource
  kubernetes: KubernetesData
  prometheus: [MetricResponse]
  nodes: [Node]
}

"supported kubernetes objects fetchable in runbooks"
union KubernetesData = Deployment | StatefulSet

type ConfigurationAction {
  updates: [PathUpdate]
}

type PathUpdate {
  path: [String]
  valueFrom: String!
}

type RunbookActionResponse {
  redirectTo: String
}

type RunbookExecutionConnection {
  pageInfo: PageInfo!
  edges: [RunbookExecutionEdge]
}

enum UpgradePolicyType {
  DEPLOY
  APPROVAL
  IGNORE
}

input UpgradePolicyAttributes {
  name: String!
  description: String
  target: String!
  type: UpgradePolicyType!
  repositories: [String]
  weight: Int
}

type UpgradePolicy {
  id: ID!
  name: String!
  description: String
  repositories: [String]
  type: UpgradePolicyType!
  target: String!
  weight: Int
  insertedAt: DateTime
  updatedAt: DateTime
}

input SmtpInput {
  server: String
  port: Int
  password: String
  sender: String
  user: String
}

input ContextAttributes {
  buckets: [String]
  domain: [String]
  configuration: Map!
  protect: [String]
}

type Smtp {
  server: String
  port: Int
  password: String
  sender: String
  user: String
}

type Installation {
  id: ID!
  repository: Repository
}

type Repository {
  id: ID!
  name: String!
  description: String
  icon: String
  docs: [FileContent]
  configuration: Configuration
  grafanaDns: String
}

type FileContent {
  path: String
  content: String
}

type Recipe {
  id: ID!
  name: String!
  description: String
  provider: String
  restricted: Boolean
  recipeSections: [RecipeSection]
  oidcEnabled: Boolean
}

type RecipeSection {
  id: ID!
  repository: Repository
  recipeItems: [RecipeItem]
  configuration: [ConfigurationItem]
}

type RecipeItem {
  id: ID!
  configuration: [ConfigurationItem]
}

type ConfigurationItem {
  name: String
  type: String
  placeholder: String
  documentation: String
  default: String
  optional: Boolean
  condition: ConfigurationCondition
  validation: ConfigurationValidation
}

type ConfigurationValidation {
  type: String
  regex: String
  message: String
}

type ConfigurationCondition {
  field: String
  value: String
  operation: String
}

type Stack {
  id: ID!
  name: String!
  bundles: [Recipe]
  sections: [RecipeSection]
  insertedAt: DateTime
  updatedAt: DateTime
}

type RepositoryContext {
  repository: String!
  context: Map
}

type PluralContext {
  buckets: [String]
  domains: [String]
  configuration: Map!
}

type Account {
  delinquentAt: DateTime
  grandfatheredUntil: DateTime
  availableFeatures: AvailableFeatures
  subscription: PluralSubscription
}

type PluralSubscription {
  id: ID
  plan: Plan
}

type Plan {
  id: ID
  name: String
  period: String
}

type InstallationConnection {
  pageInfo: PageInfo!
  edges: [InstallationEdge]
}

type RepositoryConnection {
  pageInfo: PageInfo!
  edges: [RepositoryEdge]
}

type RecipeConnection {
  pageInfo: PageInfo!
  edges: [RecipeEdge]
}

enum AuditType {
  BUILD
  POD
  CONFIGURATION
  USER
  GROUP
  ROLE
  GROUP_MEMBER
  POLICY
  TEMP_TOKEN
  SERVICE
  CLUSTER
  CLUSTER_PROVIDER
  GIT_REPOSITORY
  DEPLOYMENT_SETTINGS
  PROVIDER_CREDENTIAL
  PIPELINE
  GLOBAL
  OBJECT_STORE
  CLUSTER_RESTORE
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
  APPROVE
  CANCEL
}

type Audit {
  id: ID!
  action: AuditAction!
  type: AuditType!
  repository: String
  ip: String
  city: String
  country: String
  latitude: String
  longitude: String
  actor: User
  insertedAt: DateTime
  updatedAt: DateTime
}

type AuditMetric {
  country: String
  count: Int
}

type AuditConnection {
  pageInfo: PageInfo!
  edges: [AuditEdge]
}

enum AutoscalingTarget {
  STATEFULSET
  DEPLOYMENT
}

input LabelInput {
  name: String
  value: String
}

type Dashboard {
  id: String!
  spec: DashboardSpec!
}

type DashboardSpec {
  name: String
  description: String
  timeslices: [String]
  labels: [DashboardLabel]
  graphs: [DashboardGraph]
}

type DashboardLabel {
  name: String!
  values: [String]
}

type DashboardGraph {
  name: String!
  queries: [DashboardMetric]
  format: String
}

type DashboardMetric {
  legend: String
  query: String
  results: [MetricResult]
}

type MetricResponse {
  metric: Map
  values: [MetricResult]
}

type Metadata {
  labels: [LabelPair]
  annotations: [LabelPair]
  name: String!
  namespace: String
  creationTimestamp: String
  uid: String
}

type SecretKeySelector {
  name: String!
  key: String
}

type ClusterInfo {
  gitCommit: String
  gitVersion: String
  platform: String
  version: String
}

type LabelPair {
  name: String
  value: String
}

type ResourceSpec {
  cpu: String
  memory: String
}

type KubernetesUnstructured {
  group: String
  version: String!
  kind: String!
  raw: Map
  metadata: Metadata!
  events: [Event]
}

type ApplicationDelta {
  delta: Delta
  payload: Application
}

type PluralCluster {
  status: PluralObjectStatus!
  metadata: Metadata!
  reference: Cluster
  raw: String!
  events: [Event]
}

type PluralServiceDeployment {
  status: PluralObjectStatus!
  metadata: Metadata!
  reference: ServiceDeployment
  raw: String!
  events: [Event]
}

type PluralGitRepository {
  status: PluralObjectStatus!
  metadata: Metadata!
  reference: GitRepository
  raw: String!
  events: [Event]
}

type PluralObjectStatus {
  id: String
  conditions: [StatusCondition]
}

type DaemonSet {
  metadata: Metadata!
  status: DaemonSetStatus!
  spec: DaemonSetSpec!
  pods: [Pod]
  raw: String!
  events: [Event]
}

type DaemonSetStatus {
  currentNumberScheduled: Int
  desiredNumberScheduled: Int
  numberReady: Int
  conditions: [StatusCondition]
}

type DaemonSetSpec {
  strategy: DeploymentStrategy
}

type UpgradePlan {
  metadata: Metadata!
  status: UpgradePlanStatus!
  spec: UpgradePlanSpec!
  pods: [Pod]
  raw: String!
  events: [Event]
}

type UpgradePlanStatus {
  conditions: [StatusCondition]
}

type UpgradePlanSpec {
  version: String
  cordon: Boolean
  concurrency: Int
}

type ArgoRollout {
  metadata: Metadata!
  status: ArgoRolloutStatus!
  spec: ArgoRolloutSpec!
  pods: [Pod]
  raw: String!
  events: [Event]
}

type ArgoRolloutSpec {
  replicas: Int
  strategy: ArgoRolloutStrategy
}

type ArgoRolloutStrategy {
  blueGreen: ArgoBlueGreenStrategy
  canary: ArgoCanaryStrategy
}

type ArgoBlueGreenStrategy {
  activeService: String
  autoPromotionEnabled: Boolean
  autoPromotionSeconds: Int
}

type ArgoCanaryStrategy {
  steps: [ArgoStrategyStep]
}

type ArgoStrategyStep {
  setWeight: Int
  pause: CanaryPause
  experiment: ArgoExperiment
  analysis: ArgoAnalysis
}

type ArgoExperiment {
  templates: [ArgoExperimentTemplate]
}

type ArgoAnalysis {
  templates: [ArgoAnalysisTemplate]
}

type ArgoExperimentTemplate {
  name: String
}

type ArgoAnalysisTemplate {
  templateName: String
}

type CanaryPause {
  duration: String
}

type PauseCondition {
  reason: String
  startTime: String
}

type ArgoRolloutStatus {
  abort: Boolean
  phase: String
  replicas: Int
  readyReplicas: Int
  pauseConditions: [PauseCondition]
  conditions: [StatusCondition]
}

type Canary {
  metadata: Metadata!
  status: CanaryStatus!
  spec: CanarySpec!
  primaryDeployment: Deployment
  canaryDeployment: Deployment
  ingress: Ingress
  ingressCanary: Ingress
  raw: String!
  events: [Event]
}

type CanaryStatus {
  conditions: [StatusCondition]
  failedChecks: Int
  canaryWeight: Int
  iterations: Int
  lastTransitionTime: String
  phase: String
}

type CanarySpec {
  autoscalerRef: TargetRef
  targetRef: TargetRef
  ingressRef: TargetRef
  analysis: CanaryAnalysis
  provider: String
}

type CanaryAnalysis {
  interval: String
  maxWeight: Int
  stepWeight: Int
  stepWeights: [Int]
  threshold: Int
}

type TargetRef {
  apiVersion: String
  kind: String
  name: String
}

type ConfigMap {
  metadata: Metadata!
  data: Map!
  raw: String!
}

type Secret {
  metadata: Metadata!
  type: String
  data: Map!
}

type WireguardPeer {
  metadata: Metadata!
  status: WireguardPeerStatus
  spec: WireguardPeerSpec!
  config: String
  user: User
  raw: String!
}

type WireguardPeerStatus {
  ready: Boolean
  conditions: [StatusCondition]
}

type WireguardPeerSpec {
  wireguardRef: String
  address: String
  publicKey: String
}

type Namespace {
  status: NamespaceStatus!
  spec: NamespaceSpec!
  metadata: Metadata!
  raw: String!
  events: [Event]
}

type NamespaceSpec {
  finalizers: [String]
}

type NamespaceStatus {
  phase: String
}

type VerticalPodAutoscaler {
  metadata: Metadata!
  spec: VerticalPodAutoscalerSpec!
  status: VerticalPodAutoscalerStatus
}

type CrossVersionResourceTarget {
  apiVersion: String
  kind: String
  name: String
}

type VerticalPodAutoscalerUpdatePolicy {
  updateMode: String
}

type VerticalPodAutoscalerSpec {
  targetRef: CrossVersionResourceTarget!
  updatePolicy: VerticalPodAutoscalerUpdatePolicy!
}

type VerticalPodAutoscalerStatus {
  recommendation: Recommendation
}

type Recommendation {
  containerRecommendations: [ContainerRecommendation]
}

type ContainerRecommendation {
  name: String
  containerName: String
  target: ResourceRequest
  lowerBound: ResourceRequest
  upperBound: ResourceRequest
  uncappedTarget: ResourceRequest
}

type ConfigurationOverlay {
  metadata: Metadata!
  spec: ConfigurationOverlaySpec!
}

type OverlayUpdate {
  path: [String]
}

type ConfigurationOverlaySpec {
  name: String
  folder: String
  subfolder: String
  documentation: String
  updates: [OverlayUpdate]
  inputType: String
  inputValues: [String]
}

type Certificate {
  metadata: Metadata!
  status: CertificateStatus!
  spec: CertificateSpec!
  raw: String!
  events: [Event]
}

type CertificateStatus {
  conditions: [StatusCondition]
  notAfter: String
  notBefore: String
  renewalTime: String
}

type CertificateSpec {
  dnsNames: [String]
  secretName: String!
  issuerRef: IssuerRef
}

type IssuerRef {
  group: String
  kind: String
  name: String
}

type Job {
  metadata: Metadata!
  status: JobStatus!
  spec: JobSpec!
  raw: String!
  events: [Event]
  pods: [Pod]
  logs(container: String!, sinceSeconds: Int!): [String]
}

type JobStatus {
  active: Int
  completionTime: String
  startTime: String
  succeeded: Int
  failed: Int
}

type JobSpec {
  backoffLimit: Int
  parallelism: Int
  activeDeadlineSeconds: Int
}

type LogFilter {
  metadata: Metadata!
  spec: LogFilterSpec!
}

type LogFilterSpec {
  name: String
  description: String
  query: String
  labels: [LogLabel]
}

type CronJob {
  metadata: Metadata!
  status: CronStatus!
  spec: CronSpec!
  raw: String!
  events: [Event]
  jobs: [Job]
}

type CronStatus {
  active: [JobReference]
  lastScheduleTime: String
}

type JobReference {
  name: String!
  namespace: String!
}

type CronSpec {
  schedule: String!
  suspend: Boolean
  concurrencyPolicy: String
}

type Node {
  status: NodeStatus!
  spec: NodeSpec!
  metadata: Metadata!
  raw: String!
  pods: [Pod]
  events: [Event]
}

type NodeStatus {
  allocatable: Map
  capacity: Map
  phase: String
  conditions: [NodeCondition]
}

type NodeCondition {
  message: String
  reason: String
  status: String
  type: String
}

type NodeSpec {
  podCidr: String
  providerId: String
  unschedulable: Boolean
}

type NodeUsage {
  cpu: String
  memory: String
}

type NodeMetric {
  metadata: Metadata!
  timestamp: String
  window: String
  usage: NodeUsage
}

type Ingress {
  metadata: Metadata!
  status: ServiceStatus!
  spec: IngressSpec!
  certificates: [Certificate]
  raw: String!
  events: [Event]
}

type IngressSpec {
  ingressClassName: String
  rules: [IngressRule]
  tls: [IngressTls]
}

type IngressRule {
  host: String
  http: HttpIngressRule
}

type HttpIngressRule {
  paths: [IngressPath]
}

type IngressPath {
  backend: IngressBackend
  path: String
}

type IngressBackend {
  serviceName: String
  servicePort: String
}

type IngressTls {
  hosts: [String]
}

type Service {
  metadata: Metadata!
  status: ServiceStatus!
  spec: ServiceSpec!
  pods: [Pod]
  raw: String!
  events: [Event]
}

type ServiceStatus {
  loadBalancer: LoadBalancerStatus
  conditions: [StatusCondition]
}

type LoadBalancerStatus {
  ingress: [LoadBalancerIngressStatus]
}

type LoadBalancerIngressStatus {
  hostname: String
  ip: String
}

type ServiceSpec {
  type: String
  clusterIp: String
  selector: Map
  ports: [ServicePort]
}

type ServicePort {
  name: String
  protocol: String
  port: Int
  targetPort: String
}

type StatefulSet {
  metadata: Metadata!
  status: StatefulSetStatus!
  spec: StatefulSetSpec!
  pods: [Pod]
  raw: String!
  events: [Event]
}

type StatefulSetStatus {
  currentReplicas: Int
  replicas: Int
  readyReplicas: Int
  updatedReplicas: Int
  conditions: [StatusCondition]
}

type StatefulSetSpec {
  replicas: Int
  serviceName: String
}

type Deployment {
  metadata: Metadata!
  status: DeploymentStatus!
  spec: DeploymentSpec!
  pods: [Pod]
  raw: String!
  events: [Event]
}

type ReplicaSet {
  metadata: Metadata!
  spec: ReplicaSetSpec!
  status: ReplicaSetStatus!
  pods: [Pod]
  raw: String!
}

type DeploymentStatus {
  availableReplicas: Int
  replicas: Int
  readyReplicas: Int
  unavailableReplicas: Int
  conditions: [StatusCondition]
}

type DeploymentSpec {
  replicas: Int
  strategy: DeploymentStrategy
}

type ReplicaSetSpec {
  replicas: Int
}

type DeploymentStrategy {
  type: String
  rollingUpdate: RollingUpdate
}

type RollingUpdate {
  maxSurge: Int
  maxUnavailable: Int
}

type ReplicaSetStatus {
  availableReplicas: Int
  conditions: [StatusCondition]
  replicas: Int
  readyReplicas: Int
  fullyLabeledReplicas: Int
}

type Pod {
  status: PodStatus!
  spec: PodSpec!
  metadata: Metadata!
  raw: String!
  logs(container: String!, sinceSeconds: Int!): [String]
  events: [Event]
}

type PodStatus {
  message: String
  phase: String
  hostIp: String
  podIp: String
  reason: String
  conditions: [PodCondition]
  containerStatuses: [ContainerStatus]
  initContainerStatuses: [ContainerStatus]
}

type PodCondition {
  lastProbeTime: String
  lastTransitionTime: String
  message: String
  reason: String
  status: String
  type: String
}

type ContainerStatus {
  restartCount: Int
  ready: Boolean
  name: String
  image: String
  state: ContainerState
}

type ContainerState {
  running: RunningState
  terminated: TerminatedState
  waiting: WaitingState
}

type RunningState {
  startedAt: String
}

type TerminatedState {
  exitCode: Int
  finishedAt: String
  startedAt: String
  message: String
  reason: String
}

type WaitingState {
  message: String
  reason: String
}

type PodSpec {
  serviceAccountName: String
  nodeName: String
  containers: [Container]
  initContainers: [Container]
}

type Container {
  image: String
  name: String
  ports: [Port]
  resources: Resources
}

type Port {
  hostPort: Int
  containerPort: Int
  protocol: String
}

type Resources {
  limits: ResourceSpec
  requests: ResourceSpec
}

type PodConnection {
  pageInfo: PageInfo!
  edges: [PodEdge]
}

type PodDelta {
  delta: Delta
  payload: Pod
}

type Application {
  name: String!
  spec: ApplicationSpec!
  status: ApplicationStatus!
  cost: CostAnalysis
  license: License
  configuration: Configuration
  info: String
}

type CostAnalysis {
  minutes: Float
  cpuCost: Float
  cpuEfficiency: Float
  efficiency: Float
  gpuCost: Float
  networkCost: Float
  pvCost: Float
  ramCost: Float
  ramEfficiency: Float
  totalCost: Float
  sharedCost: Float
}

type ApplicationSpec {
  descriptor: ApplicationDescriptor!
  components: [Component]
  info: [ApplicationInfoItem]
}

type ApplicationLink {
  url: String
  description: String
}

type ApplicationInfoItem {
  type: String
  name: String
  value: String
}

type ApplicationDescriptor {
  type: String!
  version: String!
  description: String
  icons: [String]
  links: [ApplicationLink]
}

type Component {
  group: String!
  kind: String!
}

type ApplicationStatus {
  components: [StatusComponent]
  conditions: [StatusCondition]
  componentsReady: String!
}

type StatusComponent {
  group: String
  kind: String!
  name: String!
  status: String!
}

type StatusCondition {
  message: String!
  reason: String!
  status: String!
  type: String!
}

type License {
  metadata: Metadata!
  spec: LicenseSpec!
  status: LicenseStatus
}

type LicenseSpec {
  secretRef: SecretKeySelector!
}

type LicenseStatus {
  plan: String
  free: Boolean
  features: [LicenseFeature]
  limits: Map
  secrets: Map
}

type LicenseFeature {
  name: String!
  description: String
}

type Event {
  action: String
  count: Int
  eventTime: String
  lastTimestamp: String
  message: String
  reason: String
  type: String
}

enum Permission {
  READ
  CONFIGURE
  DEPLOY
  OPERATE
}

enum Severity {
  NONE
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum NotificationStatus {
  FIRING
  RESOLVED
}

enum ReadType {
  NOTIFICATION
  BUILD
}

input UserAttributes {
  name: String
  email: String
  password: String
  roles: UserRoleAttributes
  emailSettings: EmailSettingsAttributes
  signingPrivateKey: String
}

input ServiceAccountAttributes {
  name: String
  email: String
  roles: UserRoleAttributes
  assumeBindings: [PolicyBindingAttributes]
}

input UserRoleAttributes {
  admin: Boolean
}

input EmailSettingsAttributes {
  "whether you want to receive digest emails"
  digest: Boolean
}

input InviteAttributes {
  email: String
}

input ScopeAttributes {
  api: String
  apis: [String!]
  identifier: String
  ids: [String!]
}

input GroupAttributes {
  name: String!
  description: String
  global: Boolean
}

input RoleAttributes {
  name: String
  description: String
  repositories: [String]
  roleBindings: [BindingAttributes]
  permissions: [Permission]
}

input BindingAttributes {
  id: ID
  userId: ID
  groupId: ID
}

input PersonaAttributes {
  name: String

  "longform description of this persona"
  description: String

  configuration: PersonaConfigurationAttributes

  bindings: [BindingAttributes]
}

input PersonaConfigurationAttributes {
  "enable full ui for this persona"
  all: Boolean

  "configuration for the homepage for the given persona"
  home: PersonaHomeAttributes

  "enable individual parts of the deployments views"
  deployments: PersonaDeploymentAttributes

  "enable individual aspects of the sidebar"
  sidebar: PersonaSidebarAttributes
}

input PersonaDeploymentAttributes {
  clusters: Boolean
  deployments: Boolean
  repositories: Boolean
  services: Boolean
  pipelines: Boolean
  providers: Boolean
  addOns: Boolean
}

input PersonaSidebarAttributes {
  audits: Boolean
  kubernetes: Boolean
  pullRequests: Boolean
  settings: Boolean
  backups: Boolean
  stacks: Boolean
}

input PersonaHomeAttributes {
  manager: Boolean
  security: Boolean
}

type User {
  id: ID!
  name: String!
  email: String!
  deletedAt: DateTime
  profile: String
  pluralId: String
  roles: UserRoles
  emailSettings: EmailSettings
  readTimestamp: DateTime
  buildTimestamp: DateTime
  refreshToken: RefreshToken
  assumeBindings: [PolicyBinding]
  groups: [Group]
  personas: [Persona]
  boundRoles: [Role]
  jwt: String
  unreadNotifications: Int
  backgroundColor: String
  insertedAt: DateTime
  updatedAt: DateTime
}

type RefreshToken {
  id: ID!

  "the token to use to request a refresh"
  token: String!

  insertedAt: DateTime

  updatedAt: DateTime
}

type UserRoles {
  admin: Boolean
}

type EmailSettings {
  "whether you want to receive digest emails"
  digest: Boolean
}

type Invite {
  secureId: String!
  email: String
}

type Group {
  id: ID!

  name: String!

  description: String

  "automatically adds all users in the system to this group"
  global: Boolean

  insertedAt: DateTime

  updatedAt: DateTime
}

type GroupMember {
  id: ID!
  user: User
  group: Group
  insertedAt: DateTime
  updatedAt: DateTime
}

type Role {
  id: ID!
  name: String!
  description: String
  repositories: [String]
  permissions: [Permission]
  roleBindings: [RoleBinding]
  insertedAt: DateTime
  updatedAt: DateTime
}

type RoleBinding {
  id: ID!
  user: User
  group: Group
  insertedAt: DateTime
  updatedAt: DateTime
}

type LoginInfo {
  oidcUri: String
  external: Boolean
  oidcName: String
}

type Notification {
  id: ID!
  title: String!
  description: String
  fingerprint: String!
  status: NotificationStatus
  labels: Map
  annotations: Map
  repository: String!
  seenAt: DateTime
  severity: Severity
  insertedAt: DateTime
  updatedAt: DateTime
}

type AccessToken {
  id: ID
  token: String
  scopes: [AccessTokenScope]
  audits(after: String, first: Int, before: String, last: Int): AccessTokenAuditConnection
  insertedAt: DateTime
  updatedAt: DateTime
}

type AccessTokenScope {
  api: String
  apis: [String!]
  identifier: String
  ids: [String!]
}

type AccessTokenAudit {
  id: ID
  ip: String
  timestamp: DateTime
  count: Int
  city: String
  country: String
  latitude: String
  longitude: String
  insertedAt: DateTime
  updatedAt: DateTime
}

type Persona {
  id: ID!

  "the name for this persona"
  name: String!

  "longform description of this persona"
  description: String

  "the ui configuration for this persona (additive across personas)"
  configuration: PersonaConfiguration

  "the group bindings for this persona"
  bindings: [PolicyBinding]

  insertedAt: DateTime

  updatedAt: DateTime
}

type PersonaConfiguration {
  "enable full ui for this persona"
  all: Boolean

  "settings for the home page for this persona"
  home: PersonaHome

  "enable individual parts of the deployments views"
  deployments: PersonaDeployment

  "enable individual aspects of the sidebar"
  sidebar: PersonaSidebar
}

type PersonaDeployment {
  clusters: Boolean
  deployments: Boolean
  repositories: Boolean
  services: Boolean
  pipelines: Boolean
  providers: Boolean
  addOns: Boolean
}

type PersonaSidebar {
  audits: Boolean
  kubernetes: Boolean
  pullRequests: Boolean
  settings: Boolean
  backups: Boolean
  stacks: Boolean
}

type PersonaHome {
  manager: Boolean
  security: Boolean
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]
}

type GroupConnection {
  pageInfo: PageInfo!
  edges: [GroupEdge]
}

type GroupMemberConnection {
  pageInfo: PageInfo!
  edges: [GroupMemberEdge]
}

type RoleConnection {
  pageInfo: PageInfo!
  edges: [RoleEdge]
}

type NotificationConnection {
  pageInfo: PageInfo!
  edges: [NotificationEdge]
}

type AccessTokenConnection {
  pageInfo: PageInfo!
  edges: [AccessTokenEdge]
}

type AccessTokenAuditConnection {
  pageInfo: PageInfo!
  edges: [AccessTokenAuditEdge]
}

type PersonaConnection {
  pageInfo: PageInfo!
  edges: [PersonaEdge]
}

type RefreshTokenConnection {
  pageInfo: PageInfo!
  edges: [RefreshTokenEdge]
}

type NotificationDelta {
  delta: Delta
  payload: Notification
}

type Configuration {
  terraform: String
  helm: String
  readme: String
}

type LogLabel {
  name: String
  value: String
}

type PluralManifest {
  network: ManifestNetwork
  bucketPrefix: String
  cluster: String
}

type ManifestNetwork {
  pluralDns: Boolean
  subdomain: String
}

type GitStatus {
  cloned: Boolean
  output: String
}

type AvailableFeatures {
  vpn: Boolean
  audits: Boolean
  cd: Boolean
  userManagement: Boolean
  databaseManagement: Boolean
}

type ConsoleConfiguration {
  gitCommit: String

  isDemoProject: Boolean

  isSandbox: Boolean

  pluralLogin: Boolean

  vpnEnabled: Boolean

  "whether at least one cluster has been installed, false if a user hasn't fully onboarded"
  installed: Boolean

  cloud: Boolean

  byok: Boolean

  externalOidc: Boolean

  oidcName: String

  features: AvailableFeatures

  manifest: PluralManifest

  gitStatus: GitStatus
}

enum Status {
  QUEUED
  RUNNING
  SUCCESSFUL
  FAILED
  CANCELLED
  PENDING
}

enum BuildType {
  DEPLOY
  BOUNCE
  APPROVAL
  INSTALL
  DESTROY
  DEDICATED
  CONFIG
}

enum Tool {
  HELM
  TERRAFORM
}

input BuildAttributes {
  repository: String!
  type: BuildType
  message: String
}

type Build {
  id: ID!
  repository: String!
  type: BuildType!
  status: Status!
  message: String
  completedAt: DateTime
  sha: String
  commands(after: String, first: Int, before: String, last: Int): CommandConnection
  creator: User
  approver: User
  changelogs: [Changelog]
  insertedAt: DateTime
  updatedAt: DateTime
}

type Changelog {
  id: ID!
  repo: String!
  tool: String!
  content: String
  insertedAt: DateTime
  updatedAt: DateTime
}

type Command {
  id: ID!
  command: String!
  exitCode: Int
  stdout: String
  completedAt: DateTime
  build: Build
  insertedAt: DateTime
  updatedAt: DateTime
}

type BuildInfo {
  all: Int
  failed: Int
  queued: Int
  running: Int
  successful: Int
}

type BuildDelta {
  delta: Delta
  payload: Build
}

type CommandDelta {
  delta: Delta
  payload: Command
}

type BuildConnection {
  pageInfo: PageInfo!
  edges: [BuildEdge]
}

type CommandConnection {
  pageInfo: PageInfo!
  edges: [CommandEdge]
}

enum Delta {
  CREATE
  UPDATE
  DELETE
}

type MetricResult {
  timestamp: Long
  value: String
}

type LogStream {
  stream: Map
  values: [MetricResult]
}

scalar Map

scalar Json

scalar Long

"""
The `DateTime` scalar type represents a date and time in the UTC
timezone. The DateTime appears in a JSON response as an ISO8601 formatted
string, including UTC timezone ("Z"). The parsed date and time string will
be converted to UTC if there is an offset.
"""
scalar DateTime

type PageInfo {
  "When paginating backwards, are there more items?"
  hasPreviousPage: Boolean!

  "When paginating forwards, are there more items?"
  hasNextPage: Boolean!

  "When paginating backwards, the cursor to continue."
  startCursor: String

  "When paginating forwards, the cursor to continue."
  endCursor: String
}

type CommandEdge {
  node: Command
  cursor: String
}

type BuildEdge {
  node: Build
  cursor: String
}

type RefreshTokenEdge {
  node: RefreshToken
  cursor: String
}

type PersonaEdge {
  node: Persona
  cursor: String
}

type AccessTokenAuditEdge {
  node: AccessTokenAudit
  cursor: String
}

type AccessTokenEdge {
  node: AccessToken
  cursor: String
}

type NotificationEdge {
  node: Notification
  cursor: String
}

type RoleEdge {
  node: Role
  cursor: String
}

type GroupMemberEdge {
  node: GroupMember
  cursor: String
}

type GroupEdge {
  node: Group
  cursor: String
}

type UserEdge {
  node: User
  cursor: String
}

type PodEdge {
  node: Pod
  cursor: String
}

type AuditEdge {
  node: Audit
  cursor: String
}

type RecipeEdge {
  node: Recipe
  cursor: String
}

type RepositoryEdge {
  node: Repository
  cursor: String
}

type InstallationEdge {
  node: Installation
  cursor: String
}

type RunbookExecutionEdge {
  node: RunbookExecution
  cursor: String
}

type WebhookEdge {
  node: Webhook
  cursor: String
}

type AiPinEdge {
  node: AiPin
  cursor: String
}

type ChatThreadEdge {
  node: ChatThread
  cursor: String
}

type ChatEdge {
  node: Chat
  cursor: String
}

type CatalogEdge {
  node: Catalog
  cursor: String
}

type ObserverEdge {
  node: Observer
  cursor: String
}

type DependencyManagementServiceEdge {
  node: DependencyManagementService
  cursor: String
}

type ScmWebhookEdge {
  node: ScmWebhook
  cursor: String
}

type PullRequestEdge {
  node: PullRequest
  cursor: String
}

type PrAutomationEdge {
  node: PrAutomation
  cursor: String
}

type ScmConnectionEdge {
  node: ScmConnection
  cursor: String
}

type HelmRepositoryEdge {
  node: HelmRepository
  cursor: String
}

type GitRepositoryEdge {
  node: GitRepository
  cursor: String
}

type TagEdge {
  node: Tag
  cursor: String
}

type ClusterRevisionEdge {
  node: ClusterRevision
  cursor: String
}

type ClusterProviderEdge {
  node: ClusterProvider
  cursor: String
}

type ClusterEdge {
  node: Cluster
  cursor: String
}

type RevisionEdge {
  node: Revision
  cursor: String
}

type ServiceDeploymentEdge {
  node: ServiceDeployment
  cursor: String
}

type PipelineContextHistoryEdge {
  node: PipelineContextHistory
  cursor: String
}

type PipelineContextEdge {
  node: PipelineContext
  cursor: String
}

type PipelineGateEdge {
  node: PipelineGate
  cursor: String
}

type PipelineEdge {
  node: Pipeline
  cursor: String
}

type ClusterRestoreEdge {
  node: ClusterRestore
  cursor: String
}

type ClusterBackupEdge {
  node: ClusterBackup
  cursor: String
}

type ObjectStoreEdge {
  node: ObjectStore
  cursor: String
}

type AppNotificationEdge {
  node: AppNotification
  cursor: String
}

type NotificationRouterEdge {
  node: NotificationRouter
  cursor: String
}

type NotificationSinkEdge {
  node: NotificationSink
  cursor: String
}

type VulnerabilityReportEdge {
  node: VulnerabilityReport
  cursor: String
}

type PolicyConstraintEdge {
  node: PolicyConstraint
  cursor: String
}

type ManagedNamespaceEdge {
  node: ManagedNamespace
  cursor: String
}

type GlobalServiceEdge {
  node: GlobalService
  cursor: String
}

type StackDefinitionEdge {
  node: StackDefinition
  cursor: String
}

type CustomStackRunEdge {
  node: CustomStackRun
  cursor: String
}

type StackRunEdge {
  node: StackRun
  cursor: String
}

type InfrastructureStackEdge {
  node: InfrastructureStack
  cursor: String
}

type AlertEdge {
  node: Alert
  cursor: String
}

type ObservabilityWebhookEdge {
  node: ObservabilityWebhook
  cursor: String
}

type ObservabilityProviderEdge {
  node: ObservabilityProvider
  cursor: String
}

type ProjectEdge {
  node: Project
  cursor: String
}
