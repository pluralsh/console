# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
  query: RootQueryType
  mutation: RootMutationType
  subscription: RootSubscriptionType
}

"supported kubernetes objects fetchable in runbooks"
union KubernetesData = Deployment | StatefulSet

type Application {
  configuration: Configuration
  cost: CostAnalysis
  license: License
  name: String!
  spec: ApplicationSpec!
  status: ApplicationStatus!
}

type ApplicationDelta {
  delta: Delta
  payload: Application
}

type ApplicationDescriptor {
  description: String
  icons: [String]
  links: [ApplicationLink]
  type: String!
  version: String!
}

type ApplicationInfoItem {
  name: String
  type: String
  value: String
}

type ApplicationLink {
  description: String
  url: String
}

type ApplicationSpec {
  components: [Component]
  descriptor: ApplicationDescriptor!
  info: [ApplicationInfoItem]
}

type ApplicationStatus {
  components: [StatusComponent]
  componentsReady: String!
  conditions: [StatusCondition]
}

type Audit {
  action: AuditAction!
  actor: User
  city: String
  country: String
  id: ID!
  insertedAt: DateTime
  ip: String
  latitude: String
  longitude: String
  repository: String
  type: AuditType!
  updatedAt: DateTime
}

type AuditConnection {
  edges: [AuditEdge]
  pageInfo: PageInfo!
}

type AuditEdge {
  cursor: String
  node: Audit
}

type AuditMetric {
  count: Int
  country: String
}

type AvailableFeatures {
  vpn: Boolean
}

type Build {
  approver: User
  changelogs: [Changelog]
  commands(after: String, before: String, first: Int, last: Int): CommandConnection
  completedAt: DateTime
  creator: User
  id: ID!
  insertedAt: DateTime
  message: String
  repository: String!
  sha: String
  status: Status!
  type: BuildType!
  updatedAt: DateTime
}

type BuildConnection {
  edges: [BuildEdge]
  pageInfo: PageInfo!
}

type BuildDelta {
  delta: Delta
  payload: Build
}

type BuildEdge {
  cursor: String
  node: Build
}

type BuildInfo {
  all: Int
  failed: Int
  queued: Int
  running: Int
  successful: Int
}

type Certificate {
  events: [Event]
  metadata: Metadata!
  raw: String!
  spec: CertificateSpec!
  status: CertificateStatus!
}

type CertificateSpec {
  dnsNames: [String]
  issuerRef: IssuerRef
  secretName: String!
}

type CertificateStatus {
  conditions: [StatusCondition]
  notAfter: String
  notBefore: String
  renewalTime: String
}

type Changelog {
  content: String
  id: ID!
  insertedAt: DateTime
  repo: String!
  tool: String!
  updatedAt: DateTime
}

type ClusterInfo {
  gitCommit: String
  gitVersion: String
  platform: String
  version: String
}

type Command {
  build: Build
  command: String!
  completedAt: DateTime
  exitCode: Int
  id: ID!
  insertedAt: DateTime
  stdout: String
  updatedAt: DateTime
}

type CommandConnection {
  edges: [CommandEdge]
  pageInfo: PageInfo!
}

type CommandDelta {
  delta: Delta
  payload: Command
}

type CommandEdge {
  cursor: String
  node: Command
}

type Component {
  group: String!
  kind: String!
}

type Configuration {
  helm: String
  terraform: String
}

type ConfigurationAction {
  updates: [PathUpdate]
}

type ConfigurationCondition {
  field: String
  operation: String
  value: String
}

type ConfigurationItem {
  condition: ConfigurationCondition
  default: String
  documentation: String
  name: String
  optional: Boolean
  placeholder: String
  type: String
  validation: ConfigurationValidation
}

type ConfigurationOverlay {
  metadata: Metadata!
  spec: ConfigurationOverlaySpec!
}

type ConfigurationOverlaySpec {
  documentation: String
  folder: String
  inputType: String
  inputValues: [String]
  name: String
  subfolder: String
  updates: [OverlayUpdate]
}

type ConfigurationValidation {
  message: String
  regex: String
  type: String
}

type ConsoleConfiguration {
  features: AvailableFeatures
  gitCommit: String
  gitStatus: GitStatus
  isDemoProject: Boolean
  isSandbox: Boolean
  manifest: PluralManifest
  pluralLogin: Boolean
  vpnEnabled: Boolean
}

type Container {
  image: String
  name: String
  ports: [Port]
  resources: Resources
}

type ContainerRecommendation {
  containerName: String
  lowerBound: ContainerResources
  name: String
  target: ContainerResources
  uncappedTarget: ContainerResources
  upperBound: ContainerResources
}

type ContainerResources {
  cpu: String
  memory: String
}

type ContainerState {
  running: RunningState
  terminated: TerminatedState
  waiting: WaitingState
}

type ContainerStatus {
  image: String
  name: String
  ready: Boolean
  restartCount: Int
  state: ContainerState
}

type CostAnalysis {
  cpuCost: Float
  cpuEfficiency: Float
  efficiency: Float
  gpuCost: Float
  minutes: Float
  networkCost: Float
  pvCost: Float
  ramCost: Float
  ramEfficiency: Float
  sharedCost: Float
  totalCost: Float
}

type CronJob {
  events: [Event]
  jobs: [Job]
  metadata: Metadata!
  raw: String!
  spec: CronSpec!
  status: CronStatus!
}

type CronSpec {
  concurrencyPolicy: String
  schedule: String!
  suspend: Boolean
}

type CronStatus {
  active: [JobReference]
  lastScheduleTime: String
}

type CrossVersionResourceTarget {
  apiVersion: String
  kind: String
  name: String
}

type Dashboard {
  id: String!
  spec: DashboardSpec!
}

type DashboardGraph {
  format: String
  name: String!
  queries: [DashboardMetric]
}

type DashboardLabel {
  name: String!
  values: [String]
}

type DashboardMetric {
  legend: String
  query: String
  results: [MetricResult]
}

type DashboardSpec {
  description: String
  graphs: [DashboardGraph]
  labels: [DashboardLabel]
  name: String
  timeslices: [String]
}

type Deployment {
  events: [Event]
  metadata: Metadata!
  pods: [Pod]
  raw: String!
  spec: DeploymentSpec!
  status: DeploymentStatus!
}

type DeploymentSpec {
  replicas: Int
  strategy: DeploymentStrategy
}

type DeploymentStatus {
  availableReplicas: Int
  readyReplicas: Int
  replicas: Int
  unavailableReplicas: Int
}

type DeploymentStrategy {
  rollingUpdate: RollingUpdate
  type: String
}

type Event {
  action: String
  count: Int
  eventTime: String
  lastTimestamp: String
  message: String
  reason: String
  type: String
}

type FileContent {
  content: String
  path: String
}

type GitStatus {
  cloned: Boolean
  output: String
}

type Group {
  description: String
  id: ID!
  insertedAt: DateTime
  name: String!
  updatedAt: DateTime
}

type GroupConnection {
  edges: [GroupEdge]
  pageInfo: PageInfo!
}

type GroupEdge {
  cursor: String
  node: Group
}

type GroupMember {
  group: Group
  id: ID!
  insertedAt: DateTime
  updatedAt: DateTime
  user: User
}

type GroupMemberConnection {
  edges: [GroupMemberEdge]
  pageInfo: PageInfo!
}

type GroupMemberEdge {
  cursor: String
  node: GroupMember
}

type HttpIngressRule {
  paths: [IngressPath]
}

type Ingress {
  events: [Event]
  metadata: Metadata!
  raw: String!
  spec: IngressSpec!
  status: ServiceStatus!
}

type IngressBackend {
  serviceName: String
  servicePort: String
}

type IngressPath {
  backend: IngressBackend
  path: String
}

type IngressRule {
  host: String
  http: HttpIngressRule
}

type IngressSpec {
  rules: [IngressRule]
  tls: [IngressTls]
}

type IngressTls {
  hosts: [String]
}

type Installation {
  id: ID!
  repository: Repository
}

type InstallationConnection {
  edges: [InstallationEdge]
  pageInfo: PageInfo!
}

type InstallationEdge {
  cursor: String
  node: Installation
}

type Invite {
  email: String
  secureId: String!
}

type IssuerRef {
  group: String
  kind: String
  name: String
}

type Job {
  events: [Event]
  metadata: Metadata!
  pods: [Pod]
  raw: String!
  spec: JobSpec!
  status: JobStatus!
}

type JobReference {
  name: String!
  namespace: String!
}

type JobSpec {
  activeDeadlineSeconds: Int
  backoffLimit: Int
  parallelism: Int
}

type JobStatus {
  active: Int
  completionTime: String
  failed: Int
  startTime: String
  succeeded: Int
}

type KubernetesDatasource {
  name: String!
  resource: String!
}

type LabelPair {
  name: String
  value: String
}

type License {
  metadata: Metadata!
  spec: LicenseSpec!
  status: LicenseStatus
}

type LicenseFeature {
  description: String
  name: String!
}

type LicenseSpec {
  secretRef: SecretKeySelector!
}

type LicenseStatus {
  features: [LicenseFeature]
  free: Boolean
  limits: Map
  plan: String
  secrets: Map
}

type LoadBalancerIngressStatus {
  hostname: String
  ip: String
}

type LoadBalancerStatus {
  ingress: [LoadBalancerIngressStatus]
}

type LogFilter {
  metadata: Metadata!
  spec: LogFilterSpec!
}

type LogFilterSpec {
  description: String
  labels: [LogLabel]
  name: String
  query: String
}

type LogLabel {
  name: String
  value: String
}

type LogStream {
  stream: Map
  values: [MetricResult]
}

type LoginInfo {
  oidcUri: String
}

type ManifestNetwork {
  pluralDns: Boolean
  subdomain: String
}

type Metadata {
  annotations: [LabelPair]
  labels: [LabelPair]
  name: String!
  namespace: String
}

type MetricResponse {
  metric: Map
  values: [MetricResult]
}

type MetricResult {
  timestamp: Int
  value: String
}

type Namespace {
  events: [Event]
  metadata: Metadata!
  raw: String!
  spec: NamespaceSpec!
  status: NamespaceStatus!
}

type NamespaceSpec {
  finalizers: [String]
}

type NamespaceStatus {
  phase: String
}

type Node {
  events: [Event]
  metadata: Metadata!
  pods: [Pod]
  raw: String!
  spec: NodeSpec!
  status: NodeStatus!
}

type NodeCondition {
  message: String
  reason: String
  status: String
  type: String
}

type NodeMetric {
  metadata: Metadata!
  timestamp: String
  usage: NodeUsage
  window: String
}

type NodeSpec {
  podCidr: String
  providerId: String
  unschedulable: Boolean
}

type NodeStatus {
  allocatable: Map
  capacity: Map
  conditions: [NodeCondition]
  phase: String
}

type NodeUsage {
  cpu: String
  memory: String
}

type Notification {
  annotations: Map
  description: String
  fingerprint: String!
  id: ID!
  insertedAt: DateTime
  labels: Map
  repository: String!
  seenAt: DateTime
  severity: Severity
  status: NotificationStatus
  title: String!
  updatedAt: DateTime
}

type NotificationConnection {
  edges: [NotificationEdge]
  pageInfo: PageInfo!
}

type NotificationDelta {
  delta: Delta
  payload: Notification
}

type NotificationEdge {
  cursor: String
  node: Notification
}

type OverlayUpdate {
  path: [String]
}

type PageInfo {
  "When paginating forwards, the cursor to continue."
  endCursor: String
  "When paginating forwards, are there more items?"
  hasNextPage: Boolean!
  "When paginating backwards, are there more items?"
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
}

type PathUpdate {
  path: [String]
  valueFrom: String!
}

type PluralContext {
  buckets: [String]
  configuration: Map!
  domains: [String]
}

type PluralManifest {
  bucketPrefix: String
  cluster: String
  network: ManifestNetwork
}

type Pod {
  events: [Event]
  metadata: Metadata!
  raw: String!
  spec: PodSpec!
  status: PodStatus!
}

type PodCondition {
  lastProbeTime: String
  lastTransitionTime: String
  message: String
  reason: String
  status: String
  type: String
}

type PodConnection {
  edges: [PodEdge]
  pageInfo: PageInfo!
}

type PodDelta {
  delta: Delta
  payload: Pod
}

type PodEdge {
  cursor: String
  node: Pod
}

type PodSpec {
  containers: [Container]
  initContainers: [Container]
  nodeName: String
  serviceAccountName: String
}

type PodStatus {
  conditions: [PodCondition]
  containerStatuses: [ContainerStatus]
  hostIp: String
  initContainerStatuses: [ContainerStatus]
  message: String
  phase: String
  podIp: String
  reason: String
}

type Port {
  containerPort: Int
  hostPort: Int
  protocol: String
}

type PrometheusDatasource {
  format: String
  legend: String
  query: String!
}

type Recipe {
  description: String
  id: ID!
  name: String!
  oidcEnabled: Boolean
  provider: String
  recipeSections: [RecipeSection]
  restricted: Boolean
}

type RecipeConnection {
  edges: [RecipeEdge]
  pageInfo: PageInfo!
}

type RecipeEdge {
  cursor: String
  node: Recipe
}

type RecipeItem {
  configuration: [ConfigurationItem]
  id: ID!
}

type RecipeSection {
  configuration: [ConfigurationItem]
  id: ID!
  recipeItems: [RecipeItem]
  repository: Repository
}

type Recommendation {
  containerRecommendations: [ContainerRecommendation]
}

type Repository {
  configuration: Configuration
  description: String
  docs: [FileContent]
  grafanaDns: String
  icon: String
  id: ID!
  name: String!
}

type RepositoryConnection {
  edges: [RepositoryEdge]
  pageInfo: PageInfo!
}

type RepositoryContext {
  context: Map
  repository: String!
}

type RepositoryEdge {
  cursor: String
  node: Repository
}

type ResourceSpec {
  cpu: String
  memory: String
}

type Resources {
  limits: ResourceSpec
  requests: ResourceSpec
}

type Role {
  description: String
  id: ID!
  insertedAt: DateTime
  name: String!
  permissions: [Permission]
  repositories: [String]
  roleBindings: [RoleBinding]
  updatedAt: DateTime
}

type RoleBinding {
  group: Group
  id: ID!
  insertedAt: DateTime
  updatedAt: DateTime
  user: User
}

type RoleConnection {
  edges: [RoleEdge]
  pageInfo: PageInfo!
}

type RoleEdge {
  cursor: String
  node: Role
}

type RollingUpdate {
  maxSurge: Int
  maxUnavailable: Int
}

type RootMutationType {
  approveBuild(id: ID!): Build
  cancelBuild(id: ID!): Build
  createBuild(attributes: BuildAttributes!): Build
  createGroup(attributes: GroupAttributes!): Group
  createGroupMember(groupId: ID!, userId: ID!): GroupMember
  createInvite(attributes: InviteAttributes!): Invite
  createPeer(email: String, name: String!, userId: ID): WireguardPeer
  createRole(attributes: RoleAttributes!): Role
  createUpgradePolicy(attributes: UpgradePolicyAttributes!): UpgradePolicy
  createWebhook(attributes: WebhookAttributes!): Webhook
  deleteGroup(groupId: ID!): Group
  deleteGroupMember(groupId: ID!, userId: ID!): GroupMember
  deleteJob(name: String!, namespace: String!): Job
  deleteNode(name: String!): Node
  deletePeer(name: String!): Boolean
  deletePod(name: String!, namespace: String!): Pod
  deleteRole(id: ID!): Role
  deleteUpgradePolicy(id: ID!): UpgradePolicy
  deleteWebhook(id: ID!): Webhook
  executeRunbook(input: RunbookActionInput!, name: String!, namespace: String!): RunbookActionResponse
  installRecipe(context: Map!, id: ID!, oidc: Boolean): Build
  installStack(context: ContextAttributes!, name: String!, oidc: Boolean): Build
  loginLink(key: String!): User
  markRead(type: ReadType): User
  oauthCallback(code: String!, redirect: String): User
  overlayConfiguration(context: Map!, namespace: String!): Build
  readNotifications: User
  restartBuild(id: ID!): Build
  signIn(email: String!, password: String!): User
  signup(attributes: UserAttributes!, inviteId: String!): User
  updateConfiguration(content: String!, message: String, repository: String!, tool: Tool): Configuration
  updateGroup(attributes: GroupAttributes!, groupId: ID!): Group
  updateRole(attributes: RoleAttributes!, id: ID!): Role
  updateSmtp(smtp: SmtpInput!): Smtp
  updateUser(attributes: UserAttributes!, id: ID): User
}

type RootQueryType {
  application(name: String!): Application
  applications: [Application]
  auditMetrics: [AuditMetric]
  audits(after: String, before: String, first: Int, last: Int, repo: String): AuditConnection
  build(id: ID!): Build
  buildInfo: BuildInfo
  builds(after: String, before: String, first: Int, last: Int): BuildConnection
  cachedPods(namespaces: [String]): [Pod]
  certificate(name: String!, namespace: String!): Certificate
  clusterInfo: ClusterInfo
  configuration: ConsoleConfiguration
  configurationOverlays(namespace: String!): [ConfigurationOverlay]
  context: [RepositoryContext]
  cronJob(name: String!, namespace: String!): CronJob
  dashboard(labels: [LabelInput], name: String!, offset: Int, repo: String!, step: String): Dashboard
  dashboards(repo: String!): [Dashboard]
  deployment(name: String!, namespace: String!): Deployment
  externalToken: String
  groupMembers(after: String, before: String, first: Int, groupId: ID!, last: Int): GroupMemberConnection
  groups(after: String, before: String, first: Int, last: Int, q: String): GroupConnection
  ingress(name: String!, namespace: String!): Ingress
  installations(after: String, before: String, first: Int, last: Int): InstallationConnection
  invite(id: String!): Invite
  job(name: String!, namespace: String!): Job
  logFilters(namespace: String!): [LogFilter]
  loginInfo(redirect: String): LoginInfo
  logs(end: Long, limit: Int!, query: String!, start: Long): [LogStream]
  me: User
  metric(offset: Int, query: String!, step: String): [MetricResponse]
  myWireguardPeers: [WireguardPeer]
  namespaces: [Namespace]
  node(name: String!): Node
  nodeMetric(name: String!): NodeMetric
  nodeMetrics: [NodeMetric]
  nodes: [Node]
  notifications(after: String, all: Boolean, before: String, first: Int, last: Int): NotificationConnection
  pluralContext: PluralContext
  pod(name: String!, namespace: String!): Pod
  pods(after: String, before: String, first: Int, last: Int, namespaces: [String]): PodConnection
  recipe(id: ID!): Recipe
  recipes(after: String, before: String, first: Int, id: ID!, last: Int): RecipeConnection
  repositories(after: String, before: String, first: Int, last: Int, query: String!): RepositoryConnection
  repository(name: String!): Repository
  role: Role
  roles(after: String, before: String, first: Int, last: Int, q: String): RoleConnection
  runbook(name: String!, namespace: String!): Runbook
  runbooks(namespace: String!, pinned: Boolean): [Runbook]
  scalingRecommendation(kind: AutoscalingTarget!, name: String!, namespace: String!): VerticalPodAutoscaler
  service(name: String!, namespace: String!): Service
  smtp: Smtp
  stack(name: String!): Stack
  statefulSet(name: String!, namespace: String!): StatefulSet
  upgradePolicies: [UpgradePolicy]
  users(after: String, before: String, first: Int, last: Int, q: String): UserConnection
  webhooks(after: String, before: String, first: Int, last: Int): WebhookConnection
  wireguardPeer(name: String!): WireguardPeer
  wireguardPeers: [WireguardPeer]
}

type RootSubscriptionType {
  applicationDelta: ApplicationDelta
  buildDelta(buildId: ID): BuildDelta
  commandDelta(buildId: ID!): CommandDelta
  notificationDelta: NotificationDelta
  podDelta: PodDelta
}

type Runbook {
  data(context: RunbookContext): [RunbookData]
  executions(after: String, before: String, first: Int, last: Int): RunbookExecutionConnection
  name: String!
  spec: RunbookSpec!
  status: RunbookStatus
}

type RunbookAction {
  configuration: ConfigurationAction
  name: String!
  type: String!
}

type RunbookActionResponse {
  redirectTo: String
}

type RunbookAlertStatus {
  annotations: Map
  fingerprint: String
  labels: Map
  name: String!
  startsAt: String
}

type RunbookData {
  kubernetes: KubernetesData
  name: String!
  nodes: [Node]
  prometheus: [MetricResponse]
  source: RunbookDatasource
}

type RunbookDatasource {
  kubernetes: KubernetesDatasource
  name: String!
  prometheus: PrometheusDatasource
  type: String!
}

type RunbookExecution {
  context: Map!
  id: ID!
  insertedAt: DateTime
  name: String!
  namespace: String!
  updatedAt: DateTime
  user: User
}

type RunbookExecutionConnection {
  edges: [RunbookExecutionEdge]
  pageInfo: PageInfo!
}

type RunbookExecutionEdge {
  cursor: String
  node: RunbookExecution
}

type RunbookSpec {
  actions: [RunbookAction]
  datasources: [RunbookDatasource]
  description: String
  display: Map
  name: String!
}

type RunbookStatus {
  alerts: [RunbookAlertStatus]
}

type RunningState {
  startedAt: String
}

type SecretKeySelector {
  key: String
  name: String!
}

type Service {
  events: [Event]
  metadata: Metadata!
  pods: [Pod]
  raw: String!
  spec: ServiceSpec!
  status: ServiceStatus!
}

type ServicePort {
  name: String
  port: Int
  protocol: String
  targetPort: String
}

type ServiceSpec {
  clusterIp: String
  ports: [ServicePort]
  selector: Map
  type: String
}

type ServiceStatus {
  loadBalancer: LoadBalancerStatus
}

type Smtp {
  password: String
  port: Int
  sender: String
  server: String
  user: String
}

type Stack {
  bundles: [Recipe]
  id: ID!
  insertedAt: DateTime
  name: String!
  sections: [RecipeSection]
  updatedAt: DateTime
}

type StatefulSet {
  events: [Event]
  metadata: Metadata!
  pods: [Pod]
  raw: String!
  spec: StatefulSetSpec!
  status: StatefulSetStatus!
}

type StatefulSetSpec {
  replicas: Int
  serviceName: String
}

type StatefulSetStatus {
  currentReplicas: Int
  readyReplicas: Int
  replicas: Int
  updatedReplicas: Int
}

type StatusComponent {
  group: String
  kind: String!
  name: String!
  status: String!
}

type StatusCondition {
  message: String!
  reason: String!
  status: String!
  type: String!
}

type TerminatedState {
  exitCode: Int
  finishedAt: String
  message: String
  reason: String
  startedAt: String
}

type UpgradePolicy {
  description: String
  id: ID!
  insertedAt: DateTime
  name: String!
  target: String!
  type: UpgradePolicyType!
  updatedAt: DateTime
  weight: Int
}

type User {
  backgroundColor: String
  boundRoles: [Role]
  buildTimestamp: DateTime
  deletedAt: DateTime
  email: String!
  id: ID!
  insertedAt: DateTime
  jwt: String
  name: String!
  profile: String
  readTimestamp: DateTime
  roles: UserRoles
  unreadNotifications: Int
  updatedAt: DateTime
}

type UserConnection {
  edges: [UserEdge]
  pageInfo: PageInfo!
}

type UserEdge {
  cursor: String
  node: User
}

type UserRoles {
  admin: Boolean
}

type VerticalPodAutoscaler {
  metadata: Metadata!
  spec: VerticalPodAutoscalerSpec!
  status: VerticalPodAutoscalerStatus
}

type VerticalPodAutoscalerSpec {
  targetRef: CrossVersionResourceTarget!
  updatePolicy: VerticalPodAutoscalerUpdatePolicy!
}

type VerticalPodAutoscalerStatus {
  recommendation: Recommendation
}

type VerticalPodAutoscalerUpdatePolicy {
  updateMode: String
}

type WaitingState {
  message: String
  reason: String
}

type Webhook {
  health: WebhookHealth!
  id: ID!
  insertedAt: DateTime
  type: WebhookType!
  updatedAt: DateTime
  url: String!
}

type WebhookConnection {
  edges: [WebhookEdge]
  pageInfo: PageInfo!
}

type WebhookEdge {
  cursor: String
  node: Webhook
}

type WireguardPeer {
  config: String
  metadata: Metadata!
  raw: String!
  spec: WireguardPeerSpec!
  status: WireguardPeerStatus
  user: User
}

type WireguardPeerSpec {
  address: String
  publicKey: String
  wireguardRef: String
}

type WireguardPeerStatus {
  conditions: [StatusCondition]
  ready: Boolean
}

enum AuditAction {
  APPROVE
  CANCEL
  CREATE
  DELETE
  UPDATE
}

enum AuditType {
  BUILD
  CONFIGURATION
  GROUP
  GROUP_MEMBER
  POD
  POLICY
  ROLE
  USER
}

enum AutoscalingTarget {
  DEPLOYMENT
  STATEFULSET
}

enum BuildType {
  APPROVAL
  BOUNCE
  DEDICATED
  DEPLOY
  DESTROY
  INSTALL
}

enum Delta {
  CREATE
  DELETE
  UPDATE
}

enum NotificationStatus {
  FIRING
  RESOLVED
}

enum Permission {
  CONFIGURE
  DEPLOY
  OPERATE
  READ
}

enum ReadType {
  BUILD
  NOTIFICATION
}

enum Severity {
  CRITICAL
  HIGH
  LOW
  MEDIUM
  NONE
}

enum Status {
  CANCELLED
  FAILED
  PENDING
  QUEUED
  RUNNING
  SUCCESSFUL
}

enum Tool {
  HELM
  TERRAFORM
}

enum UpgradePolicyType {
  APPROVAL
  DEPLOY
  IGNORE
}

enum WebhookHealth {
  HEALTHY
  UNHEALTHY
}

enum WebhookType {
  PIAZZA
  SLACK
}

"""

The `DateTime` scalar type represents a date and time in the UTC
timezone. The DateTime appears in a JSON response as an ISO8601 formatted
string, including UTC timezone ("Z"). The parsed date and time string will
be converted to UTC if there is an offset.
"""
scalar DateTime

scalar Long

scalar Map

input BindingAttributes {
  groupId: ID
  id: ID
  userId: ID
}

input BuildAttributes {
  message: String
  repository: String!
  type: BuildType
}

input ContextAttributes {
  buckets: [String]
  configuration: Map!
  domain: [String]
}

input GroupAttributes {
  description: String
  name: String!
}

input InviteAttributes {
  email: String
}

input LabelInput {
  name: String
  value: String
}

input RoleAttributes {
  description: String
  name: String
  permissions: [Permission]
  repositories: [String]
  roleBindings: [BindingAttributes]
}

input RunbookActionInput {
  action: String!
  context: Map!
}

input RunbookContext {
  timeseriesStart: Int
  timeseriesStep: String
}

input SmtpInput {
  password: String
  port: Int
  sender: String
  server: String
  user: String
}

input UpgradePolicyAttributes {
  description: String
  name: String!
  target: String!
  type: UpgradePolicyType!
  weight: Int
}

input UserAttributes {
  email: String
  name: String
  password: String
  roles: UserRoleAttributes
}

input UserRoleAttributes {
  admin: Boolean
}

input WebhookAttributes {
  url: String!
}
