schema {
  subscription: RootSubscriptionType
  mutation: RootMutationType
  query: RootQueryType
}

type RootQueryType {
  configuration: ConsoleConfiguration

  externalToken: String

  builds(after: String, first: Int, before: String, last: Int): BuildConnection

  build(id: ID!): Build

  buildInfo: BuildInfo

  user(email: String!): User

  group(name: String!): Group

  users(after: String, first: Int, before: String, last: Int, q: String): UserConnection

  serviceAccounts(after: String, first: Int, before: String, last: Int, q: String): UserConnection

  loginInfo(redirect: String): LoginInfo

  me: User

  invite(id: String!): Invite

  groups(after: String, first: Int, before: String, last: Int, q: String): GroupConnection

  groupMembers(after: String, first: Int, before: String, last: Int, groupId: ID!): GroupMemberConnection

  role: Role

  roles(after: String, first: Int, before: String, last: Int, q: String): RoleConnection

  notifications(after: String, first: Int, before: String, last: Int, all: Boolean): NotificationConnection

  temporaryToken: String

  accessTokens(after: String, first: Int, before: String, last: Int): AccessTokenConnection

  accessToken(id: ID!): AccessToken

  persona(id: ID!): Persona

  personas(after: String, first: Int, before: String, last: Int): PersonaConnection

  refreshTokens(after: String, first: Int, before: String, last: Int): RefreshTokenConnection

  refresh(token: String!): User

  dashboards(repo: String!): [Dashboard]

  dashboard(repo: String!, name: String!, step: String, offset: Int, labels: [LabelInput]): Dashboard

  metric(query: String!, offset: Int, step: String, clusterId: ID): [MetricResponse]

  logs(query: String!, start: Long, end: Long, limit: Int!, clusterId: ID): [LogStream]

  scalingRecommendation(kind: AutoscalingTarget!, namespace: String!, name: String!): VerticalPodAutoscaler

  configMap(serviceId: ID, namespace: String!, name: String!): ConfigMap

  secret(serviceId: ID, namespace: String!, name: String!): Secret

  configMaps(namespace: String!): [ConfigMap]

  secrets(namespace: String!): [Secret]

  pluralCluster(namespace: String!, name: String!, serviceId: ID): PluralCluster

  pluralServiceDeployment(namespace: String!, name: String!, serviceId: ID): PluralServiceDeployment

  pluralGitRepository(namespace: String!, name: String!, serviceId: ID): PluralGitRepository

  unstructuredResource(group: String, version: String!, kind: String!, namespace: String, name: String!, serviceId: ID): KubernetesUnstructured

  service(namespace: String!, name: String!, serviceId: ID): Service

  clusterInfo: ClusterInfo

  deployment(namespace: String!, name: String!, serviceId: ID): Deployment

  statefulSet(namespace: String!, name: String!, serviceId: ID): StatefulSet

  daemonSet(namespace: String!, name: String!, serviceId: ID): DaemonSet

  ingress(namespace: String!, name: String!, serviceId: ID): Ingress

  nodes: [Node]

  node(name: String!, clusterId: ID): Node

  cronJob(namespace: String!, name: String!, serviceId: ID): CronJob

  job(namespace: String!, name: String!, serviceId: ID): Job

  certificate(namespace: String!, name: String!, serviceId: ID): Certificate

  pod(namespace: String!, name: String!, serviceId: ID, clusterId: ID): Pod

  pods(after: String, first: Int, before: String, last: Int, namespace: String, namespaces: [String], clusterId: ID): PodConnection

  wireguardPeers: [WireguardPeer]

  myWireguardPeers: [WireguardPeer]

  wireguardPeer(name: String!): WireguardPeer

  cachedPods(namespaces: [String]): [Pod]

  namespaces(clusterId: ID): [Namespace]

  logFilters(namespace: String!): [LogFilter]

  nodeMetrics(clusterId: ID): [NodeMetric]

  nodeMetric(name: String!, clusterId: ID): NodeMetric

  canary(namespace: String!, name: String!, serviceId: ID): Canary

  upgradePlan(namespace: String!, name: String!, serviceId: ID): UpgradePlan

  configurationOverlays(namespace: String!): [ConfigurationOverlay]

  audits(after: String, first: Int, before: String, last: Int, repo: String): AuditConnection

  auditMetrics: [AuditMetric]

  ai(prompt: String!): String

  account: Account

  installations(after: String, first: Int, before: String, last: Int): InstallationConnection

  applications: [Application]

  application(name: String!): Application

  repository(name: String!): Repository

  repositories(after: String, first: Int, before: String, last: Int, query: String!): RepositoryConnection

  recipes(after: String, first: Int, before: String, last: Int, id: ID!): RecipeConnection

  context: [RepositoryContext]

  pluralContext: PluralContext

  recipe(id: ID!): Recipe

  stack(name: String!): Stack

  smtp: Smtp

  upgradePolicies: [UpgradePolicy]

  runbook(namespace: String!, name: String!): Runbook

  runbooks(namespace: String!, pinned: Boolean): [Runbook]

  webhooks(after: String, first: Int, before: String, last: Int): WebhookConnection

  postgresDatabases: [Postgresql]

  postgresDatabase(namespace: String!, name: String!): Postgresql

  gitRepository(id: ID, url: String): GitRepository

  gitRepositories(after: String, first: Int, before: String, last: Int): GitRepositoryConnection

  helmRepositories: [HelmRepository]

  helmRepository(name: String!, namespace: String!): HelmRepository

  scmConnections(after: String, first: Int, before: String, last: Int): ScmConnectionConnection

  scmConnection(id: ID, name: String): ScmConnection

  prAutomations(after: String, first: Int, before: String, last: Int): PrAutomationConnection

  prAutomation(id: ID, name: String): PrAutomation

  pullRequests(after: String, first: Int, before: String, last: Int, clusterId: ID, serviceId: ID, q: String): PullRequestConnection

  scmWebhooks(after: String, first: Int, before: String, last: Int): ScmWebhookConnection

  dependencyManagementServices(after: String, first: Int, before: String, last: Int): DependencyManagementServiceConnection

  "exchanges a kubeconfig token for user info"
  tokenExchange(token: String!): User

  "a relay connection of all clusters visible to the current user"
  clusters(
    after: String, first: Int, before: String, last: Int, q: String, healthy: Boolean, tag: TagInput, tagQuery: TagQuery, backups: Boolean
  ): ClusterConnection

  "gets summary information for all healthy\/unhealthy clusters in your fleet"
  clusterStatuses(q: String, tag: TagInput): [ClusterStatusInfo]

  "gets summary information for upgradeability in your fleet"
  upgradeStatistics(q: String, tag: TagInput): UpgradeStatistics

  "lists tags applied to any clusters in the fleet"
  tags(tag: String): [String]

  "adds the ability to search\/filter through all tag name\/value pairs"
  tagPairs(
    after: String

    first: Int

    before: String

    last: Int

    "only return tags with name==tag"
    tag: String

    "search for tags with q as a substring in name or value"
    q: String
  ): TagConnection

  "a relay connection of all providers visible to the current user"
  clusterProviders(after: String, first: Int, before: String, last: Int): ClusterProviderConnection

  "fetches an individual cluster"
  cluster(id: ID, handle: String): Cluster

  "fetches an individual cluster provider"
  clusterProvider(id: ID, cloud: String, name: String): ClusterProvider

  "list all addons currently resident in the artifacts repo"
  clusterAddOns: [ClusterAddOn]

  "fetch an individual runtime service for more thorough detail views"
  runtimeService(id: ID!): RuntimeService

  serviceDeployments(
    after: String

    first: Int

    before: String

    last: Int

    clusterId: ID

    q: String

    status: ServiceDeploymentStatus

    "the handle of the cluster for this service"
    cluster: String
  ): ServiceDeploymentConnection

  serviceStatuses(clusterId: ID, q: String, status: ServiceDeploymentStatus): [ServiceStatusCount]

  serviceContext(name: String!): ServiceContext

  "renders a full hierarchy of resources recursively owned by this component (useful for CRD views)"
  componentTree(
    "the id of the service component for the tree view"
    id: ID!
  ): ComponentTree

  "request manifests from an agent, to be returned by a future call to fetchManifests"
  requestManifests(id: ID!): ServiceDeployment

  "Fetches the manifests from cache once the agent has given us them, will be null otherwise"
  fetchManifests(id: ID!): [String]

  pipelines(after: String, first: Int, before: String, last: Int, q: String): PipelineConnection

  pipeline(id: ID!): Pipeline

  pipelineGate(id: ID!): PipelineGate

  pipelineContext(id: ID!): PipelineContext

  clusterBackup(id: ID, clusterId: ID, namespace: String, name: String): ClusterBackup

  clusterBackups(after: String, first: Int, before: String, last: Int, clusterId: ID!): ClusterBackupConnection

  clusterRestores(after: String, first: Int, before: String, last: Int, clusterId: ID!): ClusterRestoreConnection

  objectStores(after: String, first: Int, before: String, last: Int): ObjectStoreConnection

  "the services deployed in the current cluster, to be polled by the deploy operator"
  clusterServices: [ServiceDeployment]

  pagedClusterServices(after: String, first: Int, before: String, last: Int): ServiceDeploymentConnection

  "fetches details of this service deployment, and can be called by the deploy operator"
  serviceDeployment(
    id: ID

    "the handle of the cluster for this service"
    cluster: String

    name: String
  ): ServiceDeployment

  "tells you what cluster a deploy token points to"
  myCluster: Cluster

  clusterGates: [PipelineGate]

  pagedClusterGates(after: String, first: Int, before: String, last: Int): PipelineGateConnection

  clusterGate(id: ID!): PipelineGate

  clusterRestore(id: ID!): ClusterRestore

  notificationSink(name: String, id: ID): NotificationSink

  notificationRouter(name: String, id: ID): NotificationRouter

  notificationSinks(after: String, first: Int, before: String, last: Int, q: String): NotificationSinkConnection

  notificationRouters(after: String, first: Int, before: String, last: Int, q: String): NotificationRouterConnection

  policyConstraints(
    after: String, first: Int, before: String, last: Int, kind: String, namespace: String, kinds: [String], namespaces: [String], q: String
  ): PolicyConstraintConnection

  violationStatistics(field: ConstraintViolationField!): [ViolationStatistic]

  policyConstraint(id: ID!): PolicyConstraint

  managedNamespaces(after: String, first: Int, before: String, last: Int): ManagedNamespaceConnection

  globalService(id: ID!): GlobalService

  globalServices(after: String, first: Int, before: String, last: Int): GlobalServiceConnection

  clusterManagedNamespaces(after: String, first: Int, before: String, last: Int): ManagedNamespaceConnection

  managedNamespace(id: ID!): ManagedNamespace

  clusterStackRuns(after: String, first: Int, before: String, last: Int): StackRunConnection

  stackRun(id: ID!): StackRun

  infrastructureStack(id: ID!): InfrastructureStack

  infrastructureStacks(after: String, first: Int, before: String, last: Int): InfrastructureStackConnection

  observabilityProvider(id: ID!): ObservabilityProvider

  observabilityProviders(after: String, first: Int, before: String, last: Int): ObservabilityProviderConnection

  deploymentSettings: DeploymentSettings
}

type RootMutationType {
  createBuild(attributes: BuildAttributes!): Build

  restartBuild(id: ID!): Build

  cancelBuild(id: ID!): Build

  approveBuild(id: ID!): Build

  signIn(email: String!, password: String!): User

  logout: User

  loginLink(key: String!): User

  readNotifications: User

  signup(inviteId: String!, attributes: UserAttributes!): User

  oauthCallback(code: String!, redirect: String): User

  createInvite(attributes: InviteAttributes!): Invite

  createServiceAccount(attributes: ServiceAccountAttributes!): User

  updateServiceAccount(id: ID!, attributes: ServiceAccountAttributes!): User

  updateUser(id: ID, attributes: UserAttributes!): User

  deleteUser(id: ID!): User

  markRead(type: ReadType): User

  createGroup(attributes: GroupAttributes!): Group

  deleteGroup(groupId: ID!): Group

  updateGroup(groupId: ID!, attributes: GroupAttributes!): Group

  createGroupMember(groupId: ID!, userId: ID!): GroupMember

  deleteGroupMember(groupId: ID!, userId: ID!): GroupMember

  createRole(attributes: RoleAttributes!): Role

  updateRole(id: ID!, attributes: RoleAttributes!): Role

  deleteRole(id: ID!): Role

  createAccessToken(scopes: [ScopeAttributes]): AccessToken

  createServiceAccountToken(id: ID!, scopes: [ScopeAttributes]): AccessToken

  deleteAccessToken(token: String!): AccessToken

  createPersona(attributes: PersonaAttributes!): Persona

  updatePersona(id: ID!, attributes: PersonaAttributes!): Persona

  deletePersona(id: ID!): Persona

  deleteCertificate(name: String!, namespace: String!): Boolean

  deletePod(namespace: String!, name: String!, serviceId: ID): Pod

  deleteJob(namespace: String!, name: String!, serviceId: ID): Job

  deleteNode(name: String!): Node

  overlayConfiguration(namespace: String!, context: Map!): Build

  createPeer(userId: ID, email: String, name: String!): WireguardPeer

  deletePeer(name: String!): Boolean

  installRecipe(id: ID!, context: Map!, oidc: Boolean): Build

  installStack(name: String!, context: ContextAttributes!, oidc: Boolean): Build

  updateSmtp(smtp: SmtpInput!): Smtp

  updateConfiguration(repository: String!, content: String!, tool: Tool, message: String): Configuration

  createUpgradePolicy(attributes: UpgradePolicyAttributes!): UpgradePolicy

  deleteUpgradePolicy(id: ID!): UpgradePolicy

  executeRunbook(namespace: String!, name: String!, input: RunbookActionInput!): RunbookActionResponse

  createWebhook(attributes: WebhookAttributes!): Webhook

  deleteWebhook(id: ID!): Webhook

  restorePostgres(namespace: String!, name: String!, timestamp: DateTime!, clone: CloneAttributes): Postgresql

  createGitRepository(attributes: GitAttributes!): GitRepository

  updateGitRepository(id: ID!, attributes: GitAttributes!): GitRepository

  deleteGitRepository(id: ID!): GitRepository

  createScmConnection(attributes: ScmConnectionAttributes!): ScmConnection

  updateScmConnection(id: ID!, attributes: ScmConnectionAttributes!): ScmConnection

  deleteScmConnection(id: ID!): ScmConnection

  createScmWebhook(connectionId: ID!, owner: String!): ScmWebhook

  "creates a webhook reference in our system but doesn't attempt to create it in your upstream provider"
  createScmWebhookPointer(attributes: ScmWebhookAttributes!): ScmWebhook

  createPrAutomation(attributes: PrAutomationAttributes!): PrAutomation

  updatePrAutomation(id: ID!, attributes: PrAutomationAttributes!): PrAutomation

  deletePrAutomation(id: ID!): PrAutomation

  "creates the service to enable self-hosted renovate in one pass"
  setupRenovate(
    connectionId: ID!

    repos: [String]

    "the name of the owning service"
    name: String

    "the namespace of the owning service"
    namespace: String
  ): ServiceDeployment

  reconfigureRenovate(repos: [String], serviceId: ID!): ServiceDeployment

  createPullRequest(
    "the id of the PR automation instance to use"
    id: ID!

    branch: String

    context: Json
  ): PullRequest

  "just registers a pointer record to a PR after it was created externally be some other automation"
  createPullRequestPointer(attributes: PullRequestAttributes): PullRequest

  createCluster(attributes: ClusterAttributes!): Cluster

  updateCluster(id: ID!, attributes: ClusterUpdateAttributes!): Cluster

  deleteCluster(id: ID!): Cluster

  "soft deletes a cluster, by deregistering it in our system but not disturbing any kubernetes objects"
  detachCluster(id: ID!): Cluster

  createClusterProvider(attributes: ClusterProviderAttributes!): ClusterProvider

  updateClusterProvider(id: ID!, attributes: ClusterProviderUpdateAttributes!): ClusterProvider

  deleteClusterProvider(id: ID!): ClusterProvider

  createProviderCredential(attributes: ProviderCredentialAttributes!, name: String!): ProviderCredential

  deleteProviderCredential(id: ID!): ProviderCredential

  installAddOn(name: String!, configuration: [ConfigAttributes], clusterId: ID!, global: GlobalServiceAttributes): ServiceDeployment

  createAgentMigration(attributes: AgentMigrationAttributes!): AgentMigration

  createPinnedCustomResource(attributes: PinnedCustomResourceAttributes!): PinnedCustomResource

  deletePinnedCustomResource(id: ID!): PinnedCustomResource

  createServiceDeployment(
    clusterId: ID

    "the handle of the cluster for this service"
    cluster: String

    attributes: ServiceDeploymentAttributes!
  ): ServiceDeployment

  updateServiceDeployment(
    id: ID

    "the handle of the cluster for this service"
    cluster: String

    name: String

    attributes: ServiceUpdateAttributes!
  ): ServiceDeployment

  deleteServiceDeployment(id: ID!): ServiceDeployment

  "removes a service from storage, but bypasses waiting for the agent to fully drain it from its hosting cluster"
  detachServiceDeployment(id: ID!): ServiceDeployment

  "merges configuration for a service"
  mergeService(id: ID!, configuration: [ConfigAttributes]): ServiceDeployment

  "rewires this service to use the given revision id"
  rollbackService(
    id: ID

    "the handle of the cluster for this service"
    cluster: String

    name: String

    revisionId: ID!
  ): ServiceDeployment

  "clones the spec of the given service to be deployed either into a new namespace or new cluster"
  cloneService(
    serviceId: ID

    "the handle of the cluster for this service"
    cluster: String

    name: String

    clusterId: ID!

    attributes: ServiceCloneAttributes!
  ): ServiceDeployment

  kickService(
    serviceId: ID

    "the handle of the cluster for this service"
    cluster: String

    name: String
  ): ServiceDeployment

  selfManage(values: String!): ServiceDeployment

  "marks a service as being able to proceed to the next stage of a canary rollout"
  proceed(
    id: ID

    "the handle of the cluster for this service"
    cluster: String

    name: String

    promotion: ServicePromotion
  ): ServiceDeployment

  saveServiceContext(name: String!, attributes: ServiceContextAttributes!): ServiceContext

  deleteServiceContext(id: ID!): ServiceContext

  "upserts a pipeline with a given name"
  savePipeline(name: String!, attributes: PipelineAttributes!): Pipeline

  "creates a new pipeline context and binds it to the beginning stage"
  createPipelineContext(pipelineId: ID!, attributes: PipelineContextAttributes!): PipelineContext

  deletePipeline(id: ID!): Pipeline

  "approves an approval pipeline gate"
  approveGate(id: ID!): PipelineGate

  "forces a pipeline gate to be in open state"
  forceGate(id: ID!, state: GateState): PipelineGate

  createObjectStore(attributes: ObjectStoreAttributes!): ObjectStore

  updateObjectStore(id: ID!, attributes: ObjectStoreAttributes!): ObjectStore

  deleteObjectStore(id: ID!): ObjectStore

  configureBackups(clusterId: ID!, storeId: ID!): Cluster

  delinkBackups(clusterId: ID!): Cluster

  createClusterRestore(backupId: ID!): ClusterRestore

  "a regular status ping to be sent by the deploy operator"
  pingCluster(attributes: ClusterPing!): Cluster

  "registers a list of runtime services discovered for the current cluster"
  registerRuntimeServices(services: [RuntimeServiceAttributes], serviceId: ID): Int

  "updates only the components of a given service, to be sent after deploy operator syncs"
  updateServiceComponents(id: ID!, components: [ComponentAttributes], errors: [ServiceErrorAttributes]): ServiceDeployment

  "save the manifests in cache to be retrieved by the requesting user"
  saveManifests(id: ID!, manifests: [String]): Boolean

  updateGate(id: ID!, attributes: GateUpdateAttributes!): PipelineGate

  "upserts a cluster backup resource"
  createClusterBackup(attributes: BackupAttributes!): ClusterBackup

  updateClusterRestore(id: ID!, attributes: RestoreAttributes!): ClusterRestore

  upsertNotificationSink(attributes: NotificationSinkAttributes!): NotificationSink

  deleteNotificationSink(id: ID!): NotificationSink

  upsertNotificationRouter(attributes: NotificationRouterAttributes!): NotificationRouter

  deleteNotificationRouter(id: ID!): NotificationRouter

  upsertPolicyConstraints(constraints: [PolicyConstraintAttributes]): Int

  createGlobalService(
    serviceId: ID

    "the handle of the cluster for this service"
    cluster: String

    name: String

    attributes: GlobalServiceAttributes!
  ): GlobalService

  updateGlobalService(id: ID!, attributes: GlobalServiceAttributes!): GlobalService

  deleteGlobalService(id: ID!): GlobalService

  createManagedNamespace(attributes: ManagedNamespaceAttributes!): ManagedNamespace

  updateManagedNamespace(id: ID!, attributes: ManagedNamespaceAttributes!): ManagedNamespace

  deleteManagedNamespace(id: ID!): ManagedNamespace

  updateStackRun(id: ID!, attributes: StackRunAttributes!): StackRun

  completeStackRun(id: ID!, attributes: StackRunAttributes!): StackRun

  updateRunStep(id: ID!, attributes: RunStepAttributes!): RunStep

  addRunLogs(stepId: ID!, attributes: RunLogAttributes!): RunLogs

  createStack(attributes: StackAttributes!): InfrastructureStack

  updateStack(id: ID!, attributes: StackAttributes!): InfrastructureStack

  deleteStack(id: ID!): InfrastructureStack

  detachStack(id: ID!): InfrastructureStack

  approveStackRun(id: ID!): StackRun

  upsertObservabilityProvider(attributes: ObservabilityProviderAttributes!): ObservabilityProvider

  deleteObservabilityProvider(id: ID!): ObservabilityProvider

  "a reusable mutation for updating rbac settings on core services"
  updateRbac(rbac: RbacAttributes!, serviceId: ID, clusterId: ID, providerId: ID): Boolean

  updateDeploymentSettings(attributes: DeploymentSettingsAttributes!): DeploymentSettings

  enableDeployments: DeploymentSettings
}

type RootSubscriptionType {
  applicationDelta: ApplicationDelta
  podDelta: PodDelta
  buildDelta(buildId: ID): BuildDelta
  commandDelta(buildId: ID!): CommandDelta
  notificationDelta: NotificationDelta
}

input PolicyBindingAttributes {
  id: ID
  userId: ID
  groupId: ID
}

input LokiQuery {
  labels: [LokiLabelFilter]
  filter: LokiLineFilter
}

input LokiLabelFilter {
  name: String!

  value: String!

  "whether to apply a regex match for this label"
  regex: Boolean
}

input LokiLineFilter {
  "the string to filter for (eg what is put in our search ui)"
  text: String

  "whether to treat this string as a regex match"
  regex: Boolean
}

type PolicyBinding {
  id: ID
  user: User
  group: Group
}

"global settings for CD, these specify global read\/write policies and also allow for customization of the repos for CAPI resources and the deploy operator"
type DeploymentSettings {
  id: ID!

  "whether you've yet to enable CD for this instance"
  enabled: Boolean!

  name: String!

  "whether the byok cluster has been brought under self-management"
  selfManaged: Boolean

  "the way we can connect to your loki instance"
  lokiConnection: HttpConnection

  "the way we can connect to your prometheus instance"
  prometheusConnection: HttpConnection

  "custom helm values to apply to all agents (useful for things like adding customary annotations\/labels)"
  agentHelmValues: String

  "the latest known k8s version"
  latestK8sVsn: String!

  "your compliant k8s version"
  compliantK8sVsn: String!

  "the repo to fetch CAPI manifests from, for both providers and clusters"
  artifactRepository: GitRepository

  "the repo to fetch the deploy operators manifests from"
  deployerRepository: GitRepository

  "read policy across all clusters"
  readBindings: [PolicyBinding]

  "write policy across all clusters"
  writeBindings: [PolicyBinding]

  "policy for managing git repos"
  gitBindings: [PolicyBinding]

  "policy for creation of new clusters"
  createBindings: [PolicyBinding]

  insertedAt: DateTime

  updatedAt: DateTime
}

"the details of how to connect to a http service like prometheus"
type HttpConnection {
  host: String!

  "user to connect w\/ for basic auth"
  user: String

  "password to connect w\/ for basic auth"
  password: String
}

input DeploymentSettingsAttributes {
  artifactRepositoryId: ID

  deployerRepositoryId: ID

  "custom helm values to apply to all agents (useful for things like adding customary annotations\/labels)"
  agentHelmValues: String

  "connection details for a prometheus instance to use"
  prometheusConnection: HttpConnectionAttributes

  "connection details for a loki instance to use"
  lokiConnection: HttpConnectionAttributes

  readBindings: [PolicyBindingAttributes]

  writeBindings: [PolicyBindingAttributes]

  gitBindings: [PolicyBindingAttributes]

  createBindings: [PolicyBindingAttributes]
}

input HttpConnectionAttributes {
  host: String!

  "user to connect w\/ for basic auth"
  user: String

  "password to connect w\/ for basic auth"
  password: String
}

input RbacAttributes {
  readBindings: [PolicyBindingAttributes]
  writeBindings: [PolicyBindingAttributes]
}

enum ObservabilityProviderType {
  DATADOG
  NEWRELIC
}

input ObservabilityProviderAttributes {
  type: ObservabilityProviderType!
  name: String!
  credentials: ObservabilityProviderCredentialsAttributes!
}

input ObservabilityProviderCredentialsAttributes {
  datadog: DatadogCredentialsAttributes
}

input DatadogCredentialsAttributes {
  apiKey: String!
  appKey: String!
}

type ObservabilityProvider {
  id: ID!
  type: ObservabilityProviderType!
  name: String!
  insertedAt: DateTime
  updatedAt: DateTime
}

type ObservabilityProviderConnection {
  pageInfo: PageInfo!
  edges: [ObservabilityProviderEdge]
}

enum StackStatus {
  QUEUED
  PENDING
  RUNNING
  SUCCESSFUL
  FAILED
  CANCELLED
}

enum StackType {
  TERRAFORM
  ANSIBLE
}

enum StepStatus {
  PENDING
  RUNNING
  SUCCESSFUL
  FAILED
}

enum StepStage {
  PLAN
  VERIFY
  APPLY
}

input StackAttributes {
  "the name of the stack"
  name: String!

  "A type for the stack, specifies the tool to use to apply it"
  type: StackType!

  "The repository to source IaC from"
  repositoryId: ID!

  "The cluster on which the terraform will be applied"
  clusterId: ID!

  "reference w\/in the repository where the IaC lives"
  git: GitRefAttributes!

  "optional k8s job configuration for the job that will apply this stack"
  jobSpec: GateJobAttributes

  "version\/image config for the tool you're using"
  configuration: StackConfigurationAttributes!

  "whether to require approval"
  approval: Boolean

  readBindings: [PolicyBindingAttributes]

  writeBindings: [PolicyBindingAttributes]

  files: [StackFileAttributes]

  environment: [StackEnvironmentAttributes]
}

input StackConfigurationAttributes {
  "optional custom image you might want to use"
  image: String

  "the semver of the tool you wish to use"
  version: String!
}

input StackRunAttributes {
  "The status of this run"
  status: StackStatus!

  "the state from this runs plan or apply"
  state: StackStateAttributes

  "output generated by this run"
  output: [StackOutputAttributes]

  "Any errors detected when trying to run this stack"
  errors: [ServiceErrorAttributes]
}

input RunStepAttributes {
  status: StepStatus!
}

input RunLogAttributes {
  logs: String!
}

input StackOutputAttributes {
  name: String!
  value: String!
  secret: Boolean
}

input StackEnvironmentAttributes {
  name: String!
  value: String!
  secret: Boolean
}

input StackFileAttributes {
  path: String!
  content: String!
}

input StackStateAttributes {
  plan: String
  state: [StackStateResourceAttributes]
}

input StackStateResourceAttributes {
  "a string identifier for this resource, different tools will have different conventions"
  identifier: String!

  "a string name of the resource type"
  resource: String!

  "the name of the resource within that type"
  name: String!

  "arbitrary configuration used to create the resource"
  configuration: Json

  "identifiers this resource is linked to for graphing in the UI"
  links: [String]
}

type InfrastructureStack {
  id: ID

  "the name of the stack"
  name: String!

  "A type for the stack, specifies the tool to use to apply it"
  type: StackType!

  "reference w\/in the repository where the IaC lives"
  git: GitRef!

  "optional k8s job configuration for the job that will apply this stack"
  jobSpec: JobGateSpec

  "version\/image config for the tool you're using"
  configuration: StackConfiguration!

  "whether to require approval"
  approval: Boolean

  "whether this stack was previously deleted and is pending cleanup"
  deletedAt: DateTime

  runs(after: String, first: Int, before: String, last: Int): StackRunConnection

  "files bound to a run of this stack"
  files: [StackFile]

  "environment variables for this stack"
  environment: [StackEnvironment]

  "the most recent output for this stack"
  output: [StackOutput]

  "the most recent state of this stack"
  state: StackState

  "the cluster this stack runs on"
  cluster: Cluster

  "the git repository you're sourcing IaC from"
  repository: GitRepository

  readBindings: [PolicyBinding]

  writeBindings: [PolicyBinding]

  insertedAt: DateTime

  updatedAt: DateTime
}

type StackConfiguration {
  "optional custom image you might want to use"
  image: String

  "the semver of the tool you wish to use"
  version: String!
}

type StackRun {
  id: ID!

  "The status of this run"
  status: StackStatus!

  "A type for the stack, specifies the tool to use to apply it"
  type: StackType!

  "reference w\/in the repository where the IaC lives"
  git: GitRef!

  "optional k8s job configuration for the job that will apply this stack"
  jobSpec: JobGateSpec

  "version\/image config for the tool you're using"
  configuration: StackConfiguration!

  "whether to require approval"
  approval: Boolean

  "when this run was approved"
  approvedAt: DateTime

  "https url to fetch the latest tarball of stack IaC"
  tarball: String!

  "the approver of this job"
  approver: User

  "The steps to perform when running this stack"
  steps: [RunStep]

  "files bound to a run of this stack"
  files: [StackFile]

  "environment variables for this stack"
  environment: [StackEnvironment]

  "the most recent output for this stack"
  output: [StackOutput]

  "the most recent state of this stack"
  state: StackState

  "a list of errors generated by the deployment operator"
  errors: [ServiceError]

  "the cluster this stack runs on"
  cluster: Cluster

  "the git repository you're sourcing IaC from"
  repository: GitRepository

  insertedAt: DateTime

  updatedAt: DateTime
}

type RunStep {
  id: ID!
  status: StepStatus!
  stage: StepStage!
  name: String!
  cmd: String!
  args: [String!]
  index: Int!
  logs: [RunLogs]
  insertedAt: DateTime
  updatedAt: DateTime
}

type RunLogs {
  id: ID!
  logs: String!
  insertedAt: DateTime
  updatedAt: DateTime
}

type StackOutput {
  name: String!
  value: String!
  secret: Boolean
}

type StackEnvironment {
  name: String!
  value: String!
  secret: Boolean
}

type StackFile {
  path: String!
  content: String!
}

type StackState {
  id: ID!
  plan: String
  state: [StackStateResource]
}

type StackStateResource {
  "a string identifier for this resource, different tools will have different conventions"
  identifier: String!

  "a string name of the resource type"
  resource: String!

  "the name of the resource within that type"
  name: String!

  "arbitrary configuration used to create the resource"
  configuration: Json

  "identifiers this resource is linked to for graphing in the UI"
  links: [String]
}

type InfrastructureStackConnection {
  pageInfo: PageInfo!
  edges: [InfrastructureStackEdge]
}

type StackRunConnection {
  pageInfo: PageInfo!
  edges: [StackRunEdge]
}

"A reference for a globalized service, which targets clusters based on the configured criteria"
input GlobalServiceAttributes {
  "name for this global service"
  name: String!

  "the cluster tags to target"
  tags: [TagAttributes]

  "kubernetes distribution to target"
  distro: ClusterDistro

  "cluster api provider to target"
  providerId: ID

  template: ServiceTemplateAttributes
}

"Attributes for configuring a managed namespace"
input ManagedNamespaceAttributes {
  "the name of this namespace once its placed on a cluster"
  name: String!

  "A short description of the purpose of this namespace"
  description: String

  "labels for this namespace"
  labels: Json

  "annotations for this namespace"
  annotations: Json

  "a list of pull secrets to attach to this namespace"
  pullSecrets: [String]

  service: ServiceTemplateAttributes

  target: ClusterTargetAttributes
}

"Attributes for configuring a service in something like a managed namespace"
input ServiceTemplateAttributes {
  "the name for this service (optional for managed namespaces)"
  name: String

  "the namespace for this service (optional for managed namespaces)"
  namespace: String

  templated: Boolean

  "the id of a repository to source manifests for this service"
  repositoryId: ID

  "a list of context ids to add to this service"
  contexts: [ID]

  "a list of secure configuration that will be added to any services created by this template"
  configuration: [ConfigAttributes]

  "settings to configure git for a service"
  git: GitRefAttributes

  "settings to configure helm for a service"
  helm: HelmConfigAttributes

  "settings for service kustomization"
  kustomize: KustomizeAttributes

  "attributes to configure sync settings for this service"
  syncConfig: SyncConfigAttributes
}

"A spec for targeting clusters"
input ClusterTargetAttributes {
  "the cluster tags to target"
  tags: Json

  "kubernetes distribution to target"
  distro: ClusterDistro
}

"a rules based mechanism to redeploy a service across a fleet of clusters"
type GlobalService {
  "internal id of this global service"
  id: ID!

  "a human readable name for this global service"
  name: String!

  "a set of tags to select clusters for this global service"
  tags: [Tag]

  "the kubernetes distribution to target with this global service"
  distro: ClusterDistro

  "the service template used to spawn services"
  template: ServiceTemplate

  "the service to replicate across clusters"
  service: ServiceDeployment

  "whether to only apply to clusters with this provider"
  provider: ClusterProvider

  services(after: String, first: Int, before: String, last: Int, q: String): ServiceDeploymentConnection

  insertedAt: DateTime

  updatedAt: DateTime
}

"A representation of a managed namespace, which is k8s namespace configuration + a service spec to define a namespace runtime"
type ManagedNamespace {
  id: ID!

  "the name of this namespace once its placed on a cluster"
  name: String!

  "A short description of the purpose of this namespace"
  description: String

  "labels for this namespace"
  labels: Map

  "annotations for this namespace"
  annotations: Map

  "a list of pull secrets to attach to this namespace"
  pullSecrets: [String]

  "The targeting criteria to select clusters this namespace is bound to"
  target: ClusterTarget

  "the timestamp this namespace was deleted at, indicating it's currently draining"
  deletedAt: DateTime

  "A template for creating the core service for this namespace"
  service: ServiceTemplate

  services(after: String, first: Int, before: String, last: Int, q: String): ServiceDeploymentConnection

  insertedAt: DateTime

  updatedAt: DateTime
}

"Attributes for configuring a service in something like a managed namespace"
type ServiceTemplate {
  "the name for this service (optional for managed namespaces)"
  name: String

  "the namespace for this service (optional for managed namespaces)"
  namespace: String

  templated: Boolean

  "the id of a repository to source manifests for this service"
  repositoryId: ID

  "a list of context ids to add to this service"
  contexts: [ID]

  repository: GitRepository

  "possibly secret configuration for all spawned services, don't query this in list endpoints"
  configuration: [ServiceConfiguration]

  "settings to configure git for a service"
  git: GitRef

  "settings to configure helm for a service"
  helm: HelmSpec

  "settings for service kustomization"
  kustomize: Kustomize

  "specification of how the templated service will be synced"
  syncConfig: SyncConfig
}

"A spec for targeting clusters"
type ClusterTarget {
  "the cluster tags to target"
  tags: Json

  "kubernetes distribution to target"
  distro: ClusterDistro
}

type GlobalServiceConnection {
  pageInfo: PageInfo!
  edges: [GlobalServiceEdge]
}

type ManagedNamespaceConnection {
  pageInfo: PageInfo!
  edges: [ManagedNamespaceEdge]
}

enum ConstraintViolationField {
  NAMESPACE
  KIND
}

"inputs to add constraint data from an OPA gatekeeper constraint CRD"
input PolicyConstraintAttributes {
  name: String!

  description: String

  recommendation: String

  violationCount: Int

  "pointer to the group\/name for the CR"
  ref: ConstraintRefAttributes

  violations: [ViolationAttributes]
}

input ConstraintRefAttributes {
  kind: String!
  name: String!
}

input ViolationAttributes {
  group: String
  version: String
  kind: String
  namespace: String
  name: String
  message: String
}

"A OPA Gatekeeper Constraint reference"
type PolicyConstraint {
  id: ID!

  name: String!

  description: String

  recommendation: String

  violationCount: Int

  "Fetches the live constraint object from K8s, this is an expensive query and should not be done in list endpoints"
  object: KubernetesUnstructured

  "pointer to the kubernetes resource itself"
  ref: ConstraintRef

  violations: [Violation]

  insertedAt: DateTime

  updatedAt: DateTime
}

type ConstraintRef {
  kind: String!
  name: String!
}

"A summary of statistics for violations w\/in a specific column"
type ViolationStatistic {
  "the value of this field being aggregated"
  value: String!

  "the total number of violations found"
  violations: Int

  "the total number of policy constraints"
  count: Int
}

"A violation of a given OPA Gatekeeper constraint"
type Violation {
  id: ID!
  group: String
  version: String
  kind: String
  namespace: String
  name: String
  message: String
  insertedAt: DateTime
  updatedAt: DateTime
}

type PolicyConstraintConnection {
  pageInfo: PageInfo!
  edges: [PolicyConstraintEdge]
}

enum SinkType {
  SLACK
  TEAMS
}

input NotificationSinkAttributes {
  "the name of this sink"
  name: String!

  "the channel type of this sink"
  type: SinkType!

  "configuration for the specific type"
  configuration: SinkConfigurationAttributes!
}

input SinkConfigurationAttributes {
  slack: UrlSinkAttributes
  teams: UrlSinkAttributes
}

input UrlSinkAttributes {
  url: String!
}

input NotificationRouterAttributes {
  "the name of this router"
  name: String!

  "the events to trigger, or use * for any"
  events: [String!]

  "filters by object type"
  filters: [RouterFilterAttributes]

  "sinks to deliver notifications to"
  routerSinks: [RouterSinkAttributes]
}

input RouterFilterAttributes {
  "a regex for filtering by things like pr url"
  regex: String

  "whether to enable delivery for events associated with this service"
  serviceId: ID

  "whether to enable delivery for events associated with this cluster"
  clusterId: ID

  "whether to enable delivery for events associated with this pipeline"
  pipelineId: ID
}

input RouterSinkAttributes {
  sinkId: ID!
}

type NotificationSink {
  id: ID!

  "the name of the sink"
  name: String!

  "the channel type of the sink, eg slack or teams"
  type: SinkType!

  "type specific sink configuration"
  configuration: SinkConfiguration!

  insertedAt: DateTime

  updatedAt: DateTime
}

type NotificationRouter {
  id: ID!

  "name of this router"
  name: String!

  "events this router subscribes to, use * for all"
  events: [String!]

  "resource-based filters to select events for services, clusters, pipelines"
  filters: [NotificationFilter]

  "sinks to deliver notifications to"
  sinks: [NotificationSink]

  insertedAt: DateTime

  updatedAt: DateTime
}

type NotificationFilter {
  id: ID!
  regex: String
  service: ServiceDeployment
  cluster: Cluster
  pipeline: Pipeline
}

type SinkConfiguration {
  id: ID!
  slack: UrlSinkConfiguration
  teams: UrlSinkConfiguration
}

"A notification sink based off slack incoming webhook urls"
type UrlSinkConfiguration {
  "incoming webhook url to deliver to"
  url: String!
}

type NotificationSinkConnection {
  pageInfo: PageInfo!
  edges: [NotificationSinkEdge]
}

type NotificationRouterConnection {
  pageInfo: PageInfo!
  edges: [NotificationRouterEdge]
}

enum RestoreStatus {
  CREATED
  PENDING
  SUCCESSFUL
  FAILED
}

input ObjectStoreAttributes {
  name: String!
  s3: S3StoreAttributes
  gcs: GcsStoreAttributes
  azure: AzureStoreAttributes
}

input BackupAttributes {
  name: String!
  namespace: String!
  garbageCollected: Boolean
  ttl: String
  namespaces: ResourceSelectorAttributes
  resources: ResourceSelectorAttributes
}

input ResourceSelectorAttributes {
  included: [String]
  excluded: [String]
}

input RestoreAttributes {
  status: RestoreStatus!
}

input S3StoreAttributes {
  bucket: String!
  region: String
  endpoint: String
  accessKeyId: String!
  secretAccessKey: String!
}

input GcsStoreAttributes {
  bucket: String!
  region: String
  applicationCredentials: String!
}

input AzureStoreAttributes {
  storageAccount: String!
  container: String!
  subscriptionId: String!
  resourceGroup: String!
  tenantId: String!
  clientId: String!
  clientSecret: String!
}

type ObjectStore {
  id: ID!
  name: String!
  s3: S3Store
  gcs: GcsStore
  azure: AzureStore
  insertedAt: DateTime
  updatedAt: DateTime
}

type ClusterBackup {
  id: ID!
  name: String!
  namespace: String!
  ttl: String
  garbageCollected: Boolean
  namespaces: ResourceSelector
  resources: ResourceSelector
  cluster: Cluster
  insertedAt: DateTime
  updatedAt: DateTime
}

type ResourceSelector {
  included: [String]
  excluded: [String]
}

type ClusterRestore {
  id: ID!
  status: RestoreStatus!
  backup: ClusterBackup
  insertedAt: DateTime
  updatedAt: DateTime
}

type S3Store {
  bucket: String!
  region: String
  endpoint: String
  accessKeyId: String!
}

type GcsStore {
  bucket: String!
  region: String
}

type AzureStore {
  storageAccount: String!
  container: String!
  subscriptionId: String!
  resourceGroup: String!
  tenantId: String!
  clientId: String!
}

type ObjectStoreConnection {
  pageInfo: PageInfo!
  edges: [ObjectStoreEdge]
}

type ClusterBackupConnection {
  pageInfo: PageInfo!
  edges: [ClusterBackupEdge]
}

type ClusterRestoreConnection {
  pageInfo: PageInfo!
  edges: [ClusterRestoreEdge]
}

enum GateState {
  PENDING
  OPEN
  CLOSED
  RUNNING
}

enum GateType {
  APPROVAL
  WINDOW
  JOB
}

"the top level input object for creating\/deleting pipelines"
input PipelineAttributes {
  stages: [PipelineStageAttributes]
  edges: [PipelineEdgeAttributes]
}

"specification of a stage of a pipeline"
input PipelineStageAttributes {
  name: String!
  services: [StageServiceAttributes]
}

"specification of an edge between two pipeline stages"
input PipelineEdgeAttributes {
  "stage id the edge is from, can also be specified by name"
  fromId: ID

  "stage id the edge is to, can also be specified by name"
  toId: ID

  "the name of the pipeline stage this edge emits from"
  from: String

  "the name of the pipeline stage this edge points to"
  to: String

  "any optional promotion gates you wish to configure"
  gates: [PipelineGateAttributes]
}

"will configure a promotion gate for a pipeline"
input PipelineGateAttributes {
  "the name of this gate"
  name: String!

  "the type of gate this is"
  type: GateType!

  "the handle of a cluster this gate will execute on"
  cluster: String

  "the id of the cluster this gate will execute on"
  clusterId: ID

  "a specification for more complex gate types"
  spec: GateSpecAttributes
}

"attributes needed to create a new pipeline context"
input PipelineContextAttributes {
  context: Json!
}

"the allowed inputs for a deployment agent gate update"
input GateUpdateAttributes {
  state: GateState
  status: GateStatusAttributes
}

input GateStatusAttributes {
  jobRef: NamespacedName
}

input NamespacedName {
  name: String!
  namespace: String!
}

"a more refined spec for parameters needed for complex gates"
input GateSpecAttributes {
  job: GateJobAttributes
}

"spec for a job gate"
input GateJobAttributes {
  namespace: String!

  "if you'd rather define the job spec via straight k8s yaml"
  raw: String

  containers: [ContainerAttributes]

  labels: Json

  annotations: Json

  serviceAccount: String
}

"the attributes for a container"
input ContainerAttributes {
  image: String!
  args: [String]
  env: [EnvAttributes]
  envFrom: [EnvFromAttributes]
}

input EnvAttributes {
  name: String!
  value: String!
}

input EnvFromAttributes {
  secret: String!
  configMap: String!
}

"the attributes of a service w\/in a specific stage"
input StageServiceAttributes {
  "the cluster handle of this service"
  handle: String

  "the name of this service"
  name: String

  "the name of this service"
  serviceId: ID

  criteria: PromotionCriteriaAttributes
}

"actions to perform if this stage service were promoted"
input PromotionCriteriaAttributes {
  "the handle of the cluster for the source service"
  handle: String

  "the name of the source service"
  name: String

  "the id of the service to promote from"
  sourceId: ID

  "the id of a pr automation to update this service"
  prAutomationId: ID

  "the secrets to copy over in a promotion"
  secrets: [String]
}

"a release pipeline, composed of multiple stages each with potentially multiple services"
type Pipeline {
  id: ID!

  "the name of the pipeline"
  name: String!

  "the stages of this pipeline"
  stages: [PipelineStage]

  status: PipelineStatus

  "edges linking two stages w\/in the pipeline in a full DAG"
  edges: [PipelineStageEdge]

  "lists the contexts applied to a pipeline"
  contexts(after: String, first: Int, before: String, last: Int): PipelineContextConnection

  insertedAt: DateTime

  updatedAt: DateTime
}

"A variable context that can be used to generate pull requests as a pipeline progresses"
type PipelineContext {
  id: ID!

  "the context map that will be passed to the pipeline"
  context: Map!

  pipeline: Pipeline

  "a history of pull requests created by this context thus far"
  pullRequests: [PullRequest]

  "a list of pipeline-specific PRs for this context"
  pipelinePullRequests: [PipelinePullRequest]

  insertedAt: DateTime

  updatedAt: DateTime
}

"a pipeline stage, has a list of services and potentially a promotion which might be pending"
type PipelineStage {
  id: ID!

  "the name of this stage (eg dev, prod, staging)"
  name: String!

  "the services within this stage"
  services: [StageService]

  "the context that is to be applied to this stage for PR promotions"
  context: PipelineContext

  "a promotion which might be outstanding for this stage"
  promotion: PipelinePromotion

  insertedAt: DateTime

  updatedAt: DateTime
}

"an edge in the pipeline DAG"
type PipelineStageEdge {
  id: ID!

  "when the edge was last promoted, if greater than the promotion objects revised at, was successfully promoted"
  promotedAt: DateTime

  from: PipelineStage!

  to: PipelineStage!

  gates: [PipelineGate]

  pipeline: Pipeline

  insertedAt: DateTime

  updatedAt: DateTime
}

"A gate blocking promotion along a release pipeline"
type PipelineGate {
  id: ID!

  "the name of this gate as seen in the UI"
  name: String!

  "the type of gate this is"
  type: GateType!

  "the current state of this gate"
  state: GateState!

  "more detailed specification for complex gates"
  spec: GateSpec

  "state related to the current status of this job"
  status: GateStatus

  "the kubernetes job running this gate (should only be fetched lazily as this is a heavy operation)"
  job: Job

  "the edge this gate lives on"
  edge: PipelineStageEdge

  "the cluster this gate can run on"
  cluster: Cluster

  "the last user to approve this gate"
  approver: User

  insertedAt: DateTime

  updatedAt: DateTime
}

"detailed gate specifications"
type GateSpec {
  job: JobGateSpec
}

"state delineating the current status of this gate"
type GateStatus {
  jobRef: JobReference
}

"the full specification of a job gate"
type JobGateSpec {
  "the namespace the job will run in"
  namespace: String!

  "a raw kubernetes job resource, overrides any other configuration"
  raw: String

  "list of containers to run in this job"
  containers: [ContainerSpec]

  "any pod labels to apply"
  labels: Map

  "any pod annotations to apply"
  annotations: Map

  "the service account the pod will use"
  serviceAccount: String
}

"a shortform spec for job containers, designed for ease-of-use"
type ContainerSpec {
  image: String!
  args: [String]
  env: [ContainerEnv]
  envFrom: [ContainerEnvFrom]
}

"container env variable"
type ContainerEnv {
  name: String!
  value: String!
}

"env from declarations for containers"
type ContainerEnvFrom {
  configMap: String!
  secret: String!
}

"the configuration of a service within a pipeline stage, including optional promotion criteria"
type StageService {
  id: ID!

  "a pointer to a service"
  service: ServiceDeployment

  "criteria for how a promotion of this service shall be performed"
  criteria: PromotionCriteria

  insertedAt: DateTime

  updatedAt: DateTime
}

"how a promotion for a service will be performed"
type PromotionCriteria {
  id: ID!

  "the source service in a prior stage to promote settings from"
  source: ServiceDeployment

  "whether you want to copy any configuration values from the source service"
  secrets: [String]

  insertedAt: DateTime

  updatedAt: DateTime
}

"a representation of an individual pipeline promotion, which is a list of services\/revisions and timestamps to determine promotion status"
type PipelinePromotion {
  id: ID!

  "the last time this promotion was updated"
  revisedAt: DateTime

  "the last time this promotion was fully promoted, it's no longer pending if promoted_at > revised_at"
  promotedAt: DateTime

  "the services included in this promotion"
  services: [PromotionService]

  insertedAt: DateTime

  updatedAt: DateTime
}

"a service to be potentially promoted"
type PromotionService {
  id: ID!

  "a service to promote"
  service: ServiceDeployment

  "the revision of the service to promote"
  revision: Revision

  insertedAt: DateTime

  updatedAt: DateTime
}

"a report of gate statuses within a pipeline to gauge its health"
type PipelineStatus {
  "if > 0, consider the pipeline pending"
  pending: Int

  "if > 0, consider the pipeline stopped"
  closed: Int

  "if > 0, consider the pipeline runnning"
  running: Int
}

"A pull request created in the course of executing a pipeline"
type PipelinePullRequest {
  id: ID!
  service: ServiceDeployment
  pullRequest: PullRequest
}

type PipelineConnection {
  pageInfo: PageInfo!
  edges: [PipelineEdge]
}

type PipelineGateConnection {
  pageInfo: PageInfo!
  edges: [PipelineGateEdge]
}

type PipelineContextConnection {
  pageInfo: PageInfo!
  edges: [PipelineContextEdge]
}

enum ComponentState {
  RUNNING
  PENDING
  FAILED
  PAUSED
}

enum ServiceDeploymentStatus {
  STALE
  SYNCED
  HEALTHY
  FAILED
  PAUSED
}

enum ServicePromotion {
  IGNORE
  PROCEED
  ROLLBACK
}

input ServiceDeploymentAttributes {
  name: String!

  namespace: String!

  version: String

  docsPath: String

  syncConfig: SyncConfigAttributes

  protect: Boolean

  repositoryId: ID

  dryRun: Boolean

  interval: String

  "if you should apply liquid templating to raw yaml files, defaults to true"
  templated: Boolean

  git: GitRefAttributes

  helm: HelmConfigAttributes

  kustomize: KustomizeAttributes

  configuration: [ConfigAttributes]

  readBindings: [PolicyBindingAttributes]

  writeBindings: [PolicyBindingAttributes]

  contextBindings: [ContextBindingAttributes]
}

input SyncConfigAttributes {
  createNamespace: Boolean
  namespaceMetadata: MetadataAttributes
}

input HelmConfigAttributes {
  values: String
  valuesFiles: [String]
  chart: String
  version: String
  set: HelmValueAttributes
  repository: NamespacedName
}

input MetadataAttributes {
  labels: Json
  annotations: Json
}

input HelmValueAttributes {
  "helm value name, can be deeply nested via dot like `image.tag`"
  name: String

  "value of the attribute"
  value: String
}

input ServiceUpdateAttributes {
  version: String

  protect: Boolean

  dryRun: Boolean

  interval: String

  syncConfig: SyncConfigAttributes

  "if you should apply liquid templating to raw yaml files, defaults to true"
  templated: Boolean

  git: GitRefAttributes

  helm: HelmConfigAttributes

  configuration: [ConfigAttributes]

  kustomize: KustomizeAttributes

  readBindings: [PolicyBindingAttributes]

  writeBindings: [PolicyBindingAttributes]

  contextBindings: [ContextBindingAttributes]
}

input ServiceCloneAttributes {
  name: String!
  namespace: String
  configuration: [ConfigAttributes]
}

input GitRefAttributes {
  ref: String!
  folder: String!
}

input ConfigAttributes {
  name: String!
  value: String
}

input ComponentAttributes {
  state: ComponentState
  synced: Boolean!
  group: String!
  version: String!
  kind: String!
  namespace: String!
  name: String!
  content: ComponentContentAttributes
}

"the content of a component when visualized in dry run state"
input ComponentContentAttributes {
  "the desired state of a service component as determined from the configured manifests"
  desired: String

  live: String
}

input ServiceErrorAttributes {
  source: String!
  message: String!
}

"A reusable configuration context, useful for plumbing data from external tools like terraform\/pulumi\/etc"
input ServiceContextAttributes {
  configuration: Json
  secrets: [ConfigAttributes]
}

"a binding from a service to a service context"
input ContextBindingAttributes {
  contextId: String!
}

input KustomizeAttributes {
  "the path to the kustomization file to use"
  path: String!
}

"a reference to a service deployed from a git repo into a cluster"
type ServiceDeployment {
  "internal id of this service"
  id: ID!

  "human readable name of this service, must be unique per cluster"
  name: String!

  "kubernetes namespace this service will be deployed to"
  namespace: String!

  "A summary status enum for the health of this service"
  status: ServiceDeploymentStatus!

  "semver of this service"
  version: String!

  "the desired sync interval for this service"
  interval: String

  "description on where in git the service's manifests should be fetched"
  git: GitRef

  "description of how helm charts should be applied"
  helm: HelmSpec

  "how you'd like to perform a canary promotion"
  promotion: ServicePromotion

  "if you should apply liquid templating to raw yaml files, defaults to true"
  templated: Boolean

  "if true, deletion of this service is not allowed"
  protect: Boolean

  "latest git sha we pulled from"
  sha: String

  "https url to fetch the latest tarball of kubernetes manifests"
  tarball: String

  "a n \/ m representation of the number of healthy components of this service"
  componentStatus: String

  "settings for advanced tuning of the sync process"
  syncConfig: SyncConfig

  "kustomize related service metadata"
  kustomize: Kustomize

  "the commit message currently in use"
  message: String

  "the time this service was scheduled for deletion"
  deletedAt: DateTime

  "whether this service should not actively reconcile state and instead simply report pending changes"
  dryRun: Boolean

  "fetches the \/docs directory within this services git tree.  This is a heavy operation and should NOT be used in list queries"
  docs: [GitFile]

  "the git repo of this service"
  repository: GitRepository

  helmRepository: HelmRepository

  "Queries logs for a service out of loki"
  logs(query: LokiQuery!, start: Long, end: Long, limit: Int!): [LogStream]

  "read policy for this service"
  readBindings: [PolicyBinding]

  "write policy of this service"
  writeBindings: [PolicyBinding]

  "a list of errors generated by the deployment operator"
  errors: [ServiceError]

  "the cluster this service is deployed into"
  cluster: Cluster

  "the current revision of this service"
  revision: Revision

  "possibly secret configuration used to template the manifests of this service"
  configuration: [ServiceConfiguration]

  "the kubernetes component of a service"
  components: [ServiceComponent]

  "the global service this service is the source for"
  globalService: GlobalService

  "whether this service is controlled by a global service"
  owner: GlobalService

  "bound contexts for this service"
  contexts: [ServiceContext]

  "a relay connection of all revisions of this service, these are periodically pruned up to a history limit"
  revisions(after: String, first: Int, before: String, last: Int): RevisionConnection

  "whether this service is editable"
  editable: Boolean

  insertedAt: DateTime

  updatedAt: DateTime
}

"a representation of a past revision of a service"
type Revision {
  "id of this revision"
  id: ID!

  "the service's semver"
  version: String!

  "git spec of the prior revision"
  git: GitRef

  "description of how helm charts should be applied"
  helm: HelmSpec

  "the sha this service was pulled from"
  sha: String

  "the commit message for this revision"
  message: String

  insertedAt: DateTime

  updatedAt: DateTime
}

"a representation of where to pull manifests from git"
type GitRef {
  "a general git ref, either a branch name or commit sha understandable by `git checkout <ref>`"
  ref: String!

  "the folder manifests live under"
  folder: String!
}

type ObjectReference {
  name: String
  namespace: String
}

type HelmSpec {
  "the name of the chart this service is using"
  chart: String

  "a helm values file to use with this service, requires auth and so is heavy to query"
  values: String

  "pointer to the flux helm repository resource used for this chart"
  repository: ObjectReference

  "the chart version in use currently"
  version: String

  "a list of helm name\/value pairs to precisely set individual values"
  set: [HelmValue]

  "a list of relative paths to values files to use for helm applies"
  valuesFiles: [String]
}

"a configuration item k\/v pair"
type ServiceConfiguration {
  name: String!
  value: String!
}

"a (possibly nested) helm value pair"
type HelmValue {
  name: String!
  value: String!
}

"metadata needed for configuring kustomize"
type Kustomize {
  path: String!
}

"representation of a kubernetes component deployed by a service"
type ServiceComponent {
  "internal id"
  id: ID!

  "kubernetes component health enum"
  state: ComponentState

  "whether this component has been applied to the k8s api"
  synced: Boolean!

  "api group of this resource"
  group: String

  "api version of this resource"
  version: String

  "api kind of this resource"
  kind: String!

  "kubernetes namespace of this resource"
  namespace: String

  "kubernetes name of this resource"
  name: String!

  "the live and desired states of this service component"
  content: ComponentContent

  "the service this component belongs to"
  service: ServiceDeployment

  "any api deprecations discovered from this component"
  apiDeprecations: [ApiDeprecation]
}

"dry run content of a service component"
type ComponentContent {
  id: ID!

  live: String

  "the inferred desired state of this component"
  desired: String

  insertedAt: DateTime

  updatedAt: DateTime
}

"a representation of a kubernetes api deprecation"
type ApiDeprecation {
  "the kubernetes version the deprecation was posted"
  deprecatedIn: String

  "the kubernetes version the api version will be removed and unusable in"
  removedIn: String

  "the api you can replace this resource with"
  replacement: String

  "the kubernetes version the replacement api was created in"
  availableIn: String

  "whether you cannot safely upgrade to the next kubernetes version if this deprecation exists"
  blocking: Boolean

  "the component of this deprecation"
  component: ServiceComponent
}

"an error sent from the deploy operator about sync progress"
type ServiceError {
  source: String!
  message: String!
}

"a file fetched from a git repository, eg a docs .md file"
type GitFile {
  path: String!
  content: String!
}

"a rollup count of the statuses of services in a query"
type ServiceStatusCount {
  status: ServiceDeploymentStatus!
  count: Int!
}

"Advanced configuration of how to sync resources"
type SyncConfig {
  "whether the agent should auto-create the namespace for this service"
  createNamespace: Boolean

  namespaceMetadata: NamespaceMetadata
}

"metadata fields for created namespaces"
type NamespaceMetadata {
  labels: Map
  annotations: Map
}

"A reusable bundle of configuration designed to make it easy to communicate between tools like tf\/pulumi and k8s"
type ServiceContext {
  id: ID!
  name: String!
  configuration: Map
  secrets: [ServiceConfiguration]
  insertedAt: DateTime
  updatedAt: DateTime
}

"A tree view of the kubernetes object hierarchy beneath a component"
type ComponentTree {
  root: KubernetesUnstructured
  deployments: [Deployment]
  statefulsets: [StatefulSet]
  replicasets: [ReplicaSet]
  daemonsets: [DaemonSet]
  services: [Service]
  ingresses: [Ingress]
  cronjobs: [CronJob]
  configmaps: [ConfigMap]
  secrets: [Secret]
  certificates: [Certificate]
  edges: [ResourceEdge]
}

"an edge representing mapping from kubernetes object metadata.uid -> metadata.uid"
type ResourceEdge {
  from: String!
  to: String!
}

type ServiceDeploymentConnection {
  pageInfo: PageInfo!
  edges: [ServiceDeploymentEdge]
}

type RevisionConnection {
  pageInfo: PageInfo!
  edges: [RevisionEdge]
}

enum ClusterDistro {
  GENERIC
  EKS
  AKS
  GKE
  RKE
  K3S
}

enum Conjunction {
  AND
  OR
}

input ClusterAttributes {
  name: String!

  "a short, unique human readable name used to identify this cluster and does not necessarily map to the cloud resource name"
  handle: String

  providerId: ID

  "a cloud credential to use when provisioning this cluster"
  credentialId: ID

  version: String

  distro: ClusterDistro

  metadata: Json

  protect: Boolean

  kubeconfig: KubeconfigAttributes

  cloudSettings: CloudSettingsAttributes

  "status of the upgrade plan for this cluster"
  upgradePlan: UpgradePlanAttributes

  nodePools: [NodePoolAttributes]

  readBindings: [PolicyBindingAttributes]

  writeBindings: [PolicyBindingAttributes]

  tags: [TagAttributes]
}

input KubeconfigAttributes {
  raw: String
}

input TagAttributes {
  name: String!
  value: String!
}

input ClusterPing {
  currentVersion: String!
  distro: ClusterDistro
}

input ClusterUpdateAttributes {
  version: String

  "a short, unique human readable name used to identify this cluster and does not necessarily map to the cloud resource name"
  handle: String

  "if you optionally want to reconfigure the git repository for the cluster service"
  service: ClusterServiceAttributes

  "pass a kubeconfig for this cluster (DEPRECATED)"
  kubeconfig: KubeconfigAttributes

  "status of the upgrade plan for this cluster"
  upgradePlan: UpgradePlanAttributes

  protect: Boolean

  distro: ClusterDistro

  metadata: Json

  nodePools: [NodePoolAttributes]

  tags: [TagAttributes]
}

input ClusterServiceAttributes {
  id: ID!
  repositoryId: ID
  git: GitRefAttributes!
}

input UpgradePlanAttributes {
  "whether all compatibilities for a cluster upgrade have been cleared"
  compatibilities: Boolean

  "whether all incompatibilities w\/in runtime components have been cleared"
  incompatibilities: Boolean

  "whether all deprecated apis for a cluster have been cleared"
  deprecations: Boolean
}

input NodePoolAttributes {
  name: String!
  minSize: Int!
  maxSize: Int!
  instanceType: String!
  labels: Json
  taints: [TaintAttributes]
  cloudSettings: NodePoolCloudAttributes
}

input TaintAttributes {
  key: String!
  value: String!
  effect: String!
}

input CloudSettingsAttributes {
  aws: AwsCloudAttributes
  gcp: GcpCloudAttributes
  azure: AzureCloudAttributes
}

input AwsCloudAttributes {
  region: String
}

input GcpCloudAttributes {
  project: String
  network: String
  region: String
}

input AzureCloudAttributes {
  location: String
  subscriptionId: String
  resourceGroup: String
  network: String
}

input NodePoolCloudAttributes {
  aws: AwsNodeCloudAttributes
}

input AwsNodeCloudAttributes {
  launchTemplateId: String
}

input ClusterProviderAttributes {
  name: String!
  namespace: String
  cloud: String
  cloudSettings: CloudProviderSettingsAttributes
}

input ClusterProviderUpdateAttributes {
  "if you optionally want to reconfigure the git repository for the cluster provider"
  service: ClusterServiceAttributes

  cloudSettings: CloudProviderSettingsAttributes
}

input CloudProviderSettingsAttributes {
  aws: AwsSettingsAttributes
  gcp: GcpSettingsAttributes
  azure: AzureSettingsAttributes
}

input ProviderCredentialAttributes {
  namespace: String
  name: String!
  kind: String
}

input AwsSettingsAttributes {
  accessKeyId: String!
  secretAccessKey: String!
}

input GcpSettingsAttributes {
  applicationCredentials: String!
}

input AzureSettingsAttributes {
  tenantId: String!
  subscriptionId: String!
  clientId: ID!
  clientSecret: String!
}

input RuntimeServiceAttributes {
  name: String!
  version: String!
}

input AgentMigrationAttributes {
  name: String
  ref: String
  configuration: Json
}

input PinnedCustomResourceAttributes {
  name: String!
  displayName: String!
  group: String!
  version: String!
  kind: String!
  namespaced: Boolean
  clusterId: ID
}

input TagInput {
  name: String!
  value: String!
}

input TagQuery {
  op: Conjunction!
  tags: [TagInput]
}

"a CAPI provider for a cluster, cloud is inferred from name if not provided manually"
type ClusterProvider {
  "the id of this provider"
  id: ID!

  "a human readable name for the provider, globally unique"
  name: String!

  "the namespace the CAPI resources are deployed into"
  namespace: String!

  "the name of the cloud service for this provider"
  cloud: String!

  "the details of how cluster manifests will be synced from git when created with this provider"
  git: GitRef!

  "the repository used to serve cluster manifests"
  repository: GitRepository

  "the repository for the CAPI service itself if customized"
  providerRepository: GitRepository

  "the service of the CAPI controller itself"
  service: ServiceDeployment

  "a list of credentials eligible for this provider"
  credentials: [ProviderCredential]

  "when the cluster provider was deleted"
  deletedAt: DateTime

  runtimeServices(
    "the kubernetes version you want to check is upgradeable"
    kubeVersion: String
  ): [RuntimeService]

  "the kubernetes versions this provider currently supports"
  supportedVersions: [String]

  "the region names this provider can deploy to"
  regions: [String]

  "whether the current user can edit this resource"
  editable: Boolean

  insertedAt: DateTime

  updatedAt: DateTime
}

"a representation of a cluster you can deploy to"
type Cluster {
  "internal id of this cluster"
  id: ID!

  "whether this is the management cluster itself"
  self: Boolean

  "human readable name of this cluster, will also translate to cloud k8s name"
  name: String!

  "if true, this cluster cannot be deleted"
  protect: Boolean

  "desired k8s version for the cluster"
  version: String

  "the distribution of kubernetes this cluster is running"
  distro: ClusterDistro

  "arbitrary json metadata to store user-specific state of this cluster (eg IAM roles for add-ons)"
  metadata: Map

  "current k8s version as told to us by the deployment operator"
  currentVersion: String

  "a short, unique human readable name used to identify this cluster and does not necessarily map to the cloud resource name"
  handle: String

  "whether the deploy operator has been registered for this cluster"
  installed: Boolean

  "the cloud settings for this cluster (for instance its aws region)"
  settings: CloudSettings

  "Checklist of tasks to complete to safely upgrade this cluster"
  upgradePlan: ClusterUpgradePlan

  "the url of the kas server you can access this cluster from"
  kasUrl: String

  "a auth token to be used by the deploy operator, only readable on create"
  deployToken: String

  "when this cluster was scheduled for deletion"
  deletedAt: DateTime

  "last time the deploy operator pinged this cluster"
  pingedAt: DateTime

  "read policy for this cluster"
  readBindings: [PolicyBinding]

  "write policy for this cluster"
  writeBindings: [PolicyBinding]

  "list of node pool specs managed by CAPI"
  nodePools: [NodePool]

  "the provider we use to create this cluster (null if BYOK)"
  provider: ClusterProvider

  "a custom credential to use when provisioning this cluster"
  credential: ProviderCredential

  "the service used to deploy the CAPI resources of this cluster"
  service: ServiceDeployment

  "key\/value tags to filter clusters"
  tags: [Tag]

  "all api deprecations for all services in this cluster"
  apiDeprecations: [ApiDeprecation]

  "any errors which might have occurred during the bootstrap process"
  serviceErrors: [ServiceError]

  "a custom git repository if you want to define your own CAPI manifests"
  repository: GitRepository

  "pr automations that are relevant to managing this cluster"
  prAutomations: [PrAutomation]

  "the active restore for this cluster"
  restore: ClusterRestore

  "the object store connection bound to this cluster for backup\/restore"
  objectStore: ObjectStore

  "list cached nodes for a cluster, this can be stale up to 5m"
  nodes: [Node]

  "list the cached node metrics for a cluster, can also be stale up to 5m"
  nodeMetrics: [NodeMetric]

  "custom resources with dedicated views for this cluster"
  pinnedCustomResources: [PinnedCustomResource]

  "the status of the cluster as seen from the CAPI operator, since some clusters can be provisioned without CAPI, this can be null"
  status: ClusterStatus

  "a relay connection of all revisions of this cluster, these are periodically pruned up to a history limit"
  revisions(after: String, first: Int, before: String, last: Int): ClusterRevisionConnection

  "lists OPA constraints registered in this cluster"
  policyConstraints(
    after: String

    first: Int

    before: String

    last: Int

    "only show constraints with a violation for the given namespace"
    namespace: String

    "only show constraints with a violation for the given kind"
    kind: String

    kinds: [String]

    namespaces: [String]

    q: String
  ): PolicyConstraintConnection

  "Computes a list of statistics for OPA constraint violations w\/in this cluster"
  violationStatistics(field: ConstraintViolationField!): [ViolationStatistic]

  "Queries logs for a cluster out of loki"
  logs(query: LokiQuery!, start: Long, end: Long, limit: Int!): [LogStream]

  "fetches a list of runtime services found in this cluster, this is an expensive operation that should not be done in list queries"
  runtimeServices: [RuntimeService]

  "whether the current user can edit this cluster"
  editable: Boolean

  insertedAt: DateTime

  updatedAt: DateTime
}

"A consolidated checklist of tasks that need to be completed to upgrade this cluster"
type ClusterUpgradePlan {
  "whether api compatibilities with all addons and kubernetes are satisfied"
  compatibilities: Boolean

  "whether mutual api incompatibilities with all addons and kubernetes have been satisfied"
  incompatibilities: Boolean

  "whether all api deprecations have been cleared for the target version"
  deprecations: Boolean
}

"a historical revision of a cluster, including version, cloud and node group configuration"
type ClusterRevision {
  id: ID!
  version: String
  nodePools: [NodePool]
  insertedAt: DateTime
  updatedAt: DateTime
}

"a specification for a node pool to be created in this cluster"
type NodePool {
  "internal id for this node pool"
  id: ID!

  "name of this node pool (must be unique)"
  name: String!

  "minimum number of instances in this node pool"
  minSize: Int!

  "maximum number of instances in this node pool"
  maxSize: Int!

  "the type of node to use (usually cloud-specific)"
  instanceType: String!

  "whether this is a spot pool or not"
  spot: Boolean

  "kubernetes labels to apply to the nodes in this pool, useful for node selectors"
  labels: Map

  "any taints you'd want to apply to a node, for eg preventing scheduling on spot instances"
  taints: [Taint]

  "cloud specific settings for the node groups"
  cloudSettings: NodeCloudSettings

  insertedAt: DateTime

  updatedAt: DateTime
}

"a kubernetes node taint"
type Taint {
  key: String!
  value: String!
  effect: String!
}

"the cloud configuration for a cluster"
type CloudSettings {
  aws: AwsCloudSettings
  gcp: GcpCloudSettings
  azure: AzureCloudSettings
}

"aws specific cloud configuration"
type AwsCloudSettings {
  region: String
}

"gcp specific cluster cloud configuration"
type GcpCloudSettings {
  project: String
  network: String
  region: String
}

"azure-specific cluster cloud configuration"
type AzureCloudSettings {
  location: String
  subscriptionId: String
  resourceGroup: String
  network: String
}

"cloud specific settings for a node pool"
type NodeCloudSettings {
  aws: AwsCloud
}

"aws node customizations"
type AwsCloud {
  "custom launch template for your nodes, useful for Golden AMI setups"
  launchTemplateId: String
}

"a cloud credential that can be used while creating new clusters"
type ProviderCredential {
  id: ID!
  name: String!
  namespace: String!
  kind: String!
  insertedAt: DateTime
  updatedAt: DateTime
}

"the crd status of the cluster as seen by the CAPI operator"
type ClusterStatus {
  phase: String
  controlPlaneReady: Boolean
  failureMessage: String
  failureReason: String
  conditions: [ClusterCondition]
}

"Summary statistics of the upgradeability of your fleet"
type UpgradeStatistics {
  "total number of clusters"
  count: Int

  "the number of clusters currently upgradeable"
  upgradeable: Int

  "the number of clusters currently at the latest version"
  latest: Int

  "the number of clusters compliant w\/ your versioning policy"
  compliant: Int
}

"a single condition struct for various phases of the cluster provisionining process"
type ClusterCondition {
  lastTransitionTime: String
  status: String
  type: String
  message: String
  reason: String
  severity: String
}

"A common kubernetes cluster add-on like cert-manager, istio, etc"
type ClusterAddOn {
  name: String
  version: String
  icon: String
  global: Boolean
  configuration: [AddOnConfiguration]
}

"Input configuration for an add-on you can install"
type AddOnConfiguration {
  "name for this configuration"
  name: String

  "a docstring explaining this configuration"
  documentation: String

  "a type for the configuration (should eventually be coerced back to string)"
  type: String

  "the values for ENUM type conditions"
  values: [String]

  condition: AddOnConfigCondition
}

"a condition that determines whether its configuration is viewable"
type AddOnConfigCondition {
  "the operation for this condition, eg EQ, LT, GT"
  operation: String

  "the field this condition applies to"
  field: String

  "the value to apply the condition with, for binary operators like LT\/GT"
  value: String
}

"a service encapsulating a controller like istio\/ingress-nginx\/etc that is meant to extend the kubernetes api"
type RuntimeService {
  id: ID!

  "add-on name"
  name: String!

  "add-on version, should be semver formatted"
  version: String!

  "the full specification of this kubernetes add-on"
  addon: RuntimeAddon

  "the version of the add-on you've currently deployed"
  addonVersion: AddonVersion

  "the plural service it came from"
  service: ServiceDeployment

  insertedAt: DateTime

  updatedAt: DateTime
}

"a full specification of a kubernetes runtime component's requirements"
type RuntimeAddon {
  "an icon to identify this runtime add-on"
  icon: String

  "the url to the add-ons git repository"
  gitUrl: String

  "the add-on's readme, this is a heavy operation that should not be performed w\/in lists"
  readme: String

  "the release page for a runtime service at a version, this is a heavy operation not suitable for lists"
  releaseUrl(version: String!): String

  versions: [AddonVersion]
}

"the specification of a runtime service at a specific version"
type AddonVersion {
  "add-on version, semver formatted"
  version: String

  "kubernetes versions this add-on works with"
  kube: [String]

  "any other add-ons this might require"
  requirements: [VersionReference]

  "any add-ons this might break"
  incompatibilities: [VersionReference]

  "the release page for a runtime service at a version, this is a heavy operation not suitable for lists"
  releaseUrl(version: String!): String

  "checks if this is blocking a specific kubernetes upgrade"
  blocking(kubeVersion: String!): Boolean
}

"a shortform reference to an addon by version"
type VersionReference {
  name: String!
  version: String!
}

"a representation of a bulk operation to be performed on all agent services"
type AgentMigration {
  id: ID!
  name: String
  ref: String
  configuration: Map
  completed: Boolean
  insertedAt: DateTime
  updatedAt: DateTime
}

type Tag {
  id: ID!
  name: String!
  value: String!
}

"a cluster info data struct"
type ClusterStatusInfo {
  healthy: Boolean
  count: Int
}

"A reference to a custom resource you want to be displayed in the k8s dashboard"
type PinnedCustomResource {
  id: ID!
  name: String!
  displayName: String!
  group: String!
  version: String!
  kind: String!
  namespaced: Boolean
  cluster: Cluster
}

type ClusterConnection {
  pageInfo: PageInfo!
  edges: [ClusterEdge]
}

type ClusterProviderConnection {
  pageInfo: PageInfo!
  edges: [ClusterProviderEdge]
}

type ClusterRevisionConnection {
  pageInfo: PageInfo!
  edges: [ClusterRevisionEdge]
}

type TagConnection {
  pageInfo: PageInfo!
  edges: [TagEdge]
}

enum AuthMethod {
  BASIC
  SSH
}

enum GitHealth {
  PULLABLE
  FAILED
}

enum ScmType {
  GITHUB
  GITLAB
}

enum MatchStrategy {
  ANY
  ALL
  RECURSIVE
}

enum PrRole {
  CLUSTER
  SERVICE
  PIPELINE
  UPDATE
  UPGRADE
}

enum PrStatus {
  OPEN
  MERGED
  CLOSED
}

enum ConfigurationType {
  STRING
  INT
  BOOL
  DOMAIN
  BUCKET
  FILE
  FUNCTION
  PASSWORD
}

enum Operation {
  NOT
  GT
  LT
  EQ
  GTE
  LTE
  PREFIX
  SUFFIX
}

input GitAttributes {
  "the url of this repository"
  url: String!

  "an ssh private key to use with this repo if an ssh url was given"
  privateKey: String

  "a passphrase to decrypt the given private key"
  passphrase: String

  "the http username for authenticated http repos, defaults to apiKey for github"
  username: String

  "the http password for http authenticated repos"
  password: String

  "a manually supplied https path for non standard git setups.  This is auto-inferred in many cases"
  httpsPath: String

  "similar to https_path, a manually supplied url format for custom git.  Should be something like {url}\/tree\/{ref}\/{folder}"
  urlFormat: String

  "whether to run plural crypto on this repo"
  decrypt: Boolean
}

"an object representing a means to authenticate to a source control provider like Github"
input ScmConnectionAttributes {
  name: String!

  type: ScmType!

  "the owning entity in this scm provider, eg a github organization"
  owner: String

  username: String

  token: String

  baseUrl: String

  apiUrl: String

  "a ssh private key to be used for commit signing"
  signingPrivateKey: String
}

"A way to create a self-service means of generating PRs against an IaC repo"
input PrAutomationAttributes {
  name: String

  role: PrRole

  "string id for a repository, eg for github, this is {organization}\/{repository-name}"
  identifier: String

  documentation: String

  title: String

  message: String

  branch: String

  updates: PrAutomationUpdateSpecAttributes

  creates: PrAutomationCreateSpecAttributes

  "link to an add-on name if this can update it"
  addon: String

  "link to a cluster if this is to perform an upgrade"
  clusterId: ID

  "link to a service if this can modify its configuration"
  serviceId: ID

  "the scm connection to use for pr generation"
  connectionId: ID

  "a git repository to use for create mode prs"
  repositoryId: ID

  configuration: [PrConfigurationAttributes]

  "users who can update this automation"
  writeBindings: [PolicyBindingAttributes]

  "users who can create prs with this automation"
  createBindings: [PolicyBindingAttributes]
}

"the a configuration item for creating a new pr"
input PrConfigurationAttributes {
  type: ConfigurationType!
  name: String!
  default: String
  documentation: String
  longform: String
  placeholder: String
  optional: Boolean
  condition: ConditionAttributes
}

"attributes for declaratively specifying whether a config item is relevant given prior config"
input ConditionAttributes {
  operation: Operation!
  field: String!
  value: String
}

"The operations to be performed on the files w\/in the pr"
input PrAutomationUpdateSpecAttributes {
  regexes: [String]

  "list of regex scope replacement templates, useful for ANY strategies"
  regexReplacements: [RegexReplacementAttributes]

  files: [String]

  replaceTemplate: String

  yq: String

  matchStrategy: MatchStrategy
}

"Operations to create new templated files within this pr"
input PrAutomationCreateSpecAttributes {
  git: GitRefAttributes
  templates: [PrAutomationTemplateAttributes]
}

"a fully specify regex\/replace flow"
input RegexReplacementAttributes {
  regex: String!

  replacement: String!

  "the filename to apply this regex on"
  file: String!

  "whether you want to apply liquid templating on the regex before compiling"
  templated: Boolean
}

"templates to apply in this pr"
input PrAutomationTemplateAttributes {
  source: String!

  destination: String!

  "whether the source template is sourced from an external git repo bound to this automation"
  external: Boolean!
}

"attributes for a pull request pointer record"
input PullRequestAttributes {
  url: String!
  title: String!
  creator: String
  labels: [String]
  serviceId: ID
  clusterId: ID
  service: NamespacedName
  cluster: NamespacedName
}

"The attributes to configure a new webhook for a SCM provider"
input ScmWebhookAttributes {
  "the secret token for authenticating this webhook via hmac signature"
  hmac: String!

  "the type of webhook to create"
  type: ScmType!

  "the owner for this webhook in your SCM, eg a github org or gitlab group"
  owner: String!
}

"a git repository available for deployments"
type GitRepository {
  "internal id of this repository"
  id: ID!

  "the git url of the repository, either https or ssh supported"
  url: String!

  "whether its a http or ssh url"
  authMethod: AuthMethod

  "whether we can currently pull this repo with the provided credentials"
  health: GitHealth

  "the last successsful git pull timestamp"
  pulledAt: DateTime

  "the error message if there were any pull errors"
  error: String

  "the https url for this git repo"
  httpsPath: String

  "a format string to get the http url for a subfolder in a git repo"
  urlFormat: String

  "whether to run plural crypto unlock on this repo"
  decrypt: Boolean

  "named refs like branches\/tags for a repository"
  refs: [String!]

  "whether the current user can edit this repo"
  editable: Boolean

  insertedAt: DateTime

  updatedAt: DateTime
}

"a crd representation of a helm repository"
type HelmRepository {
  metadata: Metadata!

  spec: HelmRepositorySpec!

  "the charts found in this repository (heavy operation, don't do in list endpoints)"
  charts: [HelmChartEntry]

  "can fetch the status of a given helm repository"
  status: HelmRepositoryStatus
}

"a specification of how a helm repository is fetched"
type HelmRepositorySpec {
  provider: String
  url: String!
  type: String
}

"the state of this helm repository"
type HelmRepositoryStatus {
  ready: Boolean
  message: String
}

"a chart manifest entry, including all versions"
type HelmChartEntry {
  "the name of the chart"
  name: String

  "all found versions of the chart"
  versions: [HelmChartVersion]
}

"a chart version contained within a helm repository manifest"
type HelmChartVersion {
  "the version of the app contained w\/in this chart"
  appVersion: String

  "the version of the chart itself"
  version: String

  "the name of the chart"
  name: String

  type: String

  "sha digest of this chart's contents"
  digest: String
}

"an object representing the means to connect to SCM apis"
type ScmConnection {
  id: ID!

  name: String!

  type: ScmType!

  username: String

  "base url for git clones for self-hosted versions"
  baseUrl: String

  "base url for HTTP apis for self-hosted versions if different from base url"
  apiUrl: String

  insertedAt: DateTime

  updatedAt: DateTime
}

"a description of how to generate a pr, which can either modify existing files or generate new ones w\/in a repo"
type PrAutomation {
  id: ID!

  "string id for a repository, eg for github, this is {organization}\/{repository-name}"
  identifier: String!

  "the name for this automation"
  name: String!

  "An enum describing the high-level responsibility of this pr, eg creating a cluster or service, or upgrading a cluster"
  role: PrRole

  documentation: String

  title: String!

  message: String!

  updates: PrUpdateSpec

  creates: PrCreateSpec

  configuration: [PrConfiguration]

  "write policy for this pr automation, also propagates to the notifications list for any created PRs"
  writeBindings: [PolicyBinding]

  "users who can generate prs with this automation"
  createBindings: [PolicyBinding]

  "link to an add-on name if this can update it"
  addon: String

  "the git repository to use for sourcing external templates"
  repository: GitRepository

  "link to a cluster if this is to perform an upgrade"
  cluster: Cluster

  "link to a service if this can update its configuration"
  service: ServiceDeployment

  "the scm connection to use for pr generation"
  connection: ScmConnection

  insertedAt: DateTime

  updatedAt: DateTime
}

"existing file updates that can be performed in a PR"
type PrUpdateSpec {
  regexes: [String]
  regexReplacements: [RegexReplacement]
  files: [String]
  replaceTemplate: String
  yq: String
  matchStrategy: MatchStrategy
}

"templated files used to add new files to a given pr"
type PrCreateSpec {
  "pointer within an external git repository to source templates from"
  git: GitRef

  templates: [PrTemplateSpec]
}

"the details of where to find and place a templated file"
type PrTemplateSpec {
  source: String!
  destination: String!
  external: Boolean!
}

"a fully specified regex\/replace flow"
type RegexReplacement {
  regex: String!

  "the file to apply this replacement on"
  file: String!

  "template string to replace any match with"
  replacement: String!

  "Whether to apply liquid templating before compiling this regex"
  templated: Boolean
}

"the a configuration item for creating a new pr, used for templating the ultimate code changes made"
type PrConfiguration {
  type: ConfigurationType!
  name: String!
  default: String
  documentation: String
  longform: String
  placeholder: String
  optional: Boolean
  condition: PrConfigurationCondition
}

"declaritive spec for whether a config item is relevant given prior config"
type PrConfigurationCondition {
  "a boolean operation to apply"
  operation: Operation!

  "the prior field to check"
  field: String!

  "a fixed value to check against if its a binary operation"
  value: String
}

"A reference to a pull request for your kubernetes related IaC"
type PullRequest {
  id: ID!

  status: PrStatus

  url: String!

  title: String

  creator: String

  labels: [String]

  "the cluster this pr is meant to modify"
  cluster: Cluster

  "the service this pr is meant to modify"
  service: ServiceDeployment

  insertedAt: DateTime

  updatedAt: DateTime
}

type ScmWebhook {
  id: ID!

  type: ScmType!

  owner: String!

  "the url for this specific webhook"
  url: String!

  "the name in your SCM provider for this webhook"
  name: String!

  insertedAt: DateTime

  updatedAt: DateTime
}

"A representation to a service which configures renovate for a scm connection"
type DependencyManagementService {
  id: ID!
  connection: ScmConnection
  service: ServiceDeployment
  insertedAt: DateTime
  updatedAt: DateTime
}

type GitRepositoryConnection {
  pageInfo: PageInfo!
  edges: [GitRepositoryEdge]
}

type ScmConnectionConnection {
  pageInfo: PageInfo!
  edges: [ScmConnectionEdge]
}

type PrAutomationConnection {
  pageInfo: PageInfo!
  edges: [PrAutomationEdge]
}

type PullRequestConnection {
  pageInfo: PageInfo!
  edges: [PullRequestEdge]
}

type ScmWebhookConnection {
  pageInfo: PageInfo!
  edges: [ScmWebhookEdge]
}

type DependencyManagementServiceConnection {
  pageInfo: PageInfo!
  edges: [DependencyManagementServiceEdge]
}

input CloneAttributes {
  s3AccessKeyId: String
  s3SecretAccessKey: String
  s3WalPath: String
  s3Endpoint: String
  uid: String
}

type Postgresql {
  metadata: Metadata!
  spec: PostgresqlSpec!
  status: PostgresqlStatus
  instances: [PostgresInstance]
}

type PostgresqlSpec {
  teamId: String
  users: Map
  resources: Resources
  postgresql: PostgresSettings
  numberOfInstances: Int
  databases: Map
  volume: DatabaseVolume
  pods: [Pod]
}

type DatabaseVolume {
  size: String
}

type PostgresSettings {
  version: String
}

type PostgresInstance {
  uid: String!
}

type PostgresqlStatus {
  clusterStatus: String
}

enum WebhookType {
  PIAZZA
  SLACK
}

enum WebhookHealth {
  HEALTHY
  UNHEALTHY
}

input WebhookAttributes {
  url: String!
}

type Webhook {
  id: ID!
  url: String!
  health: WebhookHealth!
  type: WebhookType!
  insertedAt: DateTime
  updatedAt: DateTime
}

type WebhookConnection {
  pageInfo: PageInfo!
  edges: [WebhookEdge]
}

input RunbookActionInput {
  action: String!
  context: Map!
}

input RunbookContext {
  timeseriesStart: Int
  timeseriesStep: String
}

type Runbook {
  name: String!
  spec: RunbookSpec!
  status: RunbookStatus
  data(context: RunbookContext): [RunbookData]
  executions(after: String, first: Int, before: String, last: Int): RunbookExecutionConnection
}

type RunbookExecution {
  id: ID!
  name: String!
  namespace: String!
  context: Map!
  user: User
  insertedAt: DateTime
  updatedAt: DateTime
}

type RunbookStatus {
  alerts: [RunbookAlertStatus]
}

type RunbookAlertStatus {
  name: String!
  startsAt: String
  fingerprint: String
  annotations: Map
  labels: Map
}

type RunbookSpec {
  name: String!
  description: String
  display: Map
  datasources: [RunbookDatasource]
  actions: [RunbookAction]
}

type RunbookAction {
  name: String!
  type: String!
  configuration: ConfigurationAction
}

type RunbookDatasource {
  name: String!
  type: String!
  prometheus: PrometheusDatasource
  kubernetes: KubernetesDatasource
}

type PrometheusDatasource {
  query: String!
  format: String
  legend: String
}

type KubernetesDatasource {
  resource: String!
  name: String!
}

type RunbookData {
  name: String!
  source: RunbookDatasource
  kubernetes: KubernetesData
  prometheus: [MetricResponse]
  nodes: [Node]
}

"supported kubernetes objects fetchable in runbooks"
union KubernetesData = Deployment | StatefulSet

type ConfigurationAction {
  updates: [PathUpdate]
}

type PathUpdate {
  path: [String]
  valueFrom: String!
}

type RunbookActionResponse {
  redirectTo: String
}

type RunbookExecutionConnection {
  pageInfo: PageInfo!
  edges: [RunbookExecutionEdge]
}

enum UpgradePolicyType {
  DEPLOY
  APPROVAL
  IGNORE
}

input UpgradePolicyAttributes {
  name: String!
  description: String
  target: String!
  type: UpgradePolicyType!
  repositories: [String]
  weight: Int
}

type UpgradePolicy {
  id: ID!
  name: String!
  description: String
  repositories: [String]
  type: UpgradePolicyType!
  target: String!
  weight: Int
  insertedAt: DateTime
  updatedAt: DateTime
}

input SmtpInput {
  server: String
  port: Int
  password: String
  sender: String
  user: String
}

input ContextAttributes {
  buckets: [String]
  domain: [String]
  configuration: Map!
  protect: [String]
}

type Smtp {
  server: String
  port: Int
  password: String
  sender: String
  user: String
}

type Installation {
  id: ID!
  repository: Repository
}

type Repository {
  id: ID!
  name: String!
  description: String
  icon: String
  docs: [FileContent]
  configuration: Configuration
  grafanaDns: String
}

type FileContent {
  path: String
  content: String
}

type Recipe {
  id: ID!
  name: String!
  description: String
  provider: String
  restricted: Boolean
  recipeSections: [RecipeSection]
  oidcEnabled: Boolean
}

type RecipeSection {
  id: ID!
  repository: Repository
  recipeItems: [RecipeItem]
  configuration: [ConfigurationItem]
}

type RecipeItem {
  id: ID!
  configuration: [ConfigurationItem]
}

type ConfigurationItem {
  name: String
  type: String
  placeholder: String
  documentation: String
  default: String
  optional: Boolean
  condition: ConfigurationCondition
  validation: ConfigurationValidation
}

type ConfigurationValidation {
  type: String
  regex: String
  message: String
}

type ConfigurationCondition {
  field: String
  value: String
  operation: String
}

type Stack {
  id: ID!
  name: String!
  bundles: [Recipe]
  sections: [RecipeSection]
  insertedAt: DateTime
  updatedAt: DateTime
}

type RepositoryContext {
  repository: String!
  context: Map
}

type PluralContext {
  buckets: [String]
  domains: [String]
  configuration: Map!
}

type Account {
  delinquentAt: DateTime
  grandfatheredUntil: DateTime
  availableFeatures: AvailableFeatures
  subscription: PluralSubscription
}

type PluralSubscription {
  id: ID
  plan: Plan
}

type Plan {
  id: ID
  name: String
  period: String
}

type InstallationConnection {
  pageInfo: PageInfo!
  edges: [InstallationEdge]
}

type RepositoryConnection {
  pageInfo: PageInfo!
  edges: [RepositoryEdge]
}

type RecipeConnection {
  pageInfo: PageInfo!
  edges: [RecipeEdge]
}

enum AuditType {
  BUILD
  POD
  CONFIGURATION
  USER
  GROUP
  ROLE
  GROUP_MEMBER
  POLICY
  TEMP_TOKEN
  SERVICE
  CLUSTER
  CLUSTER_PROVIDER
  GIT_REPOSITORY
  DEPLOYMENT_SETTINGS
  PROVIDER_CREDENTIAL
  PIPELINE
  GLOBAL
  OBJECT_STORE
  CLUSTER_RESTORE
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
  APPROVE
  CANCEL
}

type Audit {
  id: ID!
  action: AuditAction!
  type: AuditType!
  repository: String
  ip: String
  city: String
  country: String
  latitude: String
  longitude: String
  actor: User
  insertedAt: DateTime
  updatedAt: DateTime
}

type AuditMetric {
  country: String
  count: Int
}

type AuditConnection {
  pageInfo: PageInfo!
  edges: [AuditEdge]
}

enum AutoscalingTarget {
  STATEFULSET
  DEPLOYMENT
}

input LabelInput {
  name: String
  value: String
}

type Dashboard {
  id: String!
  spec: DashboardSpec!
}

type DashboardSpec {
  name: String
  description: String
  timeslices: [String]
  labels: [DashboardLabel]
  graphs: [DashboardGraph]
}

type DashboardLabel {
  name: String!
  values: [String]
}

type DashboardGraph {
  name: String!
  queries: [DashboardMetric]
  format: String
}

type DashboardMetric {
  legend: String
  query: String
  results: [MetricResult]
}

type MetricResponse {
  metric: Map
  values: [MetricResult]
}

type Metadata {
  labels: [LabelPair]
  annotations: [LabelPair]
  name: String!
  namespace: String
  creationTimestamp: String
  uid: String
}

type SecretKeySelector {
  name: String!
  key: String
}

type ClusterInfo {
  gitCommit: String
  gitVersion: String
  platform: String
  version: String
}

type LabelPair {
  name: String
  value: String
}

type ResourceSpec {
  cpu: String
  memory: String
}

type KubernetesUnstructured {
  raw: Map
  metadata: Metadata!
  events: [Event]
}

type ApplicationDelta {
  delta: Delta
  payload: Application
}

type PluralCluster {
  status: PluralObjectStatus!
  metadata: Metadata!
  reference: Cluster
  raw: String!
  events: [Event]
}

type PluralServiceDeployment {
  status: PluralObjectStatus!
  metadata: Metadata!
  reference: ServiceDeployment
  raw: String!
  events: [Event]
}

type PluralGitRepository {
  status: PluralObjectStatus!
  metadata: Metadata!
  reference: GitRepository
  raw: String!
  events: [Event]
}

type PluralObjectStatus {
  id: String
  conditions: [StatusCondition]
}

type DaemonSet {
  metadata: Metadata!
  status: DaemonSetStatus!
  spec: DaemonSetSpec!
  pods: [Pod]
  raw: String!
  events: [Event]
}

type DaemonSetStatus {
  currentNumberScheduled: Int
  desiredNumberScheduled: Int
  numberReady: Int
}

type DaemonSetSpec {
  strategy: DeploymentStrategy
}

type UpgradePlan {
  metadata: Metadata!
  status: UpgradePlanStatus!
  spec: UpgradePlanSpec!
  pods: [Pod]
  raw: String!
  events: [Event]
}

type UpgradePlanStatus {
  conditions: [StatusCondition]
}

type UpgradePlanSpec {
  version: String
  cordon: Boolean
  concurrency: Int
}

type Canary {
  metadata: Metadata!
  status: CanaryStatus!
  spec: CanarySpec!
  primaryDeployment: Deployment
  canaryDeployment: Deployment
  ingress: Ingress
  ingressCanary: Ingress
  raw: String!
  events: [Event]
}

type CanaryStatus {
  conditions: [StatusCondition]
  failedChecks: Int
  canaryWeight: Int
  iterations: Int
  lastTransitionTime: String
  phase: String
}

type CanarySpec {
  autoscalerRef: TargetRef
  targetRef: TargetRef
  ingressRef: TargetRef
  analysis: CanaryAnalysis
  provider: String
}

type CanaryAnalysis {
  interval: String
  maxWeight: Int
  stepWeight: Int
  stepWeights: [Int]
  threshold: Int
}

type TargetRef {
  apiVersion: String
  kind: String
  name: String
}

type ConfigMap {
  metadata: Metadata!
  data: Map!
  raw: String!
}

type Secret {
  metadata: Metadata!
  type: String
  data: Map!
}

type WireguardPeer {
  metadata: Metadata!
  status: WireguardPeerStatus
  spec: WireguardPeerSpec!
  config: String
  user: User
  raw: String!
}

type WireguardPeerStatus {
  ready: Boolean
  conditions: [StatusCondition]
}

type WireguardPeerSpec {
  wireguardRef: String
  address: String
  publicKey: String
}

type Namespace {
  status: NamespaceStatus!
  spec: NamespaceSpec!
  metadata: Metadata!
  raw: String!
  events: [Event]
}

type NamespaceSpec {
  finalizers: [String]
}

type NamespaceStatus {
  phase: String
}

type VerticalPodAutoscaler {
  metadata: Metadata!
  spec: VerticalPodAutoscalerSpec!
  status: VerticalPodAutoscalerStatus
}

type CrossVersionResourceTarget {
  apiVersion: String
  kind: String
  name: String
}

type VerticalPodAutoscalerUpdatePolicy {
  updateMode: String
}

type VerticalPodAutoscalerSpec {
  targetRef: CrossVersionResourceTarget!
  updatePolicy: VerticalPodAutoscalerUpdatePolicy!
}

type VerticalPodAutoscalerStatus {
  recommendation: Recommendation
}

type Recommendation {
  containerRecommendations: [ContainerRecommendation]
}

type ContainerResources {
  cpu: String
  memory: String
}

type ContainerRecommendation {
  name: String
  containerName: String
  target: ContainerResources
  lowerBound: ContainerResources
  upperBound: ContainerResources
  uncappedTarget: ContainerResources
}

type ConfigurationOverlay {
  metadata: Metadata!
  spec: ConfigurationOverlaySpec!
}

type OverlayUpdate {
  path: [String]
}

type ConfigurationOverlaySpec {
  name: String
  folder: String
  subfolder: String
  documentation: String
  updates: [OverlayUpdate]
  inputType: String
  inputValues: [String]
}

type Certificate {
  metadata: Metadata!
  status: CertificateStatus!
  spec: CertificateSpec!
  raw: String!
  events: [Event]
}

type CertificateStatus {
  conditions: [StatusCondition]
  notAfter: String
  notBefore: String
  renewalTime: String
}

type CertificateSpec {
  dnsNames: [String]
  secretName: String!
  issuerRef: IssuerRef
}

type IssuerRef {
  group: String
  kind: String
  name: String
}

type Job {
  metadata: Metadata!
  status: JobStatus!
  spec: JobSpec!
  raw: String!
  events: [Event]
  pods: [Pod]
  logs(container: String!, sinceSeconds: Int!): [String]
}

type JobStatus {
  active: Int
  completionTime: String
  startTime: String
  succeeded: Int
  failed: Int
}

type JobSpec {
  backoffLimit: Int
  parallelism: Int
  activeDeadlineSeconds: Int
}

type LogFilter {
  metadata: Metadata!
  spec: LogFilterSpec!
}

type LogFilterSpec {
  name: String
  description: String
  query: String
  labels: [LogLabel]
}

type CronJob {
  metadata: Metadata!
  status: CronStatus!
  spec: CronSpec!
  raw: String!
  events: [Event]
  jobs: [Job]
}

type CronStatus {
  active: [JobReference]
  lastScheduleTime: String
}

type JobReference {
  name: String!
  namespace: String!
}

type CronSpec {
  schedule: String!
  suspend: Boolean
  concurrencyPolicy: String
}

type Node {
  status: NodeStatus!
  spec: NodeSpec!
  metadata: Metadata!
  raw: String!
  pods: [Pod]
  events: [Event]
}

type NodeStatus {
  allocatable: Map
  capacity: Map
  phase: String
  conditions: [NodeCondition]
}

type NodeCondition {
  message: String
  reason: String
  status: String
  type: String
}

type NodeSpec {
  podCidr: String
  providerId: String
  unschedulable: Boolean
}

type NodeUsage {
  cpu: String
  memory: String
}

type NodeMetric {
  metadata: Metadata!
  timestamp: String
  window: String
  usage: NodeUsage
}

type Ingress {
  metadata: Metadata!
  status: ServiceStatus!
  spec: IngressSpec!
  certificates: [Certificate]
  raw: String!
  events: [Event]
}

type IngressSpec {
  ingressClassName: String
  rules: [IngressRule]
  tls: [IngressTls]
}

type IngressRule {
  host: String
  http: HttpIngressRule
}

type HttpIngressRule {
  paths: [IngressPath]
}

type IngressPath {
  backend: IngressBackend
  path: String
}

type IngressBackend {
  serviceName: String
  servicePort: String
}

type IngressTls {
  hosts: [String]
}

type Service {
  metadata: Metadata!
  status: ServiceStatus!
  spec: ServiceSpec!
  pods: [Pod]
  raw: String!
  events: [Event]
}

type ServiceStatus {
  loadBalancer: LoadBalancerStatus
}

type LoadBalancerStatus {
  ingress: [LoadBalancerIngressStatus]
}

type LoadBalancerIngressStatus {
  hostname: String
  ip: String
}

type ServiceSpec {
  type: String
  clusterIp: String
  selector: Map
  ports: [ServicePort]
}

type ServicePort {
  name: String
  protocol: String
  port: Int
  targetPort: String
}

type StatefulSet {
  metadata: Metadata!
  status: StatefulSetStatus!
  spec: StatefulSetSpec!
  pods: [Pod]
  raw: String!
  events: [Event]
}

type StatefulSetStatus {
  currentReplicas: Int
  replicas: Int
  readyReplicas: Int
  updatedReplicas: Int
}

type StatefulSetSpec {
  replicas: Int
  serviceName: String
}

type Deployment {
  metadata: Metadata!
  status: DeploymentStatus!
  spec: DeploymentSpec!
  pods: [Pod]
  raw: String!
  events: [Event]
}

type ReplicaSet {
  metadata: Metadata!
  spec: ReplicaSetSpec!
  status: ReplicaSetStatus!
  pods: [Pod]
  raw: String!
}

type DeploymentStatus {
  availableReplicas: Int
  replicas: Int
  readyReplicas: Int
  unavailableReplicas: Int
}

type DeploymentSpec {
  replicas: Int
  strategy: DeploymentStrategy
}

type ReplicaSetSpec {
  replicas: Int
}

type DeploymentStrategy {
  type: String
  rollingUpdate: RollingUpdate
}

type RollingUpdate {
  maxSurge: Int
  maxUnavailable: Int
}

type ReplicaSetStatus {
  availableReplicas: Int
  conditions: [StatusCondition]
  replicas: Int
  readyReplicas: Int
  fullyLabeledReplicas: Int
}

type Pod {
  status: PodStatus!
  spec: PodSpec!
  metadata: Metadata!
  raw: String!
  logs(container: String!, sinceSeconds: Int!): [String]
  events: [Event]
}

type PodStatus {
  message: String
  phase: String
  hostIp: String
  podIp: String
  reason: String
  conditions: [PodCondition]
  containerStatuses: [ContainerStatus]
  initContainerStatuses: [ContainerStatus]
}

type PodCondition {
  lastProbeTime: String
  lastTransitionTime: String
  message: String
  reason: String
  status: String
  type: String
}

type ContainerStatus {
  restartCount: Int
  ready: Boolean
  name: String
  image: String
  state: ContainerState
}

type ContainerState {
  running: RunningState
  terminated: TerminatedState
  waiting: WaitingState
}

type RunningState {
  startedAt: String
}

type TerminatedState {
  exitCode: Int
  finishedAt: String
  startedAt: String
  message: String
  reason: String
}

type WaitingState {
  message: String
  reason: String
}

type PodSpec {
  serviceAccountName: String
  nodeName: String
  containers: [Container]
  initContainers: [Container]
}

type Container {
  image: String
  name: String
  ports: [Port]
  resources: Resources
}

type Port {
  hostPort: Int
  containerPort: Int
  protocol: String
}

type Resources {
  limits: ResourceSpec
  requests: ResourceSpec
}

type PodConnection {
  pageInfo: PageInfo!
  edges: [PodEdge]
}

type PodDelta {
  delta: Delta
  payload: Pod
}

type Application {
  name: String!
  spec: ApplicationSpec!
  status: ApplicationStatus!
  cost: CostAnalysis
  license: License
  configuration: Configuration
  info: String
}

type CostAnalysis {
  minutes: Float
  cpuCost: Float
  cpuEfficiency: Float
  efficiency: Float
  gpuCost: Float
  networkCost: Float
  pvCost: Float
  ramCost: Float
  ramEfficiency: Float
  totalCost: Float
  sharedCost: Float
}

type ApplicationSpec {
  descriptor: ApplicationDescriptor!
  components: [Component]
  info: [ApplicationInfoItem]
}

type ApplicationLink {
  url: String
  description: String
}

type ApplicationInfoItem {
  type: String
  name: String
  value: String
}

type ApplicationDescriptor {
  type: String!
  version: String!
  description: String
  icons: [String]
  links: [ApplicationLink]
}

type Component {
  group: String!
  kind: String!
}

type ApplicationStatus {
  components: [StatusComponent]
  conditions: [StatusCondition]
  componentsReady: String!
}

type StatusComponent {
  group: String
  kind: String!
  name: String!
  status: String!
}

type StatusCondition {
  message: String!
  reason: String!
  status: String!
  type: String!
}

type License {
  metadata: Metadata!
  spec: LicenseSpec!
  status: LicenseStatus
}

type LicenseSpec {
  secretRef: SecretKeySelector!
}

type LicenseStatus {
  plan: String
  free: Boolean
  features: [LicenseFeature]
  limits: Map
  secrets: Map
}

type LicenseFeature {
  name: String!
  description: String
}

type Event {
  action: String
  count: Int
  eventTime: String
  lastTimestamp: String
  message: String
  reason: String
  type: String
}

enum Permission {
  READ
  CONFIGURE
  DEPLOY
  OPERATE
}

enum Severity {
  NONE
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum NotificationStatus {
  FIRING
  RESOLVED
}

enum ReadType {
  NOTIFICATION
  BUILD
}

input UserAttributes {
  name: String
  email: String
  password: String
  roles: UserRoleAttributes
  signingPrivateKey: String
}

input ServiceAccountAttributes {
  name: String
  email: String
  roles: UserRoleAttributes
  assumeBindings: [PolicyBindingAttributes]
}

input UserRoleAttributes {
  admin: Boolean
}

input InviteAttributes {
  email: String
}

input ScopeAttributes {
  api: String
  apis: [String!]
  identifier: String
  ids: [String!]
}

input GroupAttributes {
  name: String!
  description: String
}

input RoleAttributes {
  name: String
  description: String
  repositories: [String]
  roleBindings: [BindingAttributes]
  permissions: [Permission]
}

input BindingAttributes {
  id: ID
  userId: ID
  groupId: ID
}

input PersonaAttributes {
  name: String

  "longform description of this persona"
  description: String

  configuration: PersonaConfigurationAttributes

  bindings: [BindingAttributes]
}

input PersonaConfigurationAttributes {
  "enable full ui for this persona"
  all: Boolean

  "enable individual parts of the deployments views"
  deployments: PersonaDeploymentAttributes

  "enable individual aspects of the sidebar"
  sidebar: PersonaSidebarAttributes
}

input PersonaDeploymentAttributes {
  clusters: Boolean
  deployments: Boolean
  repositories: Boolean
  services: Boolean
  pipelines: Boolean
  providers: Boolean
  addOns: Boolean
}

input PersonaSidebarAttributes {
  audits: Boolean
  kubernetes: Boolean
  pullRequests: Boolean
  settings: Boolean
  backups: Boolean
  stacks: Boolean
}

type User {
  id: ID!
  name: String!
  email: String!
  deletedAt: DateTime
  profile: String
  pluralId: String
  roles: UserRoles
  readTimestamp: DateTime
  buildTimestamp: DateTime
  refreshToken: RefreshToken
  assumeBindings: [PolicyBinding]
  groups: [Group]
  personas: [Persona]
  boundRoles: [Role]
  jwt: String
  unreadNotifications: Int
  backgroundColor: String
  insertedAt: DateTime
  updatedAt: DateTime
}

type RefreshToken {
  id: ID!

  "the token to use to request a refresh"
  token: String!

  insertedAt: DateTime

  updatedAt: DateTime
}

type UserRoles {
  admin: Boolean
}

type Invite {
  secureId: String!
  email: String
}

type Group {
  id: ID!
  name: String!
  description: String
  insertedAt: DateTime
  updatedAt: DateTime
}

type GroupMember {
  id: ID!
  user: User
  group: Group
  insertedAt: DateTime
  updatedAt: DateTime
}

type Role {
  id: ID!
  name: String!
  description: String
  repositories: [String]
  permissions: [Permission]
  roleBindings: [RoleBinding]
  insertedAt: DateTime
  updatedAt: DateTime
}

type RoleBinding {
  id: ID!
  user: User
  group: Group
  insertedAt: DateTime
  updatedAt: DateTime
}

type LoginInfo {
  oidcUri: String
  external: Boolean
  oidcName: String
}

type Notification {
  id: ID!
  title: String!
  description: String
  fingerprint: String!
  status: NotificationStatus
  labels: Map
  annotations: Map
  repository: String!
  seenAt: DateTime
  severity: Severity
  insertedAt: DateTime
  updatedAt: DateTime
}

type AccessToken {
  id: ID
  token: String
  scopes: [AccessTokenScope]
  audits(after: String, first: Int, before: String, last: Int): AccessTokenAuditConnection
  insertedAt: DateTime
  updatedAt: DateTime
}

type AccessTokenScope {
  api: String
  apis: [String!]
  identifier: String
  ids: [String!]
}

type AccessTokenAudit {
  id: ID
  ip: String
  timestamp: DateTime
  count: Int
  city: String
  country: String
  latitude: String
  longitude: String
  insertedAt: DateTime
  updatedAt: DateTime
}

type Persona {
  id: ID!

  "the name for this persona"
  name: String!

  "longform description of this persona"
  description: String

  "the ui configuration for this persona (additive across personas)"
  configuration: PersonaConfiguration

  "the group bindings for this persona"
  bindings: [PolicyBinding]

  insertedAt: DateTime

  updatedAt: DateTime
}

type PersonaConfiguration {
  "enable full ui for this persona"
  all: Boolean

  "enable individual parts of the deployments views"
  deployments: PersonaDeployment

  "enable individual aspects of the sidebar"
  sidebar: PersonaSidebar
}

type PersonaDeployment {
  clusters: Boolean
  deployments: Boolean
  repositories: Boolean
  services: Boolean
  pipelines: Boolean
  providers: Boolean
  addOns: Boolean
}

type PersonaSidebar {
  audits: Boolean
  kubernetes: Boolean
  pullRequests: Boolean
  settings: Boolean
  backups: Boolean
  stacks: Boolean
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]
}

type GroupConnection {
  pageInfo: PageInfo!
  edges: [GroupEdge]
}

type GroupMemberConnection {
  pageInfo: PageInfo!
  edges: [GroupMemberEdge]
}

type RoleConnection {
  pageInfo: PageInfo!
  edges: [RoleEdge]
}

type NotificationConnection {
  pageInfo: PageInfo!
  edges: [NotificationEdge]
}

type AccessTokenConnection {
  pageInfo: PageInfo!
  edges: [AccessTokenEdge]
}

type AccessTokenAuditConnection {
  pageInfo: PageInfo!
  edges: [AccessTokenAuditEdge]
}

type PersonaConnection {
  pageInfo: PageInfo!
  edges: [PersonaEdge]
}

type RefreshTokenConnection {
  pageInfo: PageInfo!
  edges: [RefreshTokenEdge]
}

type NotificationDelta {
  delta: Delta
  payload: Notification
}

type Configuration {
  terraform: String
  helm: String
  readme: String
}

type LogLabel {
  name: String
  value: String
}

type PluralManifest {
  network: ManifestNetwork
  bucketPrefix: String
  cluster: String
}

type ManifestNetwork {
  pluralDns: Boolean
  subdomain: String
}

type GitStatus {
  cloned: Boolean
  output: String
}

type AvailableFeatures {
  vpn: Boolean
  audits: Boolean
  cd: Boolean
  userManagement: Boolean
  databaseManagement: Boolean
}

type ConsoleConfiguration {
  gitCommit: String
  isDemoProject: Boolean
  isSandbox: Boolean
  pluralLogin: Boolean
  vpnEnabled: Boolean
  byok: Boolean
  externalOidc: Boolean
  oidcName: String
  features: AvailableFeatures
  manifest: PluralManifest
  gitStatus: GitStatus
}

enum Status {
  QUEUED
  RUNNING
  SUCCESSFUL
  FAILED
  CANCELLED
  PENDING
}

enum BuildType {
  DEPLOY
  BOUNCE
  APPROVAL
  INSTALL
  DESTROY
  DEDICATED
  CONFIG
}

enum Tool {
  HELM
  TERRAFORM
}

input BuildAttributes {
  repository: String!
  type: BuildType
  message: String
}

type Build {
  id: ID!
  repository: String!
  type: BuildType!
  status: Status!
  message: String
  completedAt: DateTime
  sha: String
  commands(after: String, first: Int, before: String, last: Int): CommandConnection
  creator: User
  approver: User
  changelogs: [Changelog]
  insertedAt: DateTime
  updatedAt: DateTime
}

type Changelog {
  id: ID!
  repo: String!
  tool: String!
  content: String
  insertedAt: DateTime
  updatedAt: DateTime
}

type Command {
  id: ID!
  command: String!
  exitCode: Int
  stdout: String
  completedAt: DateTime
  build: Build
  insertedAt: DateTime
  updatedAt: DateTime
}

type BuildInfo {
  all: Int
  failed: Int
  queued: Int
  running: Int
  successful: Int
}

type BuildDelta {
  delta: Delta
  payload: Build
}

type CommandDelta {
  delta: Delta
  payload: Command
}

type BuildConnection {
  pageInfo: PageInfo!
  edges: [BuildEdge]
}

type CommandConnection {
  pageInfo: PageInfo!
  edges: [CommandEdge]
}

enum Delta {
  CREATE
  UPDATE
  DELETE
}

type MetricResult {
  timestamp: Long
  value: String
}

type LogStream {
  stream: Map
  values: [MetricResult]
}

scalar Map

scalar Json

scalar Long

"""
The `DateTime` scalar type represents a date and time in the UTC
timezone. The DateTime appears in a JSON response as an ISO8601 formatted
string, including UTC timezone ("Z"). The parsed date and time string will
be converted to UTC if there is an offset.
"""
scalar DateTime

type PageInfo {
  "When paginating backwards, are there more items?"
  hasPreviousPage: Boolean!

  "When paginating forwards, are there more items?"
  hasNextPage: Boolean!

  "When paginating backwards, the cursor to continue."
  startCursor: String

  "When paginating forwards, the cursor to continue."
  endCursor: String
}

type CommandEdge {
  node: Command
  cursor: String
}

type BuildEdge {
  node: Build
  cursor: String
}

type RefreshTokenEdge {
  node: RefreshToken
  cursor: String
}

type PersonaEdge {
  node: Persona
  cursor: String
}

type AccessTokenAuditEdge {
  node: AccessTokenAudit
  cursor: String
}

type AccessTokenEdge {
  node: AccessToken
  cursor: String
}

type NotificationEdge {
  node: Notification
  cursor: String
}

type RoleEdge {
  node: Role
  cursor: String
}

type GroupMemberEdge {
  node: GroupMember
  cursor: String
}

type GroupEdge {
  node: Group
  cursor: String
}

type UserEdge {
  node: User
  cursor: String
}

type PodEdge {
  node: Pod
  cursor: String
}

type AuditEdge {
  node: Audit
  cursor: String
}

type RecipeEdge {
  node: Recipe
  cursor: String
}

type RepositoryEdge {
  node: Repository
  cursor: String
}

type InstallationEdge {
  node: Installation
  cursor: String
}

type RunbookExecutionEdge {
  node: RunbookExecution
  cursor: String
}

type WebhookEdge {
  node: Webhook
  cursor: String
}

type DependencyManagementServiceEdge {
  node: DependencyManagementService
  cursor: String
}

type ScmWebhookEdge {
  node: ScmWebhook
  cursor: String
}

type PullRequestEdge {
  node: PullRequest
  cursor: String
}

type PrAutomationEdge {
  node: PrAutomation
  cursor: String
}

type ScmConnectionEdge {
  node: ScmConnection
  cursor: String
}

type GitRepositoryEdge {
  node: GitRepository
  cursor: String
}

type TagEdge {
  node: Tag
  cursor: String
}

type ClusterRevisionEdge {
  node: ClusterRevision
  cursor: String
}

type ClusterProviderEdge {
  node: ClusterProvider
  cursor: String
}

type ClusterEdge {
  node: Cluster
  cursor: String
}

type RevisionEdge {
  node: Revision
  cursor: String
}

type ServiceDeploymentEdge {
  node: ServiceDeployment
  cursor: String
}

type PipelineContextEdge {
  node: PipelineContext
  cursor: String
}

type PipelineGateEdge {
  node: PipelineGate
  cursor: String
}

type PipelineEdge {
  node: Pipeline
  cursor: String
}

type ClusterRestoreEdge {
  node: ClusterRestore
  cursor: String
}

type ClusterBackupEdge {
  node: ClusterBackup
  cursor: String
}

type ObjectStoreEdge {
  node: ObjectStore
  cursor: String
}

type NotificationRouterEdge {
  node: NotificationRouter
  cursor: String
}

type NotificationSinkEdge {
  node: NotificationSink
  cursor: String
}

type PolicyConstraintEdge {
  node: PolicyConstraint
  cursor: String
}

type ManagedNamespaceEdge {
  node: ManagedNamespace
  cursor: String
}

type GlobalServiceEdge {
  node: GlobalService
  cursor: String
}

type StackRunEdge {
  node: StackRun
  cursor: String
}

type InfrastructureStackEdge {
  node: InfrastructureStack
  cursor: String
}

type ObservabilityProviderEdge {
  node: ObservabilityProvider
  cursor: String
}
