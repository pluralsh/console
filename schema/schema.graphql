schema {
  query: RootQueryType
  mutation: RootMutationType
  subscription: RootSubscriptionType
}

type PageInfo {
  "When paginating backwards, are there more items?"
  hasPreviousPage: Boolean!

  "When paginating forwards, are there more items?"
  hasNextPage: Boolean!

  "When paginating backwards, the cursor to continue."
  startCursor: String

  "When paginating forwards, the cursor to continue."
  endCursor: String
}

type RunbookAction {
  name: String!
  type: String!
  configuration: ConfigurationAction
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
  APPROVE
  CANCEL
}

type AccessTokenConnection {
  pageInfo: PageInfo!
  edges: [AccessTokenEdge]
}

"a representation of a kubernetes api deprecation"
type ApiDeprecation {
  "the kubernetes version the deprecation was posted"
  deprecatedIn: String

  "the kubernetes version the api version will be removed and unusable in"
  removedIn: String

  "the api you can replace this resource with"
  replacement: String

  "the kubernetes version the replacement api was created in"
  availableIn: String

  "whether you cannot safely upgrade to the next kubernetes version if this deprecation exists"
  blocking: Boolean

  "the component of this deprecation"
  component: ServiceComponent
}

type RevisionConnection {
  pageInfo: PageInfo!
  edges: [RevisionEdge]
}

type RecipeSection {
  id: ID!
  repository: Repository
  recipeItems: [RecipeItem]
  configuration: [ConfigurationItem]
}

type StatusCondition {
  message: String!
  reason: String!
  status: String!
  type: String!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]
}

type Plan {
  id: ID
  name: String
  period: String
}

type Application {
  name: String!
  spec: ApplicationSpec!
  status: ApplicationStatus!
  cost: CostAnalysis
  license: License
  configuration: Configuration
  info: String
}

type ConfigurationAction {
  updates: [PathUpdate]
}

type NotificationConnection {
  pageInfo: PageInfo!
  edges: [NotificationEdge]
}

type RecipeItem {
  id: ID!
  configuration: [ConfigurationItem]
}

type DashboardLabel {
  name: String!
  values: [String]
}

type Changelog {
  id: ID!
  repo: String!
  tool: String!
  content: String
  insertedAt: DateTime
  updatedAt: DateTime
}

type Tag {
  name: String!
  value: String!
}

type OverlayUpdate {
  path: [String]
}

type PostgresInstance {
  uid: String!
}

type RoleEdge {
  node: Role
  cursor: String
}

type GroupEdge {
  node: Group
  cursor: String
}

type InstallationEdge {
  node: Installation
  cursor: String
}

type WebhookEdge {
  node: Webhook
  cursor: String
}

type NodeUsage {
  cpu: String
  memory: String
}

type RepositoryEdge {
  node: Repository
  cursor: String
}

type ClusterEdge {
  node: Cluster
  cursor: String
}

type FileContent {
  path: String
  content: String
}

"a reference to a service deployed from a git repo into a cluster"
type ServiceDeployment {
  "internal id of this service"
  id: ID!

  "human readable name of this service, must be unique per cluster"
  name: String!

  "kubernetes namespace this service will be deployed to"
  namespace: String!

  "A summary status enum for the health of this service"
  status: ServiceDeploymentStatus!

  "semver of this service"
  version: String!

  "description on where in git the service's manifests should be fetched"
  git: GitRef!

  "latest git sha we pulled from"
  sha: String

  "https url to fetch the latest tarball of kubernetes manifests"
  tarball: String

  "the time this service was scheduled for deletion"
  deletedAt: DateTime

  "the git repo of this service"
  repository: GitRepository

  "read policy for this service"
  readBindings: [PolicyBinding]

  "write policy of this service"
  writeBindings: [PolicyBinding]

  "a list of errors generated by the deployment operator"
  errors: [ServiceError]

  "the cluster this service is deployed into"
  cluster: Cluster

  "the current revision of this service"
  revision: Revision

  "possibly secret configuration used to template the manifests of this service"
  configuration: [ServiceConfiguration]

  "the kubernetes component of a service"
  components: [ServiceComponent]

  "the global service this service is the source for"
  globalService: GlobalService

  "whether this service is controlled by a global service"
  owner: GlobalService

  "a relay connection of all revisions of this service, these are periodically pruned up to a history limit"
  revisions(after: String, first: Int, before: String, last: Int): RevisionConnection

  "whether this service is editable"
  editable: Boolean

  insertedAt: DateTime

  updatedAt: DateTime
}

"representation of a kubernets component deployed by a service"
type ServiceComponent {
  "internal id"
  id: ID!

  "kubernetes component health enum"
  state: ComponentState

  "whether this component has been applied to the k8s api"
  synced: Boolean!

  "api group of this resource"
  group: String

  "api version of this resource"
  version: String

  "api kind of this resource"
  kind: String!

  "kubernetes namespace of this resource"
  namespace: String

  "kubernetes name of this resource"
  name: String!

  "the service this component belongs to"
  service: ServiceDeployment

  "any api deprecations discovered from this component"
  apiDeprecations: [ApiDeprecation]
}

enum AuthMethod {
  BASIC
  SSH
}

enum AutoscalingTarget {
  STATEFULSET
  DEPLOYMENT
}

type StatusComponent {
  group: String
  kind: String!
  name: String!
  status: String!
}

input SmtpInput {
  server: String
  port: Int
  password: String
  sender: String
  user: String
}

type StatefulSet {
  metadata: Metadata!
  status: StatefulSetStatus!
  spec: StatefulSetSpec!
  pods: [Pod]
  raw: String!
  events: [Event]
}

type Account {
  delinquentAt: DateTime
  grandfatheredUntil: DateTime
  availableFeatures: AvailableFeatures
  subscription: PluralSubscription
}

type MetricResult {
  timestamp: Int
  value: String
}

type Component {
  group: String!
  kind: String!
}

input CloudSettingsAttributes {
  aws: AwsCloudAttributes
}

type DeploymentSpec {
  replicas: Int
  strategy: DeploymentStrategy
}

input RbacAttributes {
  readBindings: [PolicyBindingAttributes]
  writeBindings: [PolicyBindingAttributes]
}

input GitRefAttributes {
  ref: String!
  folder: String!
}

input ServiceErrorAttributes {
  source: String!
  message: String!
}

type ConfigurationOverlaySpec {
  name: String
  folder: String
  subfolder: String
  documentation: String
  updates: [OverlayUpdate]
  inputType: String
  inputValues: [String]
}

type LoadBalancerStatus {
  ingress: [LoadBalancerIngressStatus]
}

type ContainerStatus {
  restartCount: Int
  ready: Boolean
  name: String
  image: String
  state: ContainerState
}

input ServiceDeploymentAttributes {
  name: String!
  namespace: String!
  version: String
  repositoryId: ID!
  git: GitRefAttributes!
  configuration: [ConfigAttributes]
  readBindings: [PolicyBindingAttributes]
  writeBindings: [PolicyBindingAttributes]
}

input ConfigAttributes {
  name: String!
  value: String!
}

input ContextAttributes {
  buckets: [String]
  domain: [String]
  configuration: Map!
  protect: [String]
}

type IngressTls {
  hosts: [String]
}

input TaintAttributes {
  key: String!
  value: String!
  effect: String!
}

type PostgresqlSpec {
  teamId: String
  users: Map
  resources: Resources
  postgresql: PostgresSettings
  numberOfInstances: Int
  databases: Map
  volume: DatabaseVolume
  pods: [Pod]
}

type NodeStatus {
  allocatable: Map
  capacity: Map
  phase: String
  conditions: [NodeCondition]
}

type IngressSpec {
  rules: [IngressRule]
  tls: [IngressTls]
}

type DeploymentStatus {
  availableReplicas: Int
  replicas: Int
  readyReplicas: Int
  unavailableReplicas: Int
}

input InviteAttributes {
  email: String
}

input BindingAttributes {
  id: ID
  userId: ID
  groupId: ID
}

input BuildAttributes {
  repository: String!
  type: BuildType
  message: String
}

input DeploymentSettingsAttributes {
  artifactRepositoryId: ID
  deployerRepositoryId: ID
  readBindings: [PolicyBindingAttributes]
  writeBindings: [PolicyBindingAttributes]
  gitBindings: [PolicyBindingAttributes]
  createBindings: [PolicyBindingAttributes]
}

type CronJob {
  metadata: Metadata!
  status: CronStatus!
  spec: CronSpec!
  raw: String!
  events: [Event]
  jobs: [Job]
}

"a CAPI provider for a cluster, cloud is inferred from name if not provided manually"
type ClusterProvider {
  "the id of this provider"
  id: ID!

  "a human readable name for the provider, globally unique"
  name: String!

  "the namespace the CAPI resources are deployed into"
  namespace: String!

  "the name of the cloud service for this provider"
  cloud: String!

  "the details of how cluster manifests will be synced from git when created with this provider"
  git: GitRef!

  "the repository used to serve cluster manifests"
  repository: GitRepository

  "the service of the CAPI controller itself"
  service: ServiceDeployment

  "whether the current user can edit this resource"
  editable: Boolean

  insertedAt: DateTime

  updatedAt: DateTime
}

type PodDelta {
  delta: Delta
  payload: Pod
}

"supported kubernetes objects fetchable in runbooks"
union KubernetesData = Deployment | StatefulSet

type Smtp {
  server: String
  port: Int
  password: String
  sender: String
  user: String
}

type LoginInfo {
  oidcUri: String
}

type ClusterInfo {
  gitCommit: String
  gitVersion: String
  platform: String
  version: String
}

"a configuration item k/v pair"
type ServiceConfiguration {
  name: String!
  value: String!
}

type RootSubscriptionType {
  applicationDelta: ApplicationDelta
  podDelta: PodDelta
  buildDelta(buildId: ID): BuildDelta
  commandDelta(buildId: ID!): CommandDelta
  notificationDelta: NotificationDelta
}

type ClusterConnection {
  pageInfo: PageInfo!
  edges: [ClusterEdge]
}

type RepositoryConnection {
  pageInfo: PageInfo!
  edges: [RepositoryEdge]
}

type WebhookConnection {
  pageInfo: PageInfo!
  edges: [WebhookEdge]
}

type ConfigurationValidation {
  type: String
  regex: String
  message: String
}

type InstallationConnection {
  pageInfo: PageInfo!
  edges: [InstallationEdge]
}

type PodCondition {
  lastProbeTime: String
  lastTransitionTime: String
  message: String
  reason: String
  status: String
  type: String
}

type GroupConnection {
  pageInfo: PageInfo!
  edges: [GroupEdge]
}

type RoleConnection {
  pageInfo: PageInfo!
  edges: [RoleEdge]
}

type RunbookExecution {
  id: ID!
  name: String!
  namespace: String!
  context: Map!
  user: User
  insertedAt: DateTime
  updatedAt: DateTime
}

type ConfigurationItem {
  name: String
  type: String
  placeholder: String
  documentation: String
  default: String
  optional: Boolean
  condition: ConfigurationCondition
  validation: ConfigurationValidation
}

type LogStream {
  stream: Map
  values: [MetricResult]
}

type ApplicationInfoItem {
  type: String
  name: String
  value: String
}

type LogLabel {
  name: String
  value: String
}

type ManifestNetwork {
  pluralDns: Boolean
  subdomain: String
}

type Webhook {
  id: ID!
  url: String!
  health: WebhookHealth!
  type: WebhookType!
  insertedAt: DateTime
  updatedAt: DateTime
}

type Runbook {
  name: String!
  spec: RunbookSpec!
  status: RunbookStatus
  data(context: RunbookContext): [RunbookData]
  executions(after: String, first: Int, before: String, last: Int): RunbookExecutionConnection
}

enum Severity {
  NONE
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

type Repository {
  id: ID!
  name: String!
  description: String
  icon: String
  docs: [FileContent]
  configuration: Configuration
  grafanaDns: String
}

type DeploymentStrategy {
  type: String
  rollingUpdate: RollingUpdate
}

type DashboardGraph {
  name: String!
  queries: [DashboardMetric]
  format: String
}

type IngressPath {
  backend: IngressBackend
  path: String
}

input ClusterPing {
  currentVersion: String!
}

type PolicyBinding {
  id: ID
  user: User
  group: Group
}

type LicenseFeature {
  name: String!
  description: String
}

type ClusterProviderEdge {
  node: ClusterProvider
  cursor: String
}

type IngressRule {
  host: String
  http: HttpIngressRule
}

type Service {
  metadata: Metadata!
  status: ServiceStatus!
  spec: ServiceSpec!
  pods: [Pod]
  raw: String!
  events: [Event]
}

type License {
  metadata: Metadata!
  spec: LicenseSpec!
  status: LicenseStatus
}

type Node {
  status: NodeStatus!
  spec: NodeSpec!
  metadata: Metadata!
  raw: String!
  pods: [Pod]
  events: [Event]
}

type Invite {
  secureId: String!
  email: String
}

type PodEdge {
  node: Pod
  cursor: String
}

type PrometheusDatasource {
  query: String!
  format: String
  legend: String
}

type Recipe {
  id: ID!
  name: String!
  description: String
  provider: String
  restricted: Boolean
  recipeSections: [RecipeSection]
  oidcEnabled: Boolean
}

enum BuildType {
  DEPLOY
  BOUNCE
  APPROVAL
  INSTALL
  DESTROY
  DEDICATED
  CONFIG
}

type AuditEdge {
  node: Audit
  cursor: String
}

type KubernetesDatasource {
  resource: String!
  name: String!
}

type RunbookActionResponse {
  redirectTo: String
}

type Role {
  id: ID!
  name: String!
  description: String
  repositories: [String]
  permissions: [Permission]
  roleBindings: [RoleBinding]
  insertedAt: DateTime
  updatedAt: DateTime
}

type CrossVersionResourceTarget {
  apiVersion: String
  kind: String
  name: String
}

type PluralManifest {
  network: ManifestNetwork
  bucketPrefix: String
  cluster: String
}

input RunbookContext {
  timeseriesStart: Int
  timeseriesStep: String
}

type ServicePort {
  name: String
  protocol: String
  port: Int
  targetPort: String
}

type Deployment {
  metadata: Metadata!
  status: DeploymentStatus!
  spec: DeploymentSpec!
  pods: [Pod]
  raw: String!
  events: [Event]
}

type AccessTokenAudit {
  id: ID
  ip: String
  timestamp: DateTime
  count: Int
  city: String
  country: String
  latitude: String
  longitude: String
  insertedAt: DateTime
  updatedAt: DateTime
}

type Build {
  id: ID!
  repository: String!
  type: BuildType!
  status: Status!
  message: String
  completedAt: DateTime
  sha: String
  commands(after: String, first: Int, before: String, last: Int): CommandConnection
  creator: User
  approver: User
  changelogs: [Changelog]
  insertedAt: DateTime
  updatedAt: DateTime
}

type Command {
  id: ID!
  command: String!
  exitCode: Int
  stdout: String
  completedAt: DateTime
  build: Build
  insertedAt: DateTime
  updatedAt: DateTime
}

type CostAnalysis {
  minutes: Float
  cpuCost: Float
  cpuEfficiency: Float
  efficiency: Float
  gpuCost: Float
  networkCost: Float
  pvCost: Float
  ramCost: Float
  ramEfficiency: Float
  totalCost: Float
  sharedCost: Float
}

type ApplicationSpec {
  descriptor: ApplicationDescriptor!
  components: [Component]
  info: [ApplicationInfoItem]
}

type AvailableFeatures {
  vpn: Boolean
  audits: Boolean
  userManagement: Boolean
  databaseManagement: Boolean
}

type DashboardMetric {
  legend: String
  query: String
  results: [MetricResult]
}

type NodeSpec {
  podCidr: String
  providerId: String
  unschedulable: Boolean
}

type LicenseSpec {
  secretRef: SecretKeySelector!
}

input UserAttributes {
  name: String
  email: String
  password: String
  roles: UserRoleAttributes
}

type VerticalPodAutoscalerSpec {
  targetRef: CrossVersionResourceTarget!
  updatePolicy: VerticalPodAutoscalerUpdatePolicy!
}

type ContainerResources {
  cpu: String
  memory: String
}

type CertificateStatus {
  conditions: [StatusCondition]
  notAfter: String
  notBefore: String
  renewalTime: String
}

type CertificateSpec {
  dnsNames: [String]
  secretName: String!
  issuerRef: IssuerRef
}

type JobSpec {
  backoffLimit: Int
  parallelism: Int
  activeDeadlineSeconds: Int
}

input NodePoolAttributes {
  name: String!
  minSize: Int!
  maxSize: Int!
  instanceType: String!
  labels: Map
  taints: [TaintAttributes]
  cloudSettings: CloudSettingsAttributes
}

type RunbookStatus {
  alerts: [RunbookAlertStatus]
}

type NamespaceStatus {
  phase: String
}

type PodStatus {
  message: String
  phase: String
  hostIp: String
  podIp: String
  reason: String
  conditions: [PodCondition]
  containerStatuses: [ContainerStatus]
  initContainerStatuses: [ContainerStatus]
}

type GitStatus {
  cloned: Boolean
  output: String
}

type CronSpec {
  schedule: String!
  suspend: Boolean
  concurrencyPolicy: String
}

"a representation of a cluster you can deploy to"
type Cluster {
  "internal id of this cluster"
  id: ID!

  "human readable name of this cluster, will also translate to cloud k8s name"
  name: String!

  "desired k8s version for the cluster"
  version: String

  "current k8s version as told to us by the deployment operator"
  currentVersion: String

  "a short, unique human readable name used to identify this cluster and does not necessarily map to the cloud resource name"
  handle: String

  "when this cluster was scheduled for deletion"
  deletedAt: DateTime

  "last time the deploy operator pinged this cluster"
  pingedAt: DateTime

  "read policy for this cluster"
  readBindings: [PolicyBinding]

  "write policy for this cluster"
  writeBindings: [PolicyBinding]

  "list of node pool specs managed by CAPI"
  nodePools: [NodePool]

  "the provider we use to create this cluster (null if BYOK)"
  provider: ClusterProvider

  "the service used to deploy the CAPI resources of this cluster"
  service: ServiceDeployment

  "key/value tags to filter clusters"
  tags: [Tag]

  "all api deprecations for all services in this cluster"
  apiDeprecations: [ApiDeprecation]

  "a relay connection of all revisions of this service, these are periodically pruned up to a history limit"
  revisions(after: String, first: Int, before: String, last: Int): RevisionConnection

  "whether the current user can edit this cluster"
  editable: Boolean

  insertedAt: DateTime

  updatedAt: DateTime
}

type WireguardPeer {
  metadata: Metadata!
  status: WireguardPeerStatus
  spec: WireguardPeerSpec!
  config: String
  user: User
  raw: String!
}

type Container {
  image: String
  name: String
  ports: [Port]
  resources: Resources
}

type GroupMember {
  id: ID!
  user: User
  group: Group
  insertedAt: DateTime
  updatedAt: DateTime
}

type ApplicationDescriptor {
  type: String!
  version: String!
  description: String
  icons: [String]
  links: [ApplicationLink]
}

enum Delta {
  CREATE
  UPDATE
  DELETE
}

type ApplicationDelta {
  delta: Delta
  payload: Application
}

type RootMutationType {
  createBuild(attributes: BuildAttributes!): Build

  restartBuild(id: ID!): Build

  cancelBuild(id: ID!): Build

  approveBuild(id: ID!): Build

  signIn(email: String!, password: String!): User

  loginLink(key: String!): User

  readNotifications: User

  signup(inviteId: String!, attributes: UserAttributes!): User

  oauthCallback(code: String!, redirect: String): User

  createInvite(attributes: InviteAttributes!): Invite

  updateUser(id: ID, attributes: UserAttributes!): User

  deleteUser(id: ID!): User

  markRead(type: ReadType): User

  createGroup(attributes: GroupAttributes!): Group

  deleteGroup(groupId: ID!): Group

  updateGroup(groupId: ID!, attributes: GroupAttributes!): Group

  createGroupMember(groupId: ID!, userId: ID!): GroupMember

  deleteGroupMember(groupId: ID!, userId: ID!): GroupMember

  createRole(attributes: RoleAttributes!): Role

  updateRole(id: ID!, attributes: RoleAttributes!): Role

  deleteRole(id: ID!): Role

  createAccessToken: AccessToken

  deleteAccessToken(token: String!): AccessToken

  deleteCertificate(name: String!, namespace: String!): Boolean

  deletePod(namespace: String!, name: String!): Pod

  deleteJob(namespace: String!, name: String!): Job

  deleteNode(name: String!): Node

  overlayConfiguration(namespace: String!, context: Map!): Build

  createPeer(userId: ID, email: String, name: String!): WireguardPeer

  deletePeer(name: String!): Boolean

  installRecipe(id: ID!, context: Map!, oidc: Boolean): Build

  installStack(name: String!, context: ContextAttributes!, oidc: Boolean): Build

  updateSmtp(smtp: SmtpInput!): Smtp

  updateConfiguration(repository: String!, content: String!, tool: Tool, message: String): Configuration

  createUpgradePolicy(attributes: UpgradePolicyAttributes!): UpgradePolicy

  deleteUpgradePolicy(id: ID!): UpgradePolicy

  executeRunbook(namespace: String!, name: String!, input: RunbookActionInput!): RunbookActionResponse

  createWebhook(attributes: WebhookAttributes!): Webhook

  deleteWebhook(id: ID!): Webhook

  restorePostgres(namespace: String!, name: String!, timestamp: DateTime!, clone: CloneAttributes): Postgresql

  createGitRepository(attributes: GitAttributes!): GitRepository

  createCluster(attributes: ClusterAttributes!): Cluster

  updateCluster(id: ID!, attributes: ClusterUpdateAttributes!): Cluster

  deleteCluster(id: ID!): Cluster

  createClusterProvider(attributes: ClusterProviderAttributes!): ClusterProvider

  updateClusterProvider(id: ID!, attributes: ClusterProviderUpdateAttributes!): ClusterProvider

  createServiceDeployment(
    clusterId: ID

    "the handle of the cluster for this service"
    cluster: String

    attributes: ServiceDeploymentAttributes!
  ): ServiceDeployment

  updateServiceDeployment(
    id: ID

    "the handle of the cluster for this service"
    cluster: String

    name: String

    attributes: ServiceUpdateAttributes!
  ): ServiceDeployment

  deleteServiceDeployment(id: ID!): ServiceDeployment

  "rewires this service to use the given revision id"
  rollbackService(
    id: ID

    "the handle of the cluster for this service"
    cluster: String

    name: String

    revisionId: ID!
  ): ServiceDeployment

  "clones the spec of the given service to be deployed either into a new namespace or new cluster"
  cloneService(
    serviceId: ID

    "the handle of the cluster for this service"
    cluster: String

    name: String

    clusterId: ID!

    attributes: ServiceCloneAttributes!
  ): ServiceDeployment

  createGlobalService(
    serviceId: ID

    "the handle of the cluster for this service"
    cluster: String

    name: String

    attributes: GlobalServiceAttributes!
  ): GlobalService

  deleteGlobalService(id: ID!): GlobalService

  "a regular status ping to be sent by the deploy operator"
  pingCluster(attributes: ClusterPing!): Cluster

  "updates only the components of a given service, to be sent after deploy operator syncs"
  updateServiceComponents(id: ID!, components: [ComponentAttributes], errors: [ServiceErrorAttributes]): ServiceDeployment

  "a reusable mutation for updating rbac settings on core services"
  updateRbac(rbac: RbacAttributes!, serviceId: ID, clusterId: ID, providerId: ID): Boolean

  updateDeploymentSettings(attributes: DeploymentSettingsAttributes!): DeploymentSettings
}

type PodConnection {
  pageInfo: PageInfo!
  edges: [PodEdge]
}

type AccessToken {
  id: ID
  token: String
  audits(after: String, first: Int, before: String, last: Int): AccessTokenAuditConnection
  insertedAt: DateTime
  updatedAt: DateTime
}

"a representation of a past revision of a service"
type Revision {
  "id of this revision"
  id: ID!

  "the service's semver"
  version: String!

  "git spec of the prior revision"
  git: GitRef!

  "the sha this service was pulled from"
  sha: String

  insertedAt: DateTime

  updatedAt: DateTime
}

type Installation {
  id: ID!
  repository: Repository
}

type Configuration {
  terraform: String
  helm: String
}

type ClusterProviderConnection {
  pageInfo: PageInfo!
  edges: [ClusterProviderEdge]
}

type Notification {
  id: ID!
  title: String!
  description: String
  fingerprint: String!
  status: NotificationStatus
  labels: Map
  annotations: Map
  repository: String!
  seenAt: DateTime
  severity: Severity
  insertedAt: DateTime
  updatedAt: DateTime
}

type AuditConnection {
  pageInfo: PageInfo!
  edges: [AuditEdge]
}

type ConfigurationCondition {
  field: String
  value: String
  operation: String
}

type Recommendation {
  containerRecommendations: [ContainerRecommendation]
}

type Postgresql {
  metadata: Metadata!
  spec: PostgresqlSpec!
  status: PostgresqlStatus
  instances: [PostgresInstance]
}

enum Tool {
  HELM
  TERRAFORM
}

type ApplicationLink {
  url: String
  description: String
}

type Stack {
  id: ID!
  name: String!
  bundles: [Recipe]
  sections: [RecipeSection]
  insertedAt: DateTime
  updatedAt: DateTime
}

type UpgradePolicy {
  id: ID!
  name: String!
  description: String
  repositories: [String]
  type: UpgradePolicyType!
  target: String!
  weight: Int
  insertedAt: DateTime
  updatedAt: DateTime
}

type RootQueryType {
  configuration: ConsoleConfiguration

  externalToken: String

  builds(after: String, first: Int, before: String, last: Int): BuildConnection

  build(id: ID!): Build

  buildInfo: BuildInfo

  users(after: String, first: Int, before: String, last: Int, q: String): UserConnection

  loginInfo(redirect: String): LoginInfo

  me: User

  invite(id: String!): Invite

  groups(after: String, first: Int, before: String, last: Int, q: String): GroupConnection

  groupMembers(after: String, first: Int, before: String, last: Int, groupId: ID!): GroupMemberConnection

  role: Role

  roles(after: String, first: Int, before: String, last: Int, q: String): RoleConnection

  notifications(after: String, first: Int, before: String, last: Int, all: Boolean): NotificationConnection

  temporaryToken: String

  accessTokens(after: String, first: Int, before: String, last: Int): AccessTokenConnection

  accessToken(id: ID!): AccessToken

  dashboards(repo: String!): [Dashboard]

  dashboard(repo: String!, name: String!, step: String, offset: Int, labels: [LabelInput]): Dashboard

  metric(query: String!, offset: Int, step: String): [MetricResponse]

  logs(query: String!, start: Long, end: Long, limit: Int!): [LogStream]

  scalingRecommendation(kind: AutoscalingTarget!, namespace: String!, name: String!): VerticalPodAutoscaler

  configMap(namespace: String!, name: String!): ConfigMap

  secret(namespace: String!, name: String!): Secret

  configMaps(namespace: String!): [ConfigMap]

  secrets(namespace: String!): [Secret]

  service(namespace: String!, name: String!): Service

  clusterInfo: ClusterInfo

  deployment(namespace: String!, name: String!): Deployment

  statefulSet(namespace: String!, name: String!): StatefulSet

  ingress(namespace: String!, name: String!): Ingress

  nodes: [Node]

  node(name: String!): Node

  cronJob(namespace: String!, name: String!): CronJob

  job(namespace: String!, name: String!): Job

  certificate(namespace: String!, name: String!): Certificate

  pod(namespace: String!, name: String!): Pod

  pods(after: String, first: Int, before: String, last: Int, namespaces: [String]): PodConnection

  wireguardPeers: [WireguardPeer]

  myWireguardPeers: [WireguardPeer]

  wireguardPeer(name: String!): WireguardPeer

  cachedPods(namespaces: [String]): [Pod]

  namespaces: [Namespace]

  logFilters(namespace: String!): [LogFilter]

  nodeMetrics: [NodeMetric]

  nodeMetric(name: String!): NodeMetric

  configurationOverlays(namespace: String!): [ConfigurationOverlay]

  audits(after: String, first: Int, before: String, last: Int, repo: String): AuditConnection

  auditMetrics: [AuditMetric]

  ai(prompt: String!): String

  account: Account

  installations(after: String, first: Int, before: String, last: Int): InstallationConnection

  applications: [Application]

  application(name: String!): Application

  repository(name: String!): Repository

  repositories(after: String, first: Int, before: String, last: Int, query: String!): RepositoryConnection

  recipes(after: String, first: Int, before: String, last: Int, id: ID!): RecipeConnection

  context: [RepositoryContext]

  pluralContext: PluralContext

  recipe(id: ID!): Recipe

  stack(name: String!): Stack

  smtp: Smtp

  upgradePolicies: [UpgradePolicy]

  runbook(namespace: String!, name: String!): Runbook

  runbooks(namespace: String!, pinned: Boolean): [Runbook]

  webhooks(after: String, first: Int, before: String, last: Int): WebhookConnection

  postgresDatabases: [Postgresql]

  postgresDatabase(namespace: String!, name: String!): Postgresql

  gitRepositories(after: String, first: Int, before: String, last: Int): GitRepositoryConnection

  "a relay connection of all clusters visible to the current user"
  clusters(after: String, first: Int, before: String, last: Int): ClusterConnection

  "a relay connection of all providers visible to the current user"
  clusterProviders(after: String, first: Int, before: String, last: Int): ClusterProviderConnection

  "fetches an individual cluster"
  cluster(id: ID, handle: String): Cluster

  "fetches an individual cluster provider"
  clusterProvider(id: ID!): ClusterProvider

  serviceDeployments(
    after: String

    first: Int

    before: String

    last: Int

    clusterId: ID

    "the handle of the cluster for this service"
    cluster: String
  ): ServiceDeploymentConnection

  "the services deployed in the current cluster, to be polled by the deploy operator"
  clusterServices: [ServiceDeployment]

  "fetches details of this service deployment, and can be called by the deploy operator"
  serviceDeployment(
    id: ID

    "the handle of the cluster for this service"
    cluster: String

    name: String
  ): ServiceDeployment

  deploymentSettings: DeploymentSettings
}

type RoleBinding {
  id: ID!
  user: User
  group: Group
  insertedAt: DateTime
  updatedAt: DateTime
}

"a representation of where to pull manifests from git"
type GitRef {
  "a general git ref, either a branch name or commit sha understandable by `git checkout <ref>`"
  ref: String!

  "the folder manifests live under"
  folder: String!
}

type IssuerRef {
  group: String
  kind: String
  name: String
}

type RunbookDatasource {
  name: String!
  type: String!
  prometheus: PrometheusDatasource
  kubernetes: KubernetesDatasource
}

type CommandEdge {
  node: Command
  cursor: String
}

type RunbookExecutionEdge {
  node: RunbookExecution
  cursor: String
}

"a rules based mechanism to redeploy a service across a fleet of clusters"
type GlobalService {
  "internal id of this global service"
  id: ID!

  "a human readable name for this global service"
  name: String!

  "a set of tags to select clusters for this global service"
  tags: [Tag]

  "the service to replicate across clusters"
  service: ServiceDeployment

  "whether to only apply to clusters with this provider"
  provider: ClusterProvider

  insertedAt: DateTime

  updatedAt: DateTime
}

type Namespace {
  status: NamespaceStatus!
  spec: NamespaceSpec!
  metadata: Metadata!
  raw: String!
  events: [Event]
}

type GitRepositoryEdge {
  node: GitRepository
  cursor: String
}

enum AuditType {
  BUILD
  POD
  CONFIGURATION
  USER
  GROUP
  ROLE
  GROUP_MEMBER
  POLICY
  TEMP_TOKEN
  SERVICE
  CLUSTER
  CLUSTER_PROVIDER
  GIT_REPOSITORY
  DEPLOYMENT_SETTINGS
}

type MetricResponse {
  metric: Map
  values: [MetricResult]
}

enum ReadType {
  NOTIFICATION
  BUILD
}

type BuildEdge {
  node: Build
  cursor: String
}

type RecipeEdge {
  node: Recipe
  cursor: String
}

enum ComponentState {
  RUNNING
  PENDING
  FAILED
}

type RunningState {
  startedAt: String
}

type WaitingState {
  message: String
  reason: String
}

"""
The `DateTime` scalar type represents a date and time in the UTC
timezone. The DateTime appears in a JSON response as an ISO8601 formatted
string, including UTC timezone ("Z"). The parsed date and time string will
be converted to UTC if there is an offset.
"""
scalar DateTime

type GroupMemberEdge {
  node: GroupMember
  cursor: String
}

type JobReference {
  name: String!
  namespace: String!
}

type AccessTokenAuditEdge {
  node: AccessTokenAudit
  cursor: String
}

type ServiceDeploymentEdge {
  node: ServiceDeployment
  cursor: String
}

type IngressBackend {
  serviceName: String
  servicePort: String
}

type Pod {
  status: PodStatus!
  spec: PodSpec!
  metadata: Metadata!
  raw: String!
  events: [Event]
}

type PluralContext {
  buckets: [String]
  domains: [String]
  configuration: Map!
}

type Port {
  hostPort: Int
  containerPort: Int
  protocol: String
}

"a kubernetes node taint"
type Taint {
  key: String!
  value: String!
  effect: String!
}

"aws node customizations"
type AwsCloud {
  "custom launch template for your nodes, useful for Golden AMI setups"
  launchTemplateId: String
}

type Event {
  action: String
  count: Int
  eventTime: String
  lastTimestamp: String
  message: String
  reason: String
  type: String
}

input ComponentAttributes {
  state: ComponentState
  synced: Boolean!
  group: String!
  version: String!
  kind: String!
  namespace: String!
  name: String!
}

input ClusterUpdateAttributes {
  version: String!
  nodePools: [NodePoolAttributes]
  readBindings: [PolicyBindingAttributes]
  writeBindings: [PolicyBindingAttributes]
}

input CloudProviderSettingsAttributes {
  aws: AwsSettingsAttributes
  gcp: GcpSettingsAttributes
}

input GcpSettingsAttributes {
  applicationCredentials: String!
}

type LicenseStatus {
  plan: String
  free: Boolean
  features: [LicenseFeature]
  limits: Map
  secrets: Map
}

input PolicyBindingAttributes {
  id: ID
  userId: ID
  groupId: ID
}

type ApplicationStatus {
  components: [StatusComponent]
  conditions: [StatusCondition]
  componentsReady: String!
}

"global settings for CD, these specify global read/write policies and also allow for customization of the repos for CAPI resources and the deploy operator"
type DeploymentSettings {
  id: ID!

  name: String!

  "the repo to fetch CAPI manifests from, for both providers and clusters"
  artifactRepository: GitRepository

  "the repo to fetch the deploy operators manifests from"
  deployerRepository: GitRepository

  "read policy across all clusters"
  readBindings: [PolicyBinding]

  "write policy across all clusters"
  writeBindings: [PolicyBinding]

  "policy for managing git repos"
  gitBindings: [PolicyBinding]

  "policy for creation of new clusters"
  createBindings: [PolicyBinding]

  insertedAt: DateTime

  updatedAt: DateTime
}

input ClusterAttributes {
  name: String!

  "a short, unique human readable name used to identify this cluster and does not necessarily map to the cloud resource name"
  handle: String

  providerId: ID

  version: String!

  nodePools: [NodePoolAttributes]

  readBindings: [PolicyBindingAttributes]

  writeBindings: [PolicyBindingAttributes]

  tags: [TagAttributes]
}

input TagAttributes {
  name: String!
  value: String!
}

"cloud specific settings for a node pool"
type CloudSettings {
  aws: AwsCloud
}

type PostgresSettings {
  version: String
}

type RunbookSpec {
  name: String!
  description: String
  display: Map
  datasources: [RunbookDatasource]
  actions: [RunbookAction]
}

type Ingress {
  metadata: Metadata!
  status: ServiceStatus!
  spec: IngressSpec!
  certificates: [Certificate]
  raw: String!
  events: [Event]
}

input UserRoleAttributes {
  admin: Boolean
}

enum ServiceDeploymentStatus {
  STALE
  SYNCED
  HEALTHY
  FAILED
}

input AwsCloudAttributes {
  launchTemplateId: String
}

input GitAttributes {
  "the url of this repository"
  url: String!

  "an ssh private key to use with this repo if an ssh url was given"
  privateKey: String

  "a passphrase to decrypt the given private key"
  passphrase: String

  "the http username for authenticated http repos, defaults to apiKey for github"
  username: String

  "the http password for http authenticated repos"
  password: String
}

type DashboardSpec {
  name: String
  description: String
  timeslices: [String]
  labels: [DashboardLabel]
  graphs: [DashboardGraph]
}

input AwsSettingsAttributes {
  accessKeyId: String!
  secretAccessKey: String!
}

input UpgradePolicyAttributes {
  name: String!
  description: String
  target: String!
  type: UpgradePolicyType!
  repositories: [String]
  weight: Int
}

type AuditMetric {
  country: String
  count: Int
}

input ServiceUpdateAttributes {
  version: String
  git: GitRefAttributes!
  configuration: [ConfigAttributes]
}

input CloneAttributes {
  s3AccessKeyId: String
  s3SecretAccessKey: String
  s3WalPath: String
  s3Endpoint: String
  uid: String
}

input WebhookAttributes {
  url: String!
}

input GroupAttributes {
  name: String!
  description: String
}

input RoleAttributes {
  name: String
  description: String
  repositories: [String]
  roleBindings: [BindingAttributes]
  permissions: [Permission]
}

type Job {
  metadata: Metadata!
  status: JobStatus!
  spec: JobSpec!
  raw: String!
  events: [Event]
  pods: [Pod]
}

type LogFilter {
  metadata: Metadata!
  spec: LogFilterSpec!
}

type Metadata {
  labels: [LabelPair]
  annotations: [LabelPair]
  name: String!
  namespace: String
  creationTimestamp: String
}

type BuildInfo {
  all: Int
  failed: Int
  queued: Int
  running: Int
  successful: Int
}

type NodeCondition {
  message: String
  reason: String
  status: String
  type: String
}

type GroupMemberConnection {
  pageInfo: PageInfo!
  edges: [GroupMemberEdge]
}

type ContainerRecommendation {
  name: String
  containerName: String
  target: ContainerResources
  lowerBound: ContainerResources
  upperBound: ContainerResources
  uncappedTarget: ContainerResources
}

type ServiceDeploymentConnection {
  pageInfo: PageInfo!
  edges: [ServiceDeploymentEdge]
}

type GitRepositoryConnection {
  pageInfo: PageInfo!
  edges: [GitRepositoryEdge]
}

enum Permission {
  READ
  CONFIGURE
  DEPLOY
  OPERATE
}

type RunbookExecutionConnection {
  pageInfo: PageInfo!
  edges: [RunbookExecutionEdge]
}

type PluralSubscription {
  id: ID
  plan: Plan
}

type AccessTokenAuditConnection {
  pageInfo: PageInfo!
  edges: [AccessTokenAuditEdge]
}

type ConsoleConfiguration {
  gitCommit: String
  isDemoProject: Boolean
  isSandbox: Boolean
  pluralLogin: Boolean
  vpnEnabled: Boolean
  features: AvailableFeatures
  manifest: PluralManifest
  gitStatus: GitStatus
}

type CommandConnection {
  pageInfo: PageInfo!
  edges: [CommandEdge]
}

type RecipeConnection {
  pageInfo: PageInfo!
  edges: [RecipeEdge]
}

type BuildConnection {
  pageInfo: PageInfo!
  edges: [BuildEdge]
}

"a specification for a node pool to be created in this cluster"
type NodePool {
  "internal id for this node pool"
  id: ID!

  "name of this node pool (must be unique)"
  name: String!

  "minimum number of instances in this node pool"
  minSize: Int!

  "maximum number of instances in this node pool"
  maxSize: Int!

  "the type of node to use (usually cloud-specific)"
  instanceType: String!

  "kubernetes labels to apply to the nodes in this pool, useful for node selectors"
  labels: Map

  "any taints you'd want to apply to a node, for eg preventing scheduling on spot instances"
  taints: [Taint]

  "cloud specific settings for the node groups"
  cloudSettings: CloudSettings

  insertedAt: DateTime

  updatedAt: DateTime
}

type VerticalPodAutoscalerUpdatePolicy {
  updateMode: String
}

type ConfigurationOverlay {
  metadata: Metadata!
  spec: ConfigurationOverlaySpec!
}

"a git repository available for deployments"
type GitRepository {
  "internal id of this repository"
  id: ID!

  "the git url of the repository, either https or ssh supported"
  url: String!

  "whether its a http or ssh url"
  authMethod: AuthMethod

  "whether we can currently pull this repo with the provided credentials"
  health: GitHealth

  "the last successsful git pull timestamp"
  pulledAt: DateTime

  "the error message if there were any pull errors"
  error: String

  "whether the current user can edit this repo"
  editable: Boolean

  insertedAt: DateTime

  updatedAt: DateTime
}

enum GitHealth {
  PULLABLE
  FAILED
}

enum WebhookHealth {
  HEALTHY
  UNHEALTHY
}

scalar Long

enum UpgradePolicyType {
  DEPLOY
  APPROVAL
  IGNORE
}

type RevisionEdge {
  node: Revision
  cursor: String
}

type DatabaseVolume {
  size: String
}

enum WebhookType {
  PIAZZA
  SLACK
}

type Certificate {
  metadata: Metadata!
  status: CertificateStatus!
  spec: CertificateSpec!
  raw: String!
  events: [Event]
}

type AccessTokenEdge {
  node: AccessToken
  cursor: String
}

type RollingUpdate {
  maxSurge: Int
  maxUnavailable: Int
}

type NotificationEdge {
  node: Notification
  cursor: String
}

type HttpIngressRule {
  paths: [IngressPath]
}

type TerminatedState {
  exitCode: Int
  finishedAt: String
  startedAt: String
  message: String
  reason: String
}

type PathUpdate {
  path: [String]
  valueFrom: String!
}

type UserEdge {
  node: User
  cursor: String
}

type ContainerState {
  running: RunningState
  terminated: TerminatedState
  waiting: WaitingState
}

type RepositoryContext {
  repository: String!
  context: Map
}

type Audit {
  id: ID!
  action: AuditAction!
  type: AuditType!
  repository: String
  ip: String
  city: String
  country: String
  latitude: String
  longitude: String
  actor: User
  insertedAt: DateTime
  updatedAt: DateTime
}

input LabelInput {
  name: String
  value: String
}

input RunbookActionInput {
  action: String!
  context: Map!
}

type Secret {
  metadata: Metadata!
  type: String
  data: Map!
}

type Dashboard {
  id: String!
  spec: DashboardSpec!
}

type LoadBalancerIngressStatus {
  hostname: String
  ip: String
}

input GlobalServiceAttributes {
  name: String!
  tags: [TagAttributes]
  providerId: ID
}

type PostgresqlStatus {
  clusterStatus: String
}

type VerticalPodAutoscalerStatus {
  recommendation: Recommendation
}

type Resources {
  limits: ResourceSpec
  requests: ResourceSpec
}

enum NotificationStatus {
  FIRING
  RESOLVED
}

type UserRoles {
  admin: Boolean
}

input ServiceCloneAttributes {
  name: String!
  namespace: String
  configuration: [ConfigAttributes]
}

type WireguardPeerStatus {
  ready: Boolean
  conditions: [StatusCondition]
}

type WireguardPeerSpec {
  wireguardRef: String
  address: String
  publicKey: String
}

type PodSpec {
  serviceAccountName: String
  nodeName: String
  containers: [Container]
  initContainers: [Container]
}

enum Status {
  QUEUED
  RUNNING
  SUCCESSFUL
  FAILED
  CANCELLED
  PENDING
}

input ClusterProviderAttributes {
  name: String!
  namespace: String
  cloud: String
  cloudSettings: CloudProviderSettingsAttributes
}

input ClusterProviderUpdateAttributes {
  cloudSettings: CloudProviderSettingsAttributes
}

type RunbookAlertStatus {
  name: String!
  startsAt: String
  fingerprint: String
  annotations: Map
  labels: Map
}

type NamespaceSpec {
  finalizers: [String]
}

type CronStatus {
  active: [JobReference]
  lastScheduleTime: String
}

type ServiceStatus {
  loadBalancer: LoadBalancerStatus
}

type StatefulSetStatus {
  currentReplicas: Int
  replicas: Int
  readyReplicas: Int
  updatedReplicas: Int
}

type StatefulSetSpec {
  replicas: Int
  serviceName: String
}

type ResourceSpec {
  cpu: String
  memory: String
}

type JobStatus {
  active: Int
  completionTime: String
  startTime: String
  succeeded: Int
  failed: Int
}

type LogFilterSpec {
  name: String
  description: String
  query: String
  labels: [LogLabel]
}

type NodeMetric {
  metadata: Metadata!
  timestamp: String
  window: String
  usage: NodeUsage
}

type ServiceSpec {
  type: String
  clusterIp: String
  selector: Map
  ports: [ServicePort]
}

type VerticalPodAutoscaler {
  metadata: Metadata!
  spec: VerticalPodAutoscalerSpec!
  status: VerticalPodAutoscalerStatus
}

type SecretKeySelector {
  name: String!
  key: String
}

type User {
  id: ID!
  name: String!
  email: String!
  deletedAt: DateTime
  profile: String
  pluralId: String
  roles: UserRoles
  readTimestamp: DateTime
  buildTimestamp: DateTime
  boundRoles: [Role]
  jwt: String
  unreadNotifications: Int
  backgroundColor: String
  insertedAt: DateTime
  updatedAt: DateTime
}

"an error sent from the deploy operator about sync progress"
type ServiceError {
  source: String!
  message: String!
}

type LabelPair {
  name: String
  value: String
}

type RunbookData {
  name: String!
  source: RunbookDatasource
  kubernetes: KubernetesData
  prometheus: [MetricResponse]
  nodes: [Node]
}

type BuildDelta {
  delta: Delta
  payload: Build
}

type CommandDelta {
  delta: Delta
  payload: Command
}

type NotificationDelta {
  delta: Delta
  payload: Notification
}

type ConfigMap {
  metadata: Metadata!
  data: Map!
  raw: String!
}

type Group {
  id: ID!
  name: String!
  description: String
  insertedAt: DateTime
  updatedAt: DateTime
}

scalar Map
