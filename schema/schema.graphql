schema {
  query: RootQueryType
  mutation: RootMutationType
  subscription: RootSubscriptionType
}

type PageInfo {
  "When paginating backwards, are there more items?"
  hasPreviousPage: Boolean!

  "When paginating forwards, are there more items?"
  hasNextPage: Boolean!

  "When paginating backwards, the cursor to continue."
  startCursor: String

  "When paginating forwards, the cursor to continue."
  endCursor: String
}

type RunbookAction {
  name: String!
  type: String!
  configuration: ConfigurationAction
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
  APPROVE
  CANCEL
}

type AccessTokenConnection {
  pageInfo: PageInfo!
  edges: [AccessTokenEdge]
}

type RevisionConnection {
  pageInfo: PageInfo!
  edges: [RevisionEdge]
}

type RecipeSection {
  id: ID!
  repository: Repository
  recipeItems: [RecipeItem]
  configuration: [ConfigurationItem]
}

type StatusCondition {
  message: String!
  reason: String!
  status: String!
  type: String!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]
}

type Plan {
  id: ID
  name: String
  period: String
}

type Application {
  name: String!
  spec: ApplicationSpec!
  status: ApplicationStatus!
  cost: CostAnalysis
  license: License
  configuration: Configuration
  info: String
}

type ConfigurationAction {
  updates: [PathUpdate]
}

type NotificationConnection {
  pageInfo: PageInfo!
  edges: [NotificationEdge]
}

type RecipeItem {
  id: ID!
  configuration: [ConfigurationItem]
}

type DashboardLabel {
  name: String!
  values: [String]
}

type Changelog {
  id: ID!
  repo: String!
  tool: String!
  content: String
  insertedAt: DateTime
  updatedAt: DateTime
}

type OverlayUpdate {
  path: [String]
}

type PostgresInstance {
  uid: String!
}

type RoleEdge {
  node: Role
  cursor: String
}

type GroupEdge {
  node: Group
  cursor: String
}

type InstallationEdge {
  node: Installation
  cursor: String
}

type WebhookEdge {
  node: Webhook
  cursor: String
}

type NodeUsage {
  cpu: String
  memory: String
}

type RepositoryEdge {
  node: Repository
  cursor: String
}

type ClusterEdge {
  node: Cluster
  cursor: String
}

type FileContent {
  path: String
  content: String
}

type ServiceDeployment {
  id: ID!
  name: String!
  namespace: String!
  version: String!
  git: GitRef!
  sha: String
  tarball: String
  deletedAt: DateTime
  repository: GitRepository
  readBindings: [PolicyBinding]
  writeBindings: [PolicyBinding]
  revision: Revision
  configuration: [ServiceConfiguration]
  components: [ServiceComponent]
  revisions(after: String, first: Int, before: String, last: Int): RevisionConnection
  editable: Boolean
  insertedAt: DateTime
  updatedAt: DateTime
}

type ServiceComponent {
  id: ID!
  state: ComponentState
  synced: Boolean!
  group: String!
  version: String!
  kind: String!
  namespace: String!
  name: String!
}

enum AuthMethod {
  BASIC
  SSH
}

enum AutoscalingTarget {
  STATEFULSET
  DEPLOYMENT
}

type StatusComponent {
  group: String
  kind: String!
  name: String!
  status: String!
}

input SmtpInput {
  server: String
  port: Int
  password: String
  sender: String
  user: String
}

type StatefulSet {
  metadata: Metadata!
  status: StatefulSetStatus!
  spec: StatefulSetSpec!
  pods: [Pod]
  raw: String!
  events: [Event]
}

type Account {
  delinquentAt: DateTime
  grandfatheredUntil: DateTime
  availableFeatures: AvailableFeatures
  subscription: PluralSubscription
}

type MetricResult {
  timestamp: Int
  value: String
}

type Component {
  group: String!
  kind: String!
}

input CloudSettingsAttributes {
  aws: AwsCloudAttributes
}

type DeploymentSpec {
  replicas: Int
  strategy: DeploymentStrategy
}

input RbacAttributes {
  readBindings: [PolicyBindingAttributes]
  writeBindings: [PolicyBindingAttributes]
}

input GitRefAttributes {
  ref: String!
  folder: String!
}

type ConfigurationOverlaySpec {
  name: String
  folder: String
  subfolder: String
  documentation: String
  updates: [OverlayUpdate]
  inputType: String
  inputValues: [String]
}

type LoadBalancerStatus {
  ingress: [LoadBalancerIngressStatus]
}

type ContainerStatus {
  restartCount: Int
  ready: Boolean
  name: String
  image: String
  state: ContainerState
}

input ServiceDeploymentAttributes {
  name: String!
  namespace: String!
  version: String
  repositoryId: ID!
  git: GitRefAttributes!
  configuration: [ConfigAttributes]
  readBindings: [PolicyBindingAttributes]
  writeBindings: [PolicyBindingAttributes]
}

input ConfigAttributes {
  name: String!
  value: String!
}

input ContextAttributes {
  buckets: [String]
  domain: [String]
  configuration: Map!
  protect: [String]
}

type IngressTls {
  hosts: [String]
}

input TaintAttributes {
  key: String!
  value: String!
  effect: String!
}

type PostgresqlSpec {
  teamId: String
  users: Map
  resources: Resources
  postgresql: PostgresSettings
  numberOfInstances: Int
  databases: Map
  volume: DatabaseVolume
  pods: [Pod]
}

type NodeStatus {
  allocatable: Map
  capacity: Map
  phase: String
  conditions: [NodeCondition]
}

type IngressSpec {
  rules: [IngressRule]
  tls: [IngressTls]
}

type DeploymentStatus {
  availableReplicas: Int
  replicas: Int
  readyReplicas: Int
  unavailableReplicas: Int
}

input InviteAttributes {
  email: String
}

input BindingAttributes {
  id: ID
  userId: ID
  groupId: ID
}

input BuildAttributes {
  repository: String!
  type: BuildType
  message: String
}

input DeploymentSettingsAttributes {
  artifactRepositoryId: ID
  deployerRepositoryId: ID
  readBindings: [PolicyBindingAttributes]
  writeBindings: [PolicyBindingAttributes]
  gitBindings: [PolicyBindingAttributes]
  createBindings: [PolicyBindingAttributes]
}

type CronJob {
  metadata: Metadata!
  status: CronStatus!
  spec: CronSpec!
  raw: String!
  events: [Event]
  jobs: [Job]
}

type ClusterProvider {
  id: ID!
  name: String!
  namespace: String!
  cloud: String!
  git: GitRef!
  repository: GitRepository
  service: ServiceDeployment
  editable: Boolean
  insertedAt: DateTime
  updatedAt: DateTime
}

type PodDelta {
  delta: Delta
  payload: Pod
}

"supported kubernetes objects fetchable in runbooks"
union KubernetesData = Deployment | StatefulSet

type Smtp {
  server: String
  port: Int
  password: String
  sender: String
  user: String
}

type LoginInfo {
  oidcUri: String
}

type ClusterInfo {
  gitCommit: String
  gitVersion: String
  platform: String
  version: String
}

type ServiceConfiguration {
  name: String!
  value: String!
}

type RootSubscriptionType {
  applicationDelta: ApplicationDelta
  podDelta: PodDelta
  buildDelta(buildId: ID): BuildDelta
  commandDelta(buildId: ID!): CommandDelta
  notificationDelta: NotificationDelta
}

type ClusterConnection {
  pageInfo: PageInfo!
  edges: [ClusterEdge]
}

type RepositoryConnection {
  pageInfo: PageInfo!
  edges: [RepositoryEdge]
}

type WebhookConnection {
  pageInfo: PageInfo!
  edges: [WebhookEdge]
}

type ConfigurationValidation {
  type: String
  regex: String
  message: String
}

type InstallationConnection {
  pageInfo: PageInfo!
  edges: [InstallationEdge]
}

type PodCondition {
  lastProbeTime: String
  lastTransitionTime: String
  message: String
  reason: String
  status: String
  type: String
}

type GroupConnection {
  pageInfo: PageInfo!
  edges: [GroupEdge]
}

type RoleConnection {
  pageInfo: PageInfo!
  edges: [RoleEdge]
}

type RunbookExecution {
  id: ID!
  name: String!
  namespace: String!
  context: Map!
  user: User
  insertedAt: DateTime
  updatedAt: DateTime
}

type ConfigurationItem {
  name: String
  type: String
  placeholder: String
  documentation: String
  default: String
  optional: Boolean
  condition: ConfigurationCondition
  validation: ConfigurationValidation
}

type LogStream {
  stream: Map
  values: [MetricResult]
}

type ApplicationInfoItem {
  type: String
  name: String
  value: String
}

type LogLabel {
  name: String
  value: String
}

type ManifestNetwork {
  pluralDns: Boolean
  subdomain: String
}

type Webhook {
  id: ID!
  url: String!
  health: WebhookHealth!
  type: WebhookType!
  insertedAt: DateTime
  updatedAt: DateTime
}

type Runbook {
  name: String!
  spec: RunbookSpec!
  status: RunbookStatus
  data(context: RunbookContext): [RunbookData]
  executions(after: String, first: Int, before: String, last: Int): RunbookExecutionConnection
}

enum Severity {
  NONE
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

type Repository {
  id: ID!
  name: String!
  description: String
  icon: String
  docs: [FileContent]
  configuration: Configuration
  grafanaDns: String
}

type DeploymentStrategy {
  type: String
  rollingUpdate: RollingUpdate
}

type DashboardGraph {
  name: String!
  queries: [DashboardMetric]
  format: String
}

type IngressPath {
  backend: IngressBackend
  path: String
}

input ClusterPing {
  currentVersion: String!
}

type PolicyBinding {
  id: ID
  user: User
  group: Group
}

type LicenseFeature {
  name: String!
  description: String
}

type ClusterProviderEdge {
  node: ClusterProvider
  cursor: String
}

type IngressRule {
  host: String
  http: HttpIngressRule
}

type Service {
  metadata: Metadata!
  status: ServiceStatus!
  spec: ServiceSpec!
  pods: [Pod]
  raw: String!
  events: [Event]
}

type License {
  metadata: Metadata!
  spec: LicenseSpec!
  status: LicenseStatus
}

type Node {
  status: NodeStatus!
  spec: NodeSpec!
  metadata: Metadata!
  raw: String!
  pods: [Pod]
  events: [Event]
}

type Invite {
  secureId: String!
  email: String
}

type PodEdge {
  node: Pod
  cursor: String
}

type PrometheusDatasource {
  query: String!
  format: String
  legend: String
}

type Recipe {
  id: ID!
  name: String!
  description: String
  provider: String
  restricted: Boolean
  recipeSections: [RecipeSection]
  oidcEnabled: Boolean
}

enum BuildType {
  DEPLOY
  BOUNCE
  APPROVAL
  INSTALL
  DESTROY
  DEDICATED
  CONFIG
}

type AuditEdge {
  node: Audit
  cursor: String
}

type KubernetesDatasource {
  resource: String!
  name: String!
}

type RunbookActionResponse {
  redirectTo: String
}

type Role {
  id: ID!
  name: String!
  description: String
  repositories: [String]
  permissions: [Permission]
  roleBindings: [RoleBinding]
  insertedAt: DateTime
  updatedAt: DateTime
}

type CrossVersionResourceTarget {
  apiVersion: String
  kind: String
  name: String
}

type PluralManifest {
  network: ManifestNetwork
  bucketPrefix: String
  cluster: String
}

input RunbookContext {
  timeseriesStart: Int
  timeseriesStep: String
}

type ServicePort {
  name: String
  protocol: String
  port: Int
  targetPort: String
}

type Deployment {
  metadata: Metadata!
  status: DeploymentStatus!
  spec: DeploymentSpec!
  pods: [Pod]
  raw: String!
  events: [Event]
}

type AccessTokenAudit {
  id: ID
  ip: String
  timestamp: DateTime
  count: Int
  city: String
  country: String
  latitude: String
  longitude: String
  insertedAt: DateTime
  updatedAt: DateTime
}

type Build {
  id: ID!
  repository: String!
  type: BuildType!
  status: Status!
  message: String
  completedAt: DateTime
  sha: String
  commands(after: String, first: Int, before: String, last: Int): CommandConnection
  creator: User
  approver: User
  changelogs: [Changelog]
  insertedAt: DateTime
  updatedAt: DateTime
}

type Command {
  id: ID!
  command: String!
  exitCode: Int
  stdout: String
  completedAt: DateTime
  build: Build
  insertedAt: DateTime
  updatedAt: DateTime
}

type CostAnalysis {
  minutes: Float
  cpuCost: Float
  cpuEfficiency: Float
  efficiency: Float
  gpuCost: Float
  networkCost: Float
  pvCost: Float
  ramCost: Float
  ramEfficiency: Float
  totalCost: Float
  sharedCost: Float
}

type ApplicationSpec {
  descriptor: ApplicationDescriptor!
  components: [Component]
  info: [ApplicationInfoItem]
}

type AvailableFeatures {
  vpn: Boolean
  audits: Boolean
  userManagement: Boolean
  databaseManagement: Boolean
}

type DashboardMetric {
  legend: String
  query: String
  results: [MetricResult]
}

type NodeSpec {
  podCidr: String
  providerId: String
  unschedulable: Boolean
}

type LicenseSpec {
  secretRef: SecretKeySelector!
}

input UserAttributes {
  name: String
  email: String
  password: String
  roles: UserRoleAttributes
}

type VerticalPodAutoscalerSpec {
  targetRef: CrossVersionResourceTarget!
  updatePolicy: VerticalPodAutoscalerUpdatePolicy!
}

type ContainerResources {
  cpu: String
  memory: String
}

type CertificateStatus {
  conditions: [StatusCondition]
  notAfter: String
  notBefore: String
  renewalTime: String
}

type CertificateSpec {
  dnsNames: [String]
  secretName: String!
  issuerRef: IssuerRef
}

type JobSpec {
  backoffLimit: Int
  parallelism: Int
  activeDeadlineSeconds: Int
}

input NodePoolAttributes {
  name: String!
  minSize: Int!
  maxSize: Int!
  instanceType: String!
  labels: Map
  taints: [TaintAttributes]
  cloudSettings: CloudSettingsAttributes
}

type RunbookStatus {
  alerts: [RunbookAlertStatus]
}

type NamespaceStatus {
  phase: String
}

type PodStatus {
  message: String
  phase: String
  hostIp: String
  podIp: String
  reason: String
  conditions: [PodCondition]
  containerStatuses: [ContainerStatus]
  initContainerStatuses: [ContainerStatus]
}

type GitStatus {
  cloned: Boolean
  output: String
}

type CronSpec {
  schedule: String!
  suspend: Boolean
  concurrencyPolicy: String
}

type Cluster {
  id: ID!
  name: String!
  version: String!
  currentVersion: String
  deletedAt: DateTime
  pingedAt: DateTime
  readBindings: [PolicyBinding]
  writeBindings: [PolicyBinding]
  nodePools: [NodePool]
  provider: ClusterProvider
  service: ServiceDeployment
  editable: Boolean
  insertedAt: DateTime
  updatedAt: DateTime
}

type WireguardPeer {
  metadata: Metadata!
  status: WireguardPeerStatus
  spec: WireguardPeerSpec!
  config: String
  user: User
  raw: String!
}

type Container {
  image: String
  name: String
  ports: [Port]
  resources: Resources
}

type GroupMember {
  id: ID!
  user: User
  group: Group
  insertedAt: DateTime
  updatedAt: DateTime
}

type ApplicationDescriptor {
  type: String!
  version: String!
  description: String
  icons: [String]
  links: [ApplicationLink]
}

enum Delta {
  CREATE
  UPDATE
  DELETE
}

type ApplicationDelta {
  delta: Delta
  payload: Application
}

type RootMutationType {
  createBuild(attributes: BuildAttributes!): Build
  restartBuild(id: ID!): Build
  cancelBuild(id: ID!): Build
  approveBuild(id: ID!): Build
  signIn(email: String!, password: String!): User
  loginLink(key: String!): User
  readNotifications: User
  signup(inviteId: String!, attributes: UserAttributes!): User
  oauthCallback(code: String!, redirect: String): User
  createInvite(attributes: InviteAttributes!): Invite
  updateUser(id: ID, attributes: UserAttributes!): User
  deleteUser(id: ID!): User
  markRead(type: ReadType): User
  createGroup(attributes: GroupAttributes!): Group
  deleteGroup(groupId: ID!): Group
  updateGroup(groupId: ID!, attributes: GroupAttributes!): Group
  createGroupMember(groupId: ID!, userId: ID!): GroupMember
  deleteGroupMember(groupId: ID!, userId: ID!): GroupMember
  createRole(attributes: RoleAttributes!): Role
  updateRole(id: ID!, attributes: RoleAttributes!): Role
  deleteRole(id: ID!): Role
  createAccessToken: AccessToken
  deleteAccessToken(token: String!): AccessToken
  deleteCertificate(name: String!, namespace: String!): Boolean
  deletePod(namespace: String!, name: String!): Pod
  deleteJob(namespace: String!, name: String!): Job
  deleteNode(name: String!): Node
  overlayConfiguration(namespace: String!, context: Map!): Build
  createPeer(userId: ID, email: String, name: String!): WireguardPeer
  deletePeer(name: String!): Boolean
  installRecipe(id: ID!, context: Map!, oidc: Boolean): Build
  installStack(name: String!, context: ContextAttributes!, oidc: Boolean): Build
  updateSmtp(smtp: SmtpInput!): Smtp
  updateConfiguration(repository: String!, content: String!, tool: Tool, message: String): Configuration
  createUpgradePolicy(attributes: UpgradePolicyAttributes!): UpgradePolicy
  deleteUpgradePolicy(id: ID!): UpgradePolicy
  executeRunbook(namespace: String!, name: String!, input: RunbookActionInput!): RunbookActionResponse
  createWebhook(attributes: WebhookAttributes!): Webhook
  deleteWebhook(id: ID!): Webhook
  restorePostgres(namespace: String!, name: String!, timestamp: DateTime!, clone: CloneAttributes): Postgresql
  createGitRepository(attributes: GitAttributes!): GitRepository
  createCluster(attributes: ClusterAttributes!): Cluster
  updateCluster(id: ID!, attributes: ClusterUpdateAttributes!): Cluster
  deleteCluster(id: ID!): Cluster
  createClusterProvider(attributes: ClusterProviderAttributes!): ClusterProvider
  updateClusterProvider(id: ID!, attributes: ClusterProviderUpdateAttributes!): ClusterProvider
  createServiceDeployment(clusterId: ID!, attributes: ServiceDeploymentAttributes!): ServiceDeployment
  updateServiceDeployment(id: ID!, attributes: ServiceUpdateAttributes!): ServiceDeployment
  deleteServiceDeployment(id: ID!): ServiceDeployment
  rollbackService(id: ID!, revisionId: ID!): ServiceDeployment
  pingCluster(attributes: ClusterPing!): Cluster
  updateServiceComponents(id: ID!, components: [ComponentAttributes]): ServiceDeployment
  updateRbac(rbac: RbacAttributes!, serviceId: ID, clusterId: ID, providerId: ID): Boolean
  updateDeploymentSettings(attributes: DeploymentSettingsAttributes!): DeploymentSettings
}

type PodConnection {
  pageInfo: PageInfo!
  edges: [PodEdge]
}

type AccessToken {
  id: ID
  token: String
  audits(after: String, first: Int, before: String, last: Int): AccessTokenAuditConnection
  insertedAt: DateTime
  updatedAt: DateTime
}

type Revision {
  id: ID!
  version: String!
  git: GitRef!
  sha: String
  insertedAt: DateTime
  updatedAt: DateTime
}

type Installation {
  id: ID!
  repository: Repository
}

type Configuration {
  terraform: String
  helm: String
}

type ClusterProviderConnection {
  pageInfo: PageInfo!
  edges: [ClusterProviderEdge]
}

type Notification {
  id: ID!
  title: String!
  description: String
  fingerprint: String!
  status: NotificationStatus
  labels: Map
  annotations: Map
  repository: String!
  seenAt: DateTime
  severity: Severity
  insertedAt: DateTime
  updatedAt: DateTime
}

type AuditConnection {
  pageInfo: PageInfo!
  edges: [AuditEdge]
}

type ConfigurationCondition {
  field: String
  value: String
  operation: String
}

type Recommendation {
  containerRecommendations: [ContainerRecommendation]
}

type Postgresql {
  metadata: Metadata!
  spec: PostgresqlSpec!
  status: PostgresqlStatus
  instances: [PostgresInstance]
}

enum Tool {
  HELM
  TERRAFORM
}

type ApplicationLink {
  url: String
  description: String
}

type Stack {
  id: ID!
  name: String!
  bundles: [Recipe]
  sections: [RecipeSection]
  insertedAt: DateTime
  updatedAt: DateTime
}

type UpgradePolicy {
  id: ID!
  name: String!
  description: String
  repositories: [String]
  type: UpgradePolicyType!
  target: String!
  weight: Int
  insertedAt: DateTime
  updatedAt: DateTime
}

type RootQueryType {
  configuration: ConsoleConfiguration
  externalToken: String
  builds(after: String, first: Int, before: String, last: Int): BuildConnection
  build(id: ID!): Build
  buildInfo: BuildInfo
  users(after: String, first: Int, before: String, last: Int, q: String): UserConnection
  loginInfo(redirect: String): LoginInfo
  me: User
  invite(id: String!): Invite
  groups(after: String, first: Int, before: String, last: Int, q: String): GroupConnection
  groupMembers(after: String, first: Int, before: String, last: Int, groupId: ID!): GroupMemberConnection
  role: Role
  roles(after: String, first: Int, before: String, last: Int, q: String): RoleConnection
  notifications(after: String, first: Int, before: String, last: Int, all: Boolean): NotificationConnection
  temporaryToken: String
  accessTokens(after: String, first: Int, before: String, last: Int): AccessTokenConnection
  accessToken(id: ID!): AccessToken
  dashboards(repo: String!): [Dashboard]
  dashboard(repo: String!, name: String!, step: String, offset: Int, labels: [LabelInput]): Dashboard
  metric(query: String!, offset: Int, step: String): [MetricResponse]
  logs(query: String!, start: Long, end: Long, limit: Int!): [LogStream]
  scalingRecommendation(kind: AutoscalingTarget!, namespace: String!, name: String!): VerticalPodAutoscaler
  configMap(namespace: String!, name: String!): ConfigMap
  secret(namespace: String!, name: String!): Secret
  configMaps(namespace: String!): [ConfigMap]
  secrets(namespace: String!): [Secret]
  service(namespace: String!, name: String!): Service
  clusterInfo: ClusterInfo
  deployment(namespace: String!, name: String!): Deployment
  statefulSet(namespace: String!, name: String!): StatefulSet
  ingress(namespace: String!, name: String!): Ingress
  nodes: [Node]
  node(name: String!): Node
  cronJob(namespace: String!, name: String!): CronJob
  job(namespace: String!, name: String!): Job
  certificate(namespace: String!, name: String!): Certificate
  pod(namespace: String!, name: String!): Pod
  pods(after: String, first: Int, before: String, last: Int, namespaces: [String]): PodConnection
  wireguardPeers: [WireguardPeer]
  myWireguardPeers: [WireguardPeer]
  wireguardPeer(name: String!): WireguardPeer
  cachedPods(namespaces: [String]): [Pod]
  namespaces: [Namespace]
  logFilters(namespace: String!): [LogFilter]
  nodeMetrics: [NodeMetric]
  nodeMetric(name: String!): NodeMetric
  configurationOverlays(namespace: String!): [ConfigurationOverlay]
  audits(after: String, first: Int, before: String, last: Int, repo: String): AuditConnection
  auditMetrics: [AuditMetric]
  ai(prompt: String!): String
  account: Account
  installations(after: String, first: Int, before: String, last: Int): InstallationConnection
  applications: [Application]
  application(name: String!): Application
  repository(name: String!): Repository
  repositories(after: String, first: Int, before: String, last: Int, query: String!): RepositoryConnection
  recipes(after: String, first: Int, before: String, last: Int, id: ID!): RecipeConnection
  context: [RepositoryContext]
  pluralContext: PluralContext
  recipe(id: ID!): Recipe
  stack(name: String!): Stack
  smtp: Smtp
  upgradePolicies: [UpgradePolicy]
  runbook(namespace: String!, name: String!): Runbook
  runbooks(namespace: String!, pinned: Boolean): [Runbook]
  webhooks(after: String, first: Int, before: String, last: Int): WebhookConnection
  postgresDatabases: [Postgresql]
  postgresDatabase(namespace: String!, name: String!): Postgresql
  gitRepositories(after: String, first: Int, before: String, last: Int): GitRepositoryConnection
  clusters(after: String, first: Int, before: String, last: Int): ClusterConnection
  clusterProviders(after: String, first: Int, before: String, last: Int): ClusterProviderConnection
  cluster(id: ID): Cluster
  clusterProvider(id: ID!): ClusterProvider
  serviceDeployments(after: String, first: Int, before: String, last: Int, clusterId: ID): ServiceDeploymentConnection
  serviceDeployment(id: ID!): ServiceDeployment
  clusterServices: [ServiceDeployment]
  deploymentSettings: DeploymentSettings
}

type RoleBinding {
  id: ID!
  user: User
  group: Group
  insertedAt: DateTime
  updatedAt: DateTime
}

type GitRef {
  ref: String!
  folder: String!
}

type IssuerRef {
  group: String
  kind: String
  name: String
}

type RunbookDatasource {
  name: String!
  type: String!
  prometheus: PrometheusDatasource
  kubernetes: KubernetesDatasource
}

type CommandEdge {
  node: Command
  cursor: String
}

type RunbookExecutionEdge {
  node: RunbookExecution
  cursor: String
}

type Namespace {
  status: NamespaceStatus!
  spec: NamespaceSpec!
  metadata: Metadata!
  raw: String!
  events: [Event]
}

type GitRepositoryEdge {
  node: GitRepository
  cursor: String
}

enum AuditType {
  BUILD
  POD
  CONFIGURATION
  USER
  GROUP
  ROLE
  GROUP_MEMBER
  POLICY
  TEMP_TOKEN
  SERVICE
  CLUSTER
  CLUSTER_PROVIDER
  GIT_REPOSITORY
  DEPLOYMENT_SETTINGS
}

type MetricResponse {
  metric: Map
  values: [MetricResult]
}

enum ReadType {
  NOTIFICATION
  BUILD
}

type BuildEdge {
  node: Build
  cursor: String
}

type RecipeEdge {
  node: Recipe
  cursor: String
}

enum ComponentState {
  RUNNING
  PENDING
  FAILED
}

type RunningState {
  startedAt: String
}

type WaitingState {
  message: String
  reason: String
}

"""
The `DateTime` scalar type represents a date and time in the UTC
timezone. The DateTime appears in a JSON response as an ISO8601 formatted
string, including UTC timezone ("Z"). The parsed date and time string will
be converted to UTC if there is an offset.
"""
scalar DateTime

type GroupMemberEdge {
  node: GroupMember
  cursor: String
}

type JobReference {
  name: String!
  namespace: String!
}

type AccessTokenAuditEdge {
  node: AccessTokenAudit
  cursor: String
}

type ServiceDeploymentEdge {
  node: ServiceDeployment
  cursor: String
}

type IngressBackend {
  serviceName: String
  servicePort: String
}

type Pod {
  status: PodStatus!
  spec: PodSpec!
  metadata: Metadata!
  raw: String!
  events: [Event]
}

type PluralContext {
  buckets: [String]
  domains: [String]
  configuration: Map!
}

type Port {
  hostPort: Int
  containerPort: Int
  protocol: String
}

type Taint {
  key: String!
  value: String!
  effect: String!
}

type AwsCloud {
  launchTemplateId: String
}

type Event {
  action: String
  count: Int
  eventTime: String
  lastTimestamp: String
  message: String
  reason: String
  type: String
}

input ComponentAttributes {
  state: ComponentState
  synced: Boolean!
  group: String!
  version: String!
  kind: String!
  namespace: String!
  name: String!
}

input ClusterUpdateAttributes {
  version: String!
  nodePools: [NodePoolAttributes]
  readBindings: [PolicyBindingAttributes]
  writeBindings: [PolicyBindingAttributes]
}

input CloudProviderSettingsAttributes {
  aws: AwsSettingsAttributes
  gcp: GcpSettingsAttributes
}

input GcpSettingsAttributes {
  applicationCredentials: String!
}

type LicenseStatus {
  plan: String
  free: Boolean
  features: [LicenseFeature]
  limits: Map
  secrets: Map
}

input PolicyBindingAttributes {
  id: ID
  userId: ID
  groupId: ID
}

type ApplicationStatus {
  components: [StatusComponent]
  conditions: [StatusCondition]
  componentsReady: String!
}

type DeploymentSettings {
  id: ID!
  name: String!
  artifactRepository: GitRepository
  deployerRepository: GitRepository
  readBindings: [PolicyBinding]
  writeBindings: [PolicyBinding]
  gitBindings: [PolicyBinding]
  createBindings: [PolicyBinding]
  insertedAt: DateTime
  updatedAt: DateTime
}

input ClusterAttributes {
  name: String!
  providerId: ID
  version: String!
  nodePools: [NodePoolAttributes]
  readBindings: [PolicyBindingAttributes]
  writeBindings: [PolicyBindingAttributes]
}

type CloudSettings {
  aws: AwsCloud
}

type PostgresSettings {
  version: String
}

type RunbookSpec {
  name: String!
  description: String
  display: Map
  datasources: [RunbookDatasource]
  actions: [RunbookAction]
}

type Ingress {
  metadata: Metadata!
  status: ServiceStatus!
  spec: IngressSpec!
  certificates: [Certificate]
  raw: String!
  events: [Event]
}

input UserRoleAttributes {
  admin: Boolean
}

input AwsCloudAttributes {
  launchTemplateId: String
}

input GitAttributes {
  url: String!
  privateKey: String
  passphrase: String
  username: String
  password: String
}

type DashboardSpec {
  name: String
  description: String
  timeslices: [String]
  labels: [DashboardLabel]
  graphs: [DashboardGraph]
}

input AwsSettingsAttributes {
  accessKeyId: String!
  secretAccessKey: String!
}

input UpgradePolicyAttributes {
  name: String!
  description: String
  target: String!
  type: UpgradePolicyType!
  repositories: [String]
  weight: Int
}

type AuditMetric {
  country: String
  count: Int
}

input ServiceUpdateAttributes {
  version: String
  git: GitRefAttributes!
  configuration: [ConfigAttributes]
}

input CloneAttributes {
  s3AccessKeyId: String
  s3SecretAccessKey: String
  s3WalPath: String
  s3Endpoint: String
  uid: String
}

input WebhookAttributes {
  url: String!
}

input GroupAttributes {
  name: String!
  description: String
}

input RoleAttributes {
  name: String
  description: String
  repositories: [String]
  roleBindings: [BindingAttributes]
  permissions: [Permission]
}

type Job {
  metadata: Metadata!
  status: JobStatus!
  spec: JobSpec!
  raw: String!
  events: [Event]
  pods: [Pod]
}

type LogFilter {
  metadata: Metadata!
  spec: LogFilterSpec!
}

type Metadata {
  labels: [LabelPair]
  annotations: [LabelPair]
  name: String!
  namespace: String
  creationTimestamp: String
}

type BuildInfo {
  all: Int
  failed: Int
  queued: Int
  running: Int
  successful: Int
}

type NodeCondition {
  message: String
  reason: String
  status: String
  type: String
}

type GroupMemberConnection {
  pageInfo: PageInfo!
  edges: [GroupMemberEdge]
}

type ContainerRecommendation {
  name: String
  containerName: String
  target: ContainerResources
  lowerBound: ContainerResources
  upperBound: ContainerResources
  uncappedTarget: ContainerResources
}

type ServiceDeploymentConnection {
  pageInfo: PageInfo!
  edges: [ServiceDeploymentEdge]
}

type GitRepositoryConnection {
  pageInfo: PageInfo!
  edges: [GitRepositoryEdge]
}

enum Permission {
  READ
  CONFIGURE
  DEPLOY
  OPERATE
}

type RunbookExecutionConnection {
  pageInfo: PageInfo!
  edges: [RunbookExecutionEdge]
}

type PluralSubscription {
  id: ID
  plan: Plan
}

type AccessTokenAuditConnection {
  pageInfo: PageInfo!
  edges: [AccessTokenAuditEdge]
}

type ConsoleConfiguration {
  gitCommit: String
  isDemoProject: Boolean
  isSandbox: Boolean
  pluralLogin: Boolean
  vpnEnabled: Boolean
  features: AvailableFeatures
  manifest: PluralManifest
  gitStatus: GitStatus
}

type CommandConnection {
  pageInfo: PageInfo!
  edges: [CommandEdge]
}

type RecipeConnection {
  pageInfo: PageInfo!
  edges: [RecipeEdge]
}

type BuildConnection {
  pageInfo: PageInfo!
  edges: [BuildEdge]
}

type NodePool {
  id: ID!
  name: String!
  minSize: Int!
  maxSize: Int!
  instanceType: String!
  labels: Map
  taints: [Taint]
  cloudSettings: CloudSettings
  insertedAt: DateTime
  updatedAt: DateTime
}

type VerticalPodAutoscalerUpdatePolicy {
  updateMode: String
}

type ConfigurationOverlay {
  metadata: Metadata!
  spec: ConfigurationOverlaySpec!
}

type GitRepository {
  id: ID!
  url: String!
  authMethod: AuthMethod
  health: GitHealth
  pulledAt: DateTime
  editable: Boolean
  insertedAt: DateTime
  updatedAt: DateTime
}

enum GitHealth {
  PULLABLE
  FAILED
}

enum WebhookHealth {
  HEALTHY
  UNHEALTHY
}

scalar Long

enum UpgradePolicyType {
  DEPLOY
  APPROVAL
  IGNORE
}

type RevisionEdge {
  node: Revision
  cursor: String
}

type DatabaseVolume {
  size: String
}

enum WebhookType {
  PIAZZA
  SLACK
}

type Certificate {
  metadata: Metadata!
  status: CertificateStatus!
  spec: CertificateSpec!
  raw: String!
  events: [Event]
}

type AccessTokenEdge {
  node: AccessToken
  cursor: String
}

type RollingUpdate {
  maxSurge: Int
  maxUnavailable: Int
}

type NotificationEdge {
  node: Notification
  cursor: String
}

type HttpIngressRule {
  paths: [IngressPath]
}

type TerminatedState {
  exitCode: Int
  finishedAt: String
  startedAt: String
  message: String
  reason: String
}

type PathUpdate {
  path: [String]
  valueFrom: String!
}

type UserEdge {
  node: User
  cursor: String
}

type ContainerState {
  running: RunningState
  terminated: TerminatedState
  waiting: WaitingState
}

type RepositoryContext {
  repository: String!
  context: Map
}

type Audit {
  id: ID!
  action: AuditAction!
  type: AuditType!
  repository: String
  ip: String
  city: String
  country: String
  latitude: String
  longitude: String
  actor: User
  insertedAt: DateTime
  updatedAt: DateTime
}

input LabelInput {
  name: String
  value: String
}

input RunbookActionInput {
  action: String!
  context: Map!
}

type Secret {
  metadata: Metadata!
  type: String
  data: Map!
}

type Dashboard {
  id: String!
  spec: DashboardSpec!
}

type LoadBalancerIngressStatus {
  hostname: String
  ip: String
}

type PostgresqlStatus {
  clusterStatus: String
}

type VerticalPodAutoscalerStatus {
  recommendation: Recommendation
}

type Resources {
  limits: ResourceSpec
  requests: ResourceSpec
}

enum NotificationStatus {
  FIRING
  RESOLVED
}

type UserRoles {
  admin: Boolean
}

type WireguardPeerStatus {
  ready: Boolean
  conditions: [StatusCondition]
}

type WireguardPeerSpec {
  wireguardRef: String
  address: String
  publicKey: String
}

type PodSpec {
  serviceAccountName: String
  nodeName: String
  containers: [Container]
  initContainers: [Container]
}

enum Status {
  QUEUED
  RUNNING
  SUCCESSFUL
  FAILED
  CANCELLED
  PENDING
}

input ClusterProviderAttributes {
  name: String!
  namespace: String
  cloud: String
  cloudSettings: CloudProviderSettingsAttributes
}

input ClusterProviderUpdateAttributes {
  cloudSettings: CloudProviderSettingsAttributes
}

type RunbookAlertStatus {
  name: String!
  startsAt: String
  fingerprint: String
  annotations: Map
  labels: Map
}

type NamespaceSpec {
  finalizers: [String]
}

type CronStatus {
  active: [JobReference]
  lastScheduleTime: String
}

type ServiceStatus {
  loadBalancer: LoadBalancerStatus
}

type StatefulSetStatus {
  currentReplicas: Int
  replicas: Int
  readyReplicas: Int
  updatedReplicas: Int
}

type StatefulSetSpec {
  replicas: Int
  serviceName: String
}

type ResourceSpec {
  cpu: String
  memory: String
}

type JobStatus {
  active: Int
  completionTime: String
  startTime: String
  succeeded: Int
  failed: Int
}

type LogFilterSpec {
  name: String
  description: String
  query: String
  labels: [LogLabel]
}

type NodeMetric {
  metadata: Metadata!
  timestamp: String
  window: String
  usage: NodeUsage
}

type ServiceSpec {
  type: String
  clusterIp: String
  selector: Map
  ports: [ServicePort]
}

type VerticalPodAutoscaler {
  metadata: Metadata!
  spec: VerticalPodAutoscalerSpec!
  status: VerticalPodAutoscalerStatus
}

type SecretKeySelector {
  name: String!
  key: String
}

type User {
  id: ID!
  name: String!
  email: String!
  deletedAt: DateTime
  profile: String
  pluralId: String
  roles: UserRoles
  readTimestamp: DateTime
  buildTimestamp: DateTime
  boundRoles: [Role]
  jwt: String
  unreadNotifications: Int
  backgroundColor: String
  insertedAt: DateTime
  updatedAt: DateTime
}

type LabelPair {
  name: String
  value: String
}

type RunbookData {
  name: String!
  source: RunbookDatasource
  kubernetes: KubernetesData
  prometheus: [MetricResponse]
  nodes: [Node]
}

type BuildDelta {
  delta: Delta
  payload: Build
}

type CommandDelta {
  delta: Delta
  payload: Command
}

type NotificationDelta {
  delta: Delta
  payload: Notification
}

type ConfigMap {
  metadata: Metadata!
  data: Map!
  raw: String!
}

type Group {
  id: ID!
  name: String!
  description: String
  insertedAt: DateTime
  updatedAt: DateTime
}

scalar Map
