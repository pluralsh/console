/* eslint-disable */
/* prettier-ignore */
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /**
   * The `DateTime` scalar type represents a date and time in the UTC
   * timezone. The DateTime appears in a JSON response as an ISO8601 formatted
   * string, including UTC timezone ("Z"). The parsed date and time string will
   * be converted to UTC if there is an offset.
   */
  DateTime: { input: string; output: string; }
  Json: { input: unknown; output: unknown; }
  Long: { input: any; output: any; }
  Map: { input: Record<string, unknown>; output: Record<string, unknown>; }
};

export type AccessToken = {
  __typename?: 'AccessToken';
  audits?: Maybe<AccessTokenAuditConnection>;
  id?: Maybe<Scalars['ID']['output']>;
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  scopes?: Maybe<Array<Maybe<AccessTokenScope>>>;
  token?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};


export type AccessTokenAuditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type AccessTokenAudit = {
  __typename?: 'AccessTokenAudit';
  city?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  country?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  ip?: Maybe<Scalars['String']['output']>;
  latitude?: Maybe<Scalars['String']['output']>;
  longitude?: Maybe<Scalars['String']['output']>;
  timestamp?: Maybe<Scalars['DateTime']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type AccessTokenAuditConnection = {
  __typename?: 'AccessTokenAuditConnection';
  edges?: Maybe<Array<Maybe<AccessTokenAuditEdge>>>;
  pageInfo: PageInfo;
};

export type AccessTokenAuditEdge = {
  __typename?: 'AccessTokenAuditEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<AccessTokenAudit>;
};

export type AccessTokenConnection = {
  __typename?: 'AccessTokenConnection';
  edges?: Maybe<Array<Maybe<AccessTokenEdge>>>;
  pageInfo: PageInfo;
};

export type AccessTokenEdge = {
  __typename?: 'AccessTokenEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<AccessToken>;
};

export type AccessTokenScope = {
  __typename?: 'AccessTokenScope';
  api?: Maybe<Scalars['String']['output']>;
  apis?: Maybe<Array<Scalars['String']['output']>>;
  identifier?: Maybe<Scalars['String']['output']>;
  ids?: Maybe<Array<Scalars['String']['output']>>;
};

export type Account = {
  __typename?: 'Account';
  availableFeatures?: Maybe<AvailableFeatures>;
  delinquentAt?: Maybe<Scalars['DateTime']['output']>;
  grandfatheredUntil?: Maybe<Scalars['DateTime']['output']>;
  subscription?: Maybe<PluralSubscription>;
};

/** a condition that determines whether its configuration is viewable */
export type AddOnConfigCondition = {
  __typename?: 'AddOnConfigCondition';
  /** the field this condition applies to */
  field?: Maybe<Scalars['String']['output']>;
  /** the operation for this condition, eg EQ, LT, GT */
  operation?: Maybe<Scalars['String']['output']>;
  /** the value to apply the condition with, for binary operators like LT/GT */
  value?: Maybe<Scalars['String']['output']>;
};

/** Input configuration for an add-on you can install */
export type AddOnConfiguration = {
  __typename?: 'AddOnConfiguration';
  condition?: Maybe<AddOnConfigCondition>;
  /** a docstring explaining this configuration */
  documentation?: Maybe<Scalars['String']['output']>;
  /** name for this configuration */
  name?: Maybe<Scalars['String']['output']>;
  /** a type for the configuration (should eventually be coerced back to string) */
  type?: Maybe<Scalars['String']['output']>;
  /** the values for ENUM type conditions */
  values?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** the specification of a runtime service at a specific version */
export type AddonVersion = {
  __typename?: 'AddonVersion';
  /** checks if this is blocking a specific kubernetes upgrade */
  blocking?: Maybe<Scalars['Boolean']['output']>;
  /** the version of the helm chart to install for this version */
  chartVersion?: Maybe<Scalars['String']['output']>;
  /** any add-ons this might break */
  incompatibilities?: Maybe<Array<Maybe<VersionReference>>>;
  /** kubernetes versions this add-on works with */
  kube?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** the release page for a runtime service at a version, this is a heavy operation not suitable for lists */
  releaseUrl?: Maybe<Scalars['String']['output']>;
  /** any other add-ons this might require */
  requirements?: Maybe<Array<Maybe<VersionReference>>>;
  /** add-on version, semver formatted */
  version?: Maybe<Scalars['String']['output']>;
};


/** the specification of a runtime service at a specific version */
export type AddonVersionBlockingArgs = {
  kubeVersion: Scalars['String']['input'];
};


/** the specification of a runtime service at a specific version */
export type AddonVersionReleaseUrlArgs = {
  version: Scalars['String']['input'];
};

export type AgentAnalysis = {
  __typename?: 'AgentAnalysis';
  /** the analysis of the agent run */
  analysis: Scalars['String']['output'];
  /** quick bullet points to summarize the analysis */
  bullets?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** the summary of the analysis */
  summary: Scalars['String']['output'];
};

export type AgentAnalysisAttributes = {
  /** the analysis of the agent run */
  analysis: Scalars['String']['input'];
  /** the bullets of the analysis */
  bullets?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** the summary of the analysis */
  summary: Scalars['String']['input'];
};

export type AgentBindingAttributes = {
  /** the name of the group this binding is for */
  groupName?: InputMaybe<Scalars['String']['input']>;
  /** the email of the user this binding is for */
  userEmail?: InputMaybe<Scalars['String']['input']>;
};

export type AgentMessage = {
  __typename?: 'AgentMessage';
  /** the cost of the message */
  cost?: Maybe<AgentMessageCost>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the message to send to the agent */
  message: Scalars['String']['output'];
  /** the metadata of the message */
  metadata?: Maybe<AgentMessageMetadata>;
  /** the role of the message (system, assistant, user) */
  role: AiRole;
  /** the sequence number of the message */
  seq: Scalars['Int']['output'];
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type AgentMessageAttributes = {
  cost?: InputMaybe<AgentMessageCostAttributes>;
  /** the message to send to the agent */
  message: Scalars['String']['input'];
  metadata?: InputMaybe<AgentMessageMetadataAttributes>;
  /** the role of the message */
  role: AiRole;
};

export type AgentMessageCost = {
  __typename?: 'AgentMessageCost';
  /** the tokens of the message */
  tokens?: Maybe<AgentMessageTokens>;
  /** the total cost of the message */
  total: Scalars['Float']['output'];
};

export type AgentMessageCostAttributes = {
  /** the tokens of the message */
  tokens?: InputMaybe<AgentMessageTokensAttributes>;
  /** the total cost of the message */
  total: Scalars['Float']['input'];
};

export type AgentMessageFile = {
  __typename?: 'AgentMessageFile';
  /** the end of the file */
  end?: Maybe<Scalars['Int']['output']>;
  /** the name of the file */
  name?: Maybe<Scalars['String']['output']>;
  /** the start of the file */
  start?: Maybe<Scalars['Int']['output']>;
  /** the text of the file */
  text?: Maybe<Scalars['String']['output']>;
};

export type AgentMessageFileAttributes = {
  /** the end of the file */
  end?: InputMaybe<Scalars['Int']['input']>;
  /** the name of the file */
  name?: InputMaybe<Scalars['String']['input']>;
  /** the start of the file */
  start?: InputMaybe<Scalars['Int']['input']>;
  /** the text of the file */
  text?: InputMaybe<Scalars['String']['input']>;
};

export type AgentMessageMetadata = {
  __typename?: 'AgentMessageMetadata';
  /** the file of the message */
  file?: Maybe<AgentMessageFile>;
  /** the reasoning of the message */
  reasoning?: Maybe<AgentMessageReasoning>;
  /** the tool of the message */
  tool?: Maybe<AgentMessageTool>;
};

export type AgentMessageMetadataAttributes = {
  /** the file of the message */
  file?: InputMaybe<AgentMessageFileAttributes>;
  /** the reasoning of the message */
  reasoning?: InputMaybe<AgentMessageReasoningAttributes>;
  /** the tool of the message */
  tool?: InputMaybe<AgentMessageToolAttributes>;
};

export type AgentMessageReasoning = {
  __typename?: 'AgentMessageReasoning';
  /** the end of the reasoning */
  end?: Maybe<Scalars['Int']['output']>;
  /** the start of the reasoning */
  start?: Maybe<Scalars['Int']['output']>;
  /** the text of the reasoning */
  text?: Maybe<Scalars['String']['output']>;
};

export type AgentMessageReasoningAttributes = {
  /** the end of the reasoning */
  end?: InputMaybe<Scalars['Int']['input']>;
  /** the start of the reasoning */
  start?: InputMaybe<Scalars['Int']['input']>;
  /** the text of the reasoning */
  text?: InputMaybe<Scalars['String']['input']>;
};

export type AgentMessageTokens = {
  __typename?: 'AgentMessageTokens';
  /** the input tokens of the message */
  input?: Maybe<Scalars['Float']['output']>;
  /** the output tokens of the message */
  output?: Maybe<Scalars['Float']['output']>;
  /** the reasoning tokens of the message */
  reasoning?: Maybe<Scalars['Float']['output']>;
};

export type AgentMessageTokensAttributes = {
  /** the input tokens of the message */
  input?: InputMaybe<Scalars['Float']['input']>;
  /** the output tokens of the message */
  output?: InputMaybe<Scalars['Float']['input']>;
  /** the reasoning tokens of the message */
  reasoning?: InputMaybe<Scalars['Float']['input']>;
};

export type AgentMessageTool = {
  __typename?: 'AgentMessageTool';
  /** the name of the tool */
  name?: Maybe<Scalars['String']['output']>;
  /** the output of the tool */
  output?: Maybe<Scalars['String']['output']>;
  /** the state of the tool */
  state?: Maybe<AgentMessageToolState>;
};

export type AgentMessageToolAttributes = {
  /** the name of the tool */
  name?: InputMaybe<Scalars['String']['input']>;
  /** the output of the tool */
  output?: InputMaybe<Scalars['String']['input']>;
  /** the state of the tool */
  state?: InputMaybe<AgentMessageToolState>;
};

export enum AgentMessageToolState {
  Completed = 'COMPLETED',
  Error = 'ERROR',
  Pending = 'PENDING',
  Running = 'RUNNING'
}

/** a representation of a bulk operation to be performed on all agent services */
export type AgentMigration = {
  __typename?: 'AgentMigration';
  completed?: Maybe<Scalars['Boolean']['output']>;
  configuration?: Maybe<Scalars['Map']['output']>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  ref?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type AgentMigrationAttributes = {
  configuration?: InputMaybe<Scalars['Json']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ref?: InputMaybe<Scalars['String']['input']>;
};

export type AgentPodReference = {
  __typename?: 'AgentPodReference';
  name: Scalars['String']['output'];
  namespace: Scalars['String']['output'];
};

export type AgentPrompt = {
  __typename?: 'AgentPrompt';
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the prompt to give this agent run */
  prompt: Scalars['String']['output'];
  /** the sequence number of the prompt */
  seq: Scalars['Int']['output'];
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type AgentPullRequestAttributes = {
  /** the base branch of the pull request */
  base: Scalars['String']['input'];
  /** the body of the pull request */
  body: Scalars['String']['input'];
  /** the head branch of the pull request */
  head: Scalars['String']['input'];
  /** the repository the agent will be working in */
  repository: Scalars['String']['input'];
  /** the title of the pull request */
  title: Scalars['String']['input'];
};

export type AgentRun = {
  __typename?: 'AgentRun';
  /** the analysis of the agent run */
  analysis?: Maybe<AgentAnalysis>;
  /** the branch this agent run is operating on (if not set, use default branch on clone) */
  branch?: Maybe<Scalars['String']['output']>;
  /** the error reason of the agent run */
  error?: Maybe<Scalars['String']['output']>;
  /** the flow this agent is associated with */
  flow?: Maybe<Flow>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the messages this agent run has generated during its run */
  messages?: Maybe<Array<Maybe<AgentMessage>>>;
  /** the mode of the agent run */
  mode: AgentRunMode;
  pluralCreds?: Maybe<PluralCreds>;
  /** the kubernetes pod running this agent (should only be fetched lazily as this is a heavy operation) */
  pod?: Maybe<Pod>;
  /** the kubernetes pod this agent is running on */
  podReference?: Maybe<AgentPodReference>;
  /** the prompt this agent was given */
  prompt: Scalars['String']['output'];
  /** the prompts this agent run has received */
  prompts?: Maybe<Array<Maybe<AgentPrompt>>>;
  /** the pull requests this agent run has created */
  pullRequests?: Maybe<Array<Maybe<PullRequest>>>;
  /** the repository the agent will be working in */
  repository: Scalars['String']['output'];
  /** the runtime this agent is using */
  runtime?: Maybe<AgentRuntime>;
  scmCreds?: Maybe<ScmCreds>;
  /** whether this agent run is shared */
  shared?: Maybe<Scalars['Boolean']['output']>;
  /** the status of this agent run */
  status: AgentRunStatus;
  /** the todos of the agent run */
  todos?: Maybe<Array<Maybe<AgentTodo>>>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the user who initiated this agent run */
  user?: Maybe<User>;
};

export type AgentRunAttributes = {
  /** the flow this agent run is associated with */
  flowId?: InputMaybe<Scalars['ID']['input']>;
  /** the mode of the agent run */
  mode: AgentRunMode;
  /** the prompt to give to the agent */
  prompt: Scalars['String']['input'];
  /** the repository the agent will be working in */
  repository: Scalars['String']['input'];
};

export type AgentRunConnection = {
  __typename?: 'AgentRunConnection';
  edges?: Maybe<Array<Maybe<AgentRunEdge>>>;
  pageInfo: PageInfo;
};

export type AgentRunEdge = {
  __typename?: 'AgentRunEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<AgentRun>;
};

export enum AgentRunMode {
  Analyze = 'ANALYZE',
  Write = 'WRITE'
}

export enum AgentRunStatus {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  Pending = 'PENDING',
  Running = 'RUNNING',
  Successful = 'SUCCESSFUL'
}

export type AgentRunStatusAttributes = {
  /** the error reason of the agent run */
  error?: InputMaybe<Scalars['String']['input']>;
  /** the messages this agent run has generated during its run */
  messages?: InputMaybe<Array<InputMaybe<AgentMessageAttributes>>>;
  /** the kubernetes pod this agent is running on */
  podReference?: InputMaybe<NamespacedName>;
  /** the status of this agent run */
  status: AgentRunStatus;
};

export type AgentRuntime = {
  __typename?: 'AgentRuntime';
  /** whether this runtime uses the built-in Plural AI proxy */
  aiProxy?: Maybe<Scalars['Boolean']['output']>;
  /** the cluster this runtime is running on */
  cluster?: Maybe<Cluster>;
  /** the policy for creating runs on this runtime */
  createBindings?: Maybe<Array<Maybe<PolicyBinding>>>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the name of this runtime */
  name: Scalars['String']['output'];
  pendingRuns?: Maybe<AgentRunConnection>;
  /** the type of this runtime */
  type: AgentRuntimeType;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};


export type AgentRuntimePendingRunsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type AgentRuntimeAttributes = {
  /** whether this runtime uses the built-in Plural AI proxy */
  aiProxy?: InputMaybe<Scalars['Boolean']['input']>;
  /** the policy for creating runs on this runtime */
  createBindings?: InputMaybe<Array<InputMaybe<AgentBindingAttributes>>>;
  /** the name of this runtime */
  name: Scalars['String']['input'];
  /** the type of this runtime */
  type: AgentRuntimeType;
};

export type AgentRuntimeConnection = {
  __typename?: 'AgentRuntimeConnection';
  edges?: Maybe<Array<Maybe<AgentRuntimeEdge>>>;
  pageInfo: PageInfo;
};

export type AgentRuntimeEdge = {
  __typename?: 'AgentRuntimeEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<AgentRuntime>;
};

export enum AgentRuntimeType {
  Claude = 'CLAUDE',
  Custom = 'CUSTOM',
  Gemini = 'GEMINI',
  Opencode = 'OPENCODE'
}

/** A session for an AI agent to use when acting in a chat thread */
export type AgentSession = {
  __typename?: 'AgentSession';
  /** the branch this session's pr is operating on */
  branch?: Maybe<Scalars['String']['output']>;
  cluster?: Maybe<Cluster>;
  connection?: Maybe<CloudConnection>;
  /** whether the agent has declared the work for this session done */
  done?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** whether the provisioning plan has been confirmed */
  planConfirmed?: Maybe<Scalars['Boolean']['output']>;
  pullRequest?: Maybe<PullRequest>;
  /** the pull requests associated with this chat, usually from an agentic workflow */
  pullRequests?: Maybe<PullRequestConnection>;
  runs?: Maybe<AgentRunConnection>;
  service?: Maybe<ServiceDeployment>;
  /** the services associated with this chat, usually from an agentic workflow */
  serviceDeployments?: Maybe<ServiceDeploymentConnection>;
  stack?: Maybe<InfrastructureStack>;
  /** the stacks associated with this chat, usually from an agentic workflow */
  stacks?: Maybe<InfrastructureStackConnection>;
  thread?: Maybe<ChatThread>;
  /** the type of agent this session is for */
  type?: Maybe<AgentSessionType>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};


/** A session for an AI agent to use when acting in a chat thread */
export type AgentSessionPullRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  open?: InputMaybe<Scalars['Boolean']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
};


/** A session for an AI agent to use when acting in a chat thread */
export type AgentSessionRunsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A session for an AI agent to use when acting in a chat thread */
export type AgentSessionServiceDeploymentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  errored?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<ServiceDeploymentStatus>;
};


/** A session for an AI agent to use when acting in a chat thread */
export type AgentSessionStacksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
};

export type AgentSessionAttributes = {
  /** the id of the cluster to use for this session */
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  /** the id of the cloud connection to use for this session */
  connectionId?: InputMaybe<Scalars['ID']['input']>;
  /** whether to immediately mark this session in a done state, eg no backgroud work */
  done?: InputMaybe<Scalars['Boolean']['input']>;
  /** whether the provisioning plan has been confirmed */
  planConfirmed?: InputMaybe<Scalars['Boolean']['input']>;
  /** the prompt to use for this session */
  prompt?: InputMaybe<Scalars['String']['input']>;
  /** the type of agent this session is for */
  type?: InputMaybe<AgentSessionType>;
};

export type AgentSessionConnection = {
  __typename?: 'AgentSessionConnection';
  edges?: Maybe<Array<Maybe<AgentSessionEdge>>>;
  pageInfo: PageInfo;
};

export type AgentSessionEdge = {
  __typename?: 'AgentSessionEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<AgentSession>;
};

export enum AgentSessionType {
  Chat = 'CHAT',
  Kubernetes = 'KUBERNETES',
  Manifests = 'MANIFESTS',
  Provisioning = 'PROVISIONING',
  Search = 'SEARCH',
  Terraform = 'TERRAFORM'
}

export type AgentTodo = {
  __typename?: 'AgentTodo';
  /** the description of the todo */
  description: Scalars['String']['output'];
  /** whether the todo is done */
  done?: Maybe<Scalars['Boolean']['output']>;
  /** the title of the todo */
  title: Scalars['String']['output'];
};

export type AgentTodoAttributes = {
  /** the description of the todo */
  description: Scalars['String']['input'];
  /** whether the todo is done */
  done: Scalars['Boolean']['input'];
  /** the title of the todo */
  title: Scalars['String']['input'];
};

export type AiAnalysisRates = {
  __typename?: 'AiAnalysisRates';
  /** the rate in seconds for fast analysis, eg when the prompt has seen a material change */
  fast?: Maybe<Scalars['Int']['output']>;
  /** the rate in seconds for slow analysis, eg when the prompt has not seen a material change */
  slow?: Maybe<Scalars['Int']['output']>;
};

export type AiApprovalAttributes = {
  enabled: Scalars['Boolean']['input'];
  file: Scalars['String']['input'];
  git: GitRefAttributes;
  ignoreCancel: Scalars['Boolean']['input'];
};

export type AiDelta = {
  __typename?: 'AiDelta';
  content: Scalars['String']['output'];
  message?: Maybe<Scalars['Int']['output']>;
  role?: Maybe<AiRole>;
  seq: Scalars['Int']['output'];
  tool?: Maybe<ToolDelta>;
};

/** A representation of a LLM-derived insight */
export type AiInsight = {
  __typename?: 'AiInsight';
  alert?: Maybe<Alert>;
  cluster?: Maybe<Cluster>;
  clusterInsightComponent?: Maybe<ClusterInsightComponent>;
  /** any errors generated when compiling this insight */
  error?: Maybe<Array<Maybe<ServiceError>>>;
  evidence?: Maybe<Array<Maybe<AiInsightEvidence>>>;
  freshness?: Maybe<InsightFreshness>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  service?: Maybe<ServiceDeployment>;
  serviceComponent?: Maybe<ServiceComponent>;
  /** a deduplication sha for this insight */
  sha?: Maybe<Scalars['String']['output']>;
  stack?: Maybe<InfrastructureStack>;
  stackRun?: Maybe<StackRun>;
  stackState?: Maybe<StackState>;
  /** a shortish summary of this insight */
  summary?: Maybe<Scalars['String']['output']>;
  /** the text of this insight */
  text?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type AiInsightEvidence = {
  __typename?: 'AiInsightEvidence';
  alert?: Maybe<AlertEvidence>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  knowledge?: Maybe<KnowledgeEvidence>;
  logs?: Maybe<LogsEvidence>;
  pullRequest?: Maybe<PullRequestEvidence>;
  type: EvidenceType;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

/** A saved item for future ai-based investigation */
export type AiPin = {
  __typename?: 'AiPin';
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  insight?: Maybe<AiInsight>;
  name?: Maybe<Scalars['String']['output']>;
  thread?: Maybe<ChatThread>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

/** the items you want to reference in this pin */
export type AiPinAttributes = {
  insightId?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  threadId?: InputMaybe<Scalars['ID']['input']>;
};

export type AiPinConnection = {
  __typename?: 'AiPinConnection';
  edges?: Maybe<Array<Maybe<AiPinEdge>>>;
  pageInfo: PageInfo;
};

export type AiPinEdge = {
  __typename?: 'AiPinEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<AiPin>;
};

export enum AiProvider {
  Anthropic = 'ANTHROPIC',
  Azure = 'AZURE',
  Bedrock = 'BEDROCK',
  Ollama = 'OLLAMA',
  Openai = 'OPENAI',
  Vertex = 'VERTEX'
}

/** A role to pass to an LLM, modeled after OpenAI's chat api roles */
export enum AiRole {
  Assistant = 'ASSISTANT',
  System = 'SYSTEM',
  User = 'USER'
}

/** Settings for configuring access to common LLM providers */
export type AiSettings = {
  __typename?: 'AiSettings';
  analysisRates?: Maybe<AiAnalysisRates>;
  anthropic?: Maybe<AnthropicSettings>;
  azure?: Maybe<AzureOpenaiSettings>;
  bedrock?: Maybe<BedrockAiSettings>;
  enabled?: Maybe<Scalars['Boolean']['output']>;
  ollama?: Maybe<OllamaSettings>;
  openai?: Maybe<OpenaiSettings>;
  provider?: Maybe<AiProvider>;
  /** ai provider to use with tool calls */
  toolProvider?: Maybe<AiProvider>;
  toolsEnabled?: Maybe<Scalars['Boolean']['output']>;
  vertex?: Maybe<VertexAiSettings>;
};

export type AiSettingsAttributes = {
  analysisRates?: InputMaybe<AnalysisRatesAttributes>;
  anthropic?: InputMaybe<AnthropicSettingsAttributes>;
  azure?: InputMaybe<AzureOpenaiAttributes>;
  bedrock?: InputMaybe<BedrockAiAttributes>;
  /** ai provider to use with embeddings (for vector indexing) */
  embeddingProvider?: InputMaybe<AiProvider>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  graph?: InputMaybe<GraphStoreAttributes>;
  ollama?: InputMaybe<OllamaAttributes>;
  openai?: InputMaybe<OpenaiSettingsAttributes>;
  provider?: InputMaybe<AiProvider>;
  /** ai provider to use with tool calls */
  toolProvider?: InputMaybe<AiProvider>;
  tools?: InputMaybe<ToolConfigAttributes>;
  vectorStore?: InputMaybe<VectorStoreAttributes>;
  vertex?: InputMaybe<VertexAiAttributes>;
};

export type Alert = {
  __typename?: 'Alert';
  annotations?: Maybe<Scalars['Map']['output']>;
  /** the cluster this alert was associated with */
  cluster?: Maybe<Cluster>;
  fingerprint?: Maybe<Scalars['String']['output']>;
  /** the flow this alert was associated with */
  flow?: Maybe<Flow>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** an insight explaining the state of this alert */
  insight?: Maybe<AiInsight>;
  message?: Maybe<Scalars['String']['output']>;
  /** the project this alert was associated with */
  project?: Maybe<Project>;
  /** the resolution for this alert */
  resolution?: Maybe<AlertResolution>;
  /** the service this alert was associated with */
  service?: Maybe<Service>;
  severity: AlertSeverity;
  state: AlertState;
  /** key/value tags to filter clusters */
  tags?: Maybe<Array<Maybe<Tag>>>;
  title?: Maybe<Scalars['String']['output']>;
  type: ObservabilityWebhookType;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  url?: Maybe<Scalars['String']['output']>;
};

export type AlertConnection = {
  __typename?: 'AlertConnection';
  edges?: Maybe<Array<Maybe<AlertEdge>>>;
  pageInfo: PageInfo;
};

export type AlertEdge = {
  __typename?: 'AlertEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<Alert>;
};

export type AlertEvidence = {
  __typename?: 'AlertEvidence';
  alertId?: Maybe<Scalars['ID']['output']>;
  message?: Maybe<Scalars['String']['output']>;
  resolution?: Maybe<Scalars['String']['output']>;
  title?: Maybe<Scalars['String']['output']>;
};

export type AlertResolution = {
  __typename?: 'AlertResolution';
  /** the alert this resolution was associated with */
  alert?: Maybe<Alert>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the resolution for this alert */
  resolution: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type AlertResolutionAttributes = {
  resolution: Scalars['String']['input'];
};

export enum AlertSeverity {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  Undefined = 'UNDEFINED'
}

export enum AlertState {
  Firing = 'FIRING',
  Resolved = 'RESOLVED'
}

export type AnalysisRatesAttributes = {
  /** the rate in seconds for fast analysis, eg when the prompt has seen a material change */
  fast?: InputMaybe<Scalars['Int']['input']>;
  /** the rate in seconds for slow analysis, eg when the prompt has not seen a material change */
  slow?: InputMaybe<Scalars['Int']['input']>;
};

export type AnsibleConfiguration = {
  __typename?: 'AnsibleConfiguration';
  /** Additional args for the playbook */
  additionalArgs?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The ansible inventory file to use. we recommend checking this into git alongside your playbook files */
  inventory?: Maybe<Scalars['String']['output']>;
  /** The playbook to run */
  playbook?: Maybe<Scalars['String']['output']>;
};

export type AnsibleConfigurationAttributes = {
  /** additional args for the playbook */
  additionalArgs?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** The ansible inventory file to use. we recommend checking this into git alongside your playbook files */
  inventory?: InputMaybe<Scalars['String']['input']>;
  /** the playbook to run */
  playbook?: InputMaybe<Scalars['String']['input']>;
};

/** Anthropic connection information */
export type AnthropicSettings = {
  __typename?: 'AnthropicSettings';
  /** the anthropic model version to use */
  model?: Maybe<Scalars['String']['output']>;
  /** the model to use for tool calls, which are less frequent and require more complex reasoning */
  toolModel?: Maybe<Scalars['String']['output']>;
};

export type AnthropicSettingsAttributes = {
  accessToken?: InputMaybe<Scalars['String']['input']>;
  /** the model to use for vector embeddings */
  embeddingModel?: InputMaybe<Scalars['String']['input']>;
  model?: InputMaybe<Scalars['String']['input']>;
  /** the model to use for tool calls, which are less frequent and require more complex reasoning */
  toolModel?: InputMaybe<Scalars['String']['input']>;
};

/** a representation of a kubernetes api deprecation */
export type ApiDeprecation = {
  __typename?: 'ApiDeprecation';
  /** the kubernetes version the replacement api was created in */
  availableIn?: Maybe<Scalars['String']['output']>;
  /** whether you cannot safely upgrade to the next kubernetes version if this deprecation exists */
  blocking?: Maybe<Scalars['Boolean']['output']>;
  /** the component of this deprecation */
  component?: Maybe<ServiceComponent>;
  /** the kubernetes version the deprecation was posted */
  deprecatedIn?: Maybe<Scalars['String']['output']>;
  /** the kubernetes version the api version will be removed and unusable in */
  removedIn?: Maybe<Scalars['String']['output']>;
  /** the api you can replace this resource with */
  replacement?: Maybe<Scalars['String']['output']>;
};

export type AppNotification = {
  __typename?: 'AppNotification';
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  priority?: Maybe<NotificationPriority>;
  readAt?: Maybe<Scalars['DateTime']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type AppNotificationConnection = {
  __typename?: 'AppNotificationConnection';
  edges?: Maybe<Array<Maybe<AppNotificationEdge>>>;
  pageInfo: PageInfo;
};

export type AppNotificationEdge = {
  __typename?: 'AppNotificationEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<AppNotification>;
};

export enum ApprovalResult {
  Approved = 'APPROVED',
  Indeterminate = 'INDETERMINATE',
  Rejected = 'REJECTED'
}

export type ArgoAnalysis = {
  __typename?: 'ArgoAnalysis';
  templates?: Maybe<Array<Maybe<ArgoAnalysisTemplate>>>;
};

export type ArgoAnalysisTemplate = {
  __typename?: 'ArgoAnalysisTemplate';
  templateName?: Maybe<Scalars['String']['output']>;
};

export type ArgoBlueGreenStrategy = {
  __typename?: 'ArgoBlueGreenStrategy';
  activeService?: Maybe<Scalars['String']['output']>;
  autoPromotionEnabled?: Maybe<Scalars['Boolean']['output']>;
  autoPromotionSeconds?: Maybe<Scalars['Int']['output']>;
};

export type ArgoCanaryStrategy = {
  __typename?: 'ArgoCanaryStrategy';
  steps?: Maybe<Array<Maybe<ArgoStrategyStep>>>;
};

export type ArgoExperiment = {
  __typename?: 'ArgoExperiment';
  templates?: Maybe<Array<Maybe<ArgoExperimentTemplate>>>;
};

export type ArgoExperimentTemplate = {
  __typename?: 'ArgoExperimentTemplate';
  name?: Maybe<Scalars['String']['output']>;
};

export type ArgoRollout = {
  __typename?: 'ArgoRollout';
  events?: Maybe<Array<Maybe<Event>>>;
  metadata: Metadata;
  pods?: Maybe<Array<Maybe<Pod>>>;
  raw: Scalars['String']['output'];
  spec: ArgoRolloutSpec;
  status: ArgoRolloutStatus;
};

export type ArgoRolloutSpec = {
  __typename?: 'ArgoRolloutSpec';
  replicas?: Maybe<Scalars['Int']['output']>;
  strategy?: Maybe<ArgoRolloutStrategy>;
};

export type ArgoRolloutStatus = {
  __typename?: 'ArgoRolloutStatus';
  abort?: Maybe<Scalars['Boolean']['output']>;
  conditions?: Maybe<Array<Maybe<StatusCondition>>>;
  pauseConditions?: Maybe<Array<Maybe<PauseCondition>>>;
  phase?: Maybe<Scalars['String']['output']>;
  readyReplicas?: Maybe<Scalars['Int']['output']>;
  replicas?: Maybe<Scalars['Int']['output']>;
};

export type ArgoRolloutStrategy = {
  __typename?: 'ArgoRolloutStrategy';
  blueGreen?: Maybe<ArgoBlueGreenStrategy>;
  canary?: Maybe<ArgoCanaryStrategy>;
};

export type ArgoStrategyStep = {
  __typename?: 'ArgoStrategyStep';
  analysis?: Maybe<ArgoAnalysis>;
  experiment?: Maybe<ArgoExperiment>;
  pause?: Maybe<CanaryPause>;
  setWeight?: Maybe<Scalars['Int']['output']>;
};

export type Audit = {
  __typename?: 'Audit';
  action: AuditAction;
  actor?: Maybe<User>;
  city?: Maybe<Scalars['String']['output']>;
  country?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  ip?: Maybe<Scalars['String']['output']>;
  latitude?: Maybe<Scalars['String']['output']>;
  longitude?: Maybe<Scalars['String']['output']>;
  repository?: Maybe<Scalars['String']['output']>;
  type: AuditType;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export enum AuditAction {
  Approve = 'APPROVE',
  Cancel = 'CANCEL',
  Create = 'CREATE',
  Delete = 'DELETE',
  Update = 'UPDATE'
}

export type AuditConnection = {
  __typename?: 'AuditConnection';
  edges?: Maybe<Array<Maybe<AuditEdge>>>;
  pageInfo: PageInfo;
};

export type AuditEdge = {
  __typename?: 'AuditEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<Audit>;
};

export type AuditMetric = {
  __typename?: 'AuditMetric';
  count?: Maybe<Scalars['Int']['output']>;
  country?: Maybe<Scalars['String']['output']>;
};

export enum AuditType {
  Build = 'BUILD',
  Cluster = 'CLUSTER',
  ClusterProvider = 'CLUSTER_PROVIDER',
  ClusterRestore = 'CLUSTER_RESTORE',
  Configuration = 'CONFIGURATION',
  DeploymentSettings = 'DEPLOYMENT_SETTINGS',
  GitRepository = 'GIT_REPOSITORY',
  Global = 'GLOBAL',
  Group = 'GROUP',
  GroupMember = 'GROUP_MEMBER',
  ObjectStore = 'OBJECT_STORE',
  Pipeline = 'PIPELINE',
  Pod = 'POD',
  Policy = 'POLICY',
  ProviderCredential = 'PROVIDER_CREDENTIAL',
  Role = 'ROLE',
  Service = 'SERVICE',
  TempToken = 'TEMP_TOKEN',
  User = 'USER'
}

export enum AuthMethod {
  Basic = 'BASIC',
  Ssh = 'SSH'
}

export enum AutoscalingTarget {
  Deployment = 'DEPLOYMENT',
  Statefulset = 'STATEFULSET'
}

export type AvailableFeatures = {
  __typename?: 'AvailableFeatures';
  audits?: Maybe<Scalars['Boolean']['output']>;
  cd?: Maybe<Scalars['Boolean']['output']>;
  databaseManagement?: Maybe<Scalars['Boolean']['output']>;
  userManagement?: Maybe<Scalars['Boolean']['output']>;
  vpn?: Maybe<Scalars['Boolean']['output']>;
};

/** aws node customizations */
export type AwsCloud = {
  __typename?: 'AwsCloud';
  /** custom launch template for your nodes, useful for Golden AMI setups */
  launchTemplateId?: Maybe<Scalars['String']['output']>;
};

export type AwsCloudAttributes = {
  region?: InputMaybe<Scalars['String']['input']>;
};

export type AwsCloudConnectionAttributes = {
  accessKeyId: Scalars['String']['input'];
  region?: InputMaybe<Scalars['String']['input']>;
  regions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  secretAccessKey: Scalars['String']['input'];
};

/** aws specific cloud configuration */
export type AwsCloudSettings = {
  __typename?: 'AwsCloudSettings';
  region?: Maybe<Scalars['String']['output']>;
};

/** The configuration for a cloud provider */
export type AwsConnectionAttributes = {
  __typename?: 'AwsConnectionAttributes';
  /** the access key id for aws */
  accessKeyId: Scalars['String']['output'];
  /** the region for aws */
  region?: Maybe<Scalars['String']['output']>;
  /** the regions for aws */
  regions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** the secret access key for aws */
  secretAccessKey: Scalars['String']['output'];
};

export type AwsNodeCloudAttributes = {
  launchTemplateId?: InputMaybe<Scalars['String']['input']>;
};

export type AwsSettingsAttributes = {
  accessKeyId: Scalars['String']['input'];
  secretAccessKey: Scalars['String']['input'];
};

export type AzureCloudAttributes = {
  location?: InputMaybe<Scalars['String']['input']>;
  network?: InputMaybe<Scalars['String']['input']>;
  resourceGroup?: InputMaybe<Scalars['String']['input']>;
  subscriptionId?: InputMaybe<Scalars['String']['input']>;
};

export type AzureCloudConnectionAttributes = {
  clientId: Scalars['String']['input'];
  clientSecret: Scalars['String']['input'];
  subscriptionId: Scalars['String']['input'];
  tenantId: Scalars['String']['input'];
};

/** azure-specific cluster cloud configuration */
export type AzureCloudSettings = {
  __typename?: 'AzureCloudSettings';
  location?: Maybe<Scalars['String']['output']>;
  network?: Maybe<Scalars['String']['output']>;
  resourceGroup?: Maybe<Scalars['String']['output']>;
  subscriptionId?: Maybe<Scalars['String']['output']>;
};

/** The configuration for a cloud provider */
export type AzureConnectionAttributes = {
  __typename?: 'AzureConnectionAttributes';
  /** the client id for azure */
  clientId: Scalars['String']['output'];
  /** the client secret for azure */
  clientSecret: Scalars['String']['output'];
  /** the subscription id for azure */
  subscriptionId: Scalars['String']['output'];
  /** the tenant id for azure */
  tenantId: Scalars['String']['output'];
};

/** Requirements to perform Azure DevOps authentication */
export type AzureDevopsAttributes = {
  /** the organization to use for azure devops */
  organization: Scalars['String']['input'];
  /** the project to use for azure devops */
  project: Scalars['String']['input'];
  /** the username asociated with your Azure DevOps PAT */
  username: Scalars['String']['input'];
};

export type AzureDevopsConfiguration = {
  __typename?: 'AzureDevopsConfiguration';
  /** the organization to use for azure devops */
  organization: Scalars['String']['output'];
  /** the project to use for azure devops */
  project: Scalars['String']['output'];
  /** the username asociated with your Azure DevOps PAT */
  username: Scalars['String']['output'];
};

export type AzureOpenaiAttributes = {
  /** the azure openai access token to use */
  accessToken: Scalars['String']['input'];
  /** the api version you want to use */
  apiVersion?: InputMaybe<Scalars['String']['input']>;
  /** the model to use for vector embeddings */
  embeddingModel?: InputMaybe<Scalars['String']['input']>;
  /** the endpoint of your azure openai version, should look like: https://{endpoint}/openai/deployments */
  endpoint: Scalars['String']['input'];
  /** the exact model you wish to use */
  model?: InputMaybe<Scalars['String']['input']>;
  /** the model to use for tool calls, which are less frequent and require more complex reasoning */
  toolModel?: InputMaybe<Scalars['String']['input']>;
};

/** Settings for configuring against Azure OpenAI */
export type AzureOpenaiSettings = {
  __typename?: 'AzureOpenaiSettings';
  /** the api version you want to use */
  apiVersion?: Maybe<Scalars['String']['output']>;
  /** the model to use for vector embeddings */
  embeddingModel?: Maybe<Scalars['String']['output']>;
  /** the endpoint of your azure openai version, should look like: https://{endpoint}/openai/deployments/{deployment-id} */
  endpoint: Scalars['String']['output'];
  model?: Maybe<Scalars['String']['output']>;
  /** the model to use for tool calls, which are less frequent and require more complex reasoning */
  toolModel?: Maybe<Scalars['String']['output']>;
};

export type AzureSettingsAttributes = {
  clientId: Scalars['ID']['input'];
  clientSecret: Scalars['String']['input'];
  subscriptionId: Scalars['String']['input'];
  tenantId: Scalars['String']['input'];
};

export type AzureStore = {
  __typename?: 'AzureStore';
  clientId: Scalars['String']['output'];
  container: Scalars['String']['output'];
  resourceGroup: Scalars['String']['output'];
  storageAccount: Scalars['String']['output'];
  subscriptionId: Scalars['String']['output'];
  tenantId: Scalars['String']['output'];
};

export type AzureStoreAttributes = {
  clientId: Scalars['String']['input'];
  clientSecret: Scalars['String']['input'];
  container: Scalars['String']['input'];
  resourceGroup: Scalars['String']['input'];
  storageAccount: Scalars['String']['input'];
  subscriptionId: Scalars['String']['input'];
  tenantId: Scalars['String']['input'];
};

export type BackupAttributes = {
  garbageCollected?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  namespaces?: InputMaybe<ResourceSelectorAttributes>;
  resources?: InputMaybe<ResourceSelectorAttributes>;
  ttl?: InputMaybe<Scalars['String']['input']>;
};

export type BedrockAiAttributes = {
  /** the openai bedrock access token to use */
  accessToken?: InputMaybe<Scalars['String']['input']>;
  /** the aws access key id to use (DEPRECATED) */
  awsAccessKeyId?: InputMaybe<Scalars['String']['input']>;
  /** the aws secret access key to use (DEPRECATED) */
  awsSecretAccessKey?: InputMaybe<Scalars['String']['input']>;
  /** the model to use for vector embeddings */
  embeddingModel?: InputMaybe<Scalars['String']['input']>;
  /** the bedrock model id to use */
  modelId: Scalars['String']['input'];
  /** the aws region the model is hosted in */
  region?: InputMaybe<Scalars['String']['input']>;
  /** the model to use for tool calls, which are less frequent and require more complex reasoning */
  toolModelId?: InputMaybe<Scalars['String']['input']>;
};

/** Settings for usage of AWS Bedrock for LLMs */
export type BedrockAiSettings = {
  __typename?: 'BedrockAiSettings';
  /** the openai bedrock aws access key id to use (DEPRECATED) */
  accessKeyId?: Maybe<Scalars['String']['output']>;
  /** the model to use for vector embeddings */
  embeddingModel?: Maybe<Scalars['String']['output']>;
  /** the bedrock model to use */
  modelId: Scalars['String']['output'];
  /** the aws region the model is hosted in */
  region?: Maybe<Scalars['String']['output']>;
  /** the model to use for tool calls, which are less frequent and require more complex reasoning */
  toolModelId?: Maybe<Scalars['String']['output']>;
};

export type BindingAttributes = {
  groupId?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

/** A restricted token meant only for use in registering clusters, esp for edge devices */
export type BootstrapToken = {
  __typename?: 'BootstrapToken';
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the project for all clusters to live within */
  project?: Maybe<Project>;
  /** the token to use when bootstrapping clusters */
  token: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  user?: Maybe<User>;
};

export type BootstrapTokenAttributes = {
  /** the project all clusters spawned by this bootstrap token are put into */
  projectId: Scalars['ID']['input'];
  /** An optional external user id to be the user identity for this bootstrap token in audit logs */
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export type Canary = {
  __typename?: 'Canary';
  canaryDeployment?: Maybe<Deployment>;
  events?: Maybe<Array<Maybe<Event>>>;
  ingress?: Maybe<Ingress>;
  ingressCanary?: Maybe<Ingress>;
  metadata: Metadata;
  primaryDeployment?: Maybe<Deployment>;
  raw: Scalars['String']['output'];
  spec: CanarySpec;
  status: CanaryStatus;
};

export type CanaryAnalysis = {
  __typename?: 'CanaryAnalysis';
  interval?: Maybe<Scalars['String']['output']>;
  maxWeight?: Maybe<Scalars['Int']['output']>;
  stepWeight?: Maybe<Scalars['Int']['output']>;
  stepWeights?: Maybe<Array<Maybe<Scalars['Int']['output']>>>;
  threshold?: Maybe<Scalars['Int']['output']>;
};

export type CanaryPause = {
  __typename?: 'CanaryPause';
  duration?: Maybe<Scalars['String']['output']>;
};

export type CanarySpec = {
  __typename?: 'CanarySpec';
  analysis?: Maybe<CanaryAnalysis>;
  autoscalerRef?: Maybe<TargetRef>;
  ingressRef?: Maybe<TargetRef>;
  provider?: Maybe<Scalars['String']['output']>;
  targetRef?: Maybe<TargetRef>;
};

export type CanaryStatus = {
  __typename?: 'CanaryStatus';
  canaryWeight?: Maybe<Scalars['Int']['output']>;
  conditions?: Maybe<Array<Maybe<StatusCondition>>>;
  failedChecks?: Maybe<Scalars['Int']['output']>;
  iterations?: Maybe<Scalars['Int']['output']>;
  lastTransitionTime?: Maybe<Scalars['String']['output']>;
  phase?: Maybe<Scalars['String']['output']>;
};

/** A spec for specifying cascade behavior on an owning resource */
export type Cascade = {
  __typename?: 'Cascade';
  /** whether to perform a drain-delete for all owned resources */
  delete?: Maybe<Scalars['Boolean']['output']>;
  /** whether to perform a detach-delete for all owned resources */
  detach?: Maybe<Scalars['Boolean']['output']>;
};

/** Whether you want to delete or detach owned resources */
export type CascadeAttributes = {
  delete?: InputMaybe<Scalars['Boolean']['input']>;
  detach?: InputMaybe<Scalars['Boolean']['input']>;
};

/** A catalog is an organized collection of PR Automations used for permissioning and discovery */
export type Catalog = {
  __typename?: 'Catalog';
  /** the name of the author of this catalog */
  author?: Maybe<Scalars['String']['output']>;
  /** short category name used for browsing catalogs */
  category?: Maybe<Scalars['String']['output']>;
  /** create policy for this catalog, can give permission to just create prs */
  createBindings?: Maybe<Array<Maybe<PolicyBinding>>>;
  /** a darkmode icon url to use for this catalog */
  darkIcon?: Maybe<Scalars['String']['output']>;
  /** longform description for the purpose of this catalog */
  description?: Maybe<Scalars['String']['output']>;
  /** an icon url to use for this catalog */
  icon?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  name: Scalars['String']['output'];
  project?: Maybe<Project>;
  /** read policy for this catalog */
  readBindings?: Maybe<Array<Maybe<PolicyBinding>>>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** write policy for this catalog */
  writeBindings?: Maybe<Array<Maybe<PolicyBinding>>>;
};

export type CatalogAttributes = {
  /** the name of the author of this catalog, used for attribution only */
  author: Scalars['String']['input'];
  /** short category name for browsability */
  category?: InputMaybe<Scalars['String']['input']>;
  createBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
  /** a darkmode icon url to use for this catalog */
  darkIcon?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  /** an icon url to use for this catalog */
  icon?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  /** owning project of the catalog, permissions will propagate down */
  projectId?: InputMaybe<Scalars['ID']['input']>;
  readBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
  tags?: InputMaybe<Array<InputMaybe<TagAttributes>>>;
  writeBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
};

export type CatalogConnection = {
  __typename?: 'CatalogConnection';
  edges?: Maybe<Array<Maybe<CatalogEdge>>>;
  pageInfo: PageInfo;
};

export type CatalogEdge = {
  __typename?: 'CatalogEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<Catalog>;
};

export type Certificate = {
  __typename?: 'Certificate';
  events?: Maybe<Array<Maybe<Event>>>;
  metadata: Metadata;
  raw: Scalars['String']['output'];
  spec: CertificateSpec;
  status: CertificateStatus;
};

export type CertificateSpec = {
  __typename?: 'CertificateSpec';
  dnsNames?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  issuerRef?: Maybe<IssuerRef>;
  secretName: Scalars['String']['output'];
};

export type CertificateStatus = {
  __typename?: 'CertificateStatus';
  conditions?: Maybe<Array<Maybe<StatusCondition>>>;
  notAfter?: Maybe<Scalars['String']['output']>;
  notBefore?: Maybe<Scalars['String']['output']>;
  renewalTime?: Maybe<Scalars['String']['output']>;
};

export type Chat = {
  __typename?: 'Chat';
  attributes?: Maybe<ChatTypeAttributes>;
  /** whether this chat requires confirmation */
  confirm?: Maybe<Scalars['Boolean']['output']>;
  /** when the chat was confirmed */
  confirmedAt?: Maybe<Scalars['DateTime']['output']>;
  content?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  prAutomation?: Maybe<PrAutomation>;
  pullRequest?: Maybe<PullRequest>;
  role: AiRole;
  seq: Scalars['Int']['output'];
  server?: Maybe<McpServer>;
  thread?: Maybe<ChatThread>;
  type: ChatType;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type ChatConnection = {
  __typename?: 'ChatConnection';
  edges?: Maybe<Array<Maybe<ChatEdge>>>;
  pageInfo: PageInfo;
};

export type ChatEdge = {
  __typename?: 'ChatEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<Chat>;
};

/** Additional attributes for describing a file type chat */
export type ChatFile = {
  __typename?: 'ChatFile';
  name?: Maybe<Scalars['String']['output']>;
};

/** A basic AI chat message input, modeled after OpenAI's api model */
export type ChatMessage = {
  content: Scalars['String']['input'];
  role: AiRole;
};

/** A list of chat messages around a specific topic created on demand */
export type ChatThread = {
  __typename?: 'ChatThread';
  chats?: Maybe<ChatConnection>;
  default: Scalars['Boolean']['output'];
  flow?: Maybe<Flow>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  insight?: Maybe<AiInsight>;
  lastMessageAt?: Maybe<Scalars['DateTime']['output']>;
  session?: Maybe<AgentSession>;
  settings?: Maybe<ChatThreadSettings>;
  summary: Scalars['String']['output'];
  /** the tools associated with this chat.  This is a complex operation that requires querying associated mcp servers, do not use in lists */
  tools?: Maybe<Array<Maybe<McpServerTool>>>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  user?: Maybe<User>;
};


/** A list of chat messages around a specific topic created on demand */
export type ChatThreadChatsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

/** basic user-supplied input for creating an AI chat thread */
export type ChatThreadAttributes = {
  /** the flow this thread was created in */
  flowId?: InputMaybe<Scalars['ID']['input']>;
  /** an ai insight this thread was created from */
  insightId?: InputMaybe<Scalars['ID']['input']>;
  /** a list of messages to add initially when creating this thread */
  messages?: InputMaybe<Array<InputMaybe<ChatMessage>>>;
  /** the session to use for this thread */
  session?: InputMaybe<AgentSessionAttributes>;
  /** the settings for this thread */
  settings?: InputMaybe<ChatThreadSettingsAttributes>;
  /** controls whether this thread is autosummarized, set true when users explicitly set summary */
  summarized?: InputMaybe<Scalars['Boolean']['input']>;
  summary: Scalars['String']['input'];
};

export type ChatThreadConnection = {
  __typename?: 'ChatThreadConnection';
  edges?: Maybe<Array<Maybe<ChatThreadEdge>>>;
  pageInfo: PageInfo;
};

export type ChatThreadEdge = {
  __typename?: 'ChatThreadEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<ChatThread>;
};

/** the settings for an AI chat thread */
export type ChatThreadSettings = {
  __typename?: 'ChatThreadSettings';
  /** controls whether this thread uses knowledge graph-basedmemory */
  memory?: Maybe<Scalars['Boolean']['output']>;
};

/** the settings for an AI chat thread */
export type ChatThreadSettingsAttributes = {
  /** controls whether this thread uses knowledge graph-basedmemory */
  memory?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Additional attributes for describing a tool call that derived this chat message */
export type ChatTool = {
  __typename?: 'ChatTool';
  arguments?: Maybe<Scalars['Map']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

export enum ChatType {
  Error = 'ERROR',
  File = 'FILE',
  ImplementationPlan = 'IMPLEMENTATION_PLAN',
  PrCall = 'PR_CALL',
  Text = 'TEXT',
  Tool = 'TOOL'
}

/** Additional attributes of this chat message, used for formatting it in the display */
export type ChatTypeAttributes = {
  __typename?: 'ChatTypeAttributes';
  file?: Maybe<ChatFile>;
  prCall?: Maybe<PrCallAttributes>;
  tool?: Maybe<ChatTool>;
};

export type CloudAddon = {
  __typename?: 'CloudAddon';
  cluster?: Maybe<Cluster>;
  distro: ClusterDistro;
  id: Scalars['ID']['output'];
  info?: Maybe<CloudAddonInformation>;
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  name: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  version: Scalars['String']['output'];
  versionInfo?: Maybe<CloudAddonVersionInformation>;
};

export type CloudAddonAttributes = {
  distro?: InputMaybe<ClusterDistro>;
  name?: InputMaybe<Scalars['String']['input']>;
  version?: InputMaybe<Scalars['String']['input']>;
};

export type CloudAddonInformation = {
  __typename?: 'CloudAddonInformation';
  name?: Maybe<Scalars['String']['output']>;
  publisher?: Maybe<Scalars['String']['output']>;
  versions?: Maybe<Array<Maybe<CloudAddonVersionInformation>>>;
};

export type CloudAddonVersionInformation = {
  __typename?: 'CloudAddonVersionInformation';
  /** checks if this is blocking a specific kubernetes upgrade */
  blocking?: Maybe<Scalars['Boolean']['output']>;
  compatibilities?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  version?: Maybe<Scalars['String']['output']>;
};


export type CloudAddonVersionInformationBlockingArgs = {
  kubeVersion: Scalars['String']['input'];
};

/** A read-only connection to a cloud provider */
export type CloudConnection = {
  __typename?: 'CloudConnection';
  /** the configuration for the cloud connection */
  configuration: CloudConnectionConfiguration;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the name of the cloud connection */
  name: Scalars['String']['output'];
  /** the provider of the cloud connection */
  provider: Provider;
  /** read policy across this cloud connection */
  readBindings?: Maybe<Array<Maybe<PolicyBinding>>>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type CloudConnectionAttributes = {
  configuration: CloudConnectionConfigurationAttributes;
  name: Scalars['String']['input'];
  provider: Provider;
  readBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
};

/** The configuration for a cloud provider */
export type CloudConnectionConfiguration = {
  __typename?: 'CloudConnectionConfiguration';
  /** the credentials for aws */
  aws?: Maybe<AwsConnectionAttributes>;
  /** the credentials for azure */
  azure?: Maybe<AzureConnectionAttributes>;
  /** the credentials for gcp */
  gcp?: Maybe<GcpConnectionAttributes>;
};

export type CloudConnectionConfigurationAttributes = {
  aws?: InputMaybe<AwsCloudConnectionAttributes>;
  azure?: InputMaybe<AzureCloudConnectionAttributes>;
  gcp?: InputMaybe<GcpCloudConnectionAttributes>;
};

export type CloudConnectionConnection = {
  __typename?: 'CloudConnectionConnection';
  edges?: Maybe<Array<Maybe<CloudConnectionEdge>>>;
  pageInfo: PageInfo;
};

export type CloudConnectionEdge = {
  __typename?: 'CloudConnectionEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<CloudConnection>;
};

export type CloudProviderSettingsAttributes = {
  aws?: InputMaybe<AwsSettingsAttributes>;
  azure?: InputMaybe<AzureSettingsAttributes>;
  gcp?: InputMaybe<GcpSettingsAttributes>;
};

/** the cloud configuration for a cluster */
export type CloudSettings = {
  __typename?: 'CloudSettings';
  aws?: Maybe<AwsCloudSettings>;
  azure?: Maybe<AzureCloudSettings>;
  gcp?: Maybe<GcpCloudSettings>;
};

export type CloudSettingsAttributes = {
  aws?: InputMaybe<AwsCloudAttributes>;
  azure?: InputMaybe<AzureCloudAttributes>;
  gcp?: InputMaybe<GcpCloudAttributes>;
};

/** a representation of a cluster you can deploy to */
export type Cluster = {
  __typename?: 'Cluster';
  /** The helm values for the agent installation */
  agentHelmValues?: Maybe<Scalars['String']['output']>;
  /** the url this clusters deployment operator will use for gql requests */
  agentUrl?: Maybe<Scalars['String']['output']>;
  /** list all alerts discovered for this cluster */
  alerts?: Maybe<AlertConnection>;
  /** all api deprecations for all services in this cluster */
  apiDeprecations?: Maybe<Array<Maybe<ApiDeprecation>>>;
  auditLogs?: Maybe<ClusterAuditLogConnection>;
  /** The availability zones this cluster is running in */
  availabilityZones?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** any upgrade insights provided by your cloud provider that have been discovered by our agent */
  cloudAddons?: Maybe<Array<Maybe<CloudAddon>>>;
  clusterMetrics?: Maybe<ClusterMetrics>;
  clusterNodeMetrics?: Maybe<ClusterNodeMetrics>;
  /** The total CPU capacity of the cluster */
  cpuTotal?: Maybe<Scalars['Float']['output']>;
  /** The CPU utilization of the cluster */
  cpuUtil?: Maybe<Scalars['Float']['output']>;
  /** a custom credential to use when provisioning this cluster */
  credential?: Maybe<ProviderCredential>;
  /** current k8s version as told to us by the deployment operator */
  currentVersion?: Maybe<Scalars['String']['output']>;
  /** when this cluster was scheduled for deletion */
  deletedAt?: Maybe<Scalars['DateTime']['output']>;
  /** a auth token to be used by the deploy operator, only readable on create */
  deployToken?: Maybe<Scalars['String']['output']>;
  /** fetches the discovered custom resources with new versions to be used */
  deprecatedCustomResources?: Maybe<Array<Maybe<DeprecatedCustomResource>>>;
  /** the distribution of kubernetes this cluster is running */
  distro?: Maybe<ClusterDistro>;
  /** whether the current user can edit this cluster */
  editable?: Maybe<Scalars['Boolean']['output']>;
  /** a short, unique human readable name used to identify this cluster and does not necessarily map to the cloud resource name */
  handle?: Maybe<Scalars['String']['output']>;
  /** The health score of the cluster */
  healthScore?: Maybe<Scalars['Int']['output']>;
  /** Whether this cluster was recently pinged */
  healthy?: Maybe<Scalars['Boolean']['output']>;
  /** A pod-level set of utilization metrics for this cluster for rendering a heat map */
  heatMap?: Maybe<UtilizationHeatMap>;
  /** internal id of this cluster */
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** an ai insight generated about issues discovered which might impact the health of this cluster */
  insight?: Maybe<AiInsight>;
  /** a set of kubernetes resources used to generate the ai insight for this cluster */
  insightComponents?: Maybe<Array<Maybe<ClusterInsightComponent>>>;
  /** whether the deploy operator has been registered for this cluster */
  installed?: Maybe<Scalars['Boolean']['output']>;
  /** the url of the kas server you can access this cluster from */
  kasUrl?: Maybe<Scalars['String']['output']>;
  /** The lowest discovered kubelet version for all nodes in the cluster */
  kubeletVersion?: Maybe<Scalars['String']['output']>;
  /** Queries logs for a cluster out of loki */
  logs?: Maybe<Array<Maybe<LogStream>>>;
  /** The total memory capacity of the cluster */
  memoryTotal?: Maybe<Scalars['Float']['output']>;
  /** The memory utilization of the cluster */
  memoryUtil?: Maybe<Scalars['Float']['output']>;
  /** arbitrary json metadata to store user-specific state of this cluster (eg IAM roles for add-ons) */
  metadata?: Maybe<Scalars['Map']['output']>;
  /** A summation of the metrics utilization of the current cluster */
  metricsSummary?: Maybe<ClusterMetricsSummary>;
  /** human readable name of this cluster, will also translate to cloud k8s name */
  name: Scalars['String']['output'];
  /** The number of namespaces in this cluster */
  namespaceCount?: Maybe<Scalars['Int']['output']>;
  networkGraph?: Maybe<Array<Maybe<NetworkMeshEdge>>>;
  /** The number of nodes in this cluster */
  nodeCount?: Maybe<Scalars['Int']['output']>;
  /** list the cached node metrics for a cluster, can also be stale up to 5m */
  nodeMetrics?: Maybe<Array<Maybe<NodeMetric>>>;
  /** list of node pool specs managed by CAPI */
  nodePools?: Maybe<Array<Maybe<NodePool>>>;
  /** a list of node healthstatistics for this cluster */
  nodeStatistics?: Maybe<Array<Maybe<NodeStatistic>>>;
  /** list cached nodes for a cluster, this can be stale up to 5m */
  nodes?: Maybe<Array<Maybe<Node>>>;
  /** A pod-level set of utilization metrics exceeding our noisy threshold */
  noisyNeighbors?: Maybe<UtilizationHeatMap>;
  /** the object store connection bound to this cluster for backup/restore */
  objectStore?: Maybe<ObjectStore>;
  /** The version of OpenShift this cluster is running */
  openshiftVersion?: Maybe<Scalars['String']['output']>;
  /** a high level description of the setup of common resources in a cluster */
  operationalLayout?: Maybe<OperationalLayout>;
  /** the parent of this virtual cluster */
  parentCluster?: Maybe<Cluster>;
  /** the interval in seconds between pings to the cluster */
  pingInterval?: Maybe<Scalars['Int']['output']>;
  /** last time the deploy operator pinged this cluster */
  pingedAt?: Maybe<Scalars['DateTime']['output']>;
  /** custom resources with dedicated views for this cluster */
  pinnedCustomResources?: Maybe<Array<Maybe<PinnedCustomResource>>>;
  /** The number of pods in this cluster */
  podCount?: Maybe<Scalars['Int']['output']>;
  /** lists OPA constraints registered in this cluster */
  policyConstraints?: Maybe<PolicyConstraintConnection>;
  /** pr automations that are relevant to managing this cluster */
  prAutomations?: Maybe<Array<Maybe<PrAutomation>>>;
  /** the project this cluster belongs to */
  project?: Maybe<Project>;
  /** if true, this cluster cannot be deleted */
  protect?: Maybe<Scalars['Boolean']['output']>;
  /** the provider we use to create this cluster (null if BYOK) */
  provider?: Maybe<ClusterProvider>;
  /** read policy for this cluster */
  readBindings?: Maybe<Array<Maybe<PolicyBinding>>>;
  /** a custom git repository if you want to define your own CAPI manifests */
  repository?: Maybe<GitRepository>;
  /** the active restore for this cluster */
  restore?: Maybe<ClusterRestore>;
  /** a relay connection of all revisions of this cluster, these are periodically pruned up to a history limit */
  revisions?: Maybe<ClusterRevisionConnection>;
  /** fetches a list of runtime services found in this cluster, this is an expensive operation that should not be done in list queries */
  runtimeServices?: Maybe<Array<Maybe<RuntimeService>>>;
  /** whether this is the management cluster itself */
  self?: Maybe<Scalars['Boolean']['output']>;
  /** the service used to deploy the CAPI resources of this cluster */
  service?: Maybe<ServiceDeployment>;
  /** any errors which might have occurred during the bootstrap process */
  serviceErrors?: Maybe<Array<Maybe<ServiceError>>>;
  /** the cloud settings for this cluster (for instance its aws region) */
  settings?: Maybe<CloudSettings>;
  /** the status of the cluster as seen from the CAPI operator, since some clusters can be provisioned without CAPI, this can be null */
  status?: Maybe<ClusterStatus>;
  /** key/value tags to filter clusters */
  tags?: Maybe<Array<Maybe<Tag>>>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** any upgrade insights provided by your cloud provider that have been discovered by our agent */
  upgradeInsights?: Maybe<Array<Maybe<UpgradeInsight>>>;
  /** Checklist of tasks to complete to safely upgrade this cluster */
  upgradePlan?: Maybe<ClusterUpgradePlan>;
  /** desired k8s version for the cluster */
  version?: Maybe<Scalars['String']['output']>;
  /** Computes a list of statistics for OPA constraint violations w/in this cluster */
  violationStatistics?: Maybe<Array<Maybe<ViolationStatistic>>>;
  /** whether this is actually a virtual cluster */
  virtual?: Maybe<Scalars['Boolean']['output']>;
  /** write policy for this cluster */
  writeBindings?: Maybe<Array<Maybe<PolicyBinding>>>;
};


/** a representation of a cluster you can deploy to */
export type ClusterAlertsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** a representation of a cluster you can deploy to */
export type ClusterAuditLogsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** a representation of a cluster you can deploy to */
export type ClusterClusterMetricsArgs = {
  start?: InputMaybe<Scalars['DateTime']['input']>;
  step?: InputMaybe<Scalars['String']['input']>;
  stop?: InputMaybe<Scalars['DateTime']['input']>;
};


/** a representation of a cluster you can deploy to */
export type ClusterClusterNodeMetricsArgs = {
  node: Scalars['String']['input'];
  start?: InputMaybe<Scalars['DateTime']['input']>;
  step?: InputMaybe<Scalars['String']['input']>;
  stop?: InputMaybe<Scalars['DateTime']['input']>;
};


/** a representation of a cluster you can deploy to */
export type ClusterHeatMapArgs = {
  flavor?: InputMaybe<HeatMapFlavor>;
};


/** a representation of a cluster you can deploy to */
export type ClusterLogsArgs = {
  end?: InputMaybe<Scalars['Long']['input']>;
  limit: Scalars['Int']['input'];
  query: LokiQuery;
  start?: InputMaybe<Scalars['Long']['input']>;
};


/** a representation of a cluster you can deploy to */
export type ClusterNetworkGraphArgs = {
  namespace?: InputMaybe<Scalars['String']['input']>;
  time?: InputMaybe<Scalars['DateTime']['input']>;
};


/** a representation of a cluster you can deploy to */
export type ClusterPolicyConstraintsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  kind?: InputMaybe<Scalars['String']['input']>;
  kinds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  namespaces?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  q?: InputMaybe<Scalars['String']['input']>;
};


/** a representation of a cluster you can deploy to */
export type ClusterRevisionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** a representation of a cluster you can deploy to */
export type ClusterViolationStatisticsArgs = {
  field: ConstraintViolationField;
};

/** A common kubernetes cluster add-on like cert-manager, istio, etc */
export type ClusterAddOn = {
  __typename?: 'ClusterAddOn';
  configuration?: Maybe<Array<Maybe<AddOnConfiguration>>>;
  global?: Maybe<Scalars['Boolean']['output']>;
  icon?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  version?: Maybe<Scalars['String']['output']>;
};

export type ClusterAttributes = {
  cloudSettings?: InputMaybe<CloudSettingsAttributes>;
  /** a cloud credential to use when provisioning this cluster */
  credentialId?: InputMaybe<Scalars['ID']['input']>;
  distro?: InputMaybe<ClusterDistro>;
  /** a short, unique human readable name used to identify this cluster and does not necessarily map to the cloud resource name */
  handle?: InputMaybe<Scalars['String']['input']>;
  kubeconfig?: InputMaybe<KubeconfigAttributes>;
  metadata?: InputMaybe<Scalars['Json']['input']>;
  name: Scalars['String']['input'];
  nodePools?: InputMaybe<Array<InputMaybe<NodePoolAttributes>>>;
  /** the project id this cluster will belong to */
  projectId?: InputMaybe<Scalars['ID']['input']>;
  protect?: InputMaybe<Scalars['Boolean']['input']>;
  providerId?: InputMaybe<Scalars['ID']['input']>;
  readBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
  tags?: InputMaybe<Array<InputMaybe<TagAttributes>>>;
  /** status of the upgrade plan for this cluster */
  upgradePlan?: InputMaybe<UpgradePlanAttributes>;
  version?: InputMaybe<Scalars['String']['input']>;
  writeBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
};

export type ClusterAuditAttributes = {
  /** the cluster this request was made on */
  clusterId: Scalars['ID']['input'];
  /** the http method from the given request */
  method: Scalars['String']['input'];
  /** the path made for the given request */
  path: Scalars['String']['input'];
  responseCode?: InputMaybe<Scalars['Int']['input']>;
};

export type ClusterAuditLog = {
  __typename?: 'ClusterAuditLog';
  actor?: Maybe<User>;
  cluster?: Maybe<Cluster>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  method: Scalars['String']['output'];
  path: Scalars['String']['output'];
  responseCode?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type ClusterAuditLogConnection = {
  __typename?: 'ClusterAuditLogConnection';
  edges?: Maybe<Array<Maybe<ClusterAuditLogEdge>>>;
  pageInfo: PageInfo;
};

export type ClusterAuditLogEdge = {
  __typename?: 'ClusterAuditLogEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<ClusterAuditLog>;
};

export type ClusterBackup = {
  __typename?: 'ClusterBackup';
  cluster?: Maybe<Cluster>;
  garbageCollected?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  name: Scalars['String']['output'];
  namespace: Scalars['String']['output'];
  namespaces?: Maybe<ResourceSelector>;
  resources?: Maybe<ResourceSelector>;
  ttl?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type ClusterBackupConnection = {
  __typename?: 'ClusterBackupConnection';
  edges?: Maybe<Array<Maybe<ClusterBackupEdge>>>;
  pageInfo: PageInfo;
};

export type ClusterBackupEdge = {
  __typename?: 'ClusterBackupEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<ClusterBackup>;
};

/** a single condition struct for various phases of the cluster provisionining process */
export type ClusterCondition = {
  __typename?: 'ClusterCondition';
  lastTransitionTime?: Maybe<Scalars['String']['output']>;
  message?: Maybe<Scalars['String']['output']>;
  reason?: Maybe<Scalars['String']['output']>;
  severity?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
};

export type ClusterConnection = {
  __typename?: 'ClusterConnection';
  edges?: Maybe<Array<Maybe<ClusterEdge>>>;
  pageInfo: PageInfo;
};

export enum ClusterDistro {
  Aks = 'AKS',
  Eks = 'EKS',
  Generic = 'GENERIC',
  Gke = 'GKE',
  K3S = 'K3S',
  Openshift = 'OPENSHIFT',
  Rke = 'RKE'
}

export type ClusterEdge = {
  __typename?: 'ClusterEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<Cluster>;
};

export type ClusterInfo = {
  __typename?: 'ClusterInfo';
  gitCommit?: Maybe<Scalars['String']['output']>;
  gitVersion?: Maybe<Scalars['String']['output']>;
  platform?: Maybe<Scalars['String']['output']>;
  version?: Maybe<Scalars['String']['output']>;
};

/** A kubernetes object used in the course of generating a cluster insight */
export type ClusterInsightComponent = {
  __typename?: 'ClusterInsightComponent';
  cluster?: Maybe<Cluster>;
  group?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  insight?: Maybe<AiInsight>;
  kind: Scalars['String']['output'];
  name: Scalars['String']['output'];
  namespace?: Maybe<Scalars['String']['output']>;
  priority?: Maybe<InsightComponentPriority>;
  /** the raw kubernetes resource itself, this is an expensive fetch and should be used sparingly */
  resource?: Maybe<KubernetesUnstructured>;
  version: Scalars['String']['output'];
};

export type ClusterInsightComponentAttributes = {
  group?: InputMaybe<Scalars['String']['input']>;
  kind: Scalars['String']['input'];
  name: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<InsightComponentPriority>;
  version: Scalars['String']['input'];
};

/** A reference to a built ISO image to be used for flashing new edge clusters */
export type ClusterIsoImage = {
  __typename?: 'ClusterIsoImage';
  id: Scalars['ID']['output'];
  /** the image this iso was pushed to */
  image: Scalars['String']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** ssh password for the new device */
  password?: Maybe<Scalars['String']['output']>;
  /** the project this cluster will live in (can be inferred from bootstrap token) */
  project?: Maybe<Project>;
  /** the registry holding the image */
  registry: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** ssh username for the new device */
  user?: Maybe<Scalars['String']['output']>;
};

export type ClusterIsoImageAttributes = {
  /** the image this iso was pushed to */
  image: Scalars['String']['input'];
  /** ssh password for the new device */
  password?: InputMaybe<Scalars['String']['input']>;
  /** the project this cluster will live in (can be inferred from bootstrap token) */
  projectId?: InputMaybe<Scalars['ID']['input']>;
  /** the registry holding the image */
  registry: Scalars['String']['input'];
  /** ssh username for the new device */
  user?: InputMaybe<Scalars['String']['input']>;
};

export type ClusterIsoImageConnection = {
  __typename?: 'ClusterIsoImageConnection';
  edges?: Maybe<Array<Maybe<ClusterIsoImageEdge>>>;
  pageInfo: PageInfo;
};

export type ClusterIsoImageEdge = {
  __typename?: 'ClusterIsoImageEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<ClusterIsoImage>;
};

export type ClusterMetrics = {
  __typename?: 'ClusterMetrics';
  cpu?: Maybe<Array<Maybe<MetricResponse>>>;
  cpuLimits?: Maybe<Array<Maybe<MetricResponse>>>;
  cpuRequests?: Maybe<Array<Maybe<MetricResponse>>>;
  cpuUsage?: Maybe<Array<Maybe<MetricResponse>>>;
  memory?: Maybe<Array<Maybe<MetricResponse>>>;
  memoryLimits?: Maybe<Array<Maybe<MetricResponse>>>;
  memoryRequests?: Maybe<Array<Maybe<MetricResponse>>>;
  memoryUsage?: Maybe<Array<Maybe<MetricResponse>>>;
  pods?: Maybe<Array<Maybe<MetricResponse>>>;
};

/** A summarization of the core cpu and memory metrics for this cluster */
export type ClusterMetricsSummary = {
  __typename?: 'ClusterMetricsSummary';
  /** the cpu available in vcpu */
  cpuAvailable?: Maybe<Scalars['Float']['output']>;
  /** the total cpu in use in the cluster measured in vcpu */
  cpuTotal?: Maybe<Scalars['Float']['output']>;
  /** a percentage cpu utilization of the cluster */
  cpuUsed?: Maybe<Scalars['Int']['output']>;
  /** the total number of megabytes available in the cluster */
  memoryAvailable?: Maybe<Scalars['Float']['output']>;
  /** the total number of megabytes in use in the cluster */
  memoryTotal?: Maybe<Scalars['Float']['output']>;
  /** a percentage memory utilization of the cluster */
  memoryUsed?: Maybe<Scalars['Int']['output']>;
  nodes?: Maybe<Scalars['Int']['output']>;
};

export type ClusterNamespaceUsage = {
  __typename?: 'ClusterNamespaceUsage';
  cluster?: Maybe<Cluster>;
  cpu?: Maybe<Scalars['Float']['output']>;
  cpuCost?: Maybe<Scalars['Float']['output']>;
  /** the amount of cpu utilized */
  cpuUtil?: Maybe<Scalars['Float']['output']>;
  egressCost?: Maybe<Scalars['Float']['output']>;
  gpu?: Maybe<Scalars['Float']['output']>;
  gpuCost?: Maybe<Scalars['Float']['output']>;
  id: Scalars['ID']['output'];
  ingressCost?: Maybe<Scalars['Float']['output']>;
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  loadBalancerCost?: Maybe<Scalars['Float']['output']>;
  /** the amount of memory utilized */
  memUtil?: Maybe<Scalars['Float']['output']>;
  memory?: Maybe<Scalars['Float']['output']>;
  memoryCost?: Maybe<Scalars['Float']['output']>;
  namespace?: Maybe<Scalars['String']['output']>;
  /** the amount of storage used by this namespace */
  storage?: Maybe<Scalars['Float']['output']>;
  storageCost?: Maybe<Scalars['Float']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type ClusterNamespaceUsageConnection = {
  __typename?: 'ClusterNamespaceUsageConnection';
  edges?: Maybe<Array<Maybe<ClusterNamespaceUsageEdge>>>;
  pageInfo: PageInfo;
};

export type ClusterNamespaceUsageEdge = {
  __typename?: 'ClusterNamespaceUsageEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<ClusterNamespaceUsage>;
};

export type ClusterNamespacesAttributes = {
  certManager?: InputMaybe<Scalars['String']['input']>;
  cilium?: InputMaybe<Scalars['String']['input']>;
  ebsCsiDriver?: InputMaybe<Scalars['String']['input']>;
  externalDns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  istio?: InputMaybe<Scalars['String']['input']>;
  linkerd?: InputMaybe<Scalars['String']['input']>;
};

export type ClusterNodeMetrics = {
  __typename?: 'ClusterNodeMetrics';
  cpu?: Maybe<Array<Maybe<MetricResponse>>>;
  cpuUsage?: Maybe<Array<Maybe<MetricResponse>>>;
  memory?: Maybe<Array<Maybe<MetricResponse>>>;
  memoryUsage?: Maybe<Array<Maybe<MetricResponse>>>;
};

export type ClusterPing = {
  availabilityZones?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  cpuTotal?: InputMaybe<Scalars['Float']['input']>;
  cpuUtil?: InputMaybe<Scalars['Float']['input']>;
  currentVersion: Scalars['String']['input'];
  distro?: InputMaybe<ClusterDistro>;
  healthScore?: InputMaybe<Scalars['Int']['input']>;
  /** scraped k8s objects to use for cluster insights, don't send at all if not w/in the last scrape interval */
  insightComponents?: InputMaybe<Array<InputMaybe<ClusterInsightComponentAttributes>>>;
  kubeletVersion?: InputMaybe<Scalars['String']['input']>;
  memoryTotal?: InputMaybe<Scalars['Float']['input']>;
  memoryUtil?: InputMaybe<Scalars['Float']['input']>;
  namespaceCount?: InputMaybe<Scalars['Int']['input']>;
  nodeCount?: InputMaybe<Scalars['Int']['input']>;
  nodeStatistics?: InputMaybe<Array<InputMaybe<NodeStatisticAttributes>>>;
  openshiftVersion?: InputMaybe<Scalars['String']['input']>;
  /** the interval in seconds between pings to the cluster */
  pingInterval?: InputMaybe<Scalars['Int']['input']>;
  podCount?: InputMaybe<Scalars['Int']['input']>;
};

/** a CAPI provider for a cluster, cloud is inferred from name if not provided manually */
export type ClusterProvider = {
  __typename?: 'ClusterProvider';
  /** the name of the cloud service for this provider */
  cloud: Scalars['String']['output'];
  /** a list of credentials eligible for this provider */
  credentials?: Maybe<Array<Maybe<ProviderCredential>>>;
  /** when the cluster provider was deleted */
  deletedAt?: Maybe<Scalars['DateTime']['output']>;
  /** whether the current user can edit this resource */
  editable?: Maybe<Scalars['Boolean']['output']>;
  /** the details of how cluster manifests will be synced from git when created with this provider */
  git: GitRef;
  /** the id of this provider */
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** a human readable name for the provider, globally unique */
  name: Scalars['String']['output'];
  /** the namespace the CAPI resources are deployed into */
  namespace: Scalars['String']['output'];
  /** the repository for the CAPI service itself if customized */
  providerRepository?: Maybe<GitRepository>;
  /** the region names this provider can deploy to */
  regions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** the repository used to serve cluster manifests */
  repository?: Maybe<GitRepository>;
  runtimeServices?: Maybe<Array<Maybe<RuntimeService>>>;
  /** the service of the CAPI controller itself */
  service?: Maybe<ServiceDeployment>;
  /** the kubernetes versions this provider currently supports */
  supportedVersions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};


/** a CAPI provider for a cluster, cloud is inferred from name if not provided manually */
export type ClusterProviderRuntimeServicesArgs = {
  kubeVersion?: InputMaybe<Scalars['String']['input']>;
};

export type ClusterProviderAttributes = {
  cloud?: InputMaybe<Scalars['String']['input']>;
  cloudSettings?: InputMaybe<CloudProviderSettingsAttributes>;
  name: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};

export type ClusterProviderConnection = {
  __typename?: 'ClusterProviderConnection';
  edges?: Maybe<Array<Maybe<ClusterProviderEdge>>>;
  pageInfo: PageInfo;
};

export type ClusterProviderEdge = {
  __typename?: 'ClusterProviderEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<ClusterProvider>;
};

export type ClusterProviderUpdateAttributes = {
  cloudSettings?: InputMaybe<CloudProviderSettingsAttributes>;
  /** if you optionally want to reconfigure the git repository for the cluster provider */
  service?: InputMaybe<ClusterServiceAttributes>;
};

export type ClusterRecommendationAttributes = {
  container?: InputMaybe<Scalars['String']['input']>;
  cpuCost?: InputMaybe<Scalars['Float']['input']>;
  cpuRequest?: InputMaybe<Scalars['Float']['input']>;
  /** the historical cpu utilization for this scope */
  cpuUtil?: InputMaybe<Scalars['Float']['input']>;
  gpuCost?: InputMaybe<Scalars['Float']['input']>;
  /** the historical gpu utilization for this scope */
  gpuUtil?: InputMaybe<Scalars['Float']['input']>;
  memoryCost?: InputMaybe<Scalars['Float']['input']>;
  memoryRequest?: InputMaybe<Scalars['Float']['input']>;
  /** the historical memory utilization for this scope */
  memoryUtil?: InputMaybe<Scalars['Float']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  /** the service id known to be attached to this recommendation */
  serviceId?: InputMaybe<Scalars['ID']['input']>;
  type?: InputMaybe<ScalingRecommendationType>;
};

export type ClusterRegistration = {
  __typename?: 'ClusterRegistration';
  creator?: Maybe<User>;
  /** the handle to apply to the cluster */
  handle?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** a unique machine id for the created cluster */
  machineId: Scalars['String']['output'];
  /** additional metadata to apply to the cluster */
  metadata?: Maybe<Scalars['Map']['output']>;
  /** the name to give to the cluster */
  name?: Maybe<Scalars['String']['output']>;
  /** the project the cluster will live in */
  project?: Maybe<Project>;
  /** the tags to apply to the given cluster */
  tags?: Maybe<Array<Maybe<Tag>>>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type ClusterRegistrationConnection = {
  __typename?: 'ClusterRegistrationConnection';
  edges?: Maybe<Array<Maybe<ClusterRegistrationEdge>>>;
  pageInfo: PageInfo;
};

export type ClusterRegistrationCreateAttributes = {
  /** a unique machine id for the created cluster */
  machineId: Scalars['String']['input'];
  /** the project this cluster will live in (can be inferred from bootstrap token) */
  projectId?: InputMaybe<Scalars['ID']['input']>;
};

export type ClusterRegistrationEdge = {
  __typename?: 'ClusterRegistrationEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<ClusterRegistration>;
};

export type ClusterRegistrationUpdateAttributes = {
  /** the handle to apply to the cluster */
  handle?: InputMaybe<Scalars['String']['input']>;
  /** additional metadata to apply to the cluster */
  metadata?: InputMaybe<Scalars['Json']['input']>;
  /** the name to give to the cluster */
  name: Scalars['String']['input'];
  /** the tags to apply to the given cluster */
  tags?: InputMaybe<Array<InputMaybe<TagInput>>>;
};

export type ClusterRestore = {
  __typename?: 'ClusterRestore';
  backup?: Maybe<ClusterBackup>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  status: RestoreStatus;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type ClusterRestoreConnection = {
  __typename?: 'ClusterRestoreConnection';
  edges?: Maybe<Array<Maybe<ClusterRestoreEdge>>>;
  pageInfo: PageInfo;
};

export type ClusterRestoreEdge = {
  __typename?: 'ClusterRestoreEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<ClusterRestore>;
};

/** a historical revision of a cluster, including version, cloud and node group configuration */
export type ClusterRevision = {
  __typename?: 'ClusterRevision';
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  nodePools?: Maybe<Array<Maybe<NodePool>>>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  version?: Maybe<Scalars['String']['output']>;
};

export type ClusterRevisionConnection = {
  __typename?: 'ClusterRevisionConnection';
  edges?: Maybe<Array<Maybe<ClusterRevisionEdge>>>;
  pageInfo: PageInfo;
};

export type ClusterRevisionEdge = {
  __typename?: 'ClusterRevisionEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<ClusterRevision>;
};

export type ClusterScalingRecommendation = {
  __typename?: 'ClusterScalingRecommendation';
  cluster?: Maybe<Cluster>;
  container?: Maybe<Scalars['String']['output']>;
  cpuCost?: Maybe<Scalars['Float']['output']>;
  cpuRecommendation?: Maybe<Scalars['Float']['output']>;
  cpuRequest?: Maybe<Scalars['Float']['output']>;
  /** the historical cpu utilization for this scope */
  cpuUtil?: Maybe<Scalars['Float']['output']>;
  gpuCost?: Maybe<Scalars['Float']['output']>;
  /** the historical gpu utilization for this scope */
  gpuUtil?: Maybe<Scalars['Float']['output']>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  memoryCost?: Maybe<Scalars['Float']['output']>;
  memoryRecommendation?: Maybe<Scalars['Float']['output']>;
  memoryRequest?: Maybe<Scalars['Float']['output']>;
  /** the historical memory utilization for this scope */
  memoryUtil?: Maybe<Scalars['Float']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  namespace?: Maybe<Scalars['String']['output']>;
  service?: Maybe<ServiceDeployment>;
  type?: Maybe<ScalingRecommendationType>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type ClusterScalingRecommendationConnection = {
  __typename?: 'ClusterScalingRecommendationConnection';
  edges?: Maybe<Array<Maybe<ClusterScalingRecommendationEdge>>>;
  pageInfo: PageInfo;
};

export type ClusterScalingRecommendationEdge = {
  __typename?: 'ClusterScalingRecommendationEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<ClusterScalingRecommendation>;
};

export type ClusterServiceAttributes = {
  git: GitRefAttributes;
  id: Scalars['ID']['input'];
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};

/** the crd status of the cluster as seen by the CAPI operator */
export type ClusterStatus = {
  __typename?: 'ClusterStatus';
  conditions?: Maybe<Array<Maybe<ClusterCondition>>>;
  controlPlaneReady?: Maybe<Scalars['Boolean']['output']>;
  failureMessage?: Maybe<Scalars['String']['output']>;
  failureReason?: Maybe<Scalars['String']['output']>;
  phase?: Maybe<Scalars['String']['output']>;
};

/** a cluster info data struct */
export type ClusterStatusInfo = {
  __typename?: 'ClusterStatusInfo';
  count?: Maybe<Scalars['Int']['output']>;
  healthy?: Maybe<Scalars['Boolean']['output']>;
};

/** A spec for targeting clusters */
export type ClusterTarget = {
  __typename?: 'ClusterTarget';
  /** kubernetes distribution to target */
  distro?: Maybe<ClusterDistro>;
  /** the cluster tags to target */
  tags?: Maybe<Scalars['Map']['output']>;
};

/** A spec for targeting clusters */
export type ClusterTargetAttributes = {
  /** kubernetes distribution to target */
  distro?: InputMaybe<ClusterDistro>;
  /** the cluster tags to target */
  tags?: InputMaybe<Scalars['Json']['input']>;
};

export type ClusterUpdateAttributes = {
  distro?: InputMaybe<ClusterDistro>;
  /** a short, unique human readable name used to identify this cluster and does not necessarily map to the cloud resource name */
  handle?: InputMaybe<Scalars['String']['input']>;
  /** pass a kubeconfig for this cluster (DEPRECATED) */
  kubeconfig?: InputMaybe<KubeconfigAttributes>;
  metadata?: InputMaybe<Scalars['Json']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nodePools?: InputMaybe<Array<InputMaybe<NodePoolAttributes>>>;
  protect?: InputMaybe<Scalars['Boolean']['input']>;
  readBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
  /** if you optionally want to reconfigure the git repository for the cluster service */
  service?: InputMaybe<ClusterServiceAttributes>;
  tags?: InputMaybe<Array<InputMaybe<TagAttributes>>>;
  /** status of the upgrade plan for this cluster */
  upgradePlan?: InputMaybe<UpgradePlanAttributes>;
  version?: InputMaybe<Scalars['String']['input']>;
  writeBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
};

/** A consolidated checklist of tasks that need to be completed to upgrade this cluster */
export type ClusterUpgradePlan = {
  __typename?: 'ClusterUpgradePlan';
  /** whether api compatibilities with all addons and kubernetes are satisfied */
  compatibilities?: Maybe<Scalars['Boolean']['output']>;
  /** whether all api deprecations have been cleared for the target version */
  deprecations?: Maybe<Scalars['Boolean']['output']>;
  /** whether mutual api incompatibilities with all addons and kubernetes have been satisfied */
  incompatibilities?: Maybe<Scalars['Boolean']['output']>;
  /** whether the kubelet version is in line with the current version */
  kubeletSkew?: Maybe<Scalars['Boolean']['output']>;
};

export type ClusterUsage = {
  __typename?: 'ClusterUsage';
  cluster?: Maybe<Cluster>;
  controlPlaneCost?: Maybe<Scalars['Float']['output']>;
  cpu?: Maybe<Scalars['Float']['output']>;
  cpuCost?: Maybe<Scalars['Float']['output']>;
  /** the amount of cpu utilized */
  cpuUtil?: Maybe<Scalars['Float']['output']>;
  egressCost?: Maybe<Scalars['Float']['output']>;
  gpu?: Maybe<Scalars['Float']['output']>;
  gpuCost?: Maybe<Scalars['Float']['output']>;
  history?: Maybe<ClusterUsageHistoryConnection>;
  id: Scalars['ID']['output'];
  ingressCost?: Maybe<Scalars['Float']['output']>;
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  loadBalancerCost?: Maybe<Scalars['Float']['output']>;
  /** the amount of memory utilized */
  memUtil?: Maybe<Scalars['Float']['output']>;
  memory?: Maybe<Scalars['Float']['output']>;
  memoryCost?: Maybe<Scalars['Float']['output']>;
  namespaces?: Maybe<ClusterNamespaceUsageConnection>;
  nodeCost?: Maybe<Scalars['Float']['output']>;
  recommendations?: Maybe<ClusterScalingRecommendationConnection>;
  /** the amount of storage used by this cluster */
  storage?: Maybe<Scalars['Float']['output']>;
  storageCost?: Maybe<Scalars['Float']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};


export type ClusterUsageHistoryArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type ClusterUsageNamespacesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
};


export type ClusterUsageRecommendationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<ScalingRecommendationType>;
};

export type ClusterUsageConnection = {
  __typename?: 'ClusterUsageConnection';
  edges?: Maybe<Array<Maybe<ClusterUsageEdge>>>;
  pageInfo: PageInfo;
};

export type ClusterUsageEdge = {
  __typename?: 'ClusterUsageEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<ClusterUsage>;
};

export type ClusterUsageHistory = {
  __typename?: 'ClusterUsageHistory';
  cluster?: Maybe<Cluster>;
  controlPlaneCost?: Maybe<Scalars['Float']['output']>;
  cpuCost?: Maybe<Scalars['Float']['output']>;
  egressCost?: Maybe<Scalars['Float']['output']>;
  gpuCost?: Maybe<Scalars['Float']['output']>;
  id: Scalars['ID']['output'];
  ingressCost?: Maybe<Scalars['Float']['output']>;
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  loadBalancerCost?: Maybe<Scalars['Float']['output']>;
  memoryCost?: Maybe<Scalars['Float']['output']>;
  nodeCost?: Maybe<Scalars['Float']['output']>;
  storageCost?: Maybe<Scalars['Float']['output']>;
  timestamp: Scalars['DateTime']['output'];
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type ClusterUsageHistoryConnection = {
  __typename?: 'ClusterUsageHistoryConnection';
  edges?: Maybe<Array<Maybe<ClusterUsageHistoryEdge>>>;
  pageInfo: PageInfo;
};

export type ClusterUsageHistoryEdge = {
  __typename?: 'ClusterUsageHistoryEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<ClusterUsageHistory>;
};

export type ClusterVulnAggregate = {
  __typename?: 'ClusterVulnAggregate';
  cluster?: Maybe<Cluster>;
  count: Scalars['Int']['output'];
};

export type CommandAttributes = {
  args?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  cmd: Scalars['String']['input'];
  dir?: InputMaybe<Scalars['String']['input']>;
};

export enum ComplianceReportFormat {
  Csv = 'CSV',
  Json = 'JSON'
}

export type ComplianceReportGenerator = {
  __typename?: 'ComplianceReportGenerator';
  complianceReports?: Maybe<ComplianceReportsConnection>;
  format: ComplianceReportFormat;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  name: Scalars['String']['output'];
  /** download policy for this report */
  readBindings?: Maybe<Array<Maybe<PolicyBinding>>>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};


export type ComplianceReportGeneratorComplianceReportsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type ComplianceReportGeneratorAttributes = {
  /** the format of the compliance report when a user generates it */
  format: ComplianceReportFormat;
  /** the name of this generator */
  name: Scalars['String']['input'];
  readBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
};

export type ComplianceReportGeneratorConnection = {
  __typename?: 'ComplianceReportGeneratorConnection';
  edges?: Maybe<Array<Maybe<ComplianceReportGeneratorEdge>>>;
  pageInfo: PageInfo;
};

export type ComplianceReportGeneratorEdge = {
  __typename?: 'ComplianceReportGeneratorEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<ComplianceReportGenerator>;
};

export type ComplianceReports = {
  __typename?: 'ComplianceReports';
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  name: Scalars['String']['output'];
  sha256?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type ComplianceReportsConnection = {
  __typename?: 'ComplianceReportsConnection';
  edges?: Maybe<Array<Maybe<ComplianceReportsEdge>>>;
  pageInfo: PageInfo;
};

export type ComplianceReportsEdge = {
  __typename?: 'ComplianceReportsEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<ComplianceReports>;
};

export type ComponentAttributes = {
  children?: InputMaybe<Array<InputMaybe<ComponentChildAttributes>>>;
  content?: InputMaybe<ComponentContentAttributes>;
  group: Scalars['String']['input'];
  kind: Scalars['String']['input'];
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  state?: InputMaybe<ComponentState>;
  synced: Scalars['Boolean']['input'];
  uid?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['String']['input'];
};

export type ComponentChildAttributes = {
  group?: InputMaybe<Scalars['String']['input']>;
  kind: Scalars['String']['input'];
  name: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
  parentUid?: InputMaybe<Scalars['String']['input']>;
  state?: InputMaybe<ComponentState>;
  uid: Scalars['String']['input'];
  version: Scalars['String']['input'];
};

/** dry run content of a service component */
export type ComponentContent = {
  __typename?: 'ComponentContent';
  /** the inferred desired state of this component */
  desired?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  live?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

/** the content of a component when visualized in dry run state */
export type ComponentContentAttributes = {
  /** the desired state of a service component as determined from the configured manifests */
  desired?: InputMaybe<Scalars['String']['input']>;
  live?: InputMaybe<Scalars['String']['input']>;
};

export enum ComponentState {
  Failed = 'FAILED',
  Paused = 'PAUSED',
  Pending = 'PENDING',
  Running = 'RUNNING'
}

/** A tree view of the kubernetes object hierarchy beneath a component */
export type ComponentTree = {
  __typename?: 'ComponentTree';
  certificates?: Maybe<Array<Maybe<Certificate>>>;
  configmaps?: Maybe<Array<Maybe<ConfigMap>>>;
  cronjobs?: Maybe<Array<Maybe<CronJob>>>;
  daemonsets?: Maybe<Array<Maybe<DaemonSet>>>;
  deployments?: Maybe<Array<Maybe<Deployment>>>;
  edges?: Maybe<Array<Maybe<ResourceEdge>>>;
  ingresses?: Maybe<Array<Maybe<Ingress>>>;
  replicasets?: Maybe<Array<Maybe<ReplicaSet>>>;
  root?: Maybe<KubernetesUnstructured>;
  secrets?: Maybe<Array<Maybe<Secret>>>;
  services?: Maybe<Array<Maybe<Service>>>;
  statefulsets?: Maybe<Array<Maybe<StatefulSet>>>;
};

/** attributes for declaratively specifying whether a config item is relevant given prior config */
export type ConditionAttributes = {
  field: Scalars['String']['input'];
  operation: Operation;
  value?: InputMaybe<Scalars['String']['input']>;
};

export type ConfigAttributes = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type ConfigMap = {
  __typename?: 'ConfigMap';
  data: Scalars['Map']['output'];
  metadata: Metadata;
  raw: Scalars['String']['output'];
};

export enum ConfigurationType {
  Bool = 'BOOL',
  Bucket = 'BUCKET',
  Cluster = 'CLUSTER',
  Domain = 'DOMAIN',
  Enum = 'ENUM',
  File = 'FILE',
  Flow = 'FLOW',
  Function = 'FUNCTION',
  Group = 'GROUP',
  Int = 'INT',
  Password = 'PASSWORD',
  Project = 'PROJECT',
  String = 'STRING',
  User = 'USER'
}

/** Validations to apply to this configuration entry prior to PR creation */
export type ConfigurationValidationAttributes = {
  /** whether the string is json encoded */
  json?: InputMaybe<Scalars['Boolean']['input']>;
  /** regex a string value should match */
  regex?: InputMaybe<Scalars['String']['input']>;
  /** configuration for name uniqueness */
  uniqBy?: InputMaybe<UniqByAttributes>;
};

export enum Conjunction {
  And = 'AND',
  Or = 'OR'
}

export type ConsentRequest = {
  __typename?: 'ConsentRequest';
  requestedScope?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  skip?: Maybe<Scalars['Boolean']['output']>;
};

export type ConsoleConfiguration = {
  __typename?: 'ConsoleConfiguration';
  byok?: Maybe<Scalars['Boolean']['output']>;
  cloud?: Maybe<Scalars['Boolean']['output']>;
  consoleVersion?: Maybe<Scalars['String']['output']>;
  externalOidc?: Maybe<Scalars['Boolean']['output']>;
  features?: Maybe<AvailableFeatures>;
  gitCommit?: Maybe<Scalars['String']['output']>;
  gitStatus?: Maybe<GitStatus>;
  /** whether at least one cluster has been installed, false if a user hasn't fully onboarded */
  installed?: Maybe<Scalars['Boolean']['output']>;
  isDemoProject?: Maybe<Scalars['Boolean']['output']>;
  isSandbox?: Maybe<Scalars['Boolean']['output']>;
  manifest?: Maybe<PluralManifest>;
  oidcName?: Maybe<Scalars['String']['output']>;
  pluralLogin?: Maybe<Scalars['Boolean']['output']>;
  sentryEnabled?: Maybe<Scalars['Boolean']['output']>;
  vpnEnabled?: Maybe<Scalars['Boolean']['output']>;
};

export enum ConstraintEnforcement {
  Deny = 'DENY',
  DryRun = 'DRY_RUN',
  Warn = 'WARN'
}

export type ConstraintRef = {
  __typename?: 'ConstraintRef';
  kind: Scalars['String']['output'];
  name: Scalars['String']['output'];
};

export type ConstraintRefAttributes = {
  kind: Scalars['String']['input'];
  name: Scalars['String']['input'];
};

export enum ConstraintViolationField {
  Kind = 'KIND',
  Namespace = 'NAMESPACE'
}

export type Container = {
  __typename?: 'Container';
  image?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  ports?: Maybe<Array<Maybe<Port>>>;
  resources?: Maybe<Resources>;
};

/** the attributes for a container */
export type ContainerAttributes = {
  args?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  env?: InputMaybe<Array<InputMaybe<EnvAttributes>>>;
  envFrom?: InputMaybe<Array<InputMaybe<EnvFromAttributes>>>;
  image: Scalars['String']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  resources?: InputMaybe<ContainerResourcesAttributes>;
};

/** container env variable */
export type ContainerEnv = {
  __typename?: 'ContainerEnv';
  name: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

/** env from declarations for containers */
export type ContainerEnvFrom = {
  __typename?: 'ContainerEnvFrom';
  configMap: Scalars['String']['output'];
  secret: Scalars['String']['output'];
};

export type ContainerRecommendation = {
  __typename?: 'ContainerRecommendation';
  containerName?: Maybe<Scalars['String']['output']>;
  lowerBound?: Maybe<ResourceRequest>;
  name?: Maybe<Scalars['String']['output']>;
  target?: Maybe<ResourceRequest>;
  uncappedTarget?: Maybe<ResourceRequest>;
  upperBound?: Maybe<ResourceRequest>;
};

/** A combined kubernetes pod container resource requests spec */
export type ContainerResources = {
  __typename?: 'ContainerResources';
  limits?: Maybe<ResourceRequest>;
  requests?: Maybe<ResourceRequest>;
};

export type ContainerResourcesAttributes = {
  limits?: InputMaybe<ResourceRequestAttributes>;
  requests?: InputMaybe<ResourceRequestAttributes>;
};

/** a shortform spec for job containers, designed for ease-of-use */
export type ContainerSpec = {
  __typename?: 'ContainerSpec';
  args?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  env?: Maybe<Array<Maybe<ContainerEnv>>>;
  envFrom?: Maybe<Array<Maybe<ContainerEnvFrom>>>;
  image: Scalars['String']['output'];
  resources?: Maybe<ContainerResources>;
};

export type ContainerState = {
  __typename?: 'ContainerState';
  running?: Maybe<RunningState>;
  terminated?: Maybe<TerminatedState>;
  waiting?: Maybe<WaitingState>;
};

export type ContainerStatus = {
  __typename?: 'ContainerStatus';
  image?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  ready?: Maybe<Scalars['Boolean']['output']>;
  restartCount?: Maybe<Scalars['Int']['output']>;
  state?: Maybe<ContainerState>;
};

/** a binding from a service to a service context */
export type ContextBindingAttributes = {
  contextId: Scalars['String']['input'];
};

/** The source of additional context to send to a thread */
export enum ContextSource {
  Service = 'SERVICE',
  Stack = 'STACK'
}

export type CostAttributes = {
  controlPlaneCost?: InputMaybe<Scalars['Float']['input']>;
  cpu?: InputMaybe<Scalars['Float']['input']>;
  /** the historical cpu cost for this scope */
  cpuCost?: InputMaybe<Scalars['Float']['input']>;
  /** the historical cpu utilization for this scope */
  cpuUtil?: InputMaybe<Scalars['Float']['input']>;
  egressCost?: InputMaybe<Scalars['Float']['input']>;
  gpu?: InputMaybe<Scalars['Float']['input']>;
  /** the historical gpu cost for this scope */
  gpuCost?: InputMaybe<Scalars['Float']['input']>;
  /** the historical gpu utilization for this scope */
  gpuUtil?: InputMaybe<Scalars['Float']['input']>;
  ingressCost?: InputMaybe<Scalars['Float']['input']>;
  loadBalancerCost?: InputMaybe<Scalars['Float']['input']>;
  memory?: InputMaybe<Scalars['Float']['input']>;
  /** the historical memory cost for this scope */
  memoryCost?: InputMaybe<Scalars['Float']['input']>;
  /** the historical memory utilization for this scope */
  memoryUtil?: InputMaybe<Scalars['Float']['input']>;
  /** leave null if cluster scoped */
  namespace?: InputMaybe<Scalars['String']['input']>;
  nodeCost?: InputMaybe<Scalars['Float']['input']>;
  storage?: InputMaybe<Scalars['Float']['input']>;
  storageCost?: InputMaybe<Scalars['Float']['input']>;
};

export type CostIngestAttributes = {
  cluster?: InputMaybe<CostAttributes>;
  namespaces?: InputMaybe<Array<InputMaybe<CostAttributes>>>;
  recommendations?: InputMaybe<Array<InputMaybe<ClusterRecommendationAttributes>>>;
};

/** Settings for cost management */
export type CostSettings = {
  __typename?: 'CostSettings';
  enabled?: Maybe<Scalars['Boolean']['output']>;
  /** the percentage cushion above baseline usage to give when generation recommendations, default 20% */
  recommendationCushion?: Maybe<Scalars['Int']['output']>;
  /** the percentage change needed to generate a recommendation, default 30% */
  recommendationThreshold?: Maybe<Scalars['Int']['output']>;
};

/** Settings for cost management */
export type CostSettingsAttributes = {
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** the percentage change needed to generate a recommendation, default 20% */
  recommendationCushion?: InputMaybe<Scalars['Int']['input']>;
  /** the percentage change needed to generate a recommendation, default 30% */
  recommendationThreshold?: InputMaybe<Scalars['Int']['input']>;
};

export type CreatePrConfigAttributes = {
  /** a scm connection id to use for pr automations */
  connectionId?: InputMaybe<Scalars['ID']['input']>;
};

export type CronJob = {
  __typename?: 'CronJob';
  events?: Maybe<Array<Maybe<Event>>>;
  jobs?: Maybe<Array<Maybe<Job>>>;
  metadata: Metadata;
  raw: Scalars['String']['output'];
  spec: CronSpec;
  status: CronStatus;
};

export type CronSpec = {
  __typename?: 'CronSpec';
  concurrencyPolicy?: Maybe<Scalars['String']['output']>;
  schedule: Scalars['String']['output'];
  suspend?: Maybe<Scalars['Boolean']['output']>;
};

export type CronStatus = {
  __typename?: 'CronStatus';
  active?: Maybe<Array<Maybe<JobReference>>>;
  lastScheduleTime?: Maybe<Scalars['String']['output']>;
};

export type CrossVersionResourceTarget = {
  __typename?: 'CrossVersionResourceTarget';
  apiVersion?: Maybe<Scalars['String']['output']>;
  kind?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

export type CustomRunStep = {
  __typename?: 'CustomRunStep';
  args?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  cmd: Scalars['String']['output'];
  requireApproval?: Maybe<Scalars['Boolean']['output']>;
  stage: StepStage;
};

export type CustomStackRun = {
  __typename?: 'CustomStackRun';
  /** the list of commands that will be executed */
  commands?: Maybe<Array<Maybe<StackCommand>>>;
  /** self-service configuration fields presented in the UI to configure how this run executes */
  configuration?: Maybe<Array<Maybe<PrConfiguration>>>;
  /** Documentation to explain to users what this will do */
  documentation?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Name of the custom stack run */
  name: Scalars['String']['output'];
  stack?: Maybe<InfrastructureStack>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type CustomStackRunAttributes = {
  /** the commands for this custom run */
  commands?: InputMaybe<Array<InputMaybe<CommandAttributes>>>;
  /** self-service configuration which will be presented in UI before triggering */
  configuration?: InputMaybe<Array<InputMaybe<PrConfigurationAttributes>>>;
  /** extended documentation to explain what this will do */
  documentation?: InputMaybe<Scalars['String']['input']>;
  /** human readable name for this custom run */
  name: Scalars['String']['input'];
  /** the stack to attach it to */
  stackId?: InputMaybe<Scalars['ID']['input']>;
};

export type CustomStackRunConnection = {
  __typename?: 'CustomStackRunConnection';
  edges?: Maybe<Array<Maybe<CustomStackRunEdge>>>;
  pageInfo: PageInfo;
};

export type CustomStackRunEdge = {
  __typename?: 'CustomStackRunEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<CustomStackRun>;
};

export type CustomStepAttributes = {
  args?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  cmd: Scalars['String']['input'];
  requireApproval?: InputMaybe<Scalars['Boolean']['input']>;
  stage?: InputMaybe<StepStage>;
};

export type Cvss = {
  __typename?: 'Cvss';
  v2Score?: Maybe<Scalars['Float']['output']>;
  v2Vector?: Maybe<Scalars['String']['output']>;
  v3Score?: Maybe<Scalars['Float']['output']>;
  v3Vector?: Maybe<Scalars['String']['output']>;
  v40Score?: Maybe<Scalars['Float']['output']>;
  v40Vector?: Maybe<Scalars['String']['output']>;
};

export type CvssAttributes = {
  v2Score?: InputMaybe<Scalars['Float']['input']>;
  v2Vector?: InputMaybe<Scalars['String']['input']>;
  v3Score?: InputMaybe<Scalars['Float']['input']>;
  v3Vector?: InputMaybe<Scalars['String']['input']>;
  v40Score?: InputMaybe<Scalars['Float']['input']>;
  v40Vector?: InputMaybe<Scalars['String']['input']>;
};

export type CvssBundle = {
  __typename?: 'CvssBundle';
  attackComplexity?: Maybe<VulnSeverity>;
  attackVector?: Maybe<VulnAttackVector>;
  availability?: Maybe<VulnSeverity>;
  confidentiality?: Maybe<VulnSeverity>;
  integrity?: Maybe<VulnSeverity>;
  nvidia?: Maybe<Cvss>;
  privilegesRequired?: Maybe<VulnSeverity>;
  redhat?: Maybe<Cvss>;
  userInteraction?: Maybe<VulnUserInteraction>;
};

export type CvssBundleAttributes = {
  nvidia?: InputMaybe<CvssAttributes>;
  redhat?: InputMaybe<CvssAttributes>;
};

export type DaemonSet = {
  __typename?: 'DaemonSet';
  events?: Maybe<Array<Maybe<Event>>>;
  metadata: Metadata;
  pods?: Maybe<Array<Maybe<Pod>>>;
  raw: Scalars['String']['output'];
  spec: DaemonSetSpec;
  status: DaemonSetStatus;
};

export type DaemonSetSpec = {
  __typename?: 'DaemonSetSpec';
  strategy?: Maybe<DeploymentStrategy>;
};

export type DaemonSetStatus = {
  __typename?: 'DaemonSetStatus';
  conditions?: Maybe<Array<Maybe<StatusCondition>>>;
  currentNumberScheduled?: Maybe<Scalars['Int']['output']>;
  desiredNumberScheduled?: Maybe<Scalars['Int']['output']>;
  numberReady?: Maybe<Scalars['Int']['output']>;
};

export type Dashboard = {
  __typename?: 'Dashboard';
  id: Scalars['String']['output'];
  spec: DashboardSpec;
};

export type DashboardGraph = {
  __typename?: 'DashboardGraph';
  format?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  queries?: Maybe<Array<Maybe<DashboardMetric>>>;
};

export type DashboardLabel = {
  __typename?: 'DashboardLabel';
  name: Scalars['String']['output'];
  values?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

export type DashboardMetric = {
  __typename?: 'DashboardMetric';
  legend?: Maybe<Scalars['String']['output']>;
  query?: Maybe<Scalars['String']['output']>;
  results?: Maybe<Array<Maybe<MetricResult>>>;
};

export type DashboardSpec = {
  __typename?: 'DashboardSpec';
  description?: Maybe<Scalars['String']['output']>;
  graphs?: Maybe<Array<Maybe<DashboardGraph>>>;
  labels?: Maybe<Array<Maybe<DashboardLabel>>>;
  name?: Maybe<Scalars['String']['output']>;
  timeslices?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

export type DatadogCredentialsAttributes = {
  apiKey: Scalars['String']['input'];
  appKey: Scalars['String']['input'];
};

export enum Delta {
  Create = 'CREATE',
  Delete = 'DELETE',
  Update = 'UPDATE'
}

/** A representation to a service which configures renovate for a scm connection */
export type DependencyManagementService = {
  __typename?: 'DependencyManagementService';
  connection?: Maybe<ScmConnection>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  service?: Maybe<ServiceDeployment>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type DependencyManagementServiceConnection = {
  __typename?: 'DependencyManagementServiceConnection';
  edges?: Maybe<Array<Maybe<DependencyManagementServiceEdge>>>;
  pageInfo: PageInfo;
};

export type DependencyManagementServiceEdge = {
  __typename?: 'DependencyManagementServiceEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<DependencyManagementService>;
};

export type Deployment = {
  __typename?: 'Deployment';
  events?: Maybe<Array<Maybe<Event>>>;
  metadata: Metadata;
  pods?: Maybe<Array<Maybe<Pod>>>;
  raw: Scalars['String']['output'];
  spec: DeploymentSpec;
  status: DeploymentStatus;
};

/** global settings for CD, these specify global read/write policies and also allow for customization of the repos for CAPI resources and the deploy operator */
export type DeploymentSettings = {
  __typename?: 'DeploymentSettings';
  /** custom helm values to apply to all agents (useful for things like adding customary annotations/labels) */
  agentHelmValues?: Maybe<Scalars['String']['output']>;
  /** The console's expected agent version */
  agentVsn: Scalars['String']['output'];
  /** settings for LLM provider clients */
  ai?: Maybe<AiSettings>;
  /** the repo to fetch CAPI manifests from, for both providers and clusters */
  artifactRepository?: Maybe<GitRepository>;
  /** your compliant k8s version */
  compliantK8sVsn: Scalars['String']['output'];
  /** settings for cost management */
  cost?: Maybe<CostSettings>;
  /** policy for creation of new objects */
  createBindings?: Maybe<Array<Maybe<PolicyBinding>>>;
  /** the repo to fetch the deploy operators manifests from */
  deployerRepository?: Maybe<GitRepository>;
  /** whether you've yet to enable CD for this instance */
  enabled: Scalars['Boolean']['output'];
  /** policy for managing git repos */
  gitBindings?: Maybe<Array<Maybe<PolicyBinding>>>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the latest known k8s version */
  latestK8sVsn: Scalars['String']['output'];
  /** settings for connections to log aggregation datastores */
  logging?: Maybe<LoggingSettings>;
  /** the way we can connect to your loki instance */
  lokiConnection?: Maybe<HttpConnection>;
  /** the root repo you used to run `plural up` */
  mgmtRepo?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  /** whether the console has been onboarded and getting started pages need to be shown */
  onboarded?: Maybe<Scalars['Boolean']['output']>;
  /** the way we can connect to your prometheus instance */
  prometheusConnection?: Maybe<HttpConnection>;
  /** read policy across all objects */
  readBindings?: Maybe<Array<Maybe<PolicyBinding>>>;
  /** whether the byok cluster has been brought under self-management */
  selfManaged?: Maybe<Scalars['Boolean']['output']>;
  /** smtp server configuration for email notifications */
  smtp?: Maybe<SmtpSettings>;
  /** global settings for stack configuration */
  stacks?: Maybe<StackSettings>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** write policy across all objects */
  writeBindings?: Maybe<Array<Maybe<PolicyBinding>>>;
};

export type DeploymentSettingsAttributes = {
  /** custom helm values to apply to all agents (useful for things like adding customary annotations/labels) */
  agentHelmValues?: InputMaybe<Scalars['String']['input']>;
  /** configuration for LLM provider clients */
  ai?: InputMaybe<AiSettingsAttributes>;
  artifactRepositoryId?: InputMaybe<Scalars['ID']['input']>;
  /** settings for cost management functionality */
  cost?: InputMaybe<CostSettingsAttributes>;
  createBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
  deployerRepositoryId?: InputMaybe<Scalars['ID']['input']>;
  gitBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
  logging?: InputMaybe<LoggingSettingsAttributes>;
  /** connection details for a loki instance to use */
  lokiConnection?: InputMaybe<HttpConnectionAttributes>;
  mgmtRepo?: InputMaybe<Scalars['String']['input']>;
  /** connection details for a prometheus instance to use */
  prometheusConnection?: InputMaybe<HttpConnectionAttributes>;
  readBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
  /** configuration for smtp message delivery */
  smtp?: InputMaybe<SmtpSettingsAttributes>;
  /** global configuration for stack execution */
  stacks?: InputMaybe<StackSettingsAttributes>;
  writeBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
};

export type DeploymentSpec = {
  __typename?: 'DeploymentSpec';
  replicas?: Maybe<Scalars['Int']['output']>;
  strategy?: Maybe<DeploymentStrategy>;
};

export type DeploymentStatus = {
  __typename?: 'DeploymentStatus';
  availableReplicas?: Maybe<Scalars['Int']['output']>;
  conditions?: Maybe<Array<Maybe<StatusCondition>>>;
  readyReplicas?: Maybe<Scalars['Int']['output']>;
  replicas?: Maybe<Scalars['Int']['output']>;
  unavailableReplicas?: Maybe<Scalars['Int']['output']>;
};

export type DeploymentStrategy = {
  __typename?: 'DeploymentStrategy';
  rollingUpdate?: Maybe<RollingUpdate>;
  type?: Maybe<Scalars['String']['output']>;
};

export type DeprecatedCustomResource = {
  __typename?: 'DeprecatedCustomResource';
  /** the cluster this resource belongs to */
  cluster?: Maybe<Cluster>;
  group: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  kind: Scalars['String']['output'];
  name?: Maybe<Scalars['String']['output']>;
  namespace?: Maybe<Scalars['String']['output']>;
  /** the next discovered version of this resource */
  nextVersion: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  version: Scalars['String']['output'];
};

export type DeprecatedCustomResourceAttributes = {
  group: Scalars['String']['input'];
  kind: Scalars['String']['input'];
  name: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
  /** the next valid version for this resource */
  nextVersion: Scalars['String']['input'];
  version: Scalars['String']['input'];
};

/** Allows you to control whether a specific set of fields in a kubernetes object is drift detected */
export type DiffNormalizer = {
  __typename?: 'DiffNormalizer';
  /** Whether to backfill the given pointers with the current live value, or otherwise ignore it entirely */
  backfill?: Maybe<Scalars['Boolean']['output']>;
  /** A list of json pointers to the fields to ignore */
  jsonPointers?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The kind of the resource to normalize */
  kind?: Maybe<Scalars['String']['output']>;
  /** The name of the resource to normalize */
  name?: Maybe<Scalars['String']['output']>;
  /** The namespace of the resource to normalize */
  namespace?: Maybe<Scalars['String']['output']>;
};

export type DiffNormalizerAttributes = {
  /** whether you should backfill the given pointers with the current live value, or otherwise ignore it entirely */
  backfill?: InputMaybe<Scalars['Boolean']['input']>;
  /** A list of json patches to apply to the service which controls how drift detection works */
  jsonPointers?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  kind?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
};

export type ElasticsearchConnection = {
  __typename?: 'ElasticsearchConnection';
  host: Scalars['String']['output'];
  /** the index to query for log data */
  index: Scalars['String']['output'];
  user?: Maybe<Scalars['String']['output']>;
};

export type ElasticsearchConnectionAttributes = {
  host: Scalars['String']['input'];
  index: Scalars['String']['input'];
  password?: InputMaybe<Scalars['String']['input']>;
  user?: InputMaybe<Scalars['String']['input']>;
};

export type EmailSettings = {
  __typename?: 'EmailSettings';
  /** whether you want to receive digest emails */
  digest?: Maybe<Scalars['Boolean']['output']>;
};

export type EmailSettingsAttributes = {
  /** whether you want to receive digest emails */
  digest?: InputMaybe<Scalars['Boolean']['input']>;
};

export type EnvAttributes = {
  name: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type EnvFromAttributes = {
  configMap: Scalars['String']['input'];
  secret: Scalars['String']['input'];
};

export type Event = {
  __typename?: 'Event';
  action?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  eventTime?: Maybe<Scalars['String']['output']>;
  lastTimestamp?: Maybe<Scalars['String']['output']>;
  message?: Maybe<Scalars['String']['output']>;
  reason?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
};

export enum EvidenceType {
  Alert = 'ALERT',
  Knowledge = 'KNOWLEDGE',
  Log = 'LOG',
  Pr = 'PR'
}

/** A federated credential is a way to authenticate users from an external identity provider */
export type FederatedCredential = {
  __typename?: 'FederatedCredential';
  claimsLike?: Maybe<Scalars['Map']['output']>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  issuer: Scalars['String']['output'];
  scopes?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  user?: Maybe<User>;
};

/** A federated credential is a way to authenticate users from an external identity provider */
export type FederatedCredentialAttributes = {
  claimsLike?: InputMaybe<Scalars['Json']['input']>;
  issuer: Scalars['String']['input'];
  scopes?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  userId: Scalars['ID']['input'];
};

export type Flow = {
  __typename?: 'Flow';
  alerts?: Maybe<AlertConnection>;
  description?: Maybe<Scalars['String']['output']>;
  icon?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  name: Scalars['String']['output'];
  pipelines?: Maybe<PipelineConnection>;
  previewEnvironmentInstances?: Maybe<PreviewEnvironmentInstanceConnection>;
  previewEnvironmentTemplates?: Maybe<PreviewEnvironmentTemplateConnection>;
  /** the project this flow belongs to */
  project?: Maybe<Project>;
  pullRequests?: Maybe<PullRequestConnection>;
  /** read policy for this flow */
  readBindings?: Maybe<Array<Maybe<PolicyBinding>>>;
  /** the git https urls of the application code repositories used in this flow */
  repositories?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** servers that are bound to this flow */
  servers?: Maybe<Array<Maybe<McpServer>>>;
  services?: Maybe<ServiceDeploymentConnection>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  vulnerabilityReports?: Maybe<VulnerabilityReportConnection>;
  /** write policy for this flow */
  writeBindings?: Maybe<Array<Maybe<PolicyBinding>>>;
};


export type FlowAlertsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type FlowPipelinesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type FlowPreviewEnvironmentInstancesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type FlowPreviewEnvironmentTemplatesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type FlowPullRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type FlowServicesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type FlowVulnerabilityReportsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type FlowAttributes = {
  description?: InputMaybe<Scalars['String']['input']>;
  icon?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  projectId?: InputMaybe<Scalars['ID']['input']>;
  readBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
  repositories?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  serverAssociations?: InputMaybe<Array<InputMaybe<McpServerAssociationAttributes>>>;
  writeBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
};

export type FlowConnection = {
  __typename?: 'FlowConnection';
  edges?: Maybe<Array<Maybe<FlowEdge>>>;
  pageInfo: PageInfo;
};

export type FlowEdge = {
  __typename?: 'FlowEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<Flow>;
};

/** a Flux crd representation of a Helm repository */
export type FluxHelmRepository = {
  __typename?: 'FluxHelmRepository';
  /** the charts found in this repository (heavy operation, don't do in list endpoints) */
  charts?: Maybe<Array<Maybe<HelmChartEntry>>>;
  metadata: Metadata;
  spec: HelmRepositorySpec;
  /** can fetch the status of a given helm repository */
  status?: Maybe<HelmRepositoryStatus>;
};

/** spec for a job gate */
export type GateJobAttributes = {
  annotations?: InputMaybe<Scalars['Json']['input']>;
  containers?: InputMaybe<Array<InputMaybe<ContainerAttributes>>>;
  labels?: InputMaybe<Scalars['Json']['input']>;
  namespace: Scalars['String']['input'];
  nodeSelector?: InputMaybe<Scalars['Json']['input']>;
  /** if you'd rather define the job spec via straight k8s yaml */
  raw?: InputMaybe<Scalars['String']['input']>;
  /** request overrides if you don't want to manually configure individual containers */
  resources?: InputMaybe<ContainerResourcesAttributes>;
  serviceAccount?: InputMaybe<Scalars['String']['input']>;
  tolerations?: InputMaybe<Array<InputMaybe<PodTolerationAttributes>>>;
};

/** detailed gate specifications */
export type GateSpec = {
  __typename?: 'GateSpec';
  job?: Maybe<JobGateSpec>;
};

/** a more refined spec for parameters needed for complex gates */
export type GateSpecAttributes = {
  job?: InputMaybe<GateJobAttributes>;
};

export enum GateState {
  Closed = 'CLOSED',
  Open = 'OPEN',
  Pending = 'PENDING',
  Running = 'RUNNING'
}

/** state delineating the current status of this gate */
export type GateStatus = {
  __typename?: 'GateStatus';
  jobRef?: Maybe<JobReference>;
};

export type GateStatusAttributes = {
  jobRef?: InputMaybe<NamespacedName>;
};

export enum GateType {
  Approval = 'APPROVAL',
  Job = 'JOB',
  Window = 'WINDOW'
}

/** the allowed inputs for a deployment agent gate update */
export type GateUpdateAttributes = {
  state?: InputMaybe<GateState>;
  status?: InputMaybe<GateStatusAttributes>;
};

export type GcpCloudAttributes = {
  network?: InputMaybe<Scalars['String']['input']>;
  project?: InputMaybe<Scalars['String']['input']>;
  region?: InputMaybe<Scalars['String']['input']>;
};

export type GcpCloudConnectionAttributes = {
  projectId: Scalars['String']['input'];
  serviceAccountKey: Scalars['String']['input'];
};

/** gcp specific cluster cloud configuration */
export type GcpCloudSettings = {
  __typename?: 'GcpCloudSettings';
  network?: Maybe<Scalars['String']['output']>;
  project?: Maybe<Scalars['String']['output']>;
  region?: Maybe<Scalars['String']['output']>;
};

/** The configuration for a cloud provider */
export type GcpConnectionAttributes = {
  __typename?: 'GcpConnectionAttributes';
  /** the project id for gcp */
  projectId: Scalars['String']['output'];
  /** the service account key for gcp */
  serviceAccountKey: Scalars['String']['output'];
};

export type GcpSettingsAttributes = {
  applicationCredentials: Scalars['String']['input'];
};

export type GcsStore = {
  __typename?: 'GcsStore';
  bucket: Scalars['String']['output'];
  region?: Maybe<Scalars['String']['output']>;
};

export type GcsStoreAttributes = {
  applicationCredentials: Scalars['String']['input'];
  bucket: Scalars['String']['input'];
  region?: InputMaybe<Scalars['String']['input']>;
};

export type GitAttributes = {
  /** id of a scm connection to use for authentication */
  connectionId?: InputMaybe<Scalars['ID']['input']>;
  /** whether to run plural crypto on this repo */
  decrypt?: InputMaybe<Scalars['Boolean']['input']>;
  /** a manually supplied https path for non standard git setups.  This is auto-inferred in many cases */
  httpsPath?: InputMaybe<Scalars['String']['input']>;
  /** a passphrase to decrypt the given private key */
  passphrase?: InputMaybe<Scalars['String']['input']>;
  /** the http password for http authenticated repos */
  password?: InputMaybe<Scalars['String']['input']>;
  /** an ssh private key to use with this repo if an ssh url was given */
  privateKey?: InputMaybe<Scalars['String']['input']>;
  /** the url of this repository */
  url: Scalars['String']['input'];
  /** similar to https_path, a manually supplied url format for custom git.  Should be something like {url}/tree/{ref}/{folder} */
  urlFormat?: InputMaybe<Scalars['String']['input']>;
  /** the http username for authenticated http repos, defaults to apiKey for github */
  username?: InputMaybe<Scalars['String']['input']>;
};

/** a file fetched from a git repository, eg a docs .md file */
export type GitFile = {
  __typename?: 'GitFile';
  content: Scalars['String']['output'];
  path: Scalars['String']['output'];
};

export enum GitHealth {
  Failed = 'FAILED',
  Pullable = 'PULLABLE'
}

/** a representation of where to pull manifests from git */
export type GitRef = {
  __typename?: 'GitRef';
  /** a list of individual files to include as well */
  files?: Maybe<Array<Scalars['String']['output']>>;
  /** the folder manifests live under */
  folder: Scalars['String']['output'];
  /** a general git ref, either a branch name or commit sha understandable by `git checkout <ref>` */
  ref: Scalars['String']['output'];
};

export type GitRefAttributes = {
  /** the files to include in the tarball */
  files?: InputMaybe<Array<Scalars['String']['input']>>;
  /** the subdirectory in the git repository to use */
  folder: Scalars['String']['input'];
  /** the git reference to use */
  ref: Scalars['String']['input'];
};

/** a git repository available for deployments */
export type GitRepository = {
  __typename?: 'GitRepository';
  /** whether its a http or ssh url */
  authMethod?: Maybe<AuthMethod>;
  /** whether to run plural crypto unlock on this repo */
  decrypt?: Maybe<Scalars['Boolean']['output']>;
  /** whether the current user can edit this repo */
  editable?: Maybe<Scalars['Boolean']['output']>;
  /** the error message if there were any pull errors */
  error?: Maybe<Scalars['String']['output']>;
  /** whether we can currently pull this repo with the provided credentials */
  health?: Maybe<GitHealth>;
  /** the https url for this git repo */
  httpsPath?: Maybe<Scalars['String']['output']>;
  /** internal id of this repository */
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the last successsful git pull timestamp */
  pulledAt?: Maybe<Scalars['DateTime']['output']>;
  /** named refs like branches/tags for a repository */
  refs?: Maybe<Array<Scalars['String']['output']>>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the git url of the repository, either https or ssh supported */
  url: Scalars['String']['output'];
  /** a format string to get the http url for a subfolder in a git repo */
  urlFormat?: Maybe<Scalars['String']['output']>;
};

export type GitRepositoryConnection = {
  __typename?: 'GitRepositoryConnection';
  edges?: Maybe<Array<Maybe<GitRepositoryEdge>>>;
  pageInfo: PageInfo;
};

export type GitRepositoryEdge = {
  __typename?: 'GitRepositoryEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<GitRepository>;
};

export type GitStatus = {
  __typename?: 'GitStatus';
  cloned?: Maybe<Scalars['Boolean']['output']>;
  output?: Maybe<Scalars['String']['output']>;
};

/** Requirements to perform Github App authentication */
export type GithubAppAttributes = {
  /** Github App ID */
  appId: Scalars['String']['input'];
  /** ID of this github app installation */
  installationId: Scalars['String']['input'];
  /** PEM-encoded private key for this app */
  privateKey: Scalars['String']['input'];
};

/** a rules based mechanism to redeploy a service across a fleet of clusters */
export type GlobalService = {
  __typename?: 'GlobalService';
  /** behavior for all owned resources when this global service is deleted */
  cascade?: Maybe<Cascade>;
  /** additional context used to template service metadata during global service reconciliation */
  context?: Maybe<TemplateContext>;
  /** the kubernetes distribution to target with this global service */
  distro?: Maybe<ClusterDistro>;
  /** internal id of this global service */
  id: Scalars['ID']['output'];
  /** the id of the clusters to ignore */
  ignoreClusters?: Maybe<Array<Maybe<Scalars['ID']['output']>>>;
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** whether to include management clusters in the target set */
  mgmt?: Maybe<Scalars['Boolean']['output']>;
  /** a human readable name for this global service */
  name: Scalars['String']['output'];
  /** the service which created this global service */
  parent?: Maybe<ServiceDeployment>;
  /** a project this global service is bound to */
  project?: Maybe<Project>;
  /** whether to only apply to clusters with this provider */
  provider?: Maybe<ClusterProvider>;
  /** whether you want to reparent existing plural services under this global service */
  reparent?: Maybe<Scalars['Boolean']['output']>;
  /** the service to replicate across clusters */
  service?: Maybe<ServiceDeployment>;
  services?: Maybe<ServiceDeploymentConnection>;
  /** a set of tags to select clusters for this global service */
  tags?: Maybe<Array<Maybe<Tag>>>;
  /** the service template used to spawn services */
  template?: Maybe<ServiceTemplate>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};


/** a rules based mechanism to redeploy a service across a fleet of clusters */
export type GlobalServiceServicesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
};

/** A reference for a globalized service, which targets clusters based on the configured criteria */
export type GlobalServiceAttributes = {
  /** behavior for all owned resources when this global service is deleted */
  cascade?: InputMaybe<CascadeAttributes>;
  /** additional context used to template service metadata during global service reconciliation */
  context?: InputMaybe<TemplateContextAttributes>;
  /** kubernetes distribution to target */
  distro?: InputMaybe<ClusterDistro>;
  /** the id of the clusters to ignore */
  ignoreClusters?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** the interval at which the global service will be reconciled, default is 10m */
  interval?: InputMaybe<Scalars['String']['input']>;
  /** whether to include management clusters in the target set */
  mgmt?: InputMaybe<Scalars['Boolean']['input']>;
  /** name for this global service */
  name: Scalars['String']['input'];
  /** the id of the service creating this */
  parentId?: InputMaybe<Scalars['ID']['input']>;
  /** a project this global service will sync across */
  projectId?: InputMaybe<Scalars['ID']['input']>;
  /** cluster api provider to target */
  providerId?: InputMaybe<Scalars['ID']['input']>;
  /** whether you want the global service to take ownership of existing plural services */
  reparent?: InputMaybe<Scalars['Boolean']['input']>;
  /** the cluster tags to target */
  tags?: InputMaybe<Array<InputMaybe<TagAttributes>>>;
  template?: InputMaybe<ServiceTemplateAttributes>;
};

export type GlobalServiceConnection = {
  __typename?: 'GlobalServiceConnection';
  edges?: Maybe<Array<Maybe<GlobalServiceEdge>>>;
  pageInfo: PageInfo;
};

export type GlobalServiceEdge = {
  __typename?: 'GlobalServiceEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<GlobalService>;
};

/** The webhook configuration for a pr governance controller */
export type GovernanceWebhook = {
  __typename?: 'GovernanceWebhook';
  url: Scalars['String']['output'];
};

/** The settings for configuring a pr governance controller */
export type GovernanceWebhookAttributes = {
  /** the url to send webhooks to */
  url: Scalars['String']['input'];
};

export type GraphStoreAttributes = {
  elastic?: InputMaybe<ElasticsearchConnectionAttributes>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  store?: InputMaybe<VectorStore>;
};

export type Group = {
  __typename?: 'Group';
  description?: Maybe<Scalars['String']['output']>;
  /** automatically adds all users in the system to this group */
  global?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  name: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type GroupAttributes = {
  description?: InputMaybe<Scalars['String']['input']>;
  global?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
};

export type GroupConnection = {
  __typename?: 'GroupConnection';
  edges?: Maybe<Array<Maybe<GroupEdge>>>;
  pageInfo: PageInfo;
};

export type GroupEdge = {
  __typename?: 'GroupEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<Group>;
};

export type GroupMember = {
  __typename?: 'GroupMember';
  group?: Maybe<Group>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  user?: Maybe<User>;
};

export type GroupMemberConnection = {
  __typename?: 'GroupMemberConnection';
  edges?: Maybe<Array<Maybe<GroupMemberEdge>>>;
  pageInfo: PageInfo;
};

export type GroupMemberEdge = {
  __typename?: 'GroupMemberEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<GroupMember>;
};

export type HealthRange = {
  max?: InputMaybe<Scalars['Int']['input']>;
  min?: InputMaybe<Scalars['Int']['input']>;
};

export enum HeatMapFlavor {
  Namespace = 'NAMESPACE',
  Node = 'NODE',
  Pod = 'POD'
}

export type HelmAuthAttributes = {
  aws?: InputMaybe<HelmAwsAuthAttributes>;
  azure?: InputMaybe<HelmAzureAuthAttributes>;
  basic?: InputMaybe<HelmBasicAuthAttributes>;
  bearer?: InputMaybe<HelmBearerAuthAttributes>;
  gcp?: InputMaybe<HelmGcpAuthAttributes>;
};

export enum HelmAuthProvider {
  Aws = 'AWS',
  Azure = 'AZURE',
  Basic = 'BASIC',
  Bearer = 'BEARER',
  Gcp = 'GCP'
}

export type HelmAwsAuthAttributes = {
  accessKey?: InputMaybe<Scalars['String']['input']>;
  assumeRoleArn?: InputMaybe<Scalars['String']['input']>;
  secretAccessKey?: InputMaybe<Scalars['String']['input']>;
};

export type HelmAzureAuthAttributes = {
  clientId?: InputMaybe<Scalars['String']['input']>;
  clientSecret?: InputMaybe<Scalars['String']['input']>;
  subscriptionId?: InputMaybe<Scalars['String']['input']>;
  tenantId?: InputMaybe<Scalars['String']['input']>;
};

export type HelmBasicAuthAttributes = {
  password: Scalars['String']['input'];
  username: Scalars['String']['input'];
};

export type HelmBearerAuthAttributes = {
  token: Scalars['String']['input'];
};

/** a chart manifest entry, including all versions */
export type HelmChartEntry = {
  __typename?: 'HelmChartEntry';
  /** the name of the chart */
  name?: Maybe<Scalars['String']['output']>;
  /** all found versions of the chart */
  versions?: Maybe<Array<Maybe<HelmChartVersion>>>;
};

/** a chart version contained within a helm repository manifest */
export type HelmChartVersion = {
  __typename?: 'HelmChartVersion';
  /** the version of the app contained w/in this chart */
  appVersion?: Maybe<Scalars['String']['output']>;
  /** sha digest of this chart's contents */
  digest?: Maybe<Scalars['String']['output']>;
  /** the name of the chart */
  name?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  /** the version of the chart itself */
  version?: Maybe<Scalars['String']['output']>;
};

export type HelmConfigAttributes = {
  chart?: InputMaybe<Scalars['String']['input']>;
  git?: InputMaybe<GitRefAttributes>;
  ignoreCrds?: InputMaybe<Scalars['Boolean']['input']>;
  ignoreHooks?: InputMaybe<Scalars['Boolean']['input']>;
  luaFile?: InputMaybe<Scalars['String']['input']>;
  luaFolder?: InputMaybe<Scalars['String']['input']>;
  luaScript?: InputMaybe<Scalars['String']['input']>;
  release?: InputMaybe<Scalars['String']['input']>;
  repository?: InputMaybe<NamespacedName>;
  /** pointer to a Plural GitRepository */
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
  set?: InputMaybe<HelmValueAttributes>;
  url?: InputMaybe<Scalars['String']['input']>;
  values?: InputMaybe<Scalars['String']['input']>;
  valuesFiles?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  version?: InputMaybe<Scalars['String']['input']>;
};

export type HelmGcpAuthAttributes = {
  applicationCredentials?: InputMaybe<Scalars['String']['input']>;
};

export type HelmMinimal = {
  __typename?: 'HelmMinimal';
  /** the helm release name to use when rendering this helm chart */
  release?: Maybe<Scalars['String']['output']>;
  /** a helm values file to use when rendering this helm chart */
  values?: Maybe<Scalars['String']['output']>;
  /** a list of relative paths to values files to use for helm chart templating */
  valuesFiles?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

export type HelmMinimalAttributes = {
  /** the helm release name to use when rendering this helm chart */
  release?: InputMaybe<Scalars['String']['input']>;
  /** a helm values file to use when rendering this helm chart */
  values?: InputMaybe<Scalars['String']['input']>;
  /** a list of relative paths to values files to use for helm chart templating */
  valuesFiles?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** A direct Plural representation of a Helm repository */
export type HelmRepository = {
  __typename?: 'HelmRepository';
  error?: Maybe<Scalars['String']['output']>;
  health?: Maybe<GitHealth>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  provider?: Maybe<HelmAuthProvider>;
  pulledAt?: Maybe<Scalars['DateTime']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  url: Scalars['String']['output'];
};

export type HelmRepositoryAttributes = {
  auth?: InputMaybe<HelmAuthAttributes>;
  provider?: InputMaybe<HelmAuthProvider>;
};

export type HelmRepositoryConnection = {
  __typename?: 'HelmRepositoryConnection';
  edges?: Maybe<Array<Maybe<HelmRepositoryEdge>>>;
  pageInfo: PageInfo;
};

export type HelmRepositoryEdge = {
  __typename?: 'HelmRepositoryEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<HelmRepository>;
};

/** a specification of how a helm repository is fetched */
export type HelmRepositorySpec = {
  __typename?: 'HelmRepositorySpec';
  provider?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  url: Scalars['String']['output'];
};

/** the state of this helm repository */
export type HelmRepositoryStatus = {
  __typename?: 'HelmRepositoryStatus';
  message?: Maybe<Scalars['String']['output']>;
  ready?: Maybe<Scalars['Boolean']['output']>;
};

export type HelmSpec = {
  __typename?: 'HelmSpec';
  /** the name of the chart this service is using */
  chart?: Maybe<Scalars['String']['output']>;
  /** spec of where to find the chart in git */
  git?: Maybe<GitRef>;
  ignoreCrds?: Maybe<Scalars['Boolean']['output']>;
  ignoreHooks?: Maybe<Scalars['Boolean']['output']>;
  /** a lua file to use for helm applies */
  luaFile?: Maybe<Scalars['String']['output']>;
  /** a folder of lua files to include in the final script used */
  luaFolder?: Maybe<Scalars['String']['output']>;
  /** a lua script to use for helm applies */
  luaScript?: Maybe<Scalars['String']['output']>;
  release?: Maybe<Scalars['String']['output']>;
  /** pointer to the flux helm repository resource used for this chart */
  repository?: Maybe<ObjectReference>;
  /** a git repository in Plural to use as a source */
  repositoryId?: Maybe<Scalars['ID']['output']>;
  /** a list of helm name/value pairs to precisely set individual values */
  set?: Maybe<Array<Maybe<HelmValue>>>;
  /** the helm repository url to use */
  url?: Maybe<Scalars['String']['output']>;
  /** a helm values file to use with this service, requires auth and so is heavy to query */
  values?: Maybe<Scalars['String']['output']>;
  /** a list of relative paths to values files to use for helm applies */
  valuesFiles?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** the chart version in use currently */
  version?: Maybe<Scalars['String']['output']>;
};

/** a (possibly nested) helm value pair */
export type HelmValue = {
  __typename?: 'HelmValue';
  name: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type HelmValueAttributes = {
  /** helm value name, can be deeply nested via dot like `image.tag` */
  name?: InputMaybe<Scalars['String']['input']>;
  /** value of the attribute */
  value?: InputMaybe<Scalars['String']['input']>;
};

/** the details of how to connect to a http service like prometheus */
export type HttpConnection = {
  __typename?: 'HttpConnection';
  host: Scalars['String']['output'];
  /** user to connect w/ for basic auth */
  user?: Maybe<Scalars['String']['output']>;
};

export type HttpConnectionAttributes = {
  host: Scalars['String']['input'];
  /** password to connect w/ for basic auth */
  password?: InputMaybe<Scalars['String']['input']>;
  /** user to connect w/ for basic auth */
  user?: InputMaybe<Scalars['String']['input']>;
};

export type HttpIngressRule = {
  __typename?: 'HttpIngressRule';
  paths?: Maybe<Array<Maybe<IngressPath>>>;
};

/** Configuration for http proxy usage in connections to Git or SCM providers */
export type HttpProxyAttributes = {
  url: Scalars['String']['input'];
};

/** Configuration for http proxy usage in connections to Git or SCM providers */
export type HttpProxyConfiguration = {
  __typename?: 'HttpProxyConfiguration';
  url: Scalars['String']['output'];
};

export type InfrastructureStack = {
  __typename?: 'InfrastructureStack';
  /** the actor of this stack (defaults to root console user) */
  actor?: Maybe<User>;
  /** the agent id this stack is associated with */
  agentId?: Maybe<Scalars['String']['output']>;
  /** whether to require approval */
  approval?: Maybe<Scalars['Boolean']['output']>;
  /** why this run was cancelled */
  cancellationReason?: Maybe<Scalars['String']['output']>;
  /** the cluster this stack runs on */
  cluster?: Maybe<Cluster>;
  /** version/image config for the tool you're using */
  configuration: StackConfiguration;
  /** a cron to spawn runs for this stack */
  cron?: Maybe<StackCron>;
  customStackRuns?: Maybe<CustomStackRunConnection>;
  /** the stack definition in-use by this stack */
  definition?: Maybe<StackDefinition>;
  /** the run that physically destroys the stack */
  deleteRun?: Maybe<StackRun>;
  /** whether this stack was previously deleted and is pending cleanup */
  deletedAt?: Maybe<Scalars['DateTime']['output']>;
  /** environment variables for this stack */
  environment?: Maybe<Array<Maybe<StackEnvironment>>>;
  /** files bound to a run of this stack */
  files?: Maybe<Array<Maybe<StackFile>>>;
  /** reference w/in the repository where the IaC lives */
  git: GitRef;
  id?: Maybe<Scalars['ID']['output']>;
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** an insight explaining the state of this stack */
  insight?: Maybe<AiInsight>;
  /** the interval at which the stack will be reconciled, default is 5m */
  interval?: Maybe<Scalars['String']['output']>;
  /** optional k8s job configuration for the job that will apply this stack */
  jobSpec?: Maybe<JobGateSpec>;
  /** whether you want Plural to manage the state of this stack */
  manageState?: Maybe<Scalars['Boolean']['output']>;
  /** the name of the stack */
  name: Scalars['String']['output'];
  /** the next time the stack will be reconciled */
  nextPollAt?: Maybe<Scalars['DateTime']['output']>;
  /** a list of metrics to poll to determine if a stack run should be cancelled */
  observableMetrics?: Maybe<Array<Maybe<ObservableMetric>>>;
  /** the most recent output for this stack */
  output?: Maybe<Array<Maybe<StackOutput>>>;
  /** the service this stack was created w/in */
  parent?: Maybe<ServiceDeployment>;
  /** whether the stack is actively tracking changes in git */
  paused?: Maybe<Scalars['Boolean']['output']>;
  policyEngine?: Maybe<PolicyEngine>;
  /** The project this stack belongs to */
  project?: Maybe<Project>;
  pullRequests?: Maybe<PullRequestConnection>;
  readBindings?: Maybe<Array<Maybe<PolicyBinding>>>;
  /** the git repository you're sourcing IaC from */
  repository?: Maybe<GitRepository>;
  runs?: Maybe<StackRunConnection>;
  /** the most recent state of this stack */
  state?: Maybe<StackState>;
  /** The status of the last run of the stack */
  status: StackStatus;
  /** key/value tags to filter stacks */
  tags?: Maybe<Array<Maybe<Tag>>>;
  /** A type for the stack, specifies the tool to use to apply it */
  type: StackType;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Arbitrary variables to add to a stack run */
  variables?: Maybe<Scalars['Map']['output']>;
  /** the subdirectory you want to run the stack's commands w/in */
  workdir?: Maybe<Scalars['String']['output']>;
  writeBindings?: Maybe<Array<Maybe<PolicyBinding>>>;
};


export type InfrastructureStackCustomStackRunsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type InfrastructureStackPullRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type InfrastructureStackRunsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  pullRequestId?: InputMaybe<Scalars['ID']['input']>;
};

export type InfrastructureStackConnection = {
  __typename?: 'InfrastructureStackConnection';
  edges?: Maybe<Array<Maybe<InfrastructureStackEdge>>>;
  pageInfo: PageInfo;
};

export type InfrastructureStackEdge = {
  __typename?: 'InfrastructureStackEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<InfrastructureStack>;
};

export type Ingress = {
  __typename?: 'Ingress';
  certificates?: Maybe<Array<Maybe<Certificate>>>;
  events?: Maybe<Array<Maybe<Event>>>;
  metadata: Metadata;
  raw: Scalars['String']['output'];
  spec: IngressSpec;
  status: ServiceStatus;
};

export type IngressBackend = {
  __typename?: 'IngressBackend';
  serviceName?: Maybe<Scalars['String']['output']>;
  servicePort?: Maybe<Scalars['String']['output']>;
};

export type IngressPath = {
  __typename?: 'IngressPath';
  backend?: Maybe<IngressBackend>;
  path?: Maybe<Scalars['String']['output']>;
};

export type IngressRule = {
  __typename?: 'IngressRule';
  host?: Maybe<Scalars['String']['output']>;
  http?: Maybe<HttpIngressRule>;
};

export type IngressSpec = {
  __typename?: 'IngressSpec';
  ingressClassName?: Maybe<Scalars['String']['output']>;
  rules?: Maybe<Array<Maybe<IngressRule>>>;
  tls?: Maybe<Array<Maybe<IngressTls>>>;
};

export type IngressTls = {
  __typename?: 'IngressTls';
  hosts?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

export type InsightClientInfo = {
  __typename?: 'InsightClientInfo';
  count?: Maybe<Scalars['String']['output']>;
  lastRequestAt?: Maybe<Scalars['DateTime']['output']>;
  userAgent?: Maybe<Scalars['String']['output']>;
};

export type InsightClientInfoAttributes = {
  count?: InputMaybe<Scalars['String']['input']>;
  lastRequestAt?: InputMaybe<Scalars['DateTime']['input']>;
  userAgent?: InputMaybe<Scalars['String']['input']>;
};

export enum InsightComponentPriority {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM'
}

/** enumerable to describe the recency of this insight */
export enum InsightFreshness {
  Expired = 'EXPIRED',
  Fresh = 'FRESH',
  Stale = 'STALE'
}

export type Invite = {
  __typename?: 'Invite';
  email?: Maybe<Scalars['String']['output']>;
  secureId: Scalars['String']['output'];
};

export type InviteAttributes = {
  email?: InputMaybe<Scalars['String']['input']>;
};

export type IssuerRef = {
  __typename?: 'IssuerRef';
  group?: Maybe<Scalars['String']['output']>;
  kind?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

export type Job = {
  __typename?: 'Job';
  events?: Maybe<Array<Maybe<Event>>>;
  logs?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  metadata: Metadata;
  pods?: Maybe<Array<Maybe<Pod>>>;
  raw: Scalars['String']['output'];
  spec: JobSpec;
  status: JobStatus;
};


export type JobLogsArgs = {
  container: Scalars['String']['input'];
  sinceSeconds: Scalars['Int']['input'];
};

/** the full specification of a job gate */
export type JobGateSpec = {
  __typename?: 'JobGateSpec';
  /** any pod annotations to apply */
  annotations?: Maybe<Scalars['Map']['output']>;
  /** list of containers to run in this job */
  containers?: Maybe<Array<Maybe<ContainerSpec>>>;
  /** any pod labels to apply */
  labels?: Maybe<Scalars['Map']['output']>;
  /** the namespace the job will run in */
  namespace: Scalars['String']['output'];
  /** any pod node selector to apply */
  nodeSelector?: Maybe<Scalars['Map']['output']>;
  /** a raw kubernetes job resource, overrides any other configuration */
  raw?: Maybe<Scalars['String']['output']>;
  /** equivalent to resources, present for backwards compatibility */
  requests?: Maybe<ContainerResources>;
  /** requests overrides for cases where direct container configuration is unnecessary */
  resources?: Maybe<ContainerResources>;
  /** the service account the pod will use */
  serviceAccount?: Maybe<Scalars['String']['output']>;
  /** any pod tolerations to apply */
  tolerations?: Maybe<Array<Maybe<PodToleration>>>;
};

export type JobReference = {
  __typename?: 'JobReference';
  name: Scalars['String']['output'];
  namespace: Scalars['String']['output'];
};

export type JobSpec = {
  __typename?: 'JobSpec';
  activeDeadlineSeconds?: Maybe<Scalars['Int']['output']>;
  backoffLimit?: Maybe<Scalars['Int']['output']>;
  parallelism?: Maybe<Scalars['Int']['output']>;
};

export type JobStatus = {
  __typename?: 'JobStatus';
  active?: Maybe<Scalars['Int']['output']>;
  completionTime?: Maybe<Scalars['String']['output']>;
  failed?: Maybe<Scalars['Int']['output']>;
  startTime?: Maybe<Scalars['String']['output']>;
  succeeded?: Maybe<Scalars['Int']['output']>;
};

export type KnowledgeEvidence = {
  __typename?: 'KnowledgeEvidence';
  name?: Maybe<Scalars['String']['output']>;
  observations?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  type?: Maybe<Scalars['String']['output']>;
};

export type KubeconfigAttributes = {
  raw?: InputMaybe<Scalars['String']['input']>;
};

export type KubernetesUnstructured = {
  __typename?: 'KubernetesUnstructured';
  events?: Maybe<Array<Maybe<Event>>>;
  group?: Maybe<Scalars['String']['output']>;
  kind: Scalars['String']['output'];
  metadata: Metadata;
  raw?: Maybe<Scalars['Map']['output']>;
  version: Scalars['String']['output'];
};

/** information about the kubernetes version for a given cluster */
export type KubernetesVersionInfo = {
  __typename?: 'KubernetesVersionInfo';
  /** the distribution of kubernetes this info pertains to */
  distro?: Maybe<ClusterDistro>;
  /** whether this version is on extended support */
  extended?: Maybe<Scalars['Boolean']['output']>;
  /** the kubernetes version */
  version?: Maybe<Scalars['String']['output']>;
};

/** metadata needed for configuring kustomize */
export type Kustomize = {
  __typename?: 'Kustomize';
  /** if the kustomization will need to inflate a helm chart */
  enableHelm?: Maybe<Scalars['Boolean']['output']>;
  /** the path to the kustomization file to use */
  path: Scalars['String']['output'];
};

export type KustomizeAttributes = {
  /** if the kustomization will need to inflate a helm chart */
  enableHelm?: InputMaybe<Scalars['Boolean']['input']>;
  /** the path to the kustomization file to use */
  path: Scalars['String']['input'];
};

export type LabelInput = {
  name?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

export type LabelPair = {
  __typename?: 'LabelPair';
  name?: Maybe<Scalars['String']['output']>;
  value?: Maybe<Scalars['String']['output']>;
};

export enum ListMerge {
  Append = 'APPEND',
  Overwrite = 'OVERWRITE'
}

export type LoadBalancerIngressStatus = {
  __typename?: 'LoadBalancerIngressStatus';
  hostname?: Maybe<Scalars['String']['output']>;
  ip?: Maybe<Scalars['String']['output']>;
};

export type LoadBalancerStatus = {
  __typename?: 'LoadBalancerStatus';
  ingress?: Maybe<Array<Maybe<LoadBalancerIngressStatus>>>;
};

export type LogAggregationBucket = {
  __typename?: 'LogAggregationBucket';
  count?: Maybe<Scalars['Int']['output']>;
  timestamp?: Maybe<Scalars['DateTime']['output']>;
};

export type LogAggregationInput = {
  bucketSize?: InputMaybe<Scalars['String']['input']>;
};

export enum LogDriver {
  Elastic = 'ELASTIC',
  Opensearch = 'OPENSEARCH',
  Victoria = 'VICTORIA'
}

export type LogFacet = {
  __typename?: 'LogFacet';
  key: Scalars['String']['output'];
  value?: Maybe<Scalars['String']['output']>;
};

export type LogFacetInput = {
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type LogLine = {
  __typename?: 'LogLine';
  facets?: Maybe<Array<Maybe<LogFacet>>>;
  log?: Maybe<Scalars['String']['output']>;
  timestamp?: Maybe<Scalars['DateTime']['output']>;
};

export type LogStream = {
  __typename?: 'LogStream';
  stream?: Maybe<Scalars['Map']['output']>;
  values?: Maybe<Array<Maybe<MetricResult>>>;
};

export type LogTimeRange = {
  after?: InputMaybe<Scalars['DateTime']['input']>;
  before?: InputMaybe<Scalars['DateTime']['input']>;
  duration?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Settings for configuring log aggregation throughout Plural */
export type LoggingSettings = {
  __typename?: 'LoggingSettings';
  /** the type of log aggregation solution you wish to use */
  driver?: Maybe<LogDriver>;
  /** configures a connection to elasticsearch for logging */
  elastic?: Maybe<ElasticsearchConnection>;
  enabled?: Maybe<Scalars['Boolean']['output']>;
  /** configures a connection to aws opensearch for logging */
  opensearch?: Maybe<OpensearchConnection>;
  /** configures a connection to victoria metrics */
  victoria?: Maybe<HttpConnection>;
};

export type LoggingSettingsAttributes = {
  driver?: InputMaybe<LogDriver>;
  elastic?: InputMaybe<ElasticsearchConnectionAttributes>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  opensearch?: InputMaybe<OpensearchConnectionAttributes>;
  victoria?: InputMaybe<HttpConnectionAttributes>;
};

export type LoginInfo = {
  __typename?: 'LoginInfo';
  external?: Maybe<Scalars['Boolean']['output']>;
  oidcName?: Maybe<Scalars['String']['output']>;
  oidcUri?: Maybe<Scalars['String']['output']>;
};

export type LoginRequest = {
  __typename?: 'LoginRequest';
  requestedScope?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  subject?: Maybe<Scalars['String']['output']>;
};

export type LogsEvidence = {
  __typename?: 'LogsEvidence';
  clusterId?: Maybe<Scalars['ID']['output']>;
  line?: Maybe<Scalars['String']['output']>;
  lines?: Maybe<Array<Maybe<LogLine>>>;
  serviceId?: Maybe<Scalars['ID']['output']>;
};

export type LokiLabelFilter = {
  name: Scalars['String']['input'];
  /** whether to apply a regex match for this label */
  regex?: InputMaybe<Scalars['Boolean']['input']>;
  value: Scalars['String']['input'];
};

export type LokiLineFilter = {
  /** whether to treat this string as a regex match */
  regex?: InputMaybe<Scalars['Boolean']['input']>;
  /** the string to filter for (eg what is put in our search ui) */
  text?: InputMaybe<Scalars['String']['input']>;
};

export type LokiQuery = {
  filter?: InputMaybe<LokiLineFilter>;
  labels?: InputMaybe<Array<InputMaybe<LokiLabelFilter>>>;
};

/** A representation of a managed namespace, which is k8s namespace configuration + a service spec to define a namespace runtime */
export type ManagedNamespace = {
  __typename?: 'ManagedNamespace';
  /** annotations for this namespace */
  annotations?: Maybe<Scalars['Map']['output']>;
  /** behavior for all owned resources when this global service is deleted */
  cascade?: Maybe<Cascade>;
  /** the timestamp this namespace was deleted at, indicating it's currently draining */
  deletedAt?: Maybe<Scalars['DateTime']['output']>;
  /** A short description of the purpose of this namespace */
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the interval at which the global service will be reconciled, default is 10m */
  interval?: Maybe<Scalars['String']['output']>;
  /** labels for this namespace */
  labels?: Maybe<Scalars['Map']['output']>;
  /** the name of this namespace once its placed on a cluster */
  name: Scalars['String']['output'];
  /** override the name of the kubernetes namespace if `name` is not usable */
  namespace?: Maybe<Scalars['String']['output']>;
  /** the service which created this managed namespace */
  parent?: Maybe<ServiceDeployment>;
  /** a project this global service is bound to */
  project?: Maybe<Project>;
  /** a list of pull secrets to attach to this namespace */
  pullSecrets?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** A template for creating the core service for this namespace */
  service?: Maybe<ServiceTemplate>;
  services?: Maybe<ServiceDeploymentConnection>;
  /** The targeting criteria to select clusters this namespace is bound to */
  target?: Maybe<ClusterTarget>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};


/** A representation of a managed namespace, which is k8s namespace configuration + a service spec to define a namespace runtime */
export type ManagedNamespaceServicesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
};

/** Attributes for configuring a managed namespace */
export type ManagedNamespaceAttributes = {
  /** annotations for this namespace */
  annotations?: InputMaybe<Scalars['Json']['input']>;
  /** behavior for all owned resources when this global service is deleted */
  cascade?: InputMaybe<CascadeAttributes>;
  /** A short description of the purpose of this namespace */
  description?: InputMaybe<Scalars['String']['input']>;
  /** labels for this namespace */
  labels?: InputMaybe<Scalars['Json']['input']>;
  /** the name of this managed namespace (globally unique) */
  name: Scalars['String']['input'];
  /** the name of the namespace if `name` doesn't align */
  namespace?: InputMaybe<Scalars['String']['input']>;
  /** the id of the service creating this */
  parentId?: InputMaybe<Scalars['ID']['input']>;
  /** a project this managed namespace will sync across */
  projectId?: InputMaybe<Scalars['ID']['input']>;
  /** a list of pull secrets to attach to this namespace */
  pullSecrets?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  service?: InputMaybe<ServiceTemplateAttributes>;
  target?: InputMaybe<ClusterTargetAttributes>;
};

export type ManagedNamespaceConnection = {
  __typename?: 'ManagedNamespaceConnection';
  edges?: Maybe<Array<Maybe<ManagedNamespaceEdge>>>;
  pageInfo: PageInfo;
};

export type ManagedNamespaceEdge = {
  __typename?: 'ManagedNamespaceEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<ManagedNamespace>;
};

export type ManifestNetwork = {
  __typename?: 'ManifestNetwork';
  pluralDns?: Maybe<Scalars['Boolean']['output']>;
  subdomain?: Maybe<Scalars['String']['output']>;
};

export enum MatchStrategy {
  All = 'ALL',
  Any = 'ANY',
  Recursive = 'RECURSIVE'
}

export type McpHeaderAttributes = {
  name: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type McpServer = {
  __typename?: 'McpServer';
  audits?: Maybe<McpServerAuditConnection>;
  /** authentication specs for this server */
  authentication?: Maybe<McpServerAuthentication>;
  /** whether a tool call against this server should require user confirmation */
  confirm?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the name for this server */
  name: Scalars['String']['output'];
  /** read policy for this mcp server */
  readBindings?: Maybe<Array<Maybe<PolicyBinding>>>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the HTTP url the server is hosted on */
  url: Scalars['String']['output'];
  /** write policy for this mcp server */
  writeBindings?: Maybe<Array<Maybe<PolicyBinding>>>;
};


export type McpServerAuditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type McpServerAssociationAttributes = {
  serverId?: InputMaybe<Scalars['ID']['input']>;
};

/** Input attributes for creating an mcp server */
export type McpServerAttributes = {
  authentication?: InputMaybe<McpServerAuthenticationAttributes>;
  /** whether tool calls against this server should require a confirmation */
  confirm?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  readBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
  url: Scalars['String']['input'];
  writeBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
};

export type McpServerAudit = {
  __typename?: 'McpServerAudit';
  actor?: Maybe<User>;
  arguments?: Maybe<Scalars['Map']['output']>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  server?: Maybe<McpServer>;
  tool: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type McpServerAuditConnection = {
  __typename?: 'McpServerAuditConnection';
  edges?: Maybe<Array<Maybe<McpServerAuditEdge>>>;
  pageInfo: PageInfo;
};

export type McpServerAuditEdge = {
  __typename?: 'McpServerAuditEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<McpServerAudit>;
};

export type McpServerAuthentication = {
  __typename?: 'McpServerAuthentication';
  /** any custom HTTP headers needed for authentication */
  headers?: Maybe<Array<Maybe<McpServerHeader>>>;
  /** built-in Plural JWT authentication */
  plural?: Maybe<Scalars['Boolean']['output']>;
};

export type McpServerAuthenticationAttributes = {
  headers?: InputMaybe<Array<InputMaybe<McpHeaderAttributes>>>;
  /** whether to use Plural's built-in JWT authentication */
  plural?: InputMaybe<Scalars['Boolean']['input']>;
};

export type McpServerConnection = {
  __typename?: 'McpServerConnection';
  edges?: Maybe<Array<Maybe<McpServerEdge>>>;
  pageInfo: PageInfo;
};

export type McpServerEdge = {
  __typename?: 'McpServerEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<McpServer>;
};

export type McpServerHeader = {
  __typename?: 'McpServerHeader';
  name: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

/** A tool related to an mcp server */
export type McpServerTool = {
  __typename?: 'McpServerTool';
  server?: Maybe<McpServer>;
  tool?: Maybe<McpTool>;
};

/** The description of a tool extracted from its MCP server */
export type McpTool = {
  __typename?: 'McpTool';
  description?: Maybe<Scalars['String']['output']>;
  inputSchema?: Maybe<Scalars['Map']['output']>;
  name: Scalars['String']['output'];
};

export type Metadata = {
  __typename?: 'Metadata';
  annotations?: Maybe<Array<Maybe<LabelPair>>>;
  creationTimestamp?: Maybe<Scalars['String']['output']>;
  labels?: Maybe<Array<Maybe<LabelPair>>>;
  name: Scalars['String']['output'];
  namespace?: Maybe<Scalars['String']['output']>;
  uid?: Maybe<Scalars['String']['output']>;
};

export type MetadataAttributes = {
  annotations?: InputMaybe<Scalars['Json']['input']>;
  labels?: InputMaybe<Scalars['Json']['input']>;
};

export type MetricPointResponse = {
  __typename?: 'MetricPointResponse';
  metric?: Maybe<Scalars['Map']['output']>;
  value?: Maybe<MetricResult>;
};

export type MetricResponse = {
  __typename?: 'MetricResponse';
  metric?: Maybe<Scalars['Map']['output']>;
  values?: Maybe<Array<Maybe<MetricResult>>>;
};

export type MetricResult = {
  __typename?: 'MetricResult';
  timestamp?: Maybe<Scalars['Long']['output']>;
  value?: Maybe<Scalars['String']['output']>;
};

export type Namespace = {
  __typename?: 'Namespace';
  events?: Maybe<Array<Maybe<Event>>>;
  metadata: Metadata;
  raw: Scalars['String']['output'];
  spec: NamespaceSpec;
  status: NamespaceStatus;
};

/** metadata fields for created namespaces */
export type NamespaceMetadata = {
  __typename?: 'NamespaceMetadata';
  annotations?: Maybe<Scalars['Map']['output']>;
  labels?: Maybe<Scalars['Map']['output']>;
};

export type NamespaceSpec = {
  __typename?: 'NamespaceSpec';
  finalizers?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

export type NamespaceStatus = {
  __typename?: 'NamespaceStatus';
  phase?: Maybe<Scalars['String']['output']>;
};

export type NamespaceVuln = {
  __typename?: 'NamespaceVuln';
  namespace: Scalars['String']['output'];
};

export type NamespaceVulnAttributes = {
  namespace: Scalars['String']['input'];
};

export type NamespacedName = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
};

/** An edge representing traffic statistics between two workloads in a service mesh */
export type NetworkMeshEdge = {
  __typename?: 'NetworkMeshEdge';
  from: NetworkMeshWorkload;
  id: Scalars['String']['output'];
  statistics: NetworkMeshStatistics;
  to: NetworkMeshWorkload;
};

/** The relevant statistics for traffic within a service mesh */
export type NetworkMeshStatistics = {
  __typename?: 'NetworkMeshStatistics';
  bytes?: Maybe<Scalars['Float']['output']>;
  connections?: Maybe<Scalars['Float']['output']>;
  http200?: Maybe<Scalars['Float']['output']>;
  http400?: Maybe<Scalars['Float']['output']>;
  http500?: Maybe<Scalars['Float']['output']>;
  httpClientLatency?: Maybe<Scalars['Float']['output']>;
  packets?: Maybe<Scalars['Float']['output']>;
};

/** An abstract workload discovered by querying statistics on a service mesh */
export type NetworkMeshWorkload = {
  __typename?: 'NetworkMeshWorkload';
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  namespace?: Maybe<Scalars['String']['output']>;
  service?: Maybe<Scalars['String']['output']>;
};

export type NewRelicCredentialsAttributes = {
  apiKey: Scalars['String']['input'];
};

export type Node = {
  __typename?: 'Node';
  events?: Maybe<Array<Maybe<Event>>>;
  metadata: Metadata;
  pods?: Maybe<Array<Maybe<Pod>>>;
  raw: Scalars['String']['output'];
  spec: NodeSpec;
  status: NodeStatus;
};

/** cloud specific settings for a node pool */
export type NodeCloudSettings = {
  __typename?: 'NodeCloudSettings';
  aws?: Maybe<AwsCloud>;
};

export type NodeCondition = {
  __typename?: 'NodeCondition';
  message?: Maybe<Scalars['String']['output']>;
  reason?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
};

export type NodeMetric = {
  __typename?: 'NodeMetric';
  metadata: Metadata;
  timestamp?: Maybe<Scalars['String']['output']>;
  usage?: Maybe<NodeUsage>;
  window?: Maybe<Scalars['String']['output']>;
};

/** a specification for a node pool to be created in this cluster */
export type NodePool = {
  __typename?: 'NodePool';
  /** cloud specific settings for the node groups */
  cloudSettings?: Maybe<NodeCloudSettings>;
  /** internal id for this node pool */
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the type of node to use (usually cloud-specific) */
  instanceType: Scalars['String']['output'];
  /** kubernetes labels to apply to the nodes in this pool, useful for node selectors */
  labels?: Maybe<Scalars['Map']['output']>;
  /** maximum number of instances in this node pool */
  maxSize: Scalars['Int']['output'];
  /** minimum number of instances in this node pool */
  minSize: Scalars['Int']['output'];
  /** name of this node pool (must be unique) */
  name: Scalars['String']['output'];
  /** whether this is a spot pool or not */
  spot?: Maybe<Scalars['Boolean']['output']>;
  /** any taints you'd want to apply to a node, for eg preventing scheduling on spot instances */
  taints?: Maybe<Array<Maybe<Taint>>>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type NodePoolAttributes = {
  cloudSettings?: InputMaybe<NodePoolCloudAttributes>;
  instanceType: Scalars['String']['input'];
  labels?: InputMaybe<Scalars['Json']['input']>;
  maxSize: Scalars['Int']['input'];
  minSize: Scalars['Int']['input'];
  name: Scalars['String']['input'];
  taints?: InputMaybe<Array<InputMaybe<TaintAttributes>>>;
};

export type NodePoolCloudAttributes = {
  aws?: InputMaybe<AwsNodeCloudAttributes>;
};

export type NodeSpec = {
  __typename?: 'NodeSpec';
  podCidr?: Maybe<Scalars['String']['output']>;
  providerId?: Maybe<Scalars['String']['output']>;
  unschedulable?: Maybe<Scalars['Boolean']['output']>;
};

/** A representation of node health within a cluster */
export type NodeStatistic = {
  __typename?: 'NodeStatistic';
  cluster?: Maybe<Cluster>;
  health?: Maybe<NodeStatisticHealth>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  name: Scalars['String']['output'];
  pendingPods?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type NodeStatisticAttributes = {
  health?: InputMaybe<NodeStatisticHealth>;
  name?: InputMaybe<Scalars['String']['input']>;
  pendingPods?: InputMaybe<Scalars['Int']['input']>;
};

export enum NodeStatisticHealth {
  Failed = 'FAILED',
  Healthy = 'HEALTHY',
  Warning = 'WARNING'
}

export type NodeStatus = {
  __typename?: 'NodeStatus';
  allocatable?: Maybe<Scalars['Map']['output']>;
  capacity?: Maybe<Scalars['Map']['output']>;
  conditions?: Maybe<Array<Maybe<NodeCondition>>>;
  phase?: Maybe<Scalars['String']['output']>;
};

export type NodeUsage = {
  __typename?: 'NodeUsage';
  cpu?: Maybe<Scalars['String']['output']>;
  memory?: Maybe<Scalars['String']['output']>;
};

export type Notification = {
  __typename?: 'Notification';
  annotations?: Maybe<Scalars['Map']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  fingerprint: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  labels?: Maybe<Scalars['Map']['output']>;
  repository: Scalars['String']['output'];
  seenAt?: Maybe<Scalars['DateTime']['output']>;
  severity?: Maybe<Severity>;
  status?: Maybe<NotificationStatus>;
  title: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type NotificationConnection = {
  __typename?: 'NotificationConnection';
  edges?: Maybe<Array<Maybe<NotificationEdge>>>;
  pageInfo: PageInfo;
};

export type NotificationDelta = {
  __typename?: 'NotificationDelta';
  delta?: Maybe<Delta>;
  payload?: Maybe<Notification>;
};

export type NotificationEdge = {
  __typename?: 'NotificationEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<Notification>;
};

export type NotificationFilter = {
  __typename?: 'NotificationFilter';
  cluster?: Maybe<Cluster>;
  id: Scalars['ID']['output'];
  pipeline?: Maybe<Pipeline>;
  regex?: Maybe<Scalars['String']['output']>;
  service?: Maybe<ServiceDeployment>;
};

export enum NotificationPriority {
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM'
}

export type NotificationRouter = {
  __typename?: 'NotificationRouter';
  /** events this router subscribes to, use * for all */
  events?: Maybe<Array<Scalars['String']['output']>>;
  /** resource-based filters to select events for services, clusters, pipelines */
  filters?: Maybe<Array<Maybe<NotificationFilter>>>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** name of this router */
  name: Scalars['String']['output'];
  /** sinks to deliver notifications to */
  sinks?: Maybe<Array<Maybe<NotificationSink>>>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type NotificationRouterAttributes = {
  /** the events to trigger, or use * for any */
  events?: InputMaybe<Array<Scalars['String']['input']>>;
  /** filters by object type */
  filters?: InputMaybe<Array<InputMaybe<RouterFilterAttributes>>>;
  /** the name of this router */
  name: Scalars['String']['input'];
  /** sinks to deliver notifications to */
  routerSinks?: InputMaybe<Array<InputMaybe<RouterSinkAttributes>>>;
};

export type NotificationRouterConnection = {
  __typename?: 'NotificationRouterConnection';
  edges?: Maybe<Array<Maybe<NotificationRouterEdge>>>;
  pageInfo: PageInfo;
};

export type NotificationRouterEdge = {
  __typename?: 'NotificationRouterEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<NotificationRouter>;
};

export type NotificationSink = {
  __typename?: 'NotificationSink';
  /** type specific sink configuration */
  configuration: SinkConfiguration;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the name of the sink */
  name: Scalars['String']['output'];
  /** the users/groups an in-app notification can be delivered to */
  notificationBindings?: Maybe<Array<Maybe<PolicyBinding>>>;
  /** the channel type of the sink, eg slack or teams */
  type: SinkType;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type NotificationSinkAttributes = {
  /** configuration for the specific type */
  configuration: SinkConfigurationAttributes;
  /** the name of this sink */
  name: Scalars['String']['input'];
  /** the users/groups you want this sink to deliver to if it's PLURAL type */
  notificationBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
  /** the channel type of this sink */
  type: SinkType;
};

export type NotificationSinkConnection = {
  __typename?: 'NotificationSinkConnection';
  edges?: Maybe<Array<Maybe<NotificationSinkEdge>>>;
  pageInfo: PageInfo;
};

export type NotificationSinkEdge = {
  __typename?: 'NotificationSinkEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<NotificationSink>;
};

export enum NotificationStatus {
  Firing = 'FIRING',
  Resolved = 'RESOLVED'
}

export type OauthResponse = {
  __typename?: 'OauthResponse';
  redirectTo: Scalars['String']['output'];
};

export type ObjectReference = {
  __typename?: 'ObjectReference';
  name?: Maybe<Scalars['String']['output']>;
  namespace?: Maybe<Scalars['String']['output']>;
};

export type ObjectStore = {
  __typename?: 'ObjectStore';
  azure?: Maybe<AzureStore>;
  gcs?: Maybe<GcsStore>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  name: Scalars['String']['output'];
  s3?: Maybe<S3Store>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type ObjectStoreAttributes = {
  azure?: InputMaybe<AzureStoreAttributes>;
  gcs?: InputMaybe<GcsStoreAttributes>;
  name: Scalars['String']['input'];
  s3?: InputMaybe<S3StoreAttributes>;
};

export type ObjectStoreConnection = {
  __typename?: 'ObjectStoreConnection';
  edges?: Maybe<Array<Maybe<ObjectStoreEdge>>>;
  pageInfo: PageInfo;
};

export type ObjectStoreEdge = {
  __typename?: 'ObjectStoreEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<ObjectStore>;
};

export type ObservabilityProvider = {
  __typename?: 'ObservabilityProvider';
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  name: Scalars['String']['output'];
  type: ObservabilityProviderType;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type ObservabilityProviderAttributes = {
  credentials: ObservabilityProviderCredentialsAttributes;
  name: Scalars['String']['input'];
  type: ObservabilityProviderType;
};

export type ObservabilityProviderConnection = {
  __typename?: 'ObservabilityProviderConnection';
  edges?: Maybe<Array<Maybe<ObservabilityProviderEdge>>>;
  pageInfo: PageInfo;
};

export type ObservabilityProviderCredentialsAttributes = {
  datadog?: InputMaybe<DatadogCredentialsAttributes>;
  newrelic?: InputMaybe<NewRelicCredentialsAttributes>;
};

export type ObservabilityProviderEdge = {
  __typename?: 'ObservabilityProviderEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<ObservabilityProvider>;
};

export enum ObservabilityProviderType {
  Datadog = 'DATADOG',
  Newrelic = 'NEWRELIC'
}

/** A webhook receiver for an observability provider like grafana or datadog */
export type ObservabilityWebhook = {
  __typename?: 'ObservabilityWebhook';
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  name: Scalars['String']['output'];
  type: ObservabilityWebhookType;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the url for this specific webhook */
  url: Scalars['String']['output'];
};

/** input data to persist a webhook receiver for an observability provider like grafana or datadog */
export type ObservabilityWebhookAttributes = {
  name: Scalars['String']['input'];
  secret?: InputMaybe<Scalars['String']['input']>;
  type: ObservabilityWebhookType;
};

export type ObservabilityWebhookConnection = {
  __typename?: 'ObservabilityWebhookConnection';
  edges?: Maybe<Array<Maybe<ObservabilityWebhookEdge>>>;
  pageInfo: PageInfo;
};

export type ObservabilityWebhookEdge = {
  __typename?: 'ObservabilityWebhookEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<ObservabilityWebhook>;
};

export enum ObservabilityWebhookType {
  Datadog = 'DATADOG',
  Grafana = 'GRAFANA',
  Newrelic = 'NEWRELIC',
  Pagerduty = 'PAGERDUTY',
  Sentry = 'SENTRY'
}

export type ObservableMetric = {
  __typename?: 'ObservableMetric';
  id: Scalars['ID']['output'];
  identifier: Scalars['String']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  provider?: Maybe<ObservabilityProvider>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type ObservableMetricAttributes = {
  identifier: Scalars['String']['input'];
  providerId: Scalars['ID']['input'];
};

/** An observer is a mechanism to poll an external helm, oci or other datasources and perform a list of actions in response */
export type Observer = {
  __typename?: 'Observer';
  actions?: Maybe<Array<Maybe<ObserverAction>>>;
  crontab: Scalars['String']['output'];
  errors?: Maybe<Array<Maybe<ServiceError>>>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  lastRunAt: Scalars['DateTime']['output'];
  lastValue?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  nextRunAt: Scalars['DateTime']['output'];
  project?: Maybe<Project>;
  status: ObserverStatus;
  target: ObserverTarget;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

/** A spec of an action that can be taken in response to an observed entity */
export type ObserverAction = {
  __typename?: 'ObserverAction';
  configuration: ObserverActionConfiguration;
  type: ObserverActionType;
};

/** A spec of an action that can be taken in response to an observed entity */
export type ObserverActionAttributes = {
  configuration: ObserverActionConfigurationAttributes;
  type: ObserverActionType;
};

/** configuration for an observer action */
export type ObserverActionConfiguration = {
  __typename?: 'ObserverActionConfiguration';
  pipeline?: Maybe<ObserverPipelineAction>;
  pr?: Maybe<ObserverPrAction>;
};

/** configuration for an observer action */
export type ObserverActionConfigurationAttributes = {
  pipeline?: InputMaybe<ObserverPipelineActionAttributes>;
  pr?: InputMaybe<ObserverPrActionAttributes>;
};

export enum ObserverActionType {
  Pipeline = 'PIPELINE',
  Pr = 'PR'
}

/** The settings for configuring add-on scraping */
export type ObserverAddonAttributes = {
  kubernetesVersion?: InputMaybe<Scalars['String']['input']>;
  kubernetesVersions?: InputMaybe<Array<Scalars['String']['input']>>;
  name: Scalars['String']['input'];
};

/** An observer is a mechanism to poll an external helm, oci or other datasources and perform a list of actions in response */
export type ObserverAttributes = {
  actions?: InputMaybe<Array<InputMaybe<ObserverActionAttributes>>>;
  crontab: Scalars['String']['input'];
  initial?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  projectId?: InputMaybe<Scalars['ID']['input']>;
  target: ObserverTargetAttributes;
};

export type ObserverConnection = {
  __typename?: 'ObserverConnection';
  edges?: Maybe<Array<Maybe<ObserverEdge>>>;
  pageInfo: PageInfo;
};

export type ObserverEdge = {
  __typename?: 'ObserverEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<Observer>;
};

export type ObserverGitAttributes = {
  filter?: InputMaybe<ObserverGitFilterAttributes>;
  repositoryId: Scalars['ID']['input'];
  type: ObserverGitTargetType;
};

/** a spec for filtering a git repository tags in an observer */
export type ObserverGitFilter = {
  __typename?: 'ObserverGitFilter';
  /** a regex to filter the git repository tags for the observed value */
  regex?: Maybe<Scalars['String']['output']>;
};

/** a spec for filtering a git repository tags in an observer */
export type ObserverGitFilterAttributes = {
  /** a regex to filter the git repository tags for the observed value */
  regex?: InputMaybe<Scalars['String']['input']>;
};

/** a spec for polling a git repository for recent updates */
export type ObserverGitRepo = {
  __typename?: 'ObserverGitRepo';
  filter?: Maybe<ObserverGitFilter>;
  repositoryId: Scalars['ID']['output'];
  /** the resource within the git repository you want to poll */
  type: ObserverGitTargetType;
};

export enum ObserverGitTargetType {
  Tags = 'TAGS'
}

/** a spec for querying a helm repository in an observer */
export type ObserverHelmAttributes = {
  auth?: InputMaybe<HelmAuthAttributes>;
  chart: Scalars['String']['input'];
  provider?: InputMaybe<HelmAuthProvider>;
  url: Scalars['String']['input'];
};

/** a spec for querying a helm in an observer */
export type ObserverHelmRepo = {
  __typename?: 'ObserverHelmRepo';
  chart: Scalars['String']['output'];
  provider?: Maybe<HelmAuthProvider>;
  url: Scalars['String']['output'];
};

/** a spec for querying a helm repository in an observer */
export type ObserverOciAttributes = {
  auth?: InputMaybe<HelmAuthAttributes>;
  provider?: InputMaybe<HelmAuthProvider>;
  url: Scalars['String']['input'];
};

/** a spec for querying a oci repository in an observer */
export type ObserverOciRepo = {
  __typename?: 'ObserverOciRepo';
  provider?: Maybe<HelmAuthProvider>;
  url: Scalars['String']['output'];
};

/** Configuration for setting a pipeline context in an observer */
export type ObserverPipelineAction = {
  __typename?: 'ObserverPipelineAction';
  /** the context to apply, use $value to interject the observed value */
  context: Scalars['Map']['output'];
  pipelineId: Scalars['ID']['output'];
};

/** Configuration for setting a pipeline context in an observer */
export type ObserverPipelineActionAttributes = {
  /** the context to apply, use $value to interject the observed value */
  context: Scalars['Json']['input'];
  pipelineId: Scalars['ID']['input'];
};

/** Configuration for sending a pr in response to an observer */
export type ObserverPrAction = {
  __typename?: 'ObserverPrAction';
  automationId: Scalars['ID']['output'];
  /** a template to use for the created branch, use $value to interject the observed value */
  branchTemplate?: Maybe<Scalars['String']['output']>;
  /** the context to apply, use $value to interject the observed value */
  context: Scalars['Map']['output'];
  repository?: Maybe<Scalars['String']['output']>;
};

/** Configuration for sending a pr in response to an observer */
export type ObserverPrActionAttributes = {
  automationId: Scalars['ID']['input'];
  /** a template to use for the created branch, use $value to interject the observed value */
  branchTemplate?: InputMaybe<Scalars['String']['input']>;
  /** the context to apply, use $value to interject the observed value */
  context: Scalars['Json']['input'];
  repository?: InputMaybe<Scalars['String']['input']>;
};

/** Resets the current value of the observer */
export type ObserverResetAttributes = {
  lastValue: Scalars['String']['input'];
};

export enum ObserverStatus {
  Failed = 'FAILED',
  Healthy = 'HEALTHY'
}

/** A spec for a target to poll */
export type ObserverTarget = {
  __typename?: 'ObserverTarget';
  /**
   * a regex for extracting the target value, useful in cases where a semver is nested
   * in a larger release string.  The first capture group is the substring that is used for the value.
   */
  format?: Maybe<Scalars['String']['output']>;
  git?: Maybe<ObserverGitRepo>;
  helm?: Maybe<ObserverHelmRepo>;
  oci?: Maybe<ObserverOciRepo>;
  /** the order in which polled results are applied, defaults to SEMVER */
  order: ObserverTargetOrder;
  /** present for backwards compat, use `type` instead */
  target: ObserverTargetType;
  type: ObserverTargetType;
};

/** A spec for a target to poll */
export type ObserverTargetAttributes = {
  addon?: InputMaybe<ObserverAddonAttributes>;
  eksAddon?: InputMaybe<ObserverAddonAttributes>;
  format?: InputMaybe<Scalars['String']['input']>;
  git?: InputMaybe<ObserverGitAttributes>;
  helm?: InputMaybe<ObserverHelmAttributes>;
  oci?: InputMaybe<ObserverOciAttributes>;
  order: ObserverTargetOrder;
  /** present for backwards compat */
  target?: InputMaybe<ObserverTargetType>;
  type?: InputMaybe<ObserverTargetType>;
};

export enum ObserverTargetOrder {
  Latest = 'LATEST',
  Semver = 'SEMVER'
}

export enum ObserverTargetType {
  Addon = 'ADDON',
  EksAddon = 'EKS_ADDON',
  Git = 'GIT',
  Helm = 'HELM',
  Oci = 'OCI'
}

/** Supported methods for fetching an OIDC auth token */
export enum OidcAuthMethod {
  Basic = 'BASIC',
  Post = 'POST'
}

/** A representation of a created OIDC provider client */
export type OidcProvider = {
  __typename?: 'OidcProvider';
  authMethod?: Maybe<OidcAuthMethod>;
  /** bindings determining if a user can login with this oidc client */
  bindings?: Maybe<Array<Maybe<PolicyBinding>>>;
  /** the generated client ID used in configuring OAuth clients */
  clientId: Scalars['String']['output'];
  /** the generated client secret, used in configuring an OAuth client */
  clientSecret: Scalars['String']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  /** the redirect uris oidc is whitelisted to use */
  redirectUris?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** bindings determining if a user can edit this oidc client */
  writeBindings?: Maybe<Array<Maybe<PolicyBinding>>>;
};

/** Configuration settings for creating a new OIDC provider client */
export type OidcProviderAttributes = {
  authMethod?: InputMaybe<OidcAuthMethod>;
  /** users and groups able to utilize this provider */
  bindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
  description?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  /** the redirect uris oidc is whitelisted to use */
  redirectUris?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** users and groups able to utilize this provider */
  writeBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
};

export type OidcProviderConnection = {
  __typename?: 'OidcProviderConnection';
  edges?: Maybe<Array<Maybe<OidcProviderEdge>>>;
  pageInfo: PageInfo;
};

export type OidcProviderEdge = {
  __typename?: 'OidcProviderEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<OidcProvider>;
};

/** Supported OIDC-compatible Auth Providers */
export enum OidcProviderType {
  Console = 'CONSOLE',
  Plural = 'PLURAL'
}

export type OidcStepResponse = {
  __typename?: 'OidcStepResponse';
  consent?: Maybe<ConsentRequest>;
  login?: Maybe<LoginRequest>;
};

export type OllamaAttributes = {
  /** An http authorization header to use on calls to the Ollama api */
  authorization?: InputMaybe<Scalars['String']['input']>;
  /** the model to use for vector embeddings */
  embeddingModel?: InputMaybe<Scalars['String']['input']>;
  model: Scalars['String']['input'];
  /** the model to use for tool calls, which are less frequent and require more complex reasoning */
  toolModel?: InputMaybe<Scalars['String']['input']>;
  url: Scalars['String']['input'];
};

/** Settings for a self-hosted ollama-based LLM deployment */
export type OllamaSettings = {
  __typename?: 'OllamaSettings';
  model: Scalars['String']['output'];
  /** the model to use for tool calls, which are less frequent and require more complex reasoning */
  toolModel?: Maybe<Scalars['String']['output']>;
  /** the url your ollama deployment is hosted on */
  url: Scalars['String']['output'];
};

/** OpenAI connection information */
export type OpenaiSettings = {
  __typename?: 'OpenaiSettings';
  /** the base url to use when querying an OpenAI compatible API, leave blank for OpenAI */
  baseUrl?: Maybe<Scalars['String']['output']>;
  /** the model to use for vector embeddings */
  embeddingModel?: Maybe<Scalars['String']['output']>;
  /** the openai model version to use */
  model?: Maybe<Scalars['String']['output']>;
  /** the model to use for tool calls, which are less frequent and require more complex reasoning */
  toolModel?: Maybe<Scalars['String']['output']>;
};

export type OpenaiSettingsAttributes = {
  accessToken?: InputMaybe<Scalars['String']['input']>;
  baseUrl?: InputMaybe<Scalars['String']['input']>;
  /** the model to use for vector embeddings */
  embeddingModel?: InputMaybe<Scalars['String']['input']>;
  model?: InputMaybe<Scalars['String']['input']>;
  /** the model to use for tool calls, which are less frequent and require more complex reasoning */
  toolModel?: InputMaybe<Scalars['String']['input']>;
};

export type OpensearchConnection = {
  __typename?: 'OpensearchConnection';
  awsAccessKeyId?: Maybe<Scalars['String']['output']>;
  awsRegion?: Maybe<Scalars['String']['output']>;
  host: Scalars['String']['output'];
  /** the index to query for log data */
  index: Scalars['String']['output'];
};

export type OpensearchConnectionAttributes = {
  awsAccessKeyId?: InputMaybe<Scalars['String']['input']>;
  awsRegion?: InputMaybe<Scalars['String']['input']>;
  awsSecretAccessKey?: InputMaybe<Scalars['String']['input']>;
  host: Scalars['String']['input'];
  index: Scalars['String']['input'];
};

export enum Operation {
  Eq = 'EQ',
  Gt = 'GT',
  Gte = 'GTE',
  Lt = 'LT',
  Lte = 'LTE',
  Not = 'NOT',
  Prefix = 'PREFIX',
  Suffix = 'SUFFIX'
}

/** a high level description of the setup of common resources in a cluster */
export type OperationalLayout = {
  __typename?: 'OperationalLayout';
  serviceMesh?: Maybe<ServiceMesh>;
};

export type OperationalLayoutAttributes = {
  namespaces?: InputMaybe<ClusterNamespacesAttributes>;
  serviceMesh?: InputMaybe<ServiceMesh>;
};

export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']['output']>;
};

export type PauseCondition = {
  __typename?: 'PauseCondition';
  reason?: Maybe<Scalars['String']['output']>;
  startTime?: Maybe<Scalars['String']['output']>;
};

export enum Permission {
  Configure = 'CONFIGURE',
  Deploy = 'DEPLOY',
  Operate = 'OPERATE',
  Read = 'READ'
}

export type Persona = {
  __typename?: 'Persona';
  /** the group bindings for this persona */
  bindings?: Maybe<Array<Maybe<PolicyBinding>>>;
  /** the ui configuration for this persona (additive across personas) */
  configuration?: Maybe<PersonaConfiguration>;
  /** longform description of this persona */
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the name for this persona */
  name: Scalars['String']['output'];
  /** the role of this persona */
  role?: Maybe<PersonaRole>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type PersonaAi = {
  __typename?: 'PersonaAi';
  pr?: Maybe<Scalars['Boolean']['output']>;
};

export type PersonaAiAttributes = {
  pr?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PersonaAttributes = {
  bindings?: InputMaybe<Array<InputMaybe<BindingAttributes>>>;
  configuration?: InputMaybe<PersonaConfigurationAttributes>;
  /** longform description of this persona */
  description?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  /** the role of this persona, controls the behavior of the homepage */
  role?: InputMaybe<PersonaRole>;
};

export type PersonaConfiguration = {
  __typename?: 'PersonaConfiguration';
  /** enable individual parts of the ai views */
  ai?: Maybe<PersonaAi>;
  /** enable full ui for this persona */
  all?: Maybe<Scalars['Boolean']['output']>;
  /** enable individual parts of the deployments views */
  deployments?: Maybe<PersonaDeployment>;
  /** settings for the home page for this persona */
  home?: Maybe<PersonaHome>;
  /** enable individual parts of the services views */
  services?: Maybe<PersonaServices>;
  /** enable individual aspects of the sidebar */
  sidebar?: Maybe<PersonaSidebar>;
};

export type PersonaConfigurationAttributes = {
  /** enable individual parts of the ai views */
  ai?: InputMaybe<PersonaAiAttributes>;
  /** enable full ui for this persona */
  all?: InputMaybe<Scalars['Boolean']['input']>;
  /** enable individual parts of the deployments views */
  deployments?: InputMaybe<PersonaDeploymentAttributes>;
  /** configuration for the homepage for the given persona */
  home?: InputMaybe<PersonaHomeAttributes>;
  /** enable individual parts of the services views */
  services?: InputMaybe<PersonaServicesAttributes>;
  /** enable individual aspects of the sidebar */
  sidebar?: InputMaybe<PersonaSidebarAttributes>;
};

export type PersonaConnection = {
  __typename?: 'PersonaConnection';
  edges?: Maybe<Array<Maybe<PersonaEdge>>>;
  pageInfo: PageInfo;
};

export type PersonaDeployment = {
  __typename?: 'PersonaDeployment';
  addOns?: Maybe<Scalars['Boolean']['output']>;
  clusters?: Maybe<Scalars['Boolean']['output']>;
  deployments?: Maybe<Scalars['Boolean']['output']>;
  pipelines?: Maybe<Scalars['Boolean']['output']>;
  providers?: Maybe<Scalars['Boolean']['output']>;
  repositories?: Maybe<Scalars['Boolean']['output']>;
  services?: Maybe<Scalars['Boolean']['output']>;
};

export type PersonaDeploymentAttributes = {
  addOns?: InputMaybe<Scalars['Boolean']['input']>;
  clusters?: InputMaybe<Scalars['Boolean']['input']>;
  deployments?: InputMaybe<Scalars['Boolean']['input']>;
  pipelines?: InputMaybe<Scalars['Boolean']['input']>;
  providers?: InputMaybe<Scalars['Boolean']['input']>;
  repositories?: InputMaybe<Scalars['Boolean']['input']>;
  services?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PersonaEdge = {
  __typename?: 'PersonaEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<Persona>;
};

export type PersonaHome = {
  __typename?: 'PersonaHome';
  manager?: Maybe<Scalars['Boolean']['output']>;
  security?: Maybe<Scalars['Boolean']['output']>;
};

export type PersonaHomeAttributes = {
  manager?: InputMaybe<Scalars['Boolean']['input']>;
  security?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum PersonaRole {
  Developer = 'DEVELOPER',
  Finops = 'FINOPS',
  Management = 'MANAGEMENT',
  Platform = 'PLATFORM',
  Security = 'SECURITY'
}

export type PersonaServices = {
  __typename?: 'PersonaServices';
  configuration?: Maybe<Scalars['Boolean']['output']>;
  secrets?: Maybe<Scalars['Boolean']['output']>;
};

export type PersonaServicesAttributes = {
  configuration?: InputMaybe<Scalars['Boolean']['input']>;
  secrets?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PersonaSidebar = {
  __typename?: 'PersonaSidebar';
  audits?: Maybe<Scalars['Boolean']['output']>;
  backups?: Maybe<Scalars['Boolean']['output']>;
  cost?: Maybe<Scalars['Boolean']['output']>;
  kubernetes?: Maybe<Scalars['Boolean']['output']>;
  pullRequests?: Maybe<Scalars['Boolean']['output']>;
  security?: Maybe<Scalars['Boolean']['output']>;
  settings?: Maybe<Scalars['Boolean']['output']>;
  stacks?: Maybe<Scalars['Boolean']['output']>;
};

export type PersonaSidebarAttributes = {
  audits?: InputMaybe<Scalars['Boolean']['input']>;
  backups?: InputMaybe<Scalars['Boolean']['input']>;
  cost?: InputMaybe<Scalars['Boolean']['input']>;
  kubernetes?: InputMaybe<Scalars['Boolean']['input']>;
  pullRequests?: InputMaybe<Scalars['Boolean']['input']>;
  security?: InputMaybe<Scalars['Boolean']['input']>;
  settings?: InputMaybe<Scalars['Boolean']['input']>;
  stacks?: InputMaybe<Scalars['Boolean']['input']>;
};

/** A reference to a custom resource you want to be displayed in the k8s dashboard */
export type PinnedCustomResource = {
  __typename?: 'PinnedCustomResource';
  cluster?: Maybe<Cluster>;
  displayName: Scalars['String']['output'];
  group: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  kind: Scalars['String']['output'];
  name: Scalars['String']['output'];
  namespaced?: Maybe<Scalars['Boolean']['output']>;
  version: Scalars['String']['output'];
};

export type PinnedCustomResourceAttributes = {
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  displayName: Scalars['String']['input'];
  group: Scalars['String']['input'];
  kind: Scalars['String']['input'];
  name: Scalars['String']['input'];
  namespaced?: InputMaybe<Scalars['Boolean']['input']>;
  version: Scalars['String']['input'];
};

/** a release pipeline, composed of multiple stages each with potentially multiple services */
export type Pipeline = {
  __typename?: 'Pipeline';
  /** lists the contexts applied to a pipeline */
  contexts?: Maybe<PipelineContextConnection>;
  /** edges linking two stages w/in the pipeline in a full DAG */
  edges?: Maybe<Array<Maybe<PipelineStageEdge>>>;
  /** the flow this pipeline belongs to */
  flow?: Maybe<Flow>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the name of the pipeline */
  name: Scalars['String']['output'];
  /** the project this pipeline belongs to */
  project?: Maybe<Project>;
  /** read policy for this pipeline */
  readBindings?: Maybe<Array<Maybe<PolicyBinding>>>;
  /** the stages of this pipeline */
  stages?: Maybe<Array<Maybe<PipelineStage>>>;
  status?: Maybe<PipelineStatus>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** write policy of this pipeline */
  writeBindings?: Maybe<Array<Maybe<PolicyBinding>>>;
};


/** a release pipeline, composed of multiple stages each with potentially multiple services */
export type PipelineContextsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** the top level input object for creating/deleting pipelines */
export type PipelineAttributes = {
  edges?: InputMaybe<Array<InputMaybe<PipelineEdgeAttributes>>>;
  flowId?: InputMaybe<Scalars['ID']['input']>;
  projectId?: InputMaybe<Scalars['ID']['input']>;
  readBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
  stages?: InputMaybe<Array<InputMaybe<PipelineStageAttributes>>>;
  writeBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
};

export type PipelineConnection = {
  __typename?: 'PipelineConnection';
  edges?: Maybe<Array<Maybe<PipelineEdge>>>;
  pageInfo: PageInfo;
};

/** A variable context that can be used to generate pull requests as a pipeline progresses */
export type PipelineContext = {
  __typename?: 'PipelineContext';
  /** the context map that will be passed to the pipeline */
  context: Scalars['Map']['output'];
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  pipeline?: Maybe<Pipeline>;
  /** a list of pipeline-specific PRs for this context */
  pipelinePullRequests?: Maybe<Array<Maybe<PipelinePullRequest>>>;
  /** a history of pull requests created by this context thus far */
  pullRequests?: Maybe<Array<Maybe<PullRequest>>>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

/** attributes needed to create a new pipeline context */
export type PipelineContextAttributes = {
  context: Scalars['Json']['input'];
};

export type PipelineContextConnection = {
  __typename?: 'PipelineContextConnection';
  edges?: Maybe<Array<Maybe<PipelineContextEdge>>>;
  pageInfo: PageInfo;
};

export type PipelineContextEdge = {
  __typename?: 'PipelineContextEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<PipelineContext>;
};

/** A record of a prior pipeline context attached to a stage */
export type PipelineContextHistory = {
  __typename?: 'PipelineContextHistory';
  context?: Maybe<PipelineContext>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  stage?: Maybe<PipelineStage>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type PipelineContextHistoryConnection = {
  __typename?: 'PipelineContextHistoryConnection';
  edges?: Maybe<Array<Maybe<PipelineContextHistoryEdge>>>;
  pageInfo: PageInfo;
};

export type PipelineContextHistoryEdge = {
  __typename?: 'PipelineContextHistoryEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<PipelineContextHistory>;
};

export type PipelineEdge = {
  __typename?: 'PipelineEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<Pipeline>;
};

/** specification of an edge between two pipeline stages */
export type PipelineEdgeAttributes = {
  /** the name of the pipeline stage this edge emits from */
  from?: InputMaybe<Scalars['String']['input']>;
  /** stage id the edge is from, can also be specified by name */
  fromId?: InputMaybe<Scalars['ID']['input']>;
  /** any optional promotion gates you wish to configure */
  gates?: InputMaybe<Array<InputMaybe<PipelineGateAttributes>>>;
  /** the name of the pipeline stage this edge points to */
  to?: InputMaybe<Scalars['String']['input']>;
  /** stage id the edge is to, can also be specified by name */
  toId?: InputMaybe<Scalars['ID']['input']>;
};

/** A gate blocking promotion along a release pipeline */
export type PipelineGate = {
  __typename?: 'PipelineGate';
  /** the last user to approve this gate */
  approver?: Maybe<User>;
  /** the cluster this gate can run on */
  cluster?: Maybe<Cluster>;
  /** the edge this gate lives on */
  edge?: Maybe<PipelineStageEdge>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the kubernetes job running this gate (should only be fetched lazily as this is a heavy operation) */
  job?: Maybe<Job>;
  /** the name of this gate as seen in the UI */
  name: Scalars['String']['output'];
  /** more detailed specification for complex gates */
  spec?: Maybe<GateSpec>;
  /** the current state of this gate */
  state: GateState;
  /** state related to the current status of this job */
  status?: Maybe<GateStatus>;
  /** the type of gate this is */
  type: GateType;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

/** will configure a promotion gate for a pipeline */
export type PipelineGateAttributes = {
  /** the handle of a cluster this gate will execute on */
  cluster?: InputMaybe<Scalars['String']['input']>;
  /** the id of the cluster this gate will execute on */
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  /** the name of this gate */
  name: Scalars['String']['input'];
  /** a specification for more complex gate types */
  spec?: InputMaybe<GateSpecAttributes>;
  /** the type of gate this is */
  type: GateType;
};

export type PipelineGateConnection = {
  __typename?: 'PipelineGateConnection';
  edges?: Maybe<Array<Maybe<PipelineGateEdge>>>;
  pageInfo: PageInfo;
};

export type PipelineGateEdge = {
  __typename?: 'PipelineGateEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<PipelineGate>;
};

/** a representation of an individual pipeline promotion, which is a list of services/revisions and timestamps to determine promotion status */
export type PipelinePromotion = {
  __typename?: 'PipelinePromotion';
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the last time this promotion was fully promoted, it's no longer pending if promoted_at > revised_at */
  promotedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the last time this promotion was updated */
  revisedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the services included in this promotion */
  services?: Maybe<Array<Maybe<PromotionService>>>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

/** A pull request created in the course of executing a pipeline */
export type PipelinePullRequest = {
  __typename?: 'PipelinePullRequest';
  id: Scalars['ID']['output'];
  pullRequest?: Maybe<PullRequest>;
  service?: Maybe<ServiceDeployment>;
  stage?: Maybe<PipelineStage>;
};

/** a pipeline stage, has a list of services and potentially a promotion which might be pending */
export type PipelineStage = {
  __typename?: 'PipelineStage';
  /** the context that is to be applied to this stage for PR promotions */
  context?: Maybe<PipelineContext>;
  contextHistory?: Maybe<PipelineContextHistoryConnection>;
  /** the errors for this stage */
  errors?: Maybe<Array<Maybe<ServiceError>>>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the name of this stage (eg dev, prod, staging) */
  name: Scalars['String']['output'];
  /** a promotion which might be outstanding for this stage */
  promotion?: Maybe<PipelinePromotion>;
  /** the services within this stage */
  services?: Maybe<Array<Maybe<StageService>>>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};


/** a pipeline stage, has a list of services and potentially a promotion which might be pending */
export type PipelineStageContextHistoryArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** specification of a stage of a pipeline */
export type PipelineStageAttributes = {
  name: Scalars['String']['input'];
  services?: InputMaybe<Array<InputMaybe<StageServiceAttributes>>>;
};

/** an edge in the pipeline DAG */
export type PipelineStageEdge = {
  __typename?: 'PipelineStageEdge';
  from: PipelineStage;
  gates?: Maybe<Array<Maybe<PipelineGate>>>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  pipeline?: Maybe<Pipeline>;
  /** when the edge was last promoted, if greater than the promotion objects revised at, was successfully promoted */
  promotedAt?: Maybe<Scalars['DateTime']['output']>;
  to: PipelineStage;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

/** a report of gate statuses within a pipeline to gauge its health */
export type PipelineStatus = {
  __typename?: 'PipelineStatus';
  /** if > 0, consider the pipeline stopped */
  closed?: Maybe<Scalars['Int']['output']>;
  /** if > 0, consider the pipeline pending */
  pending?: Maybe<Scalars['Int']['output']>;
  /** if > 0, consider the pipeline runnning */
  running?: Maybe<Scalars['Int']['output']>;
};

export type Plan = {
  __typename?: 'Plan';
  id?: Maybe<Scalars['ID']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  period?: Maybe<Scalars['String']['output']>;
};

export type PluralCluster = {
  __typename?: 'PluralCluster';
  events?: Maybe<Array<Maybe<Event>>>;
  metadata: Metadata;
  raw: Scalars['String']['output'];
  reference?: Maybe<Cluster>;
  status: PluralObjectStatus;
};

/** temporary credentials for the user attached to this stack */
export type PluralCreds = {
  __typename?: 'PluralCreds';
  /** authentication token to use for gql requests */
  token?: Maybe<Scalars['String']['output']>;
  /** the api url of this instance */
  url?: Maybe<Scalars['String']['output']>;
};

export type PluralGitRepository = {
  __typename?: 'PluralGitRepository';
  events?: Maybe<Array<Maybe<Event>>>;
  metadata: Metadata;
  raw: Scalars['String']['output'];
  reference?: Maybe<GitRepository>;
  status: PluralObjectStatus;
};

export type PluralManifest = {
  __typename?: 'PluralManifest';
  bucketPrefix?: Maybe<Scalars['String']['output']>;
  cluster?: Maybe<Scalars['String']['output']>;
  network?: Maybe<ManifestNetwork>;
};

export type PluralObjectStatus = {
  __typename?: 'PluralObjectStatus';
  conditions?: Maybe<Array<Maybe<StatusCondition>>>;
  id?: Maybe<Scalars['String']['output']>;
};

export type PluralServiceDeployment = {
  __typename?: 'PluralServiceDeployment';
  events?: Maybe<Array<Maybe<Event>>>;
  metadata: Metadata;
  raw: Scalars['String']['output'];
  reference?: Maybe<ServiceDeployment>;
  status: PluralObjectStatus;
};

export type PluralSinkAttributes = {
  priority: NotificationPriority;
  /** whether to immediately deliver the derived notification via SMTP */
  urgent?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PluralSinkConfiguration = {
  __typename?: 'PluralSinkConfiguration';
  priority: NotificationPriority;
  /** whether to immediately deliver the derived notification via SMTP */
  urgent?: Maybe<Scalars['Boolean']['output']>;
};

export type PluralSubscription = {
  __typename?: 'PluralSubscription';
  id?: Maybe<Scalars['ID']['output']>;
  plan?: Maybe<Plan>;
};

export type Pod = {
  __typename?: 'Pod';
  events?: Maybe<Array<Maybe<Event>>>;
  logs?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  metadata: Metadata;
  raw: Scalars['String']['output'];
  spec: PodSpec;
  status: PodStatus;
};


export type PodLogsArgs = {
  container: Scalars['String']['input'];
  sinceSeconds: Scalars['Int']['input'];
};

export type PodCondition = {
  __typename?: 'PodCondition';
  lastProbeTime?: Maybe<Scalars['String']['output']>;
  lastTransitionTime?: Maybe<Scalars['String']['output']>;
  message?: Maybe<Scalars['String']['output']>;
  reason?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
};

export type PodConnection = {
  __typename?: 'PodConnection';
  edges?: Maybe<Array<Maybe<PodEdge>>>;
  pageInfo: PageInfo;
};

export type PodDelta = {
  __typename?: 'PodDelta';
  delta?: Maybe<Delta>;
  payload?: Maybe<Pod>;
};

export type PodEdge = {
  __typename?: 'PodEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<Pod>;
};

export type PodSpec = {
  __typename?: 'PodSpec';
  containers?: Maybe<Array<Maybe<Container>>>;
  initContainers?: Maybe<Array<Maybe<Container>>>;
  nodeName?: Maybe<Scalars['String']['output']>;
  serviceAccountName?: Maybe<Scalars['String']['output']>;
};

export type PodStatus = {
  __typename?: 'PodStatus';
  conditions?: Maybe<Array<Maybe<PodCondition>>>;
  containerStatuses?: Maybe<Array<Maybe<ContainerStatus>>>;
  hostIp?: Maybe<Scalars['String']['output']>;
  initContainerStatuses?: Maybe<Array<Maybe<ContainerStatus>>>;
  message?: Maybe<Scalars['String']['output']>;
  phase?: Maybe<Scalars['String']['output']>;
  podIp?: Maybe<Scalars['String']['output']>;
  reason?: Maybe<Scalars['String']['output']>;
};

export type PodToleration = {
  __typename?: 'PodToleration';
  effect?: Maybe<Scalars['String']['output']>;
  key?: Maybe<Scalars['String']['output']>;
  operator?: Maybe<Scalars['String']['output']>;
  value?: Maybe<Scalars['String']['output']>;
};

export type PodTolerationAttributes = {
  effect?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  operator?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

export enum PolicyAggregate {
  Cluster = 'CLUSTER',
  Enforcement = 'ENFORCEMENT',
  Installed = 'INSTALLED'
}

export type PolicyBinding = {
  __typename?: 'PolicyBinding';
  group?: Maybe<Group>;
  id?: Maybe<Scalars['ID']['output']>;
  user?: Maybe<User>;
};

export type PolicyBindingAttributes = {
  groupId?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

/** A OPA Gatekeeper Constraint reference */
export type PolicyConstraint = {
  __typename?: 'PolicyConstraint';
  cluster?: Maybe<Cluster>;
  description?: Maybe<Scalars['String']['output']>;
  enforcement?: Maybe<ConstraintEnforcement>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  name: Scalars['String']['output'];
  /** Fetches the live constraint object from K8s, this is an expensive query and should not be done in list endpoints */
  object?: Maybe<KubernetesUnstructured>;
  recommendation?: Maybe<Scalars['String']['output']>;
  /** pointer to the kubernetes resource itself */
  ref?: Maybe<ConstraintRef>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  violationCount?: Maybe<Scalars['Int']['output']>;
  violations?: Maybe<Array<Maybe<Violation>>>;
};

/** inputs to add constraint data from an OPA gatekeeper constraint CRD */
export type PolicyConstraintAttributes = {
  description?: InputMaybe<Scalars['String']['input']>;
  enforcement?: InputMaybe<ConstraintEnforcement>;
  name: Scalars['String']['input'];
  recommendation?: InputMaybe<Scalars['String']['input']>;
  /** pointer to the group/name for the CR */
  ref?: InputMaybe<ConstraintRefAttributes>;
  violationCount?: InputMaybe<Scalars['Int']['input']>;
  violations?: InputMaybe<Array<InputMaybe<ViolationAttributes>>>;
};

export type PolicyConstraintConnection = {
  __typename?: 'PolicyConstraintConnection';
  edges?: Maybe<Array<Maybe<PolicyConstraintEdge>>>;
  pageInfo: PageInfo;
};

export type PolicyConstraintEdge = {
  __typename?: 'PolicyConstraintEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<PolicyConstraint>;
};

/** Configuration for applying policy enforcement to a stack */
export type PolicyEngine = {
  __typename?: 'PolicyEngine';
  /** the maximum allowed severity without failing the stack run */
  maxSeverity?: Maybe<VulnSeverity>;
  /** the policy engine to use with this stack */
  type: PolicyEngineType;
};

export type PolicyEngineAttributes = {
  /** the maximum allowed severity without failing the stack run */
  maxSeverity?: InputMaybe<VulnSeverity>;
  /** the policy engine to use with this stack */
  type: PolicyEngineType;
};

export enum PolicyEngineType {
  Trivy = 'TRIVY'
}

/** Aggregate statistics for policies across your fleet */
export type PolicyStatistic = {
  __typename?: 'PolicyStatistic';
  /** the field you're computing this statistic on */
  aggregate?: Maybe<Scalars['String']['output']>;
  /** the count for this aggregate */
  count?: Maybe<Scalars['Int']['output']>;
};

export type Port = {
  __typename?: 'Port';
  containerPort?: Maybe<Scalars['Int']['output']>;
  hostPort?: Maybe<Scalars['Int']['output']>;
  protocol?: Maybe<Scalars['String']['output']>;
};

/** a description of how to generate a pr, which can either modify existing files or generate new ones w/in a repo */
export type PrAutomation = {
  __typename?: 'PrAutomation';
  /** link to an add-on name if this can update it */
  addon?: Maybe<Scalars['String']['output']>;
  /** the catalog this pr automation belongs to */
  catalog?: Maybe<Catalog>;
  /** link to a cluster if this is to perform an upgrade */
  cluster?: Maybe<Cluster>;
  configuration?: Maybe<Array<Maybe<PrConfiguration>>>;
  /** optional confirmation block to express prerequisites for this PR */
  confirmation?: Maybe<PrConfirmation>;
  /** the scm connection to use for pr generation */
  connection?: Maybe<ScmConnection>;
  /** users who can generate prs with this automation */
  createBindings?: Maybe<Array<Maybe<PolicyBinding>>>;
  creates?: Maybe<PrCreateSpec>;
  /** a darkmode icon url to use for this catalog */
  darkIcon?: Maybe<Scalars['String']['output']>;
  deletes?: Maybe<PrDeleteSpec>;
  documentation?: Maybe<Scalars['String']['output']>;
  /** an icon url to use for this catalog */
  icon?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** string id for a repository, eg for github, this is {organization}/{repository-name} */
  identifier?: Maybe<Scalars['String']['output']>;
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  message: Scalars['String']['output'];
  /** the name for this automation */
  name: Scalars['String']['output'];
  /** the project this automation lives w/in */
  project?: Maybe<Project>;
  /** the git repository to use for sourcing external templates */
  repository?: Maybe<GitRepository>;
  /** An enum describing the high-level responsibility of this pr, eg creating a cluster or service, or upgrading a cluster */
  role?: Maybe<PrRole>;
  /** the secrets to create as part of this pr */
  secrets?: Maybe<PrSecrets>;
  /** link to a service if this can update its configuration */
  service?: Maybe<ServiceDeployment>;
  title: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  updates?: Maybe<PrUpdateSpec>;
  /** write policy for this pr automation, also propagates to the notifications list for any created PRs */
  writeBindings?: Maybe<Array<Maybe<PolicyBinding>>>;
};

/** A way to create a self-service means of generating PRs against an IaC repo */
export type PrAutomationAttributes = {
  /** link to an add-on name if this can update it */
  addon?: InputMaybe<Scalars['String']['input']>;
  branch?: InputMaybe<Scalars['String']['input']>;
  /** the catalog this automation will belong to */
  catalogId?: InputMaybe<Scalars['ID']['input']>;
  /** link to a cluster if this is to perform an upgrade */
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  configuration?: InputMaybe<Array<InputMaybe<PrConfigurationAttributes>>>;
  confirmation?: InputMaybe<PrConfirmationAttributes>;
  /** the scm connection to use for pr generation */
  connectionId?: InputMaybe<Scalars['ID']['input']>;
  /** users who can create prs with this automation */
  createBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
  creates?: InputMaybe<PrAutomationCreateSpecAttributes>;
  /** a darkmode icon url to use for this catalog */
  darkIcon?: InputMaybe<Scalars['String']['input']>;
  deletes?: InputMaybe<PrAutomationDeleteSpecAttributes>;
  documentation?: InputMaybe<Scalars['String']['input']>;
  /** the governance controller to use for this pr */
  governanceId?: InputMaybe<Scalars['ID']['input']>;
  /** an icon url to use for this catalog */
  icon?: InputMaybe<Scalars['String']['input']>;
  /** string id for a repository, eg for github, this is {organization}/{repository-name} */
  identifier?: InputMaybe<Scalars['String']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  /** whether to generate a patch for this pr instead of a full pr */
  patch?: InputMaybe<Scalars['Boolean']['input']>;
  /** the project this automation lives in */
  projectId?: InputMaybe<Scalars['ID']['input']>;
  /** a git repository to use for create mode prs */
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
  role?: InputMaybe<PrRole>;
  secrets?: InputMaybe<PrSecretsAttributes>;
  /** link to a service if this can modify its configuration */
  serviceId?: InputMaybe<Scalars['ID']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  updates?: InputMaybe<PrAutomationUpdateSpecAttributes>;
  /** users who can update this automation */
  writeBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
};

export type PrAutomationConnection = {
  __typename?: 'PrAutomationConnection';
  edges?: Maybe<Array<Maybe<PrAutomationEdge>>>;
  pageInfo: PageInfo;
};

/** Operations to create new templated files within this pr */
export type PrAutomationCreateSpecAttributes = {
  git?: InputMaybe<GitRefAttributes>;
  templates?: InputMaybe<Array<InputMaybe<PrAutomationTemplateAttributes>>>;
};

/** Operations to delete files within this pr */
export type PrAutomationDeleteSpecAttributes = {
  files?: InputMaybe<Array<Scalars['String']['input']>>;
  folders?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type PrAutomationEdge = {
  __typename?: 'PrAutomationEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<PrAutomation>;
};

/** templates to apply in this pr */
export type PrAutomationTemplateAttributes = {
  condition?: InputMaybe<Scalars['String']['input']>;
  context?: InputMaybe<Scalars['Json']['input']>;
  destination: Scalars['String']['input'];
  /** whether the source template is sourced from an external git repo bound to this automation */
  external: Scalars['Boolean']['input'];
  source: Scalars['String']['input'];
};

/** The operations to be performed on the files w/in the pr */
export type PrAutomationUpdateSpecAttributes = {
  files?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  matchStrategy?: InputMaybe<MatchStrategy>;
  /** list of regex scope replacement templates, useful for ANY strategies */
  regexReplacements?: InputMaybe<Array<InputMaybe<RegexReplacementAttributes>>>;
  regexes?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  replaceTemplate?: InputMaybe<Scalars['String']['input']>;
  /** list of yaml overlay operations to apply to a file */
  yamlOverlays?: InputMaybe<Array<InputMaybe<YamlOverlayAttributes>>>;
  yq?: InputMaybe<Scalars['String']['input']>;
};

/** Additional attributes for describing a pr call tool call that derived this chat message */
export type PrCallAttributes = {
  __typename?: 'PrCallAttributes';
  branch?: Maybe<Scalars['String']['output']>;
  context?: Maybe<Scalars['Map']['output']>;
};

/** a checkbox item to render before creating a pr */
export type PrChecklist = {
  __typename?: 'PrChecklist';
  /** the label for the checkbox */
  label: Scalars['String']['output'];
};

/** a checkbox item to render before creating a pr */
export type PrChecklistAttributes = {
  /** the label for the checkbox */
  label: Scalars['String']['input'];
};

/** the a configuration item for creating a new pr, used for templating the ultimate code changes made */
export type PrConfiguration = {
  __typename?: 'PrConfiguration';
  condition?: Maybe<PrConfigurationCondition>;
  default?: Maybe<Scalars['String']['output']>;
  displayName?: Maybe<Scalars['String']['output']>;
  documentation?: Maybe<Scalars['String']['output']>;
  longform?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  optional?: Maybe<Scalars['Boolean']['output']>;
  /** the page to use for the pr configuration */
  page?: Maybe<Scalars['Int']['output']>;
  placeholder?: Maybe<Scalars['String']['output']>;
  type: ConfigurationType;
  values?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** the a configuration item for creating a new pr */
export type PrConfigurationAttributes = {
  condition?: InputMaybe<ConditionAttributes>;
  default?: InputMaybe<Scalars['String']['input']>;
  displayName?: InputMaybe<Scalars['String']['input']>;
  documentation?: InputMaybe<Scalars['String']['input']>;
  longform?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  optional?: InputMaybe<Scalars['Boolean']['input']>;
  /** the page to use for the pr automation */
  page?: InputMaybe<Scalars['Int']['input']>;
  placeholder?: InputMaybe<Scalars['String']['input']>;
  type: ConfigurationType;
  validation?: InputMaybe<ConfigurationValidationAttributes>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** declaritive spec for whether a config item is relevant given prior config */
export type PrConfigurationCondition = {
  __typename?: 'PrConfigurationCondition';
  /** the prior field to check */
  field: Scalars['String']['output'];
  /** a boolean operation to apply */
  operation: Operation;
  /** a fixed value to check against if its a binary operation */
  value?: Maybe<Scalars['String']['output']>;
};

/** Additional details to verify all prerequisites are satisfied before generating this pr */
export type PrConfirmation = {
  __typename?: 'PrConfirmation';
  /** itemized checklist to complete before pr create */
  checklist?: Maybe<Array<Maybe<PrChecklist>>>;
  /** optional markdown text to present before pr create */
  text?: Maybe<Scalars['String']['output']>;
};

/** Additional details to verify all prerequisites are satisfied before generating this pr */
export type PrConfirmationAttributes = {
  /** itemized checklist to complete before pr create */
  checklist?: InputMaybe<Array<InputMaybe<PrChecklistAttributes>>>;
  /** optional markdown text to present before pr create */
  text?: InputMaybe<Scalars['String']['input']>;
};

/** templated files used to add new files to a given pr */
export type PrCreateSpec = {
  __typename?: 'PrCreateSpec';
  /** pointer within an external git repository to source templates from */
  git?: Maybe<GitRef>;
  templates?: Maybe<Array<Maybe<PrTemplateSpec>>>;
};

/** Files or folders you want to delete in this pr */
export type PrDeleteSpec = {
  __typename?: 'PrDeleteSpec';
  files?: Maybe<Array<Scalars['String']['output']>>;
  folders?: Maybe<Array<Scalars['String']['output']>>;
};

/** A governance controller is a mechanism to enforce a set of rules on a set of PRs */
export type PrGovernance = {
  __typename?: 'PrGovernance';
  configuration?: Maybe<PrGovernanceConfiguration>;
  connection?: Maybe<ScmConnection>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  name: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

/** The settings for configuring a pr governance controller */
export type PrGovernanceAttributes = {
  configuration?: InputMaybe<PrGovernanceConfigurationAttributes>;
  /** the scm connection to use for pr generation */
  connectionId: Scalars['ID']['input'];
  name: Scalars['String']['input'];
};

/** The configuration for a pr governance controller */
export type PrGovernanceConfiguration = {
  __typename?: 'PrGovernanceConfiguration';
  webhook?: Maybe<GovernanceWebhook>;
};

/** The settings for configuring a pr governance controller */
export type PrGovernanceConfigurationAttributes = {
  webhook?: InputMaybe<GovernanceWebhookAttributes>;
};

export enum PrRole {
  Cluster = 'CLUSTER',
  Cost = 'COST',
  Pipeline = 'PIPELINE',
  Service = 'SERVICE',
  Update = 'UPDATE',
  Upgrade = 'UPGRADE'
}

export type PrSecretEntry = {
  __typename?: 'PrSecretEntry';
  /** whether to autogenerate the secret */
  autogenerate?: Maybe<Scalars['Boolean']['output']>;
  /** the documentation for the secret entry */
  documentation?: Maybe<Scalars['String']['output']>;
  /** the name of the secret entry */
  name?: Maybe<Scalars['String']['output']>;
};

export type PrSecretEntryAttributes = {
  /** whether to autogenerate the secret entry */
  autogenerate?: InputMaybe<Scalars['Boolean']['input']>;
  /** the documentation for the secret entry */
  documentation?: InputMaybe<Scalars['String']['input']>;
  /** the name of the secret entry */
  name?: InputMaybe<Scalars['String']['input']>;
};

export type PrSecrets = {
  __typename?: 'PrSecrets';
  /** the cluster handle that will hold this secret */
  cluster?: Maybe<Scalars['String']['output']>;
  entries?: Maybe<Array<Maybe<PrSecretEntry>>>;
  /** the name of the secret */
  name?: Maybe<Scalars['String']['output']>;
  /** the k8s namespace to place the secret in */
  namespace?: Maybe<Scalars['String']['output']>;
};

export type PrSecretsAttributes = {
  /** the cluster handle that will hold this secret */
  cluster?: InputMaybe<Scalars['String']['input']>;
  entries?: InputMaybe<Array<InputMaybe<PrSecretEntryAttributes>>>;
  /** the name of the secret */
  name?: InputMaybe<Scalars['String']['input']>;
  /** the k8s namespace to place the secret in */
  namespace?: InputMaybe<Scalars['String']['input']>;
};

export enum PrStatus {
  Closed = 'CLOSED',
  Merged = 'MERGED',
  Open = 'OPEN'
}

/** the details of where to find and place a templated file */
export type PrTemplateSpec = {
  __typename?: 'PrTemplateSpec';
  condition?: Maybe<Scalars['String']['output']>;
  context?: Maybe<Scalars['Map']['output']>;
  destination: Scalars['String']['output'];
  external: Scalars['Boolean']['output'];
  source: Scalars['String']['output'];
};

/** existing file updates that can be performed in a PR */
export type PrUpdateSpec = {
  __typename?: 'PrUpdateSpec';
  files?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  matchStrategy?: Maybe<MatchStrategy>;
  regexReplacements?: Maybe<Array<Maybe<RegexReplacement>>>;
  regexes?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  replaceTemplate?: Maybe<Scalars['String']['output']>;
  yamlOverlays?: Maybe<Array<Maybe<YamlOverlay>>>;
  yq?: Maybe<Scalars['String']['output']>;
};

/** An instance of a preview environment template */
export type PreviewEnvironmentInstance = {
  __typename?: 'PreviewEnvironmentInstance';
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  pullRequest?: Maybe<PullRequest>;
  service?: Maybe<ServiceDeployment>;
  template?: Maybe<PreviewEnvironmentTemplate>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type PreviewEnvironmentInstanceConnection = {
  __typename?: 'PreviewEnvironmentInstanceConnection';
  edges?: Maybe<Array<Maybe<PreviewEnvironmentInstanceEdge>>>;
  pageInfo: PageInfo;
};

export type PreviewEnvironmentInstanceEdge = {
  __typename?: 'PreviewEnvironmentInstanceEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<PreviewEnvironmentInstance>;
};

/** A template for generating preview environments */
export type PreviewEnvironmentTemplate = {
  __typename?: 'PreviewEnvironmentTemplate';
  commentTemplate?: Maybe<Scalars['String']['output']>;
  connection?: Maybe<ScmConnection>;
  flow?: Maybe<Flow>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  name: Scalars['String']['output'];
  referenceService?: Maybe<ServiceDeployment>;
  template?: Maybe<ServiceTemplate>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type PreviewEnvironmentTemplateAttributes = {
  /** a liquid template for custom information in the PR comment */
  commentTemplate?: InputMaybe<Scalars['String']['input']>;
  /** an scm connection id to use for PR preview comment generation */
  connectionId?: InputMaybe<Scalars['ID']['input']>;
  /** the flow that will own the preview environment */
  flowId: Scalars['ID']['input'];
  /** the name of the preview environment template */
  name: Scalars['String']['input'];
  /** the service that will be cloned to create the preview environment */
  referenceServiceId: Scalars['ID']['input'];
  /** a set of service configuration overrides to use while cloning */
  template: ServiceTemplateAttributes;
};

export type PreviewEnvironmentTemplateConnection = {
  __typename?: 'PreviewEnvironmentTemplateConnection';
  edges?: Maybe<Array<Maybe<PreviewEnvironmentTemplateEdge>>>;
  pageInfo: PageInfo;
};

export type PreviewEnvironmentTemplateEdge = {
  __typename?: 'PreviewEnvironmentTemplateEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<PreviewEnvironmentTemplate>;
};

/** A unit of organization to control permissions for a set of objects within your Console instance */
export type Project = {
  __typename?: 'Project';
  /** list all alerts discovered for this project */
  alerts?: Maybe<AlertConnection>;
  default?: Maybe<Scalars['Boolean']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  name: Scalars['String']['output'];
  /** read policy across this project */
  readBindings?: Maybe<Array<Maybe<PolicyBinding>>>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** write policy across this project */
  writeBindings?: Maybe<Array<Maybe<PolicyBinding>>>;
};


/** A unit of organization to control permissions for a set of objects within your Console instance */
export type ProjectAlertsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type ProjectAttributes = {
  description?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  readBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
  writeBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
};

export type ProjectConnection = {
  __typename?: 'ProjectConnection';
  edges?: Maybe<Array<Maybe<ProjectEdge>>>;
  pageInfo: PageInfo;
};

export type ProjectEdge = {
  __typename?: 'ProjectEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<Project>;
};

export type ProjectUsageHistory = {
  __typename?: 'ProjectUsageHistory';
  controlPlaneCost?: Maybe<Scalars['Float']['output']>;
  cpu?: Maybe<Scalars['Float']['output']>;
  cpuCost?: Maybe<Scalars['Float']['output']>;
  egressCost?: Maybe<Scalars['Float']['output']>;
  gpu?: Maybe<Scalars['Float']['output']>;
  gpuCost?: Maybe<Scalars['Float']['output']>;
  ingressCost?: Maybe<Scalars['Float']['output']>;
  loadBalancerCost?: Maybe<Scalars['Float']['output']>;
  memory?: Maybe<Scalars['Float']['output']>;
  memoryCost?: Maybe<Scalars['Float']['output']>;
  nodeCost?: Maybe<Scalars['Float']['output']>;
  projectId?: Maybe<Scalars['ID']['output']>;
  storageCost?: Maybe<Scalars['Float']['output']>;
  timestamp: Scalars['DateTime']['output'];
};

export type ProjectUsageHistoryConnection = {
  __typename?: 'ProjectUsageHistoryConnection';
  edges?: Maybe<Array<Maybe<ProjectUsageHistoryEdge>>>;
  pageInfo: PageInfo;
};

export type ProjectUsageHistoryEdge = {
  __typename?: 'ProjectUsageHistoryEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<ProjectUsageHistory>;
};

/** how a promotion for a service will be performed */
export type PromotionCriteria = {
  __typename?: 'PromotionCriteria';
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** overrides the repository slug for the referenced pr automation */
  repository?: Maybe<Scalars['String']['output']>;
  /** whether you want to copy any configuration values from the source service */
  secrets?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** the source service in a prior stage to promote settings from */
  source?: Maybe<ServiceDeployment>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

/** actions to perform if this stage service were promoted */
export type PromotionCriteriaAttributes = {
  /** the handle of the cluster for the source service */
  handle?: InputMaybe<Scalars['String']['input']>;
  /** the name of the source service */
  name?: InputMaybe<Scalars['String']['input']>;
  /** the id of a pr automation to update this service */
  prAutomationId?: InputMaybe<Scalars['ID']['input']>;
  /** overrides the repository slug for the referenced pr automation */
  repository?: InputMaybe<Scalars['String']['input']>;
  /** the secrets to copy over in a promotion */
  secrets?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** the id of the service to promote from */
  sourceId?: InputMaybe<Scalars['ID']['input']>;
};

/** a service to be potentially promoted */
export type PromotionService = {
  __typename?: 'PromotionService';
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the revision of the service to promote */
  revision?: Maybe<Revision>;
  /** a service to promote */
  service?: Maybe<ServiceDeployment>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export enum Provider {
  Aws = 'AWS',
  Azure = 'AZURE',
  Gcp = 'GCP'
}

/** a cloud credential that can be used while creating new clusters */
export type ProviderCredential = {
  __typename?: 'ProviderCredential';
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  kind: Scalars['String']['output'];
  name: Scalars['String']['output'];
  namespace: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type ProviderCredentialAttributes = {
  kind?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};

/** A reference to a pull request for your kubernetes related IaC */
export type PullRequest = {
  __typename?: 'PullRequest';
  /** the cluster this pr is meant to modify */
  cluster?: Maybe<Cluster>;
  creator?: Maybe<Scalars['String']['output']>;
  /** the flow this pr is meant to modify */
  flow?: Maybe<Flow>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  labels?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** the patch for this pr, if it is a patch.  This is in place of generating a full pr */
  patch?: Maybe<Scalars['String']['output']>;
  /** the service this pr is meant to modify */
  service?: Maybe<ServiceDeployment>;
  status?: Maybe<PrStatus>;
  title?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  url: Scalars['String']['output'];
};

/** attributes for a pull request pointer record */
export type PullRequestAttributes = {
  cluster?: InputMaybe<NamespacedName>;
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  creator?: InputMaybe<Scalars['String']['input']>;
  labels?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  service?: InputMaybe<NamespacedName>;
  serviceId?: InputMaybe<Scalars['ID']['input']>;
  title: Scalars['String']['input'];
  url: Scalars['String']['input'];
};

export type PullRequestConnection = {
  __typename?: 'PullRequestConnection';
  edges?: Maybe<Array<Maybe<PullRequestEdge>>>;
  pageInfo: PageInfo;
};

export type PullRequestEdge = {
  __typename?: 'PullRequestEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<PullRequest>;
};

export type PullRequestEvidence = {
  __typename?: 'PullRequestEvidence';
  contents?: Maybe<Scalars['String']['output']>;
  filename?: Maybe<Scalars['String']['output']>;
  patch?: Maybe<Scalars['String']['output']>;
  repo?: Maybe<Scalars['String']['output']>;
  sha?: Maybe<Scalars['String']['output']>;
  title?: Maybe<Scalars['String']['output']>;
  url?: Maybe<Scalars['String']['output']>;
};

/** attributes for a pull request pointer record */
export type PullRequestUpdateAttributes = {
  cluster?: InputMaybe<NamespacedName>;
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  labels?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  service?: InputMaybe<NamespacedName>;
  serviceId?: InputMaybe<Scalars['ID']['input']>;
  status: PrStatus;
  title: Scalars['String']['input'];
};

export type RbacAttributes = {
  readBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
  writeBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
};

export enum ReadType {
  Build = 'BUILD',
  Notification = 'NOTIFICATION'
}

export type Recommendation = {
  __typename?: 'Recommendation';
  containerRecommendations?: Maybe<Array<Maybe<ContainerRecommendation>>>;
};

export type RefreshToken = {
  __typename?: 'RefreshToken';
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the token to use to request a refresh */
  token: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type RefreshTokenConnection = {
  __typename?: 'RefreshTokenConnection';
  edges?: Maybe<Array<Maybe<RefreshTokenEdge>>>;
  pageInfo: PageInfo;
};

export type RefreshTokenEdge = {
  __typename?: 'RefreshTokenEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<RefreshToken>;
};

/** a fully specified regex/replace flow */
export type RegexReplacement = {
  __typename?: 'RegexReplacement';
  /** the file to apply this replacement on */
  file: Scalars['String']['output'];
  regex: Scalars['String']['output'];
  /** template string to replace any match with */
  replacement: Scalars['String']['output'];
  /** Whether to apply liquid templating before compiling this regex */
  templated?: Maybe<Scalars['Boolean']['output']>;
};

/** a fully specified regex/replace flow */
export type RegexReplacementAttributes = {
  /** the filename to apply this regex on */
  file: Scalars['String']['input'];
  regex: Scalars['String']['input'];
  replacement: Scalars['String']['input'];
  /** whether you want to apply liquid templating on the regex before compiling */
  templated?: InputMaybe<Scalars['Boolean']['input']>;
};

export type Renderer = {
  __typename?: 'Renderer';
  helm?: Maybe<HelmMinimal>;
  path: Scalars['String']['output'];
  type: RendererType;
};

export type RendererAttributes = {
  helm?: InputMaybe<HelmMinimalAttributes>;
  path: Scalars['String']['input'];
  type: RendererType;
};

export enum RendererType {
  Auto = 'AUTO',
  Helm = 'HELM',
  Kustomize = 'KUSTOMIZE',
  Raw = 'RAW'
}

export type ReplicaSet = {
  __typename?: 'ReplicaSet';
  metadata: Metadata;
  pods?: Maybe<Array<Maybe<Pod>>>;
  raw: Scalars['String']['output'];
  spec: ReplicaSetSpec;
  status: ReplicaSetStatus;
};

export type ReplicaSetSpec = {
  __typename?: 'ReplicaSetSpec';
  replicas?: Maybe<Scalars['Int']['output']>;
};

export type ReplicaSetStatus = {
  __typename?: 'ReplicaSetStatus';
  availableReplicas?: Maybe<Scalars['Int']['output']>;
  conditions?: Maybe<Array<Maybe<StatusCondition>>>;
  fullyLabeledReplicas?: Maybe<Scalars['Int']['output']>;
  readyReplicas?: Maybe<Scalars['Int']['output']>;
  replicas?: Maybe<Scalars['Int']['output']>;
};

/** an edge representing mapping from kubernetes object metadata.uid -> metadata.uid */
export type ResourceEdge = {
  __typename?: 'ResourceEdge';
  from: Scalars['String']['output'];
  to: Scalars['String']['output'];
};

/** A kubernetes pod container resource request spec */
export type ResourceRequest = {
  __typename?: 'ResourceRequest';
  cpu?: Maybe<Scalars['String']['output']>;
  memory?: Maybe<Scalars['String']['output']>;
};

export type ResourceRequestAttributes = {
  cpu?: InputMaybe<Scalars['String']['input']>;
  memory?: InputMaybe<Scalars['String']['input']>;
};

export type ResourceSelector = {
  __typename?: 'ResourceSelector';
  excluded?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  included?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

export type ResourceSelectorAttributes = {
  excluded?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  included?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export type ResourceSpec = {
  __typename?: 'ResourceSpec';
  cpu?: Maybe<Scalars['String']['output']>;
  memory?: Maybe<Scalars['String']['output']>;
};

export type Resources = {
  __typename?: 'Resources';
  limits?: Maybe<ResourceSpec>;
  requests?: Maybe<ResourceSpec>;
};

export type RestoreAttributes = {
  status: RestoreStatus;
};

export enum RestoreStatus {
  Created = 'CREATED',
  Failed = 'FAILED',
  Pending = 'PENDING',
  Successful = 'SUCCESSFUL'
}

/** a representation of a past revision of a service */
export type Revision = {
  __typename?: 'Revision';
  /** git spec of the prior revision */
  git?: Maybe<GitRef>;
  /** description of how helm charts should be applied */
  helm?: Maybe<HelmSpec>;
  /** id of this revision */
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the commit message for this revision */
  message?: Maybe<Scalars['String']['output']>;
  /** the sha this service was pulled from */
  sha?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the service's semver */
  version: Scalars['String']['output'];
};

export type RevisionConnection = {
  __typename?: 'RevisionConnection';
  edges?: Maybe<Array<Maybe<RevisionEdge>>>;
  pageInfo: PageInfo;
};

export type RevisionEdge = {
  __typename?: 'RevisionEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<Revision>;
};

export type Role = {
  __typename?: 'Role';
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  name: Scalars['String']['output'];
  permissions?: Maybe<Array<Maybe<Permission>>>;
  repositories?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  roleBindings?: Maybe<Array<Maybe<RoleBinding>>>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type RoleAttributes = {
  description?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  permissions?: InputMaybe<Array<InputMaybe<Permission>>>;
  repositories?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  roleBindings?: InputMaybe<Array<InputMaybe<BindingAttributes>>>;
};

export type RoleBinding = {
  __typename?: 'RoleBinding';
  group?: Maybe<Group>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  user?: Maybe<User>;
};

export type RoleConnection = {
  __typename?: 'RoleConnection';
  edges?: Maybe<Array<Maybe<RoleEdge>>>;
  pageInfo: PageInfo;
};

export type RoleEdge = {
  __typename?: 'RoleEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<Role>;
};

export type RollingUpdate = {
  __typename?: 'RollingUpdate';
  maxSurge?: Maybe<Scalars['Int']['output']>;
  maxUnavailable?: Maybe<Scalars['Int']['output']>;
};

export type RootMutationType = {
  __typename?: 'RootMutationType';
  acceptLogin?: Maybe<OauthResponse>;
  /** it will add additional context to the given chat from a source object */
  addChatContext?: Maybe<Array<Maybe<Chat>>>;
  addClusterAuditLog?: Maybe<Scalars['Boolean']['output']>;
  addRunLogs?: Maybe<RunLogs>;
  agentPullRequest?: Maybe<PullRequest>;
  aiFixPr?: Maybe<PullRequest>;
  applyScalingRecommendation?: Maybe<PullRequest>;
  /** approves an approval pipeline gate */
  approveGate?: Maybe<PipelineGate>;
  approveStackRun?: Maybe<StackRun>;
  cancelAgentRun?: Maybe<AgentRun>;
  /** Cancels a chat message, if the user has access to the thread, by just deleting the chat record */
  cancelChat?: Maybe<Chat>;
  /** saves a set of messages and generates a new one transactionally */
  chat?: Maybe<Chat>;
  /** Wipes your current chat history blank */
  clearChatHistory?: Maybe<Scalars['Int']['output']>;
  /** clones the spec of the given service to be deployed either into a new namespace or new cluster */
  cloneService?: Maybe<ServiceDeployment>;
  cloneThread?: Maybe<ChatThread>;
  completeStackRun?: Maybe<StackRun>;
  configureBackups?: Maybe<Cluster>;
  /** Confirms a chat message and calls its MCP server, if the user has access to the thread */
  confirmChat?: Maybe<Chat>;
  /** Confirms a plan for an agentic chat thread, which will transition to suggesting the PR automations to provision */
  confirmPlan?: Maybe<Array<Maybe<Chat>>>;
  /** Reads and deletes a given shared secret */
  consumeSecret?: Maybe<SharedSecret>;
  createAccessToken?: Maybe<AccessToken>;
  createAgentMigration?: Maybe<AgentMigration>;
  createAgentRun?: Maybe<AgentRun>;
  /** Creates a chat thread and agent session that will operate autonomously based on the prompt provided */
  createAgentSession?: Maybe<ChatThread>;
  createAlertResolution?: Maybe<AlertResolution>;
  createBootstrapToken?: Maybe<BootstrapToken>;
  createCluster?: Maybe<Cluster>;
  /** upserts a cluster backup resource */
  createClusterBackup?: Maybe<ClusterBackup>;
  createClusterIsoImage?: Maybe<ClusterIsoImage>;
  createClusterProvider?: Maybe<ClusterProvider>;
  createClusterRegistration?: Maybe<ClusterRegistration>;
  createClusterRestore?: Maybe<ClusterRestore>;
  createCustomStackRun?: Maybe<CustomStackRun>;
  createFederatedCredential?: Maybe<FederatedCredential>;
  createGitRepository?: Maybe<GitRepository>;
  createGlobalService?: Maybe<GlobalService>;
  createGroup?: Maybe<Group>;
  createGroupMember?: Maybe<GroupMember>;
  createInvite?: Maybe<Invite>;
  createManagedNamespace?: Maybe<ManagedNamespace>;
  createObjectStore?: Maybe<ObjectStore>;
  createOidcProvider?: Maybe<OidcProvider>;
  createPersona?: Maybe<Persona>;
  createPin?: Maybe<AiPin>;
  createPinnedCustomResource?: Maybe<PinnedCustomResource>;
  /** creates a new pipeline context and binds it to the beginning stage */
  createPipelineContext?: Maybe<PipelineContext>;
  createPrAutomation?: Maybe<PrAutomation>;
  createProject?: Maybe<Project>;
  createProviderCredential?: Maybe<ProviderCredential>;
  createPullRequest?: Maybe<PullRequest>;
  /** just registers a pointer record to a PR after it was created externally be some other automation */
  createPullRequestPointer?: Maybe<PullRequest>;
  createRole?: Maybe<Role>;
  createScmConnection?: Maybe<ScmConnection>;
  createScmWebhook?: Maybe<ScmWebhook>;
  /** creates a webhook reference in our system but doesn't attempt to create it in your upstream provider */
  createScmWebhookPointer?: Maybe<ScmWebhook>;
  createSentinel?: Maybe<Sentinel>;
  createServiceAccount?: Maybe<User>;
  createServiceAccountToken?: Maybe<AccessToken>;
  createServiceDeployment?: Maybe<ServiceDeployment>;
  createStack?: Maybe<InfrastructureStack>;
  createStackDefinition?: Maybe<StackDefinition>;
  createThread?: Maybe<ChatThread>;
  createUser?: Maybe<User>;
  deleteAccessToken?: Maybe<AccessToken>;
  deleteAgentRuntime?: Maybe<AgentRuntime>;
  deleteBootstrapToken?: Maybe<BootstrapToken>;
  deleteCatalog?: Maybe<Catalog>;
  /** deletes a chat from a users history */
  deleteChat?: Maybe<Chat>;
  deleteCloudConnection?: Maybe<CloudConnection>;
  deleteCluster?: Maybe<Cluster>;
  deleteClusterIsoImage?: Maybe<ClusterIsoImage>;
  deleteClusterProvider?: Maybe<ClusterProvider>;
  deleteClusterRegistration?: Maybe<ClusterRegistration>;
  deleteComplianceReportGenerator?: Maybe<ComplianceReportGenerator>;
  deleteCustomStackRun?: Maybe<CustomStackRun>;
  deleteFederatedCredential?: Maybe<FederatedCredential>;
  deleteFlow?: Maybe<Flow>;
  deleteGitRepository?: Maybe<GitRepository>;
  deleteGlobalService?: Maybe<GlobalService>;
  deleteGroup?: Maybe<Group>;
  deleteGroupMember?: Maybe<GroupMember>;
  deleteJob?: Maybe<Job>;
  deleteManagedNamespace?: Maybe<ManagedNamespace>;
  deleteMcpServer?: Maybe<McpServer>;
  deleteNotificationRouter?: Maybe<NotificationRouter>;
  deleteNotificationSink?: Maybe<NotificationSink>;
  deleteObjectStore?: Maybe<ObjectStore>;
  deleteObservabilityProvider?: Maybe<ObservabilityProvider>;
  deleteObservabilityWebhook?: Maybe<ObservabilityWebhook>;
  deleteObserver?: Maybe<Observer>;
  deleteOidcProvider?: Maybe<OidcProvider>;
  deletePersona?: Maybe<Persona>;
  deletePin?: Maybe<AiPin>;
  deletePinnedCustomResource?: Maybe<PinnedCustomResource>;
  deletePipeline?: Maybe<Pipeline>;
  deletePod?: Maybe<Pod>;
  deletePrAutomation?: Maybe<PrAutomation>;
  /** deletes a governance controller */
  deletePrGovernance?: Maybe<PrGovernance>;
  deletePreviewEnvironmentTemplate?: Maybe<PreviewEnvironmentTemplate>;
  deleteProject?: Maybe<Project>;
  deleteProviderCredential?: Maybe<ProviderCredential>;
  deletePullRequest?: Maybe<PullRequest>;
  deleteRole?: Maybe<Role>;
  deleteScmConnection?: Maybe<ScmConnection>;
  deleteScmWebhook?: Maybe<ScmWebhook>;
  deleteSentinel?: Maybe<Sentinel>;
  deleteServiceContext?: Maybe<ServiceContext>;
  deleteServiceDeployment?: Maybe<ServiceDeployment>;
  deleteStack?: Maybe<InfrastructureStack>;
  deleteStackDefinition?: Maybe<StackDefinition>;
  deleteThread?: Maybe<ChatThread>;
  deleteUser?: Maybe<User>;
  deleteVirtualCluster?: Maybe<Cluster>;
  delinkBackups?: Maybe<Cluster>;
  /** soft deletes a cluster, by deregistering it in our system but not disturbing any kubernetes objects */
  detachCluster?: Maybe<Cluster>;
  /** removes a service from storage, but bypasses waiting for the agent to fully drain it from its hosting cluster */
  detachServiceDeployment?: Maybe<ServiceDeployment>;
  detachStack?: Maybe<InfrastructureStack>;
  dismissOnboarding?: Maybe<DeploymentSettings>;
  enableDeployments?: Maybe<DeploymentSettings>;
  /** forces a pipeline gate to be in open state */
  forceGate?: Maybe<PipelineGate>;
  /** Chat mutation that can also execute MCP servers in line with the overall completion */
  hybridChat?: Maybe<Array<Maybe<Chat>>>;
  impersonateServiceAccount?: Maybe<User>;
  ingestClusterCost?: Maybe<Scalars['Boolean']['output']>;
  installAddOn?: Maybe<ServiceDeployment>;
  kickObserver?: Maybe<Observer>;
  kickService?: Maybe<ServiceDeployment>;
  /** refresh the source repo of this stack, and potentially create a fresh run */
  kickStack?: Maybe<StackRun>;
  /** refresh the source repo of this stack, and potentially create a fresh run for this pr */
  kickStackPullRequest?: Maybe<StackRun>;
  loginLink?: Maybe<User>;
  logout?: Maybe<User>;
  markRead?: Maybe<User>;
  /** merges configuration for a service */
  mergeService?: Maybe<ServiceDeployment>;
  oauthCallback?: Maybe<User>;
  oauthConsent?: Maybe<OauthResponse>;
  /** Creates a custom run, with the given command list, to execute w/in the stack's environment */
  onDemandRun?: Maybe<StackRun>;
  /** a regular status ping to be sent by the deploy operator */
  pingCluster?: Maybe<Cluster>;
  /** marks a service as being able to proceed to the next stage of a canary rollout */
  proceed?: Maybe<ServiceDeployment>;
  readAppNotifications?: Maybe<Scalars['Int']['output']>;
  readNotifications?: Maybe<User>;
  reconfigureRenovate?: Maybe<ServiceDeployment>;
  /** Refreshes an insight, which will trigger a new AI insight generation in the background */
  refreshInsight?: Maybe<AiInsight>;
  registerGithubApp?: Maybe<ScmConnection>;
  /** registers a list of runtime services discovered for the current cluster */
  registerRuntimeServices?: Maybe<Scalars['Int']['output']>;
  resetObserver?: Maybe<Observer>;
  restartStackRun?: Maybe<StackRun>;
  /** un-deletes a stack and cancels the destroy run that was spawned to remove its managed infrastructure */
  restoreStack?: Maybe<InfrastructureStack>;
  /** rewires this service to use the given revision id */
  rollbackService?: Maybe<ServiceDeployment>;
  runSentinel?: Maybe<SentinelRun>;
  /** saves a list of chat messages to your current chat history, can be used at any time */
  saveChats?: Maybe<Array<Maybe<Chat>>>;
  /** save the manifests in cache to be retrieved by the requesting user */
  saveManifests?: Maybe<Scalars['Boolean']['output']>;
  /** upserts a pipeline with a given name */
  savePipeline?: Maybe<Pipeline>;
  saveServiceContext?: Maybe<ServiceContext>;
  /** agent api to persist upgrade insights for its cluster */
  saveUpgradeInsights?: Maybe<Array<Maybe<UpgradeInsight>>>;
  selfManage?: Maybe<ServiceDeployment>;
  /** creates the service to enable self-hosted renovate in one pass */
  setupRenovate?: Maybe<ServiceDeployment>;
  shareAgentRun?: Maybe<AgentRun>;
  /** Shares a one-time-viewable secret to a list of eligible users */
  shareSecret?: Maybe<SharedSecret>;
  signIn?: Maybe<User>;
  signup?: Maybe<User>;
  suggestScalingRecommendation?: Maybe<Scalars['String']['output']>;
  syncGlobalService?: Maybe<GlobalService>;
  /** Creates a pull request given the thread message history */
  threadPr?: Maybe<Chat>;
  /** start a new run from the newest sha in the stack's run history */
  triggerRun?: Maybe<StackRun>;
  updateAgentRun?: Maybe<AgentRun>;
  updateAgentRunAnalysis?: Maybe<AgentRun>;
  updateAgentRunTodos?: Maybe<AgentRun>;
  updateCluster?: Maybe<Cluster>;
  updateClusterIsoImage?: Maybe<ClusterIsoImage>;
  updateClusterProvider?: Maybe<ClusterProvider>;
  updateClusterRegistration?: Maybe<ClusterRegistration>;
  updateClusterRestore?: Maybe<ClusterRestore>;
  updateCustomStackRun?: Maybe<CustomStackRun>;
  updateDeploymentSettings?: Maybe<DeploymentSettings>;
  updateFederatedCredential?: Maybe<FederatedCredential>;
  updateGate?: Maybe<PipelineGate>;
  updateGitRepository?: Maybe<GitRepository>;
  updateGlobalService?: Maybe<GlobalService>;
  updateGroup?: Maybe<Group>;
  updateManagedNamespace?: Maybe<ManagedNamespace>;
  updateObjectStore?: Maybe<ObjectStore>;
  updateOidcProvider?: Maybe<OidcProvider>;
  updatePersona?: Maybe<Persona>;
  updatePrAutomation?: Maybe<PrAutomation>;
  updateProject?: Maybe<Project>;
  updatePullRequest?: Maybe<PullRequest>;
  /** a reusable mutation for updating rbac settings on core services */
  updateRbac?: Maybe<Scalars['Boolean']['output']>;
  updateRole?: Maybe<Role>;
  updateRunStep?: Maybe<RunStep>;
  updateScmConnection?: Maybe<ScmConnection>;
  updateSentinel?: Maybe<Sentinel>;
  updateServiceAccount?: Maybe<User>;
  /** updates only the components of a given service, to be sent after deploy operator syncs */
  updateServiceComponents?: Maybe<ServiceDeployment>;
  updateServiceDeployment?: Maybe<ServiceDeployment>;
  updateStack?: Maybe<InfrastructureStack>;
  updateStackDefinition?: Maybe<StackDefinition>;
  updateStackRun?: Maybe<StackRun>;
  updateThread?: Maybe<ChatThread>;
  updateUser?: Maybe<User>;
  upsertAgentRuntime?: Maybe<AgentRuntime>;
  upsertCatalog?: Maybe<Catalog>;
  upsertCloudConnection?: Maybe<CloudConnection>;
  upsertComplianceReportGenerator?: Maybe<ComplianceReportGenerator>;
  upsertFlow?: Maybe<Flow>;
  upsertHelmRepository?: Maybe<HelmRepository>;
  upsertMcpServer?: Maybe<McpServer>;
  upsertNotificationRouter?: Maybe<NotificationRouter>;
  upsertNotificationSink?: Maybe<NotificationSink>;
  upsertObservabilityProvider?: Maybe<ObservabilityProvider>;
  upsertObservabilityWebhook?: Maybe<ObservabilityWebhook>;
  upsertObserver?: Maybe<Observer>;
  upsertPolicyConstraints?: Maybe<Scalars['Int']['output']>;
  /** upserts a governance controller */
  upsertPrGovernance?: Maybe<PrGovernance>;
  upsertPreviewEnvironmentTemplate?: Maybe<PreviewEnvironmentTemplate>;
  upsertUser?: Maybe<User>;
  upsertVirtualCluster?: Maybe<Cluster>;
  upsertVulnerabilities?: Maybe<Scalars['Int']['output']>;
};


export type RootMutationTypeAcceptLoginArgs = {
  challenge: Scalars['String']['input'];
};


export type RootMutationTypeAddChatContextArgs = {
  source: ContextSource;
  sourceId?: InputMaybe<Scalars['ID']['input']>;
  threadId: Scalars['ID']['input'];
};


export type RootMutationTypeAddClusterAuditLogArgs = {
  audit: ClusterAuditAttributes;
};


export type RootMutationTypeAddRunLogsArgs = {
  attributes: RunLogAttributes;
  stepId: Scalars['ID']['input'];
};


export type RootMutationTypeAgentPullRequestArgs = {
  attributes: AgentPullRequestAttributes;
  runId: Scalars['ID']['input'];
};


export type RootMutationTypeAiFixPrArgs = {
  insightId: Scalars['ID']['input'];
  messages?: InputMaybe<Array<InputMaybe<ChatMessage>>>;
};


export type RootMutationTypeApplyScalingRecommendationArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeApproveGateArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeApproveStackRunArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeCancelAgentRunArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeCancelChatArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeChatArgs = {
  messages?: InputMaybe<Array<InputMaybe<ChatMessage>>>;
  threadId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootMutationTypeClearChatHistoryArgs = {
  before?: InputMaybe<Scalars['Int']['input']>;
  threadId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootMutationTypeCloneServiceArgs = {
  attributes: ServiceCloneAttributes;
  cluster?: InputMaybe<Scalars['String']['input']>;
  clusterId: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  serviceId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootMutationTypeCloneThreadArgs = {
  id: Scalars['ID']['input'];
  seq?: InputMaybe<Scalars['Int']['input']>;
};


export type RootMutationTypeCompleteStackRunArgs = {
  attributes: StackRunAttributes;
  id: Scalars['ID']['input'];
};


export type RootMutationTypeConfigureBackupsArgs = {
  clusterId: Scalars['ID']['input'];
  storeId: Scalars['ID']['input'];
};


export type RootMutationTypeConfirmChatArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeConfirmPlanArgs = {
  threadId: Scalars['ID']['input'];
};


export type RootMutationTypeConsumeSecretArgs = {
  handle: Scalars['String']['input'];
};


export type RootMutationTypeCreateAccessTokenArgs = {
  scopes?: InputMaybe<Array<InputMaybe<ScopeAttributes>>>;
};


export type RootMutationTypeCreateAgentMigrationArgs = {
  attributes: AgentMigrationAttributes;
};


export type RootMutationTypeCreateAgentRunArgs = {
  attributes: AgentRunAttributes;
  runtimeId: Scalars['ID']['input'];
};


export type RootMutationTypeCreateAgentSessionArgs = {
  attributes: AgentSessionAttributes;
};


export type RootMutationTypeCreateAlertResolutionArgs = {
  attributes: AlertResolutionAttributes;
  id: Scalars['ID']['input'];
};


export type RootMutationTypeCreateBootstrapTokenArgs = {
  attributes: BootstrapTokenAttributes;
};


export type RootMutationTypeCreateClusterArgs = {
  attributes: ClusterAttributes;
};


export type RootMutationTypeCreateClusterBackupArgs = {
  attributes: BackupAttributes;
};


export type RootMutationTypeCreateClusterIsoImageArgs = {
  attributes: ClusterIsoImageAttributes;
};


export type RootMutationTypeCreateClusterProviderArgs = {
  attributes: ClusterProviderAttributes;
};


export type RootMutationTypeCreateClusterRegistrationArgs = {
  attributes: ClusterRegistrationCreateAttributes;
};


export type RootMutationTypeCreateClusterRestoreArgs = {
  backupId: Scalars['ID']['input'];
};


export type RootMutationTypeCreateCustomStackRunArgs = {
  attributes: CustomStackRunAttributes;
};


export type RootMutationTypeCreateFederatedCredentialArgs = {
  attributes: FederatedCredentialAttributes;
};


export type RootMutationTypeCreateGitRepositoryArgs = {
  attributes: GitAttributes;
};


export type RootMutationTypeCreateGlobalServiceArgs = {
  attributes: GlobalServiceAttributes;
  cluster?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  serviceId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootMutationTypeCreateGroupArgs = {
  attributes: GroupAttributes;
};


export type RootMutationTypeCreateGroupMemberArgs = {
  groupId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
};


export type RootMutationTypeCreateInviteArgs = {
  attributes: InviteAttributes;
};


export type RootMutationTypeCreateManagedNamespaceArgs = {
  attributes: ManagedNamespaceAttributes;
};


export type RootMutationTypeCreateObjectStoreArgs = {
  attributes: ObjectStoreAttributes;
};


export type RootMutationTypeCreateOidcProviderArgs = {
  attributes: OidcProviderAttributes;
  type: OidcProviderType;
};


export type RootMutationTypeCreatePersonaArgs = {
  attributes: PersonaAttributes;
};


export type RootMutationTypeCreatePinArgs = {
  attributes: AiPinAttributes;
};


export type RootMutationTypeCreatePinnedCustomResourceArgs = {
  attributes: PinnedCustomResourceAttributes;
};


export type RootMutationTypeCreatePipelineContextArgs = {
  attributes: PipelineContextAttributes;
  pipelineId?: InputMaybe<Scalars['ID']['input']>;
  pipelineName?: InputMaybe<Scalars['String']['input']>;
};


export type RootMutationTypeCreatePrAutomationArgs = {
  attributes: PrAutomationAttributes;
};


export type RootMutationTypeCreateProjectArgs = {
  attributes: ProjectAttributes;
};


export type RootMutationTypeCreateProviderCredentialArgs = {
  attributes: ProviderCredentialAttributes;
  name: Scalars['String']['input'];
};


export type RootMutationTypeCreatePullRequestArgs = {
  branch?: InputMaybe<Scalars['String']['input']>;
  context?: InputMaybe<Scalars['Json']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  identifier?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  secrets?: InputMaybe<Scalars['Json']['input']>;
  threadId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootMutationTypeCreatePullRequestPointerArgs = {
  attributes?: InputMaybe<PullRequestAttributes>;
};


export type RootMutationTypeCreateRoleArgs = {
  attributes: RoleAttributes;
};


export type RootMutationTypeCreateScmConnectionArgs = {
  attributes: ScmConnectionAttributes;
};


export type RootMutationTypeCreateScmWebhookArgs = {
  connectionId: Scalars['ID']['input'];
  owner: Scalars['String']['input'];
};


export type RootMutationTypeCreateScmWebhookPointerArgs = {
  attributes: ScmWebhookAttributes;
};


export type RootMutationTypeCreateSentinelArgs = {
  attributes?: InputMaybe<SentinelAttributes>;
};


export type RootMutationTypeCreateServiceAccountArgs = {
  attributes: ServiceAccountAttributes;
};


export type RootMutationTypeCreateServiceAccountTokenArgs = {
  id: Scalars['ID']['input'];
  scopes?: InputMaybe<Array<InputMaybe<ScopeAttributes>>>;
};


export type RootMutationTypeCreateServiceDeploymentArgs = {
  attributes: ServiceDeploymentAttributes;
  cluster?: InputMaybe<Scalars['String']['input']>;
  clusterId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootMutationTypeCreateStackArgs = {
  attributes: StackAttributes;
};


export type RootMutationTypeCreateStackDefinitionArgs = {
  attributes: StackDefinitionAttributes;
};


export type RootMutationTypeCreateThreadArgs = {
  attributes: ChatThreadAttributes;
};


export type RootMutationTypeCreateUserArgs = {
  attributes: UserAttributes;
};


export type RootMutationTypeDeleteAccessTokenArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  token?: InputMaybe<Scalars['String']['input']>;
};


export type RootMutationTypeDeleteAgentRuntimeArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteBootstrapTokenArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteCatalogArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteChatArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteCloudConnectionArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteClusterArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteClusterIsoImageArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteClusterProviderArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteClusterRegistrationArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteComplianceReportGeneratorArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteCustomStackRunArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteFederatedCredentialArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteFlowArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteGitRepositoryArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteGlobalServiceArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteGroupArgs = {
  groupId: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteGroupMemberArgs = {
  groupId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteJobArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  serviceId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootMutationTypeDeleteManagedNamespaceArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteMcpServerArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteNotificationRouterArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteNotificationSinkArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteObjectStoreArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteObservabilityProviderArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteObservabilityWebhookArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteObserverArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteOidcProviderArgs = {
  id: Scalars['ID']['input'];
  type: OidcProviderType;
};


export type RootMutationTypeDeletePersonaArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeletePinArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeletePinnedCustomResourceArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeletePipelineArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeletePodArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  serviceId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootMutationTypeDeletePrAutomationArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeletePrGovernanceArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeletePreviewEnvironmentTemplateArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteProjectArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteProviderCredentialArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeletePullRequestArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteRoleArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteScmConnectionArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteScmWebhookArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteSentinelArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteServiceContextArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteServiceDeploymentArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteStackArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteStackDefinitionArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteThreadArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteUserArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDeleteVirtualClusterArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDelinkBackupsArgs = {
  clusterId: Scalars['ID']['input'];
};


export type RootMutationTypeDetachClusterArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDetachServiceDeploymentArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeDetachStackArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeForceGateArgs = {
  id: Scalars['ID']['input'];
  state?: InputMaybe<GateState>;
};


export type RootMutationTypeHybridChatArgs = {
  messages?: InputMaybe<Array<InputMaybe<ChatMessage>>>;
  threadId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootMutationTypeImpersonateServiceAccountArgs = {
  email: Scalars['String']['input'];
};


export type RootMutationTypeIngestClusterCostArgs = {
  costs: CostIngestAttributes;
};


export type RootMutationTypeInstallAddOnArgs = {
  clusterId: Scalars['ID']['input'];
  configuration?: InputMaybe<Array<InputMaybe<ConfigAttributes>>>;
  global?: InputMaybe<GlobalServiceAttributes>;
  name: Scalars['String']['input'];
};


export type RootMutationTypeKickObserverArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeKickServiceArgs = {
  cluster?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  serviceId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootMutationTypeKickStackArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeKickStackPullRequestArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeLoginLinkArgs = {
  key: Scalars['String']['input'];
};


export type RootMutationTypeMarkReadArgs = {
  type?: InputMaybe<ReadType>;
};


export type RootMutationTypeMergeServiceArgs = {
  configuration?: InputMaybe<Array<InputMaybe<ConfigAttributes>>>;
  id: Scalars['ID']['input'];
};


export type RootMutationTypeOauthCallbackArgs = {
  code: Scalars['String']['input'];
  redirect?: InputMaybe<Scalars['String']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
};


export type RootMutationTypeOauthConsentArgs = {
  challenge: Scalars['String']['input'];
  scopes?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};


export type RootMutationTypeOnDemandRunArgs = {
  commands?: InputMaybe<Array<InputMaybe<CommandAttributes>>>;
  context?: InputMaybe<Scalars['Json']['input']>;
  stackId: Scalars['ID']['input'];
};


export type RootMutationTypePingClusterArgs = {
  attributes: ClusterPing;
};


export type RootMutationTypeProceedArgs = {
  cluster?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  promotion?: InputMaybe<ServicePromotion>;
};


export type RootMutationTypeReconfigureRenovateArgs = {
  repos?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  serviceId: Scalars['ID']['input'];
};


export type RootMutationTypeRefreshInsightArgs = {
  insightId: Scalars['ID']['input'];
};


export type RootMutationTypeRegisterGithubAppArgs = {
  installationId: Scalars['String']['input'];
  name: Scalars['String']['input'];
};


export type RootMutationTypeRegisterRuntimeServicesArgs = {
  deprecated?: InputMaybe<Array<InputMaybe<DeprecatedCustomResourceAttributes>>>;
  layout?: InputMaybe<OperationalLayoutAttributes>;
  serviceId?: InputMaybe<Scalars['ID']['input']>;
  services?: InputMaybe<Array<InputMaybe<RuntimeServiceAttributes>>>;
};


export type RootMutationTypeResetObserverArgs = {
  attributes: ObserverResetAttributes;
  id: Scalars['ID']['input'];
};


export type RootMutationTypeRestartStackRunArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeRestoreStackArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeRollbackServiceArgs = {
  cluster?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  revisionId: Scalars['ID']['input'];
};


export type RootMutationTypeRunSentinelArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeSaveChatsArgs = {
  messages?: InputMaybe<Array<InputMaybe<ChatMessage>>>;
  threadId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootMutationTypeSaveManifestsArgs = {
  id: Scalars['ID']['input'];
  manifests?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};


export type RootMutationTypeSavePipelineArgs = {
  attributes: PipelineAttributes;
  name: Scalars['String']['input'];
};


export type RootMutationTypeSaveServiceContextArgs = {
  attributes: ServiceContextAttributes;
  name: Scalars['String']['input'];
};


export type RootMutationTypeSaveUpgradeInsightsArgs = {
  addons?: InputMaybe<Array<InputMaybe<CloudAddonAttributes>>>;
  insights?: InputMaybe<Array<InputMaybe<UpgradeInsightAttributes>>>;
};


export type RootMutationTypeSelfManageArgs = {
  values: Scalars['String']['input'];
};


export type RootMutationTypeSetupRenovateArgs = {
  connectionId: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  repos?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};


export type RootMutationTypeShareAgentRunArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeShareSecretArgs = {
  attributes: SharedSecretAttributes;
};


export type RootMutationTypeSignInArgs = {
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
};


export type RootMutationTypeSignupArgs = {
  attributes: UserAttributes;
  inviteId: Scalars['String']['input'];
};


export type RootMutationTypeSuggestScalingRecommendationArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeSyncGlobalServiceArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeThreadPrArgs = {
  threadId: Scalars['ID']['input'];
};


export type RootMutationTypeTriggerRunArgs = {
  id: Scalars['ID']['input'];
};


export type RootMutationTypeUpdateAgentRunArgs = {
  attributes: AgentRunStatusAttributes;
  id: Scalars['ID']['input'];
};


export type RootMutationTypeUpdateAgentRunAnalysisArgs = {
  attributes: AgentAnalysisAttributes;
  id: Scalars['ID']['input'];
};


export type RootMutationTypeUpdateAgentRunTodosArgs = {
  id: Scalars['ID']['input'];
  todos?: InputMaybe<Array<InputMaybe<AgentTodoAttributes>>>;
};


export type RootMutationTypeUpdateClusterArgs = {
  attributes: ClusterUpdateAttributes;
  id: Scalars['ID']['input'];
};


export type RootMutationTypeUpdateClusterIsoImageArgs = {
  attributes: ClusterIsoImageAttributes;
  id: Scalars['ID']['input'];
};


export type RootMutationTypeUpdateClusterProviderArgs = {
  attributes: ClusterProviderUpdateAttributes;
  id: Scalars['ID']['input'];
};


export type RootMutationTypeUpdateClusterRegistrationArgs = {
  attributes: ClusterRegistrationUpdateAttributes;
  id: Scalars['ID']['input'];
};


export type RootMutationTypeUpdateClusterRestoreArgs = {
  attributes: RestoreAttributes;
  id: Scalars['ID']['input'];
};


export type RootMutationTypeUpdateCustomStackRunArgs = {
  attributes: CustomStackRunAttributes;
  id: Scalars['ID']['input'];
};


export type RootMutationTypeUpdateDeploymentSettingsArgs = {
  attributes: DeploymentSettingsAttributes;
};


export type RootMutationTypeUpdateFederatedCredentialArgs = {
  attributes: FederatedCredentialAttributes;
  id: Scalars['ID']['input'];
};


export type RootMutationTypeUpdateGateArgs = {
  attributes: GateUpdateAttributes;
  id: Scalars['ID']['input'];
};


export type RootMutationTypeUpdateGitRepositoryArgs = {
  attributes: GitAttributes;
  id: Scalars['ID']['input'];
};


export type RootMutationTypeUpdateGlobalServiceArgs = {
  attributes: GlobalServiceAttributes;
  id: Scalars['ID']['input'];
};


export type RootMutationTypeUpdateGroupArgs = {
  attributes: GroupAttributes;
  groupId: Scalars['ID']['input'];
};


export type RootMutationTypeUpdateManagedNamespaceArgs = {
  attributes: ManagedNamespaceAttributes;
  id: Scalars['ID']['input'];
};


export type RootMutationTypeUpdateObjectStoreArgs = {
  attributes: ObjectStoreAttributes;
  id: Scalars['ID']['input'];
};


export type RootMutationTypeUpdateOidcProviderArgs = {
  attributes: OidcProviderAttributes;
  id: Scalars['ID']['input'];
  type: OidcProviderType;
};


export type RootMutationTypeUpdatePersonaArgs = {
  attributes: PersonaAttributes;
  id: Scalars['ID']['input'];
};


export type RootMutationTypeUpdatePrAutomationArgs = {
  attributes: PrAutomationAttributes;
  id: Scalars['ID']['input'];
};


export type RootMutationTypeUpdateProjectArgs = {
  attributes: ProjectAttributes;
  id: Scalars['ID']['input'];
};


export type RootMutationTypeUpdatePullRequestArgs = {
  attributes?: InputMaybe<PullRequestUpdateAttributes>;
  id: Scalars['ID']['input'];
};


export type RootMutationTypeUpdateRbacArgs = {
  catalogId?: InputMaybe<Scalars['ID']['input']>;
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  flowId?: InputMaybe<Scalars['ID']['input']>;
  pipelineId?: InputMaybe<Scalars['ID']['input']>;
  projectId?: InputMaybe<Scalars['ID']['input']>;
  providerId?: InputMaybe<Scalars['ID']['input']>;
  rbac: RbacAttributes;
  serverId?: InputMaybe<Scalars['ID']['input']>;
  serviceId?: InputMaybe<Scalars['ID']['input']>;
  stackId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootMutationTypeUpdateRoleArgs = {
  attributes: RoleAttributes;
  id: Scalars['ID']['input'];
};


export type RootMutationTypeUpdateRunStepArgs = {
  attributes: RunStepAttributes;
  id: Scalars['ID']['input'];
};


export type RootMutationTypeUpdateScmConnectionArgs = {
  attributes: ScmConnectionAttributes;
  id: Scalars['ID']['input'];
};


export type RootMutationTypeUpdateSentinelArgs = {
  attributes?: InputMaybe<SentinelAttributes>;
  id: Scalars['ID']['input'];
};


export type RootMutationTypeUpdateServiceAccountArgs = {
  attributes: ServiceAccountAttributes;
  id: Scalars['ID']['input'];
};


export type RootMutationTypeUpdateServiceComponentsArgs = {
  components?: InputMaybe<Array<InputMaybe<ComponentAttributes>>>;
  errors?: InputMaybe<Array<InputMaybe<ServiceErrorAttributes>>>;
  id: Scalars['ID']['input'];
  metadata?: InputMaybe<ServiceMetadataAttributes>;
  revisionId?: InputMaybe<Scalars['ID']['input']>;
  sha?: InputMaybe<Scalars['String']['input']>;
};


export type RootMutationTypeUpdateServiceDeploymentArgs = {
  attributes: ServiceUpdateAttributes;
  cluster?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};


export type RootMutationTypeUpdateStackArgs = {
  attributes: StackAttributes;
  id: Scalars['ID']['input'];
};


export type RootMutationTypeUpdateStackDefinitionArgs = {
  attributes: StackDefinitionAttributes;
  id: Scalars['ID']['input'];
};


export type RootMutationTypeUpdateStackRunArgs = {
  attributes: StackRunAttributes;
  id: Scalars['ID']['input'];
};


export type RootMutationTypeUpdateThreadArgs = {
  attributes: ChatThreadAttributes;
  id: Scalars['ID']['input'];
};


export type RootMutationTypeUpdateUserArgs = {
  attributes: UserAttributes;
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type RootMutationTypeUpsertAgentRuntimeArgs = {
  attributes: AgentRuntimeAttributes;
};


export type RootMutationTypeUpsertCatalogArgs = {
  attributes?: InputMaybe<CatalogAttributes>;
};


export type RootMutationTypeUpsertCloudConnectionArgs = {
  attributes: CloudConnectionAttributes;
};


export type RootMutationTypeUpsertComplianceReportGeneratorArgs = {
  attributes: ComplianceReportGeneratorAttributes;
};


export type RootMutationTypeUpsertFlowArgs = {
  attributes: FlowAttributes;
};


export type RootMutationTypeUpsertHelmRepositoryArgs = {
  attributes?: InputMaybe<HelmRepositoryAttributes>;
  url: Scalars['String']['input'];
};


export type RootMutationTypeUpsertMcpServerArgs = {
  attributes: McpServerAttributes;
};


export type RootMutationTypeUpsertNotificationRouterArgs = {
  attributes: NotificationRouterAttributes;
};


export type RootMutationTypeUpsertNotificationSinkArgs = {
  attributes: NotificationSinkAttributes;
};


export type RootMutationTypeUpsertObservabilityProviderArgs = {
  attributes: ObservabilityProviderAttributes;
};


export type RootMutationTypeUpsertObservabilityWebhookArgs = {
  attributes: ObservabilityWebhookAttributes;
};


export type RootMutationTypeUpsertObserverArgs = {
  attributes?: InputMaybe<ObserverAttributes>;
};


export type RootMutationTypeUpsertPolicyConstraintsArgs = {
  constraints?: InputMaybe<Array<InputMaybe<PolicyConstraintAttributes>>>;
};


export type RootMutationTypeUpsertPrGovernanceArgs = {
  attributes: PrGovernanceAttributes;
};


export type RootMutationTypeUpsertPreviewEnvironmentTemplateArgs = {
  attributes: PreviewEnvironmentTemplateAttributes;
};


export type RootMutationTypeUpsertUserArgs = {
  attributes: UserAttributes;
};


export type RootMutationTypeUpsertVirtualClusterArgs = {
  attributes: ClusterAttributes;
  parentId: Scalars['ID']['input'];
};


export type RootMutationTypeUpsertVulnerabilitiesArgs = {
  vulnerabilities?: InputMaybe<Array<InputMaybe<VulnerabilityReportAttributes>>>;
};

export type RootQueryType = {
  __typename?: 'RootQueryType';
  accessToken?: Maybe<AccessToken>;
  accessTokens?: Maybe<AccessTokenConnection>;
  account?: Maybe<Account>;
  agentRun?: Maybe<AgentRun>;
  agentRuns?: Maybe<AgentRunConnection>;
  agentRuntime?: Maybe<AgentRuntime>;
  agentRuntimes?: Maybe<AgentRuntimeConnection>;
  agentSessions?: Maybe<AgentSessionConnection>;
  /** General api to query the configured LLM for your console */
  aiCompletion?: Maybe<Scalars['String']['output']>;
  aiInsight?: Maybe<AiInsight>;
  aiPin?: Maybe<AiPin>;
  aiPins?: Maybe<AiPinConnection>;
  /** Use the content of an insight and additional context from its associated object to suggest a fix */
  aiSuggestedFix?: Maybe<Scalars['String']['output']>;
  appNotifications?: Maybe<AppNotificationConnection>;
  argoRollout?: Maybe<ArgoRollout>;
  auditMetrics?: Maybe<Array<Maybe<AuditMetric>>>;
  audits?: Maybe<AuditConnection>;
  cachedPods?: Maybe<Array<Maybe<Pod>>>;
  canary?: Maybe<Canary>;
  catalog?: Maybe<Catalog>;
  catalogs?: Maybe<CatalogConnection>;
  certificate?: Maybe<Certificate>;
  /** gets an individual chat thread, with the ability to sideload chats on top */
  chatThread?: Maybe<ChatThread>;
  chatThreads?: Maybe<ChatThreadConnection>;
  /** gets the chat history from prior AI chat sessions */
  chats?: Maybe<ChatConnection>;
  cloudConnection?: Maybe<CloudConnection>;
  cloudConnections?: Maybe<CloudConnectionConnection>;
  /** fetches an individual cluster */
  cluster?: Maybe<Cluster>;
  /** list all addons currently resident in the artifacts repo */
  clusterAddOns?: Maybe<Array<Maybe<ClusterAddOn>>>;
  clusterBackup?: Maybe<ClusterBackup>;
  clusterBackups?: Maybe<ClusterBackupConnection>;
  clusterGate?: Maybe<PipelineGate>;
  clusterGates?: Maybe<Array<Maybe<PipelineGate>>>;
  clusterInfo?: Maybe<ClusterInfo>;
  clusterInsightComponent?: Maybe<ClusterInsightComponent>;
  clusterIsoImage?: Maybe<ClusterIsoImage>;
  clusterIsoImages?: Maybe<ClusterIsoImageConnection>;
  clusterManagedNamespaces?: Maybe<ManagedNamespaceConnection>;
  /** fetches an individual cluster provider */
  clusterProvider?: Maybe<ClusterProvider>;
  /** a relay connection of all providers visible to the current user */
  clusterProviders?: Maybe<ClusterProviderConnection>;
  clusterRegistration?: Maybe<ClusterRegistration>;
  clusterRegistrations?: Maybe<ClusterRegistrationConnection>;
  clusterRestore?: Maybe<ClusterRestore>;
  clusterRestores?: Maybe<ClusterRestoreConnection>;
  /** the services deployed in the current cluster, to be polled by the deploy operator */
  clusterServices?: Maybe<Array<Maybe<ServiceDeployment>>>;
  clusterStackRuns?: Maybe<StackRunConnection>;
  /** gets summary information for all healthy/unhealthy clusters in your fleet */
  clusterStatuses?: Maybe<Array<Maybe<ClusterStatusInfo>>>;
  clusterUsage?: Maybe<ClusterUsage>;
  clusterUsages?: Maybe<ClusterUsageConnection>;
  clusterVulnerabilityAggregate?: Maybe<Array<Maybe<ClusterVulnAggregate>>>;
  /** a relay connection of all clusters visible to the current user */
  clusters?: Maybe<ClusterConnection>;
  complianceReportGenerator?: Maybe<ComplianceReportGenerator>;
  complianceReportGenerators?: Maybe<ComplianceReportGeneratorConnection>;
  complianceReports?: Maybe<ComplianceReportsConnection>;
  /** renders a full hierarchy of resources recursively owned by this component (useful for CRD views) */
  componentTree?: Maybe<ComponentTree>;
  configMap?: Maybe<ConfigMap>;
  configuration?: Maybe<ConsoleConfiguration>;
  cronJob?: Maybe<CronJob>;
  customStackRun?: Maybe<CustomStackRun>;
  daemonSet?: Maybe<DaemonSet>;
  dashboard?: Maybe<Dashboard>;
  dashboards?: Maybe<Array<Maybe<Dashboard>>>;
  dependencyManagementServices?: Maybe<DependencyManagementServiceConnection>;
  deployment?: Maybe<Deployment>;
  deploymentSettings?: Maybe<DeploymentSettings>;
  federatedCredential?: Maybe<FederatedCredential>;
  /** Fetches the manifests from cache once the agent has given us them, will be null otherwise */
  fetchManifests?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  flow?: Maybe<Flow>;
  flows?: Maybe<FlowConnection>;
  fluxHelmRepositories?: Maybe<Array<Maybe<FluxHelmRepository>>>;
  fluxHelmRepository?: Maybe<FluxHelmRepository>;
  gitRepositories?: Maybe<GitRepositoryConnection>;
  gitRepository?: Maybe<GitRepository>;
  globalService?: Maybe<GlobalService>;
  globalServices?: Maybe<GlobalServiceConnection>;
  group?: Maybe<Group>;
  groupMembers?: Maybe<GroupMemberConnection>;
  groups?: Maybe<GroupConnection>;
  helmRepositories?: Maybe<HelmRepositoryConnection>;
  helmRepository?: Maybe<HelmRepository>;
  infrastructureStack?: Maybe<InfrastructureStack>;
  infrastructureStacks?: Maybe<InfrastructureStackConnection>;
  ingress?: Maybe<Ingress>;
  invite?: Maybe<Invite>;
  job?: Maybe<Job>;
  kubernetesVersionInfo?: Maybe<Array<Maybe<KubernetesVersionInfo>>>;
  logAggregation?: Maybe<Array<Maybe<LogLine>>>;
  logAggregationBuckets?: Maybe<Array<Maybe<LogAggregationBucket>>>;
  loginInfo?: Maybe<LoginInfo>;
  logs?: Maybe<Array<Maybe<LogStream>>>;
  managedNamespace?: Maybe<ManagedNamespace>;
  managedNamespaces?: Maybe<ManagedNamespaceConnection>;
  mcpServer?: Maybe<McpServer>;
  mcpServers?: Maybe<McpServerConnection>;
  mcpToken?: Maybe<Scalars['String']['output']>;
  me?: Maybe<User>;
  metric?: Maybe<Array<Maybe<MetricResponse>>>;
  /** tells you what cluster a deploy token points to */
  myCluster?: Maybe<Cluster>;
  namespaces?: Maybe<Array<Maybe<Namespace>>>;
  node?: Maybe<Node>;
  nodeMetric?: Maybe<NodeMetric>;
  nodeMetrics?: Maybe<Array<Maybe<NodeMetric>>>;
  notificationRouter?: Maybe<NotificationRouter>;
  notificationRouters?: Maybe<NotificationRouterConnection>;
  notificationSink?: Maybe<NotificationSink>;
  notificationSinks?: Maybe<NotificationSinkConnection>;
  notifications?: Maybe<NotificationConnection>;
  objectStores?: Maybe<ObjectStoreConnection>;
  observabilityProvider?: Maybe<ObservabilityProvider>;
  observabilityProviders?: Maybe<ObservabilityProviderConnection>;
  observabilityWebhook?: Maybe<ObservabilityWebhook>;
  observabilityWebhooks?: Maybe<ObservabilityWebhookConnection>;
  observer?: Maybe<Observer>;
  observers?: Maybe<ObserverConnection>;
  oidcConsent?: Maybe<OidcStepResponse>;
  oidcLogin?: Maybe<OidcStepResponse>;
  oidcProviders?: Maybe<OidcProviderConnection>;
  pagedClusterGates?: Maybe<PipelineGateConnection>;
  pagedClusterServices?: Maybe<ServiceDeploymentConnection>;
  persona?: Maybe<Persona>;
  personas?: Maybe<PersonaConnection>;
  pipeline?: Maybe<Pipeline>;
  pipelineContext?: Maybe<PipelineContext>;
  pipelineGate?: Maybe<PipelineGate>;
  pipelines?: Maybe<PipelineConnection>;
  pluralCluster?: Maybe<PluralCluster>;
  pluralGitRepository?: Maybe<PluralGitRepository>;
  pluralServiceDeployment?: Maybe<PluralServiceDeployment>;
  pod?: Maybe<Pod>;
  pods?: Maybe<PodConnection>;
  policyConstraint?: Maybe<PolicyConstraint>;
  policyConstraints?: Maybe<PolicyConstraintConnection>;
  policyStatistics?: Maybe<Array<Maybe<PolicyStatistic>>>;
  prAutomation?: Maybe<PrAutomation>;
  prAutomations?: Maybe<PrAutomationConnection>;
  prGovernance?: Maybe<PrGovernance>;
  previewEnvironmentTemplate?: Maybe<PreviewEnvironmentTemplate>;
  project?: Maybe<Project>;
  projectUsageHistory?: Maybe<ProjectUsageHistoryConnection>;
  projects?: Maybe<ProjectConnection>;
  pullRequests?: Maybe<PullRequestConnection>;
  refresh?: Maybe<User>;
  refreshTokens?: Maybe<RefreshTokenConnection>;
  /** request manifests from an agent, to be returned by a future call to fetchManifests */
  requestManifests?: Maybe<ServiceDeployment>;
  role?: Maybe<Role>;
  roles?: Maybe<RoleConnection>;
  /** fetch an individual runtime service for more thorough detail views */
  runtimeService?: Maybe<RuntimeService>;
  scalingRecommendation?: Maybe<VerticalPodAutoscaler>;
  scmConnection?: Maybe<ScmConnection>;
  scmConnections?: Maybe<ScmConnectionConnection>;
  scmWebhook?: Maybe<ScmWebhook>;
  scmWebhooks?: Maybe<ScmWebhookConnection>;
  secret?: Maybe<Secret>;
  sentinel?: Maybe<Sentinel>;
  sentinels?: Maybe<SentinelConnection>;
  service?: Maybe<Service>;
  serviceAccounts?: Maybe<UserConnection>;
  serviceContext?: Maybe<ServiceContext>;
  /** fetches details of this service deployment, and can be called by the deploy operator */
  serviceDeployment?: Maybe<ServiceDeployment>;
  serviceDeployments?: Maybe<ServiceDeploymentConnection>;
  serviceStatuses?: Maybe<Array<Maybe<ServiceStatusCount>>>;
  /** Renders a filtered list of services and all their descendents returned as a paginated connection */
  serviceTree?: Maybe<ServiceDeploymentConnection>;
  sharedAgentRun?: Maybe<AgentRun>;
  stackDefinition?: Maybe<StackDefinition>;
  stackDefinitions?: Maybe<StackDefinitionConnection>;
  stackRun?: Maybe<StackRun>;
  statefulSet?: Maybe<StatefulSet>;
  /** adds the ability to search/filter through all tag name/value pairs */
  tagPairs?: Maybe<TagConnection>;
  /** lists tags applied to any clusters in the fleet */
  tags?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  temporaryToken?: Maybe<Scalars['String']['output']>;
  /** exchanges a kubeconfig token for user info */
  tokenExchange?: Maybe<User>;
  unreadAppNotifications?: Maybe<Scalars['Int']['output']>;
  unstructuredResource?: Maybe<KubernetesUnstructured>;
  upgradePlan?: Maybe<UpgradePlan>;
  /** gets summary information for upgradeability in your fleet */
  upgradeStatistics?: Maybe<UpgradeStatistics>;
  user?: Maybe<User>;
  users?: Maybe<UserConnection>;
  violationStatistics?: Maybe<Array<Maybe<ViolationStatistic>>>;
  vulnerabilityReport?: Maybe<VulnerabilityReport>;
  vulnerabilityReports?: Maybe<VulnerabilityReportConnection>;
  vulnerabilityStatistics?: Maybe<Array<Maybe<VulnerabilityStatistic>>>;
};


export type RootQueryTypeAccessTokenArgs = {
  id: Scalars['ID']['input'];
};


export type RootQueryTypeAccessTokensArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type RootQueryTypeAgentRunArgs = {
  id: Scalars['ID']['input'];
};


export type RootQueryTypeAgentRunsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type RootQueryTypeAgentRuntimeArgs = {
  id: Scalars['ID']['input'];
};


export type RootQueryTypeAgentRuntimesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<AgentRuntimeType>;
};


export type RootQueryTypeAgentSessionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type RootQueryTypeAiCompletionArgs = {
  chat?: InputMaybe<Array<InputMaybe<ChatMessage>>>;
  input?: InputMaybe<Scalars['String']['input']>;
  scopeId?: InputMaybe<Scalars['String']['input']>;
  system: Scalars['String']['input'];
};


export type RootQueryTypeAiInsightArgs = {
  id: Scalars['ID']['input'];
};


export type RootQueryTypeAiPinArgs = {
  insightId?: InputMaybe<Scalars['ID']['input']>;
  threadId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootQueryTypeAiPinsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type RootQueryTypeAiSuggestedFixArgs = {
  insightId: Scalars['ID']['input'];
};


export type RootQueryTypeAppNotificationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type RootQueryTypeArgoRolloutArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  serviceId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootQueryTypeAuditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  repo?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeCachedPodsArgs = {
  namespaces?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};


export type RootQueryTypeCanaryArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  serviceId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootQueryTypeCatalogArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeCatalogsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootQueryTypeCertificateArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  serviceId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootQueryTypeChatThreadArgs = {
  id: Scalars['ID']['input'];
};


export type RootQueryTypeChatThreadsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  flowId?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeChatsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  threadId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootQueryTypeCloudConnectionArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeCloudConnectionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeClusterArgs = {
  handle?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type RootQueryTypeClusterBackupArgs = {
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeClusterBackupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  clusterId: Scalars['ID']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type RootQueryTypeClusterGateArgs = {
  id: Scalars['ID']['input'];
};


export type RootQueryTypeClusterInsightComponentArgs = {
  id: Scalars['ID']['input'];
};


export type RootQueryTypeClusterIsoImageArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  image?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeClusterIsoImagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type RootQueryTypeClusterManagedNamespacesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type RootQueryTypeClusterProviderArgs = {
  cloud?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeClusterProvidersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type RootQueryTypeClusterRegistrationArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  machineId?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeClusterRegistrationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type RootQueryTypeClusterRestoreArgs = {
  id: Scalars['ID']['input'];
};


export type RootQueryTypeClusterRestoresArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  clusterId: Scalars['ID']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type RootQueryTypeClusterStackRunsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type RootQueryTypeClusterStatusesArgs = {
  projectId?: InputMaybe<Scalars['ID']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
  tag?: InputMaybe<TagInput>;
};


export type RootQueryTypeClusterUsageArgs = {
  id: Scalars['ID']['input'];
};


export type RootQueryTypeClusterUsagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Scalars['ID']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
  tagQuery?: InputMaybe<TagQuery>;
};


export type RootQueryTypeClusterVulnerabilityAggregateArgs = {
  grade: VulnReportGrade;
};


export type RootQueryTypeClustersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  backups?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  compliance?: InputMaybe<VersionCompliance>;
  first?: InputMaybe<Scalars['Int']['input']>;
  healthRange?: InputMaybe<HealthRange>;
  healthy?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  parentId?: InputMaybe<Scalars['ID']['input']>;
  projectId?: InputMaybe<Scalars['ID']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
  tag?: InputMaybe<TagInput>;
  tagQuery?: InputMaybe<TagQuery>;
  upgradeable?: InputMaybe<Scalars['Boolean']['input']>;
};


export type RootQueryTypeComplianceReportGeneratorArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeComplianceReportGeneratorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type RootQueryTypeComplianceReportsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type RootQueryTypeComponentTreeArgs = {
  id: Scalars['ID']['input'];
};


export type RootQueryTypeConfigMapArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  serviceId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootQueryTypeCronJobArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  serviceId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootQueryTypeCustomStackRunArgs = {
  id: Scalars['ID']['input'];
};


export type RootQueryTypeDaemonSetArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  serviceId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootQueryTypeDashboardArgs = {
  labels?: InputMaybe<Array<InputMaybe<LabelInput>>>;
  name: Scalars['String']['input'];
  offset?: InputMaybe<Scalars['Int']['input']>;
  repo: Scalars['String']['input'];
  step?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeDashboardsArgs = {
  repo: Scalars['String']['input'];
};


export type RootQueryTypeDependencyManagementServicesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type RootQueryTypeDeploymentArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  serviceId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootQueryTypeFederatedCredentialArgs = {
  id: Scalars['ID']['input'];
};


export type RootQueryTypeFetchManifestsArgs = {
  id: Scalars['ID']['input'];
};


export type RootQueryTypeFlowArgs = {
  id: Scalars['ID']['input'];
};


export type RootQueryTypeFlowsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeFluxHelmRepositoryArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
};


export type RootQueryTypeGitRepositoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type RootQueryTypeGitRepositoryArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeGlobalServiceArgs = {
  id: Scalars['ID']['input'];
};


export type RootQueryTypeGlobalServicesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Scalars['ID']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeGroupArgs = {
  name: Scalars['String']['input'];
};


export type RootQueryTypeGroupMembersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId: Scalars['ID']['input'];
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type RootQueryTypeGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeHelmRepositoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type RootQueryTypeHelmRepositoryArgs = {
  url: Scalars['String']['input'];
};


export type RootQueryTypeInfrastructureStackArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeInfrastructureStacksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Scalars['ID']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
  tagQuery?: InputMaybe<TagQuery>;
};


export type RootQueryTypeIngressArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  serviceId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootQueryTypeInviteArgs = {
  id: Scalars['String']['input'];
};


export type RootQueryTypeJobArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  serviceId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootQueryTypeKubernetesVersionInfoArgs = {
  distro?: InputMaybe<ClusterDistro>;
};


export type RootQueryTypeLogAggregationArgs = {
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  facets?: InputMaybe<Array<InputMaybe<LogFacetInput>>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  serviceId?: InputMaybe<Scalars['ID']['input']>;
  time?: InputMaybe<LogTimeRange>;
};


export type RootQueryTypeLogAggregationBucketsArgs = {
  aggregation?: InputMaybe<LogAggregationInput>;
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  facets?: InputMaybe<Array<InputMaybe<LogFacetInput>>>;
  query?: InputMaybe<Scalars['String']['input']>;
  serviceId?: InputMaybe<Scalars['ID']['input']>;
  time?: InputMaybe<LogTimeRange>;
};


export type RootQueryTypeLoginInfoArgs = {
  redirect?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeLogsArgs = {
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  end?: InputMaybe<Scalars['Long']['input']>;
  limit: Scalars['Int']['input'];
  query: Scalars['String']['input'];
  start?: InputMaybe<Scalars['Long']['input']>;
};


export type RootQueryTypeManagedNamespaceArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeManagedNamespacesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootQueryTypeMcpServerArgs = {
  id: Scalars['ID']['input'];
};


export type RootQueryTypeMcpServersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeMetricArgs = {
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  query: Scalars['String']['input'];
  step?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeNamespacesArgs = {
  clusterId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootQueryTypeNodeArgs = {
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  name: Scalars['String']['input'];
};


export type RootQueryTypeNodeMetricArgs = {
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  name: Scalars['String']['input'];
};


export type RootQueryTypeNodeMetricsArgs = {
  clusterId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootQueryTypeNotificationRouterArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeNotificationRoutersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeNotificationSinkArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeNotificationSinksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeNotificationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  all?: InputMaybe<Scalars['Boolean']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type RootQueryTypeObjectStoresArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type RootQueryTypeObservabilityProviderArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeObservabilityProvidersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type RootQueryTypeObservabilityWebhookArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeObservabilityWebhooksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type RootQueryTypeObserverArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeObserversArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootQueryTypeOidcConsentArgs = {
  challenge: Scalars['String']['input'];
};


export type RootQueryTypeOidcLoginArgs = {
  challenge: Scalars['String']['input'];
};


export type RootQueryTypeOidcProvidersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypePagedClusterGatesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type RootQueryTypePagedClusterServicesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type RootQueryTypePersonaArgs = {
  id: Scalars['ID']['input'];
};


export type RootQueryTypePersonasArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type RootQueryTypePipelineArgs = {
  id: Scalars['ID']['input'];
};


export type RootQueryTypePipelineContextArgs = {
  id: Scalars['ID']['input'];
};


export type RootQueryTypePipelineGateArgs = {
  id: Scalars['ID']['input'];
};


export type RootQueryTypePipelinesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Scalars['ID']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypePluralClusterArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  serviceId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootQueryTypePluralGitRepositoryArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  serviceId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootQueryTypePluralServiceDeploymentArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  serviceId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootQueryTypePodArgs = {
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  serviceId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootQueryTypePodsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  namespaces?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};


export type RootQueryTypePolicyConstraintArgs = {
  id: Scalars['ID']['input'];
};


export type RootQueryTypePolicyConstraintsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  clusters?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  kind?: InputMaybe<Scalars['String']['input']>;
  kinds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  namespaces?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  q?: InputMaybe<Scalars['String']['input']>;
  violated?: InputMaybe<Scalars['Boolean']['input']>;
};


export type RootQueryTypePolicyStatisticsArgs = {
  aggregate: PolicyAggregate;
  clusters?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  kind?: InputMaybe<Scalars['String']['input']>;
  kinds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  namespaces?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  q?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypePrAutomationArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypePrAutomationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  catalogId?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Scalars['ID']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<PrRole>;
};


export type RootQueryTypePrGovernanceArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypePreviewEnvironmentTemplateArgs = {
  flowId?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeProjectArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeProjectUsageHistoryArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type RootQueryTypeProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypePullRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  open?: InputMaybe<Scalars['Boolean']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
  serviceId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootQueryTypeRefreshArgs = {
  token: Scalars['String']['input'];
};


export type RootQueryTypeRefreshTokensArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type RootQueryTypeRequestManifestsArgs = {
  id: Scalars['ID']['input'];
};


export type RootQueryTypeRolesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeRuntimeServiceArgs = {
  id: Scalars['ID']['input'];
};


export type RootQueryTypeScalingRecommendationArgs = {
  kind: AutoscalingTarget;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
};


export type RootQueryTypeScmConnectionArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeScmConnectionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type RootQueryTypeScmWebhookArgs = {
  externalId?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type RootQueryTypeScmWebhooksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type RootQueryTypeSecretArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  serviceId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootQueryTypeSentinelArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeSentinelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeServiceArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  serviceId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootQueryTypeServiceAccountsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeServiceContextArgs = {
  name: Scalars['String']['input'];
};


export type RootQueryTypeServiceDeploymentArgs = {
  cluster?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeServiceDeploymentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  cluster?: InputMaybe<Scalars['String']['input']>;
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  errored?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Scalars['ID']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<ServiceDeploymentStatus>;
};


export type RootQueryTypeServiceStatusesArgs = {
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  projectId?: InputMaybe<Scalars['ID']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<ServiceDeploymentStatus>;
};


export type RootQueryTypeServiceTreeArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  errored?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Scalars['ID']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<ServiceDeploymentStatus>;
};


export type RootQueryTypeSharedAgentRunArgs = {
  id: Scalars['ID']['input'];
};


export type RootQueryTypeStackDefinitionArgs = {
  id: Scalars['ID']['input'];
};


export type RootQueryTypeStackDefinitionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type RootQueryTypeStackRunArgs = {
  id: Scalars['ID']['input'];
};


export type RootQueryTypeStatefulSetArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  serviceId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootQueryTypeTagPairsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
  tag?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<TagType>;
};


export type RootQueryTypeTagsArgs = {
  tag?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeTokenExchangeArgs = {
  token: Scalars['String']['input'];
};


export type RootQueryTypeUnstructuredResourceArgs = {
  group?: InputMaybe<Scalars['String']['input']>;
  kind: Scalars['String']['input'];
  name: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
  serviceId?: InputMaybe<Scalars['ID']['input']>;
  version: Scalars['String']['input'];
};


export type RootQueryTypeUpgradePlanArgs = {
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  serviceId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootQueryTypeUpgradeStatisticsArgs = {
  projectId?: InputMaybe<Scalars['ID']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
  tag?: InputMaybe<TagInput>;
};


export type RootQueryTypeUserArgs = {
  email: Scalars['String']['input'];
};


export type RootQueryTypeUsersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeViolationStatisticsArgs = {
  field: ConstraintViolationField;
};


export type RootQueryTypeVulnerabilityReportArgs = {
  id: Scalars['ID']['input'];
};


export type RootQueryTypeVulnerabilityReportsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  clusters?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  grade?: InputMaybe<VulnReportGrade>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespaces?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  q?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeVulnerabilityStatisticsArgs = {
  clusters?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  namespaces?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  q?: InputMaybe<Scalars['String']['input']>;
};

export type RootSubscriptionType = {
  __typename?: 'RootSubscriptionType';
  /** streams chunks of ai text for a given parent scope */
  aiStream?: Maybe<AiDelta>;
  notificationDelta?: Maybe<NotificationDelta>;
  podDelta?: Maybe<PodDelta>;
  runLogsDelta?: Maybe<RunLogsDelta>;
};


export type RootSubscriptionTypeAiStreamArgs = {
  insightId?: InputMaybe<Scalars['ID']['input']>;
  recommendationId?: InputMaybe<Scalars['ID']['input']>;
  scopeId?: InputMaybe<Scalars['String']['input']>;
  threadId?: InputMaybe<Scalars['ID']['input']>;
};


export type RootSubscriptionTypeRunLogsDeltaArgs = {
  stepId: Scalars['ID']['input'];
};

export type RouterFilterAttributes = {
  /** whether to enable delivery for events associated with this cluster */
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  /** whether to enable delivery for events associated with this pipeline */
  pipelineId?: InputMaybe<Scalars['ID']['input']>;
  /** a regex for filtering by things like pr url */
  regex?: InputMaybe<Scalars['String']['input']>;
  /** whether to enable delivery for events associated with this service */
  serviceId?: InputMaybe<Scalars['ID']['input']>;
};

export type RouterSinkAttributes = {
  sinkId: Scalars['ID']['input'];
};

export type RunLogAttributes = {
  logs: Scalars['String']['input'];
};

export type RunLogs = {
  __typename?: 'RunLogs';
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  logs: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type RunLogsDelta = {
  __typename?: 'RunLogsDelta';
  delta?: Maybe<Delta>;
  payload?: Maybe<RunLogs>;
};

export type RunStep = {
  __typename?: 'RunStep';
  args?: Maybe<Array<Scalars['String']['output']>>;
  cmd: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  index: Scalars['Int']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  logs?: Maybe<Array<Maybe<RunLogs>>>;
  name: Scalars['String']['output'];
  requireApproval?: Maybe<Scalars['Boolean']['output']>;
  stage: StepStage;
  status: StepStatus;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type RunStepAttributes = {
  status: StepStatus;
};

export type RunningState = {
  __typename?: 'RunningState';
  startedAt?: Maybe<Scalars['String']['output']>;
};

/** a full specification of a kubernetes runtime component's requirements */
export type RuntimeAddon = {
  __typename?: 'RuntimeAddon';
  /** the url to the add-ons git repository */
  gitUrl?: Maybe<Scalars['String']['output']>;
  /** an icon to identify this runtime add-on */
  icon?: Maybe<Scalars['String']['output']>;
  /** the add-on's readme, this is a heavy operation that should not be performed w/in lists */
  readme?: Maybe<Scalars['String']['output']>;
  /** the release page for a runtime service at a version, this is a heavy operation not suitable for lists */
  releaseUrl?: Maybe<Scalars['String']['output']>;
  versions?: Maybe<Array<Maybe<AddonVersion>>>;
};


/** a full specification of a kubernetes runtime component's requirements */
export type RuntimeAddonReleaseUrlArgs = {
  version: Scalars['String']['input'];
};

/** a service encapsulating a controller like istio/ingress-nginx/etc that is meant to extend the kubernetes api */
export type RuntimeService = {
  __typename?: 'RuntimeService';
  /** the full specification of this kubernetes add-on */
  addon?: Maybe<RuntimeAddon>;
  /** the version of the add-on you've currently deployed */
  addonVersion?: Maybe<AddonVersion>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the number of instances of this service we've detected */
  instanceCount?: Maybe<Scalars['Int']['output']>;
  /** add-on name */
  name: Scalars['String']['output'];
  /** the plural service it came from */
  service?: Maybe<ServiceDeployment>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** add-on version, should be semver formatted */
  version: Scalars['String']['output'];
};

export type RuntimeServiceAttributes = {
  /** the number of instances of this service we've found */
  instanceCount?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  version: Scalars['String']['input'];
};

export type S3Store = {
  __typename?: 'S3Store';
  accessKeyId: Scalars['String']['output'];
  bucket: Scalars['String']['output'];
  endpoint?: Maybe<Scalars['String']['output']>;
  region?: Maybe<Scalars['String']['output']>;
};

export type S3StoreAttributes = {
  accessKeyId: Scalars['String']['input'];
  bucket: Scalars['String']['input'];
  endpoint?: InputMaybe<Scalars['String']['input']>;
  region?: InputMaybe<Scalars['String']['input']>;
  secretAccessKey: Scalars['String']['input'];
};

export enum ScalingRecommendationType {
  Daemonset = 'DAEMONSET',
  Deployment = 'DEPLOYMENT',
  Rollout = 'ROLLOUT',
  Statefulset = 'STATEFULSET'
}

/** an object representing the means to connect to SCM apis */
export type ScmConnection = {
  __typename?: 'ScmConnection';
  /** base url for HTTP apis for self-hosted versions if different from base url */
  apiUrl?: Maybe<Scalars['String']['output']>;
  /** the azure devops attributes for this connection */
  azure?: Maybe<AzureDevopsConfiguration>;
  /** base url for git clones for self-hosted versions */
  baseUrl?: Maybe<Scalars['String']['output']>;
  default?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  name: Scalars['String']['output'];
  /** a proxy to use for git requests */
  proxy?: Maybe<HttpProxyConfiguration>;
  type: ScmType;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  username?: Maybe<Scalars['String']['output']>;
};

/** an object representing a means to authenticate to a source control provider like Github */
export type ScmConnectionAttributes = {
  apiUrl?: InputMaybe<Scalars['String']['input']>;
  azure?: InputMaybe<AzureDevopsAttributes>;
  baseUrl?: InputMaybe<Scalars['String']['input']>;
  default?: InputMaybe<Scalars['Boolean']['input']>;
  github?: InputMaybe<GithubAppAttributes>;
  name: Scalars['String']['input'];
  /** the owning entity in this scm provider, eg a github organization */
  owner?: InputMaybe<Scalars['String']['input']>;
  proxy?: InputMaybe<HttpProxyAttributes>;
  /** a ssh private key to be used for commit signing */
  signingPrivateKey?: InputMaybe<Scalars['String']['input']>;
  token?: InputMaybe<Scalars['String']['input']>;
  type: ScmType;
  username?: InputMaybe<Scalars['String']['input']>;
};

export type ScmConnectionConnection = {
  __typename?: 'ScmConnectionConnection';
  edges?: Maybe<Array<Maybe<ScmConnectionEdge>>>;
  pageInfo: PageInfo;
};

export type ScmConnectionEdge = {
  __typename?: 'ScmConnectionEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<ScmConnection>;
};

export type ScmCreds = {
  __typename?: 'ScmCreds';
  token: Scalars['String']['output'];
  username: Scalars['String']['output'];
};

export enum ScmType {
  AzureDevops = 'AZURE_DEVOPS',
  Bitbucket = 'BITBUCKET',
  Github = 'GITHUB',
  Gitlab = 'GITLAB'
}

export type ScmWebhook = {
  __typename?: 'ScmWebhook';
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the name in your SCM provider for this webhook */
  name: Scalars['String']['output'];
  owner: Scalars['String']['output'];
  type: ScmType;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the url for this specific webhook */
  url: Scalars['String']['output'];
};

/** The attributes to configure a new webhook for a SCM provider */
export type ScmWebhookAttributes = {
  /** the secret token for authenticating this webhook via hmac signature */
  hmac: Scalars['String']['input'];
  /** the owner for this webhook in your SCM, eg a github org or gitlab group */
  owner: Scalars['String']['input'];
  /** the type of webhook to create */
  type: ScmType;
};

export type ScmWebhookConnection = {
  __typename?: 'ScmWebhookConnection';
  edges?: Maybe<Array<Maybe<ScmWebhookEdge>>>;
  pageInfo: PageInfo;
};

export type ScmWebhookEdge = {
  __typename?: 'ScmWebhookEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<ScmWebhook>;
};

export type ScopeAttributes = {
  api?: InputMaybe<Scalars['String']['input']>;
  apis?: InputMaybe<Array<Scalars['String']['input']>>;
  identifier?: InputMaybe<Scalars['String']['input']>;
  ids?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type Secret = {
  __typename?: 'Secret';
  data: Scalars['Map']['output'];
  metadata: Metadata;
  type?: Maybe<Scalars['String']['output']>;
};

export type Sentinel = {
  __typename?: 'Sentinel';
  /** the checks to run for this sentinel */
  checks?: Maybe<Array<Maybe<SentinelCheck>>>;
  /** the description of the sentinel */
  description?: Maybe<Scalars['String']['output']>;
  /** the git location for rules files from the associated repository */
  git?: Maybe<GitRef>;
  /** the id of the sentinel */
  id: Scalars['String']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the name of the sentinel */
  name: Scalars['String']['output'];
  /** the project of this sentinel */
  project?: Maybe<Project>;
  /** the git repository to use for fetching rules files for AI enabled analysis */
  repository?: Maybe<GitRepository>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type SentinelAttributes = {
  /** the checks to run for this sentinel */
  checks?: InputMaybe<Array<InputMaybe<SentinelCheckAttributes>>>;
  /** the description of the sentinel */
  description?: InputMaybe<Scalars['String']['input']>;
  /** the git repository to use for this sentinel */
  git?: InputMaybe<GitAttributes>;
  /** the name of the sentinel */
  name?: InputMaybe<Scalars['String']['input']>;
  /** the project to use for this sentinel */
  projectId?: InputMaybe<Scalars['ID']['input']>;
  /** the repository to use for this sentinel */
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};

export type SentinelCheck = {
  __typename?: 'SentinelCheck';
  /** the configuration to use for this check */
  configuration?: Maybe<SentinelCheckConfiguration>;
  /** the id of the check */
  id: Scalars['String']['output'];
  /** the name of the check */
  name: Scalars['String']['output'];
  /** the rule file to use for this check */
  ruleFile?: Maybe<Scalars['String']['output']>;
  /** the type of check to run */
  type: SentinelCheckType;
};

export type SentinelCheckAttributes = {
  /** the configuration to use for this check */
  configuration?: InputMaybe<SentinelCheckConfigurationAttributes>;
  /** the name of the check */
  name: Scalars['String']['input'];
  /** the rule file to use for this check */
  ruleFile?: InputMaybe<Scalars['String']['input']>;
  /** the type of check to run */
  type: SentinelCheckType;
};

export type SentinelCheckConfiguration = {
  __typename?: 'SentinelCheckConfiguration';
  /** the kubernetes configuration to use for this check */
  kubernetes?: Maybe<SentinelCheckKubernetesConfiguration>;
  /** the log configuration to use for this check */
  log?: Maybe<SentinelCheckLogConfiguration>;
};

export type SentinelCheckConfigurationAttributes = {
  /** the kubernetes configuration to use for this check */
  kubernetes?: InputMaybe<SentinelCheckKubernetesConfigurationAttributes>;
  /** the log configuration to use for this check */
  log?: InputMaybe<SentinelCheckLogConfigurationAttributes>;
};

export type SentinelCheckKubernetesConfiguration = {
  __typename?: 'SentinelCheckKubernetesConfiguration';
  /** the api group to use when fetching this resource */
  group?: Maybe<Scalars['String']['output']>;
  /** the kind to use when fetching this resource */
  kind: Scalars['String']['output'];
  /** the name to use when fetching this resource */
  name: Scalars['String']['output'];
  /** the namespace to use when fetching this resource */
  namespace?: Maybe<Scalars['String']['output']>;
  /** the api version to use when fetching this resource */
  version: Scalars['String']['output'];
};

export type SentinelCheckKubernetesConfigurationAttributes = {
  /** the cluster to run the query against */
  clusterId: Scalars['ID']['input'];
  /** the api group to use when fetching this resource */
  group?: InputMaybe<Scalars['String']['input']>;
  /** the kind to use when fetching this resource */
  kind: Scalars['String']['input'];
  /** the name to use when fetching this resource */
  name: Scalars['String']['input'];
  /** the namespace to use when fetching this resource */
  namespace?: InputMaybe<Scalars['String']['input']>;
  /** the api version to use when fetching this resource */
  version: Scalars['String']['input'];
};

export type SentinelCheckLogConfiguration = {
  __typename?: 'SentinelCheckLogConfiguration';
  /** the cluster to run the query against */
  clusterId?: Maybe<Scalars['ID']['output']>;
  /** The duration of the log analysis run */
  duration: Scalars['String']['output'];
  /** the log facets to run the query against */
  facets?: Maybe<Array<Maybe<LogFacet>>>;
  /** the namespaces to run the query against */
  namespaces?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** a search query this will run against the logs */
  query: Scalars['String']['output'];
};

export type SentinelCheckLogConfigurationAttributes = {
  /** the cluster to run the query against */
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  /** The duration of the log analysis run */
  duration: Scalars['String']['input'];
  /** the log facets to run the query against */
  facets?: InputMaybe<Array<InputMaybe<LogFacetInput>>>;
  /** the namespaces to run the query against */
  namespaces?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** a search query this will run against the logs */
  query: Scalars['String']['input'];
};

export enum SentinelCheckType {
  Kubernetes = 'KUBERNETES',
  Log = 'LOG'
}

export type SentinelConnection = {
  __typename?: 'SentinelConnection';
  edges?: Maybe<Array<Maybe<SentinelEdge>>>;
  pageInfo: PageInfo;
};

export type SentinelEdge = {
  __typename?: 'SentinelEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<Sentinel>;
};

export type SentinelRun = {
  __typename?: 'SentinelRun';
  /** the id of the run */
  id: Scalars['String']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the results of the run */
  results?: Maybe<Array<Maybe<SentinelRunResult>>>;
  /** the sentinel that was run */
  sentinel?: Maybe<Sentinel>;
  /** the status of the run */
  status: SentinelRunStatus;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type SentinelRunResult = {
  __typename?: 'SentinelRunResult';
  /** the name of the check */
  name?: Maybe<Scalars['String']['output']>;
  /** the reason for the result */
  reason?: Maybe<Scalars['String']['output']>;
  /** the status of the result */
  status: SentinelRunStatus;
};

export enum SentinelRunStatus {
  Failed = 'FAILED',
  Pending = 'PENDING',
  Success = 'SUCCESS'
}

export type Service = {
  __typename?: 'Service';
  events?: Maybe<Array<Maybe<Event>>>;
  metadata: Metadata;
  pods?: Maybe<Array<Maybe<Pod>>>;
  raw: Scalars['String']['output'];
  spec: ServiceSpec;
  status: ServiceStatus;
};

export type ServiceAccountAttributes = {
  assumeBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
  email?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  roles?: InputMaybe<UserRoleAttributes>;
};

export type ServiceCloneAttributes = {
  configuration?: InputMaybe<Array<InputMaybe<ConfigAttributes>>>;
  name: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};

/** representation of a kubernetes component deployed by a service */
export type ServiceComponent = {
  __typename?: 'ServiceComponent';
  /** any api deprecations discovered from this component */
  apiDeprecations?: Maybe<Array<Maybe<ApiDeprecation>>>;
  /** any kubernetes objects created as a descendent of this component */
  children?: Maybe<Array<Maybe<ServiceComponentChild>>>;
  /** the live and desired states of this service component */
  content?: Maybe<ComponentContent>;
  /** api group of this resource */
  group?: Maybe<Scalars['String']['output']>;
  /** internal id */
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** an insight explaining the state of this component */
  insight?: Maybe<AiInsight>;
  /** api kind of this resource */
  kind: Scalars['String']['output'];
  /** kubernetes name of this resource */
  name: Scalars['String']['output'];
  /** kubernetes namespace of this resource */
  namespace?: Maybe<Scalars['String']['output']>;
  /** the service this component belongs to */
  service?: Maybe<ServiceDeployment>;
  /** kubernetes component health enum */
  state?: Maybe<ComponentState>;
  /** whether this component has been applied to the k8s api */
  synced: Scalars['Boolean']['output'];
  /** kubernetes uid of this resource */
  uid?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** api version of this resource */
  version?: Maybe<Scalars['String']['output']>;
};

/** a kubernetes object that was created as a descendent of this service component */
export type ServiceComponentChild = {
  __typename?: 'ServiceComponentChild';
  group?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** an insight explaining the state of this component */
  insight?: Maybe<AiInsight>;
  kind: Scalars['String']['output'];
  name: Scalars['String']['output'];
  namespace?: Maybe<Scalars['String']['output']>;
  parentUid?: Maybe<Scalars['String']['output']>;
  state?: Maybe<ComponentState>;
  uid: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  version: Scalars['String']['output'];
};

export type ServiceComponentMetrics = {
  __typename?: 'ServiceComponentMetrics';
  cpu?: Maybe<Array<Maybe<MetricResponse>>>;
  mem?: Maybe<Array<Maybe<MetricResponse>>>;
  podCpu?: Maybe<Array<Maybe<MetricResponse>>>;
  podMem?: Maybe<Array<Maybe<MetricResponse>>>;
};

/** a configuration item k/v pair */
export type ServiceConfiguration = {
  __typename?: 'ServiceConfiguration';
  name: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

/** A reusable bundle of configuration designed to make it easy to communicate between tools like tf/pulumi and k8s */
export type ServiceContext = {
  __typename?: 'ServiceContext';
  configuration?: Maybe<Scalars['Map']['output']>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  name: Scalars['String']['output'];
  /** the project this context belongs to */
  project?: Maybe<Project>;
  secrets?: Maybe<Array<Maybe<ServiceConfiguration>>>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

/** A reusable configuration context, useful for plumbing data from external tools like terraform/pulumi/etc */
export type ServiceContextAttributes = {
  configuration?: InputMaybe<Scalars['Json']['input']>;
  /** the project this context belongs to */
  projectId?: InputMaybe<Scalars['ID']['input']>;
  secrets?: InputMaybe<Array<InputMaybe<ConfigAttributes>>>;
};

/** A dependency of a service, the service will not actualize until all dependencies are ready */
export type ServiceDependency = {
  __typename?: 'ServiceDependency';
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  name: Scalars['String']['output'];
  status?: Maybe<ServiceDeploymentStatus>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

/** A named depedency of a service, will prevent applying any manifests until the dependency has become ready */
export type ServiceDependencyAttributes = {
  name: Scalars['String']['input'];
};

/** a reference to a service deployed from a git repo into a cluster */
export type ServiceDeployment = {
  __typename?: 'ServiceDeployment';
  /** the agent id this service is associated with */
  agentId?: Maybe<Scalars['String']['output']>;
  /** list all alerts discovered for this service */
  alerts?: Maybe<AlertConnection>;
  /** the cluster this service is deployed into */
  cluster?: Maybe<Cluster>;
  componentMetrics?: Maybe<ServiceComponentMetrics>;
  /** a n / m representation of the number of healthy components of this service */
  componentStatus?: Maybe<Scalars['String']['output']>;
  /** the kubernetes component of a service */
  components?: Maybe<Array<Maybe<ServiceComponent>>>;
  /** possibly secret configuration used to template the manifests of this service */
  configuration?: Maybe<Array<Maybe<ServiceConfiguration>>>;
  /** bound contexts for this service */
  contexts?: Maybe<Array<Maybe<ServiceContext>>>;
  /** the time this service was scheduled for deletion */
  deletedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the dependencies of this service, actualization will not happen until all are HEALTHY */
  dependencies?: Maybe<Array<Maybe<ServiceDependency>>>;
  /** fetches the /docs directory within this services git tree.  This is a heavy operation and should NOT be used in list queries */
  docs?: Maybe<Array<Maybe<GitFile>>>;
  /** whether this service should not actively reconcile state and instead simply report pending changes */
  dryRun?: Maybe<Scalars['Boolean']['output']>;
  /** whether this service is editable */
  editable?: Maybe<Scalars['Boolean']['output']>;
  /** a list of errors generated by the deployment operator */
  errors?: Maybe<Array<Maybe<ServiceError>>>;
  /** the flow this service belongs to */
  flow?: Maybe<Flow>;
  /** description on where in git the service's manifests should be fetched */
  git?: Maybe<GitRef>;
  /** the global service this service is the source for */
  globalService?: Maybe<GlobalService>;
  /** A pod-level set of utilization metrics for this cluster for rendering a heat map */
  heatMap?: Maybe<UtilizationHeatMap>;
  /** description of how helm charts should be applied */
  helm?: Maybe<HelmSpec>;
  helmRepository?: Maybe<FluxHelmRepository>;
  /** internal id of this service */
  id: Scalars['ID']['output'];
  /** imports from stack outputs */
  imports?: Maybe<Array<Maybe<ServiceImport>>>;
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** an insight explaining the state of this service */
  insight?: Maybe<AiInsight>;
  /** the desired sync interval for this service */
  interval?: Maybe<Scalars['String']['output']>;
  /** kustomize related service metadata */
  kustomize?: Maybe<Kustomize>;
  /** Queries logs for a service out of loki */
  logs?: Maybe<Array<Maybe<LogStream>>>;
  /** the commit message currently in use */
  message?: Maybe<Scalars['String']['output']>;
  /** metadata about the deployed contents of this service */
  metadata?: Maybe<ServiceMetadata>;
  /** human readable name of this service, must be unique per cluster */
  name: Scalars['String']['output'];
  /** kubernetes namespace this service will be deployed to */
  namespace: Scalars['String']['output'];
  networkGraph?: Maybe<Array<Maybe<NetworkMeshEdge>>>;
  /** whether this service is controlled by a global service */
  owner?: Maybe<GlobalService>;
  /** the service that owns this service in a service-of-services setup */
  parent?: Maybe<ServiceDeployment>;
  /** how you'd like to perform a canary promotion */
  promotion?: Maybe<ServicePromotion>;
  /** if true, deletion of this service is not allowed */
  protect?: Maybe<Scalars['Boolean']['output']>;
  /** authorizes the given component or nested child id and returns the raw kubernetes resource it points to */
  rawResource?: Maybe<KubernetesUnstructured>;
  /** read policy for this service */
  readBindings?: Maybe<Array<Maybe<PolicyBinding>>>;
  /** the renderers of this service */
  renderers?: Maybe<Array<Maybe<Renderer>>>;
  /** the git repo of this service */
  repository?: Maybe<GitRepository>;
  /** the current revision of this service */
  revision?: Maybe<Revision>;
  /** a relay connection of all revisions of this service, these are periodically pruned up to a history limit */
  revisions?: Maybe<RevisionConnection>;
  scalingRecommendations?: Maybe<Array<Maybe<ClusterScalingRecommendation>>>;
  /** latest git sha we pulled from */
  sha?: Maybe<Scalars['String']['output']>;
  /** the sources of this service */
  sources?: Maybe<Array<Maybe<ServiceSource>>>;
  /** A summary status enum for the health of this service */
  status: ServiceDeploymentStatus;
  /** settings for advanced tuning of the sync process */
  syncConfig?: Maybe<SyncConfig>;
  /** https url to fetch the latest tarball of kubernetes manifests */
  tarball?: Maybe<Scalars['String']['output']>;
  /** if you should apply liquid templating to raw yaml files, defaults to true */
  templated?: Maybe<Scalars['Boolean']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** semver of this service */
  version: Scalars['String']['output'];
  /** sideload detected vulnerabilities for this service */
  vulns?: Maybe<ServiceVuln>;
  /** write policy of this service */
  writeBindings?: Maybe<Array<Maybe<PolicyBinding>>>;
};


/** a reference to a service deployed from a git repo into a cluster */
export type ServiceDeploymentAlertsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** a reference to a service deployed from a git repo into a cluster */
export type ServiceDeploymentComponentMetricsArgs = {
  componentId: Scalars['ID']['input'];
  start?: InputMaybe<Scalars['DateTime']['input']>;
  step?: InputMaybe<Scalars['String']['input']>;
  stop?: InputMaybe<Scalars['DateTime']['input']>;
};


/** a reference to a service deployed from a git repo into a cluster */
export type ServiceDeploymentHeatMapArgs = {
  flavor?: InputMaybe<HeatMapFlavor>;
};


/** a reference to a service deployed from a git repo into a cluster */
export type ServiceDeploymentLogsArgs = {
  end?: InputMaybe<Scalars['Long']['input']>;
  limit: Scalars['Int']['input'];
  query: LokiQuery;
  start?: InputMaybe<Scalars['Long']['input']>;
};


/** a reference to a service deployed from a git repo into a cluster */
export type ServiceDeploymentNetworkGraphArgs = {
  time?: InputMaybe<Scalars['DateTime']['input']>;
};


/** a reference to a service deployed from a git repo into a cluster */
export type ServiceDeploymentRawResourceArgs = {
  childId?: InputMaybe<Scalars['ID']['input']>;
  componentId?: InputMaybe<Scalars['ID']['input']>;
};


/** a reference to a service deployed from a git repo into a cluster */
export type ServiceDeploymentRevisionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type ServiceDeploymentAttributes = {
  agentId?: InputMaybe<Scalars['String']['input']>;
  configuration?: InputMaybe<Array<InputMaybe<ConfigAttributes>>>;
  contextBindings?: InputMaybe<Array<InputMaybe<ContextBindingAttributes>>>;
  dependencies?: InputMaybe<Array<InputMaybe<ServiceDependencyAttributes>>>;
  docsPath?: InputMaybe<Scalars['String']['input']>;
  dryRun?: InputMaybe<Scalars['Boolean']['input']>;
  flowId?: InputMaybe<Scalars['ID']['input']>;
  git?: InputMaybe<GitRefAttributes>;
  helm?: InputMaybe<HelmConfigAttributes>;
  imports?: InputMaybe<Array<InputMaybe<ServiceImportAttributes>>>;
  interval?: InputMaybe<Scalars['String']['input']>;
  kustomize?: InputMaybe<KustomizeAttributes>;
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  parentId?: InputMaybe<Scalars['ID']['input']>;
  protect?: InputMaybe<Scalars['Boolean']['input']>;
  readBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
  renderers?: InputMaybe<Array<InputMaybe<RendererAttributes>>>;
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
  sources?: InputMaybe<Array<InputMaybe<ServiceSourceAttributes>>>;
  syncConfig?: InputMaybe<SyncConfigAttributes>;
  /** if you should apply liquid templating to raw yaml files, defaults to true */
  templated?: InputMaybe<Scalars['Boolean']['input']>;
  version?: InputMaybe<Scalars['String']['input']>;
  writeBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
};

export type ServiceDeploymentConnection = {
  __typename?: 'ServiceDeploymentConnection';
  edges?: Maybe<Array<Maybe<ServiceDeploymentEdge>>>;
  pageInfo: PageInfo;
};

export type ServiceDeploymentEdge = {
  __typename?: 'ServiceDeploymentEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<ServiceDeployment>;
};

export enum ServiceDeploymentStatus {
  Failed = 'FAILED',
  Healthy = 'HEALTHY',
  Paused = 'PAUSED',
  Stale = 'STALE',
  Synced = 'SYNCED'
}

/** an error sent from the deploy operator about sync progress */
export type ServiceError = {
  __typename?: 'ServiceError';
  message: Scalars['String']['output'];
  source: Scalars['String']['output'];
  /** whether this is just a warning */
  warning?: Maybe<Scalars['Boolean']['output']>;
};

export type ServiceErrorAttributes = {
  message: Scalars['String']['input'];
  source: Scalars['String']['input'];
  warning?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Import of stack data into a service's context */
export type ServiceImport = {
  __typename?: 'ServiceImport';
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The outputs of that stack */
  outputs?: Maybe<Array<Maybe<StackOutput>>>;
  /** The stack you're importing from */
  stack?: Maybe<InfrastructureStack>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type ServiceImportAttributes = {
  stackId: Scalars['ID']['input'];
};

export enum ServiceMesh {
  Cilium = 'CILIUM',
  Ebpf = 'EBPF',
  Istio = 'ISTIO',
  Linkerd = 'LINKERD'
}

/** metadata about the deployed contents of a service */
export type ServiceMetadata = {
  __typename?: 'ServiceMetadata';
  /** a list of fqdns to discover */
  fqdns?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** a list of images to deployed in this service */
  images?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** metadata about the deployed contents of a service */
export type ServiceMetadataAttributes = {
  /** a list of fqdns to discover */
  fqdns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** a list of images to deployed in this service */
  images?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export type ServicePort = {
  __typename?: 'ServicePort';
  name?: Maybe<Scalars['String']['output']>;
  port?: Maybe<Scalars['Int']['output']>;
  protocol?: Maybe<Scalars['String']['output']>;
  targetPort?: Maybe<Scalars['String']['output']>;
};

export enum ServicePromotion {
  Ignore = 'IGNORE',
  Proceed = 'PROCEED',
  Rollback = 'ROLLBACK'
}

export type ServiceSource = {
  __typename?: 'ServiceSource';
  /** the git reference to use */
  git?: Maybe<GitRef>;
  /** the subdirectory in the git repository to use */
  path?: Maybe<Scalars['String']['output']>;
  /** the id of the git repository to source from */
  repositoryId?: Maybe<Scalars['ID']['output']>;
};

export type ServiceSourceAttributes = {
  /** the location in git to use */
  git?: InputMaybe<GitRefAttributes>;
  /** the subdirectory this source will live in the final tarball */
  path?: InputMaybe<Scalars['String']['input']>;
  /** the id of the git repository to source from */
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
};

export type ServiceSpec = {
  __typename?: 'ServiceSpec';
  clusterIp?: Maybe<Scalars['String']['output']>;
  ports?: Maybe<Array<Maybe<ServicePort>>>;
  selector?: Maybe<Scalars['Map']['output']>;
  type?: Maybe<Scalars['String']['output']>;
};

export type ServiceStatus = {
  __typename?: 'ServiceStatus';
  conditions?: Maybe<Array<Maybe<StatusCondition>>>;
  loadBalancer?: Maybe<LoadBalancerStatus>;
};

/** a rollup count of the statuses of services in a query */
export type ServiceStatusCount = {
  __typename?: 'ServiceStatusCount';
  count: Scalars['Int']['output'];
  status: ServiceDeploymentStatus;
};

/** Attributes for configuring a service in something like a managed namespace */
export type ServiceTemplate = {
  __typename?: 'ServiceTemplate';
  /** possibly secret configuration for all spawned services, don't query this in list endpoints */
  configuration?: Maybe<Array<Maybe<ServiceConfiguration>>>;
  /** a list of context names to add to this service */
  contexts?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  dependencies?: Maybe<Array<Maybe<ServiceDependency>>>;
  /** settings to configure git for a service */
  git?: Maybe<GitRef>;
  /** settings to configure helm for a service */
  helm?: Maybe<HelmSpec>;
  /** settings for service kustomization */
  kustomize?: Maybe<Kustomize>;
  /** the name for this service (optional for managed namespaces) */
  name?: Maybe<Scalars['String']['output']>;
  /** the namespace for this service (optional for managed namespaces) */
  namespace?: Maybe<Scalars['String']['output']>;
  /** a list of renderers to render manifests for the created service */
  renderers?: Maybe<Array<Maybe<Renderer>>>;
  repository?: Maybe<GitRepository>;
  /** the id of a repository to source manifests for this service */
  repositoryId?: Maybe<Scalars['ID']['output']>;
  /** a list of sources to source manifests for the created service */
  sources?: Maybe<Array<Maybe<ServiceSource>>>;
  /** specification of how the templated service will be synced */
  syncConfig?: Maybe<SyncConfig>;
  templated?: Maybe<Scalars['Boolean']['output']>;
};

/** Attributes for configuring a service in something like a managed namespace */
export type ServiceTemplateAttributes = {
  /** a list of secure configuration that will be added to any services created by this template */
  configuration?: InputMaybe<Array<InputMaybe<ConfigAttributes>>>;
  /** a list of context names to add to this service */
  contexts?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** dependencies for the service to be spawned */
  dependencies?: InputMaybe<Array<InputMaybe<ServiceDependencyAttributes>>>;
  /** settings to configure git for a service */
  git?: InputMaybe<GitRefAttributes>;
  /** settings to configure helm for a service */
  helm?: InputMaybe<HelmConfigAttributes>;
  /** settings for service kustomization */
  kustomize?: InputMaybe<KustomizeAttributes>;
  /** the name for this service (optional for managed namespaces) */
  name?: InputMaybe<Scalars['String']['input']>;
  /** the namespace for this service (optional for managed namespaces) */
  namespace?: InputMaybe<Scalars['String']['input']>;
  /** whether to protect this templated service from deletion */
  protect?: InputMaybe<Scalars['Boolean']['input']>;
  /** a list of renderers to render manifests for this service */
  renderers?: InputMaybe<Array<InputMaybe<RendererAttributes>>>;
  /** the id of a repository to source manifests for this service */
  repositoryId?: InputMaybe<Scalars['ID']['input']>;
  /** a list of sources to source manifests for this service */
  sources?: InputMaybe<Array<InputMaybe<ServiceSourceAttributes>>>;
  /** attributes to configure sync settings for this service */
  syncConfig?: InputMaybe<SyncConfigAttributes>;
  templated?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ServiceUpdateAttributes = {
  agentId?: InputMaybe<Scalars['String']['input']>;
  configuration?: InputMaybe<Array<InputMaybe<ConfigAttributes>>>;
  contextBindings?: InputMaybe<Array<InputMaybe<ContextBindingAttributes>>>;
  dependencies?: InputMaybe<Array<InputMaybe<ServiceDependencyAttributes>>>;
  dryRun?: InputMaybe<Scalars['Boolean']['input']>;
  flowId?: InputMaybe<Scalars['ID']['input']>;
  git?: InputMaybe<GitRefAttributes>;
  helm?: InputMaybe<HelmConfigAttributes>;
  imports?: InputMaybe<Array<InputMaybe<ServiceImportAttributes>>>;
  interval?: InputMaybe<Scalars['String']['input']>;
  kustomize?: InputMaybe<KustomizeAttributes>;
  parentId?: InputMaybe<Scalars['ID']['input']>;
  protect?: InputMaybe<Scalars['Boolean']['input']>;
  readBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
  renderers?: InputMaybe<Array<InputMaybe<RendererAttributes>>>;
  sources?: InputMaybe<Array<InputMaybe<ServiceSourceAttributes>>>;
  syncConfig?: InputMaybe<SyncConfigAttributes>;
  /** if you should apply liquid templating to raw yaml files, defaults to true */
  templated?: InputMaybe<Scalars['Boolean']['input']>;
  version?: InputMaybe<Scalars['String']['input']>;
  writeBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
};

export type ServiceVuln = {
  __typename?: 'ServiceVuln';
  service?: Maybe<ServiceDeployment>;
};

export type ServiceVulnAttributes = {
  serviceId: Scalars['ID']['input'];
};

export enum Severity {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  None = 'NONE'
}

export type SharedSecret = {
  __typename?: 'SharedSecret';
  handle: Scalars['String']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  name: Scalars['String']['output'];
  secret: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type SharedSecretAttributes = {
  name: Scalars['String']['input'];
  /** the users/groups you want this secret to be delivered to */
  notificationBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
  secret: Scalars['String']['input'];
};

export type SinkConfiguration = {
  __typename?: 'SinkConfiguration';
  id: Scalars['ID']['output'];
  plural?: Maybe<PluralSinkConfiguration>;
  slack?: Maybe<UrlSinkConfiguration>;
  teams?: Maybe<UrlSinkConfiguration>;
};

export type SinkConfigurationAttributes = {
  plural?: InputMaybe<PluralSinkAttributes>;
  slack?: InputMaybe<UrlSinkAttributes>;
  teams?: InputMaybe<UrlSinkAttributes>;
};

export enum SinkType {
  Plural = 'PLURAL',
  Slack = 'SLACK',
  Teams = 'TEAMS'
}

/** SMTP server configuration for email notifications */
export type SmtpSettings = {
  __typename?: 'SmtpSettings';
  port: Scalars['Int']['output'];
  sender: Scalars['String']['output'];
  server: Scalars['String']['output'];
  ssl: Scalars['Boolean']['output'];
  user: Scalars['String']['output'];
};

export type SmtpSettingsAttributes = {
  password: Scalars['String']['input'];
  port: Scalars['Int']['input'];
  sender: Scalars['String']['input'];
  server: Scalars['String']['input'];
  ssl: Scalars['Boolean']['input'];
  user: Scalars['String']['input'];
};

export type StackAttributes = {
  /** user id to use for default Plural authentication in this stack */
  actorId?: InputMaybe<Scalars['ID']['input']>;
  /** the agent id this stack is associated with */
  agentId?: InputMaybe<Scalars['String']['input']>;
  /** whether to require approval */
  approval?: InputMaybe<Scalars['Boolean']['input']>;
  /** The cluster on which the terraform will be applied */
  clusterId: Scalars['ID']['input'];
  /** version/image config for the tool you're using */
  configuration?: InputMaybe<StackConfigurationAttributes>;
  /** id of an scm connection to use for pr callbacks */
  connectionId?: InputMaybe<Scalars['ID']['input']>;
  /** a cron to spawn runs for this stack */
  cron?: InputMaybe<StackCronAttributes>;
  /** the id of a stack definition to use */
  definitionId?: InputMaybe<Scalars['ID']['input']>;
  environment?: InputMaybe<Array<InputMaybe<StackEnvironmentAttributes>>>;
  files?: InputMaybe<Array<InputMaybe<StackFileAttributes>>>;
  /** reference w/in the repository where the IaC lives */
  git: GitRefAttributes;
  /** the interval at which the stack will be reconciled, default is 5m */
  interval?: InputMaybe<Scalars['String']['input']>;
  /** optional k8s job configuration for the job that will apply this stack */
  jobSpec?: InputMaybe<GateJobAttributes>;
  /** whether you want Plural to manage your terraform state for this stack */
  manageState?: InputMaybe<Scalars['Boolean']['input']>;
  /** the name of the stack */
  name: Scalars['String']['input'];
  observableMetrics?: InputMaybe<Array<InputMaybe<ObservableMetricAttributes>>>;
  /** the parent service this stack was created w/in */
  parentId?: InputMaybe<Scalars['ID']['input']>;
  policyEngine?: InputMaybe<PolicyEngineAttributes>;
  /** the project id this stack will belong to */
  projectId?: InputMaybe<Scalars['ID']['input']>;
  readBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
  /** The repository to source IaC from */
  repositoryId: Scalars['ID']['input'];
  tags?: InputMaybe<Array<InputMaybe<TagAttributes>>>;
  /** A type for the stack, specifies the tool to use to apply it */
  type: StackType;
  /** arbitrary variables to pass into the stack */
  variables?: InputMaybe<Scalars['Json']['input']>;
  /** the subdirectory you want to run the stack's commands w/in */
  workdir?: InputMaybe<Scalars['String']['input']>;
  writeBindings?: InputMaybe<Array<InputMaybe<PolicyBindingAttributes>>>;
};

export type StackCommand = {
  __typename?: 'StackCommand';
  /** cli args to pass */
  args?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** the executable to call */
  cmd: Scalars['String']['output'];
  /** working directory for this command (not required) */
  dir?: Maybe<Scalars['String']['output']>;
};

export type StackConfiguration = {
  __typename?: 'StackConfiguration';
  /** the ansible configuration for this stack */
  ansible?: Maybe<AnsibleConfiguration>;
  /** the hooks to customize execution for this stack */
  hooks?: Maybe<Array<Maybe<StackHook>>>;
  /** optional custom image you might want to use */
  image?: Maybe<Scalars['String']['output']>;
  /** the docker image tag you wish to use if you're customizing the version */
  tag?: Maybe<Scalars['String']['output']>;
  /** the terraform configuration for this stack */
  terraform?: Maybe<TerraformConfiguration>;
  /** the semver of the tool you wish to use */
  version?: Maybe<Scalars['String']['output']>;
};

export type StackConfigurationAttributes = {
  /** the ai approval configuration for this stack */
  aiApproval?: InputMaybe<AiApprovalAttributes>;
  /** the ansible configuration for this stack */
  ansible?: InputMaybe<AnsibleConfigurationAttributes>;
  /** the hooks to customize execution for this stack */
  hooks?: InputMaybe<Array<InputMaybe<StackHookAttributes>>>;
  /** optional custom image you might want to use */
  image?: InputMaybe<Scalars['String']['input']>;
  /** the docker image tag you wish to use if you're customizing the version */
  tag?: InputMaybe<Scalars['String']['input']>;
  /** the terraform configuration for this stack */
  terraform?: InputMaybe<TerraformConfigurationAttributes>;
  /** the semver of the tool you wish to use */
  version?: InputMaybe<Scalars['String']['input']>;
};

export type StackCron = {
  __typename?: 'StackCron';
  /** whether you want any cron-derived runs to automatically approve changes */
  autoApprove?: Maybe<Scalars['Boolean']['output']>;
  /** the crontab used to independently spawn runs for this stack */
  crontab: Scalars['String']['output'];
  /** configuration overrides for the cron run */
  overrides?: Maybe<StackOverrides>;
};

export type StackCronAttributes = {
  /** whether you want to auto approve any changes spawned by the cron worker */
  autoApprove?: InputMaybe<Scalars['Boolean']['input']>;
  /** the crontab to use for spawning stack runs */
  crontab: Scalars['String']['input'];
  /** configuration overrides for the cron run */
  overrides?: InputMaybe<StackOverridesAttributes>;
};

export type StackDefinition = {
  __typename?: 'StackDefinition';
  configuration: StackConfiguration;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  name: Scalars['String']['output'];
  steps?: Maybe<Array<Maybe<CustomRunStep>>>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type StackDefinitionAttributes = {
  configuration?: InputMaybe<StackConfigurationAttributes>;
  description?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  steps?: InputMaybe<Array<InputMaybe<CustomStepAttributes>>>;
};

export type StackDefinitionConnection = {
  __typename?: 'StackDefinitionConnection';
  edges?: Maybe<Array<Maybe<StackDefinitionEdge>>>;
  pageInfo: PageInfo;
};

export type StackDefinitionEdge = {
  __typename?: 'StackDefinitionEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<StackDefinition>;
};

export type StackEnvironment = {
  __typename?: 'StackEnvironment';
  name: Scalars['String']['output'];
  secret?: Maybe<Scalars['Boolean']['output']>;
  value: Scalars['String']['output'];
};

export type StackEnvironmentAttributes = {
  name: Scalars['String']['input'];
  secret?: InputMaybe<Scalars['Boolean']['input']>;
  value: Scalars['String']['input'];
};

export type StackFile = {
  __typename?: 'StackFile';
  content: Scalars['String']['output'];
  path: Scalars['String']['output'];
};

export type StackFileAttributes = {
  content: Scalars['String']['input'];
  path: Scalars['String']['input'];
};

export type StackHook = {
  __typename?: 'StackHook';
  /** the stage to run this hook before */
  afterStage: StepStage;
  /** args for `cmd` */
  args?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** a script hook to run at a stage */
  cmd: Scalars['String']['output'];
};

export type StackHookAttributes = {
  /** the stage to run this hook before */
  afterStage: StepStage;
  /** args for `cmd` */
  args?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** a script hook to run at a stage */
  cmd: Scalars['String']['input'];
};

export type StackOutput = {
  __typename?: 'StackOutput';
  name: Scalars['String']['output'];
  secret?: Maybe<Scalars['Boolean']['output']>;
  value: Scalars['String']['output'];
};

export type StackOutputAttributes = {
  name: Scalars['String']['input'];
  secret?: InputMaybe<Scalars['Boolean']['input']>;
  value: Scalars['String']['input'];
};

/** Configuration overrides for a stack cron run */
export type StackOverrides = {
  __typename?: 'StackOverrides';
  /** the terraform configuration for this stack */
  terraform?: Maybe<TerraformConfiguration>;
};

export type StackOverridesAttributes = {
  /** the terraform configuration for this stack */
  terraform?: InputMaybe<TerraformConfigurationAttributes>;
};

export type StackPolicyViolation = {
  __typename?: 'StackPolicyViolation';
  /** the causes of this violation line-by-line in code */
  causes?: Maybe<Array<Maybe<StackViolationCause>>>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  policyId: Scalars['String']['output'];
  policyModule?: Maybe<Scalars['String']['output']>;
  policyUrl?: Maybe<Scalars['String']['output']>;
  resolution?: Maybe<Scalars['String']['output']>;
  severity: VulnSeverity;
  title: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type StackPolicyViolationAttributes = {
  causes?: InputMaybe<Array<InputMaybe<StackViolationCauseAttributes>>>;
  description?: InputMaybe<Scalars['String']['input']>;
  policyId: Scalars['String']['input'];
  policyModule?: InputMaybe<Scalars['String']['input']>;
  policyUrl?: InputMaybe<Scalars['String']['input']>;
  resolution?: InputMaybe<Scalars['String']['input']>;
  severity: VulnSeverity;
  title: Scalars['String']['input'];
};

export type StackRun = {
  __typename?: 'StackRun';
  /** the actor of this run (defaults to root console user) */
  actor?: Maybe<User>;
  /** whether to require approval */
  approval?: Maybe<Scalars['Boolean']['output']>;
  /** the result of the approval decision by the ai */
  approvalResult?: Maybe<StackRunApprovalResult>;
  /** when this run was approved */
  approvedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the approver of this job */
  approver?: Maybe<User>;
  /** explanation for why this run was cancelled */
  cancellationReason?: Maybe<Scalars['String']['output']>;
  /** the cluster this stack runs on */
  cluster?: Maybe<Cluster>;
  /** version/image config for the tool you're using */
  configuration: StackConfiguration;
  /** whether this run is a dry run */
  dryRun: Scalars['Boolean']['output'];
  /** environment variables for this stack */
  environment?: Maybe<Array<Maybe<StackEnvironment>>>;
  /** a list of errors generated by the deployment operator */
  errors?: Maybe<Array<Maybe<ServiceError>>>;
  /** files bound to a run of this stack */
  files?: Maybe<Array<Maybe<StackFile>>>;
  /** reference w/in the repository where the IaC lives */
  git: GitRef;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** an insight explaining the state of this stack run */
  insight?: Maybe<AiInsight>;
  /** the kubernetes job for this run (useful for debugging if issues arise) */
  job?: Maybe<Job>;
  /** optional k8s job configuration for the job that will apply this stack */
  jobSpec?: Maybe<JobGateSpec>;
  /** whether you want Plural to manage the state of this stack */
  manageState?: Maybe<Scalars['Boolean']['output']>;
  /** the commit message */
  message?: Maybe<Scalars['String']['output']>;
  /** the most recent output for this stack */
  output?: Maybe<Array<Maybe<StackOutput>>>;
  /** temporary plural creds usable for terraform authentication */
  pluralCreds?: Maybe<PluralCreds>;
  policyEngine?: Maybe<PolicyEngine>;
  /** the pull request this stack belongs to */
  pullRequest?: Maybe<PullRequest>;
  /** the git repository you're sourcing IaC from */
  repository?: Maybe<GitRepository>;
  /** the stack attached to this run */
  stack?: Maybe<InfrastructureStack>;
  /** the most recent state of this stack */
  state?: Maybe<StackState>;
  stateUrls?: Maybe<StateUrls>;
  /** The status of this run */
  status: StackStatus;
  /** The steps to perform when running this stack */
  steps?: Maybe<Array<Maybe<RunStep>>>;
  /** https url to fetch the latest tarball of stack IaC */
  tarball: Scalars['String']['output'];
  /** A type for the stack, specifies the tool to use to apply it */
  type: StackType;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Arbitrary variables to add to a stack run */
  variables?: Maybe<Scalars['Map']['output']>;
  /** policy violations for this stack */
  violations?: Maybe<Array<Maybe<StackPolicyViolation>>>;
  /** the subdirectory you want to run the stack's commands w/in */
  workdir?: Maybe<Scalars['String']['output']>;
};

export type StackRunApprovalResult = {
  __typename?: 'StackRunApprovalResult';
  /** the reason for the approval decision by the ai */
  reason?: Maybe<Scalars['String']['output']>;
  /** the result of the approval decision by the ai */
  result?: Maybe<ApprovalResult>;
};

export type StackRunAttributes = {
  /** Why you decided to cancel this run */
  cancellationReason?: InputMaybe<Scalars['String']['input']>;
  /** Any errors detected when trying to run this stack */
  errors?: InputMaybe<Array<InputMaybe<ServiceErrorAttributes>>>;
  /** the reference to the k8s job running this stack */
  jobRef?: InputMaybe<NamespacedName>;
  /** Output generated by this run */
  output?: InputMaybe<Array<InputMaybe<StackOutputAttributes>>>;
  /** The state from this runs plan or apply */
  state?: InputMaybe<StackStateAttributes>;
  /** The status of this run */
  status: StackStatus;
  /** the violations detected by the policy engine */
  violations?: InputMaybe<Array<InputMaybe<StackPolicyViolationAttributes>>>;
};

export type StackRunConnection = {
  __typename?: 'StackRunConnection';
  edges?: Maybe<Array<Maybe<StackRunEdge>>>;
  pageInfo: PageInfo;
};

export type StackRunEdge = {
  __typename?: 'StackRunEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<StackRun>;
};

export type StackSettings = {
  __typename?: 'StackSettings';
  connectionId?: Maybe<Scalars['ID']['output']>;
  jobSpec?: Maybe<JobGateSpec>;
};

export type StackSettingsAttributes = {
  connectionId?: InputMaybe<Scalars['ID']['input']>;
  jobSpec?: InputMaybe<GateJobAttributes>;
};

export type StackState = {
  __typename?: 'StackState';
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** an insight explaining the state of this stack state, eg the terraform plan it represents */
  insight?: Maybe<AiInsight>;
  plan?: Maybe<Scalars['String']['output']>;
  state?: Maybe<Array<Maybe<StackStateResource>>>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type StackStateAttributes = {
  plan?: InputMaybe<Scalars['String']['input']>;
  state?: InputMaybe<Array<InputMaybe<StackStateResourceAttributes>>>;
};

export type StackStateResource = {
  __typename?: 'StackStateResource';
  /** arbitrary configuration used to create the resource */
  configuration?: Maybe<Scalars['Map']['output']>;
  /** a string identifier for this resource, different tools will have different conventions */
  identifier: Scalars['String']['output'];
  /** identifiers this resource is linked to for graphing in the UI */
  links?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** the name of the resource within that type */
  name: Scalars['String']['output'];
  /** a string name of the resource type */
  resource: Scalars['String']['output'];
};

export type StackStateResourceAttributes = {
  /** arbitrary configuration used to create the resource */
  configuration?: InputMaybe<Scalars['Json']['input']>;
  /** a string identifier for this resource, different tools will have different conventions */
  identifier: Scalars['String']['input'];
  /** identifiers this resource is linked to for graphing in the UI */
  links?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** the name of the resource within that type */
  name: Scalars['String']['input'];
  /** a string name of the resource type */
  resource: Scalars['String']['input'];
};

export enum StackStatus {
  Cancelled = 'CANCELLED',
  Failed = 'FAILED',
  Pending = 'PENDING',
  PendingApproval = 'PENDING_APPROVAL',
  Queued = 'QUEUED',
  Running = 'RUNNING',
  Successful = 'SUCCESSFUL'
}

export enum StackType {
  Ansible = 'ANSIBLE',
  Custom = 'CUSTOM',
  Terraform = 'TERRAFORM'
}

export type StackViolationCause = {
  __typename?: 'StackViolationCause';
  end: Scalars['Int']['output'];
  filename?: Maybe<Scalars['String']['output']>;
  lines?: Maybe<Array<Maybe<StackViolationCauseLine>>>;
  resource: Scalars['String']['output'];
  start: Scalars['Int']['output'];
};

export type StackViolationCauseAttributes = {
  end: Scalars['Int']['input'];
  filename?: InputMaybe<Scalars['String']['input']>;
  lines?: InputMaybe<Array<InputMaybe<StackViolationCauseLineAttributes>>>;
  resource: Scalars['String']['input'];
  start: Scalars['Int']['input'];
};

export type StackViolationCauseLine = {
  __typename?: 'StackViolationCauseLine';
  content: Scalars['String']['output'];
  first?: Maybe<Scalars['Boolean']['output']>;
  last?: Maybe<Scalars['Boolean']['output']>;
  line: Scalars['Int']['output'];
};

export type StackViolationCauseLineAttributes = {
  content: Scalars['String']['input'];
  first?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Boolean']['input']>;
  line: Scalars['Int']['input'];
};

/** the configuration of a service within a pipeline stage, including optional promotion criteria */
export type StageService = {
  __typename?: 'StageService';
  /** criteria for how a promotion of this service shall be performed */
  criteria?: Maybe<PromotionCriteria>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  /** a pointer to a service */
  service?: Maybe<ServiceDeployment>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

/** the attributes of a service w/in a specific stage */
export type StageServiceAttributes = {
  criteria?: InputMaybe<PromotionCriteriaAttributes>;
  /** the cluster handle of this service */
  handle?: InputMaybe<Scalars['String']['input']>;
  /** the name of this service */
  name?: InputMaybe<Scalars['String']['input']>;
  /** the name of this service */
  serviceId?: InputMaybe<Scalars['ID']['input']>;
};

/** grab-bag of state configuration urls for supported tools */
export type StateUrls = {
  __typename?: 'StateUrls';
  terraform?: Maybe<TerraformStateUrls>;
};

export type StatefulSet = {
  __typename?: 'StatefulSet';
  events?: Maybe<Array<Maybe<Event>>>;
  metadata: Metadata;
  pods?: Maybe<Array<Maybe<Pod>>>;
  raw: Scalars['String']['output'];
  spec: StatefulSetSpec;
  status: StatefulSetStatus;
};

export type StatefulSetSpec = {
  __typename?: 'StatefulSetSpec';
  replicas?: Maybe<Scalars['Int']['output']>;
  serviceName?: Maybe<Scalars['String']['output']>;
};

export type StatefulSetStatus = {
  __typename?: 'StatefulSetStatus';
  conditions?: Maybe<Array<Maybe<StatusCondition>>>;
  currentReplicas?: Maybe<Scalars['Int']['output']>;
  readyReplicas?: Maybe<Scalars['Int']['output']>;
  replicas?: Maybe<Scalars['Int']['output']>;
  updatedReplicas?: Maybe<Scalars['Int']['output']>;
};

export type StatusCondition = {
  __typename?: 'StatusCondition';
  message: Scalars['String']['output'];
  reason: Scalars['String']['output'];
  status: Scalars['String']['output'];
  type: Scalars['String']['output'];
};

export enum StepStage {
  Apply = 'APPLY',
  Destroy = 'DESTROY',
  Init = 'INIT',
  Plan = 'PLAN',
  Verify = 'VERIFY'
}

export enum StepStatus {
  Failed = 'FAILED',
  Pending = 'PENDING',
  Running = 'RUNNING',
  Successful = 'SUCCESSFUL'
}

/** Advanced configuration of how to sync resources */
export type SyncConfig = {
  __typename?: 'SyncConfig';
  /** whether the agent should auto-create the namespace for this service */
  createNamespace?: Maybe<Scalars['Boolean']['output']>;
  /** whether the agent should delete the namespace for this service upon deletion */
  deleteNamespace?: Maybe<Scalars['Boolean']['output']>;
  /** A list of diff normalizers to apply to the service which controls how drift detection works */
  diffNormalizers?: Maybe<Array<Maybe<DiffNormalizer>>>;
  /** Whether to require all resources are placed in the same namespace */
  enforceNamespace?: Maybe<Scalars['Boolean']['output']>;
  namespaceMetadata?: Maybe<NamespaceMetadata>;
  /** Whether to require all resources are owned by this service and fail if they are owned by another */
  requireOwnership?: Maybe<Scalars['Boolean']['output']>;
};

export type SyncConfigAttributes = {
  createNamespace?: InputMaybe<Scalars['Boolean']['input']>;
  deleteNamespace?: InputMaybe<Scalars['Boolean']['input']>;
  /** A list of diff normalizers to apply to the service which controls how drift detection works */
  diffNormalizers?: InputMaybe<Array<InputMaybe<DiffNormalizerAttributes>>>;
  enforceNamespace?: InputMaybe<Scalars['Boolean']['input']>;
  namespaceMetadata?: InputMaybe<MetadataAttributes>;
  requireOwnership?: InputMaybe<Scalars['Boolean']['input']>;
};

export type Tag = {
  __typename?: 'Tag';
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type TagAttributes = {
  name: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type TagConnection = {
  __typename?: 'TagConnection';
  edges?: Maybe<Array<Maybe<TagEdge>>>;
  pageInfo: PageInfo;
};

export type TagEdge = {
  __typename?: 'TagEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<Tag>;
};

export type TagInput = {
  name: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type TagQuery = {
  op: Conjunction;
  tags?: InputMaybe<Array<InputMaybe<TagInput>>>;
};

export enum TagType {
  Cluster = 'CLUSTER',
  Stack = 'STACK'
}

/** a kubernetes node taint */
export type Taint = {
  __typename?: 'Taint';
  effect: Scalars['String']['output'];
  key: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type TaintAttributes = {
  effect: Scalars['String']['input'];
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type TargetRef = {
  __typename?: 'TargetRef';
  apiVersion?: Maybe<Scalars['String']['output']>;
  kind?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** Additional context used to template service metadata during global service reconciliation */
export type TemplateContext = {
  __typename?: 'TemplateContext';
  raw?: Maybe<Scalars['Map']['output']>;
};

/** Additional context used to template service metadata during global service reconciliation */
export type TemplateContextAttributes = {
  raw?: InputMaybe<Scalars['Json']['input']>;
};

export type TerminatedState = {
  __typename?: 'TerminatedState';
  exitCode?: Maybe<Scalars['Int']['output']>;
  finishedAt?: Maybe<Scalars['String']['output']>;
  message?: Maybe<Scalars['String']['output']>;
  reason?: Maybe<Scalars['String']['output']>;
  startedAt?: Maybe<Scalars['String']['output']>;
};

export type TerraformConfiguration = {
  __typename?: 'TerraformConfiguration';
  /** equivalent to the -parallelism flag in terraform */
  parallelism?: Maybe<Scalars['Int']['output']>;
  /** equivalent to the -refresh flag in terraform */
  refresh?: Maybe<Scalars['Boolean']['output']>;
};

export type TerraformConfigurationAttributes = {
  /** equivalent to the -parallelism flag in terraform */
  parallelism?: InputMaybe<Scalars['Int']['input']>;
  /** equivalent to the -refresh flag in terraform */
  refresh?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Urls for configuring terraform HTTP remote state */
export type TerraformStateUrls = {
  __typename?: 'TerraformStateUrls';
  /** GET and POST urls for uploadnig state */
  address?: Maybe<Scalars['String']['output']>;
  /** POST url to lock state */
  lock?: Maybe<Scalars['String']['output']>;
  /** POST url to unlock state */
  unlock?: Maybe<Scalars['String']['output']>;
};

export type ToolConfigAttributes = {
  createPr?: InputMaybe<CreatePrConfigAttributes>;
};

export type ToolDelta = {
  __typename?: 'ToolDelta';
  arguments?: Maybe<Scalars['Map']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** How to enforce uniqueness for a field */
export type UniqByAttributes = {
  /** the scope this name is uniq w/in */
  scope: ValidationUniqScope;
};

export type UpgradeInsight = {
  __typename?: 'UpgradeInsight';
  /** longform description of this insight */
  description?: Maybe<Scalars['String']['output']>;
  details?: Maybe<Array<Maybe<UpgradeInsightDetail>>>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  name: Scalars['String']['output'];
  refreshedAt?: Maybe<Scalars['DateTime']['output']>;
  status?: Maybe<UpgradeInsightStatus>;
  transitionedAt?: Maybe<Scalars['DateTime']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** the k8s version this insight applies to */
  version?: Maybe<Scalars['String']['output']>;
};

export type UpgradeInsightAttributes = {
  /** longform description of this insight */
  description?: InputMaybe<Scalars['String']['input']>;
  details?: InputMaybe<Array<InputMaybe<UpgradeInsightDetailAttributes>>>;
  name: Scalars['String']['input'];
  refreshedAt?: InputMaybe<Scalars['DateTime']['input']>;
  status?: InputMaybe<UpgradeInsightStatus>;
  transitionedAt?: InputMaybe<Scalars['DateTime']['input']>;
  /** the k8s version this insight applies to */
  version?: InputMaybe<Scalars['String']['input']>;
};

export type UpgradeInsightDetail = {
  __typename?: 'UpgradeInsightDetail';
  /** information about the HTTP clients triggering this insight */
  clientInfo?: Maybe<Array<Maybe<InsightClientInfo>>>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  lastUsedAt?: Maybe<Scalars['DateTime']['output']>;
  removedIn?: Maybe<Scalars['String']['output']>;
  replacedIn?: Maybe<Scalars['String']['output']>;
  /** the replacement for this API */
  replacement?: Maybe<Scalars['String']['output']>;
  status?: Maybe<UpgradeInsightStatus>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  /** a possibly deprecated API */
  used?: Maybe<Scalars['String']['output']>;
};

export type UpgradeInsightDetailAttributes = {
  /** descriptions of the HTTP clients triggering this insight */
  clientInfo?: InputMaybe<Array<InputMaybe<InsightClientInfoAttributes>>>;
  /** the latest timestamp this insight has been observed */
  lastUsedAt?: InputMaybe<Scalars['DateTime']['input']>;
  removedIn?: InputMaybe<Scalars['String']['input']>;
  replacedIn?: InputMaybe<Scalars['String']['input']>;
  /** the replacement for this API */
  replacement?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<UpgradeInsightStatus>;
  /** a possibly deprecated API */
  used?: InputMaybe<Scalars['String']['input']>;
};

export enum UpgradeInsightStatus {
  Failed = 'FAILED',
  Passing = 'PASSING',
  Unknown = 'UNKNOWN',
  Warning = 'WARNING'
}

export type UpgradePlan = {
  __typename?: 'UpgradePlan';
  events?: Maybe<Array<Maybe<Event>>>;
  metadata: Metadata;
  pods?: Maybe<Array<Maybe<Pod>>>;
  raw: Scalars['String']['output'];
  spec: UpgradePlanSpec;
  status: UpgradePlanStatus;
};

export type UpgradePlanAttributes = {
  /** whether all compatibilities for a cluster upgrade have been cleared */
  compatibilities?: InputMaybe<Scalars['Boolean']['input']>;
  /** whether all deprecated apis for a cluster have been cleared */
  deprecations?: InputMaybe<Scalars['Boolean']['input']>;
  /** whether all incompatibilities w/in runtime components have been cleared */
  incompatibilities?: InputMaybe<Scalars['Boolean']['input']>;
};

export type UpgradePlanSpec = {
  __typename?: 'UpgradePlanSpec';
  concurrency?: Maybe<Scalars['Int']['output']>;
  cordon?: Maybe<Scalars['Boolean']['output']>;
  version?: Maybe<Scalars['String']['output']>;
};

export type UpgradePlanStatus = {
  __typename?: 'UpgradePlanStatus';
  conditions?: Maybe<Array<Maybe<StatusCondition>>>;
};

/** Summary statistics of the upgradeability of your fleet */
export type UpgradeStatistics = {
  __typename?: 'UpgradeStatistics';
  /** the number of clusters compliant w/ your versioning policy */
  compliant?: Maybe<Scalars['Int']['output']>;
  /** total number of clusters */
  count?: Maybe<Scalars['Int']['output']>;
  /** the number of clusters currently at the latest version */
  latest?: Maybe<Scalars['Int']['output']>;
  /** the number of clusters currently upgradeable */
  upgradeable?: Maybe<Scalars['Int']['output']>;
};

export type UrlSinkAttributes = {
  url: Scalars['String']['input'];
};

/** A notification sink based off slack incoming webhook urls */
export type UrlSinkConfiguration = {
  __typename?: 'UrlSinkConfiguration';
  /** incoming webhook url to deliver to */
  url: Scalars['String']['output'];
};

export type User = {
  __typename?: 'User';
  assumeBindings?: Maybe<Array<Maybe<PolicyBinding>>>;
  backgroundColor?: Maybe<Scalars['String']['output']>;
  boundRoles?: Maybe<Array<Maybe<Role>>>;
  buildTimestamp?: Maybe<Scalars['DateTime']['output']>;
  deletedAt?: Maybe<Scalars['DateTime']['output']>;
  email: Scalars['String']['output'];
  emailSettings?: Maybe<EmailSettings>;
  groups?: Maybe<Array<Maybe<Group>>>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  jwt?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  personas?: Maybe<Array<Maybe<Persona>>>;
  pluralId?: Maybe<Scalars['String']['output']>;
  profile?: Maybe<Scalars['String']['output']>;
  readTimestamp?: Maybe<Scalars['DateTime']['output']>;
  refreshToken?: Maybe<RefreshToken>;
  roles?: Maybe<UserRoles>;
  unreadNotifications?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type UserAttributes = {
  email?: InputMaybe<Scalars['String']['input']>;
  emailSettings?: InputMaybe<EmailSettingsAttributes>;
  name?: InputMaybe<Scalars['String']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
  roles?: InputMaybe<UserRoleAttributes>;
  signingPrivateKey?: InputMaybe<Scalars['String']['input']>;
};

export type UserConnection = {
  __typename?: 'UserConnection';
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  pageInfo: PageInfo;
};

export type UserEdge = {
  __typename?: 'UserEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<User>;
};

export type UserRoleAttributes = {
  admin?: InputMaybe<Scalars['Boolean']['input']>;
};

export type UserRoles = {
  __typename?: 'UserRoles';
  admin?: Maybe<Scalars['Boolean']['output']>;
};

/** A representation of the metrics to render a utilization heat map */
export type UtilizationHeatMap = {
  __typename?: 'UtilizationHeatMap';
  cpu?: Maybe<Array<Maybe<MetricPointResponse>>>;
  memory?: Maybe<Array<Maybe<MetricPointResponse>>>;
};

export enum ValidationUniqScope {
  Cluster = 'CLUSTER',
  Project = 'PROJECT'
}

export enum VectorStore {
  Elastic = 'ELASTIC',
  Opensearch = 'OPENSEARCH'
}

export type VectorStoreAttributes = {
  elastic?: InputMaybe<ElasticsearchConnectionAttributes>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  opensearch?: InputMaybe<OpensearchConnectionAttributes>;
  store?: InputMaybe<VectorStore>;
};

export enum VersionCompliance {
  Compliant = 'COMPLIANT',
  Latest = 'LATEST',
  Outdated = 'OUTDATED'
}

/** a shortform reference to an addon by version */
export type VersionReference = {
  __typename?: 'VersionReference';
  name: Scalars['String']['output'];
  version: Scalars['String']['output'];
};

export type VertexAiAttributes = {
  /** the model to use for vector embeddings */
  embeddingModel?: InputMaybe<Scalars['String']['input']>;
  /** custom vertexai endpoint if for dedicated customer deployments */
  endpoint?: InputMaybe<Scalars['String']['input']>;
  /** the gcp region the model is hosted in */
  location: Scalars['String']['input'];
  /** the vertex model id to use */
  model?: InputMaybe<Scalars['String']['input']>;
  /** the gcp project id to use */
  project: Scalars['String']['input'];
  /** optional service account json to auth to the GCP vertex apis */
  serviceAccountJson?: InputMaybe<Scalars['String']['input']>;
  /** the model to use for tool calls, which are less frequent and require more complex reasoning */
  toolModel?: InputMaybe<Scalars['String']['input']>;
};

/** Settings for usage of GCP VertexAI for LLMs */
export type VertexAiSettings = {
  __typename?: 'VertexAiSettings';
  /** the model to use for vector embeddings */
  embeddingModel?: Maybe<Scalars['String']['output']>;
  /** the gcp region the model */
  location: Scalars['String']['output'];
  /** the vertex ai model to use */
  model?: Maybe<Scalars['String']['output']>;
  /** the gcp project id to use */
  project: Scalars['String']['output'];
  /** the model to use for tool calls, which are less frequent and require more complex reasoning */
  toolModel?: Maybe<Scalars['String']['output']>;
};

export type VerticalPodAutoscaler = {
  __typename?: 'VerticalPodAutoscaler';
  metadata: Metadata;
  spec: VerticalPodAutoscalerSpec;
  status?: Maybe<VerticalPodAutoscalerStatus>;
};

export type VerticalPodAutoscalerSpec = {
  __typename?: 'VerticalPodAutoscalerSpec';
  targetRef: CrossVersionResourceTarget;
  updatePolicy: VerticalPodAutoscalerUpdatePolicy;
};

export type VerticalPodAutoscalerStatus = {
  __typename?: 'VerticalPodAutoscalerStatus';
  recommendation?: Maybe<Recommendation>;
};

export type VerticalPodAutoscalerUpdatePolicy = {
  __typename?: 'VerticalPodAutoscalerUpdatePolicy';
  updateMode?: Maybe<Scalars['String']['output']>;
};

/** A violation of a given OPA Gatekeeper constraint */
export type Violation = {
  __typename?: 'Violation';
  group?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  kind?: Maybe<Scalars['String']['output']>;
  message?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  namespace?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  version?: Maybe<Scalars['String']['output']>;
};

export type ViolationAttributes = {
  group?: InputMaybe<Scalars['String']['input']>;
  kind?: InputMaybe<Scalars['String']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  version?: InputMaybe<Scalars['String']['input']>;
};

/** A summary of statistics for violations w/in a specific column */
export type ViolationStatistic = {
  __typename?: 'ViolationStatistic';
  /** the total number of policy constraints */
  count?: Maybe<Scalars['Int']['output']>;
  /** the value of this field being aggregated */
  value?: Maybe<Scalars['String']['output']>;
  /** the total number of violations found */
  violations?: Maybe<Scalars['Int']['output']>;
};

export type VulnArtifact = {
  __typename?: 'VulnArtifact';
  digest?: Maybe<Scalars['String']['output']>;
  mime?: Maybe<Scalars['String']['output']>;
  registry?: Maybe<Scalars['String']['output']>;
  repository?: Maybe<Scalars['String']['output']>;
  tag?: Maybe<Scalars['String']['output']>;
};

export type VulnArtifactAttributes = {
  digest?: InputMaybe<Scalars['String']['input']>;
  mime?: InputMaybe<Scalars['String']['input']>;
  registry?: InputMaybe<Scalars['String']['input']>;
  repository?: InputMaybe<Scalars['String']['input']>;
  tag?: InputMaybe<Scalars['String']['input']>;
};

export enum VulnAttackVector {
  Adjacent = 'ADJACENT',
  Local = 'LOCAL',
  Network = 'NETWORK',
  Physical = 'PHYSICAL'
}

export type VulnOs = {
  __typename?: 'VulnOs';
  eosl?: Maybe<Scalars['Boolean']['output']>;
  family?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

export type VulnOsAttributes = {
  eosl?: InputMaybe<Scalars['Boolean']['input']>;
  family?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export enum VulnReportGrade {
  A = 'A',
  B = 'B',
  C = 'C',
  D = 'D',
  F = 'F'
}

export enum VulnSeverity {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Low = 'LOW',
  Medium = 'MEDIUM',
  None = 'NONE',
  Unknown = 'UNKNOWN'
}

export type VulnSummary = {
  __typename?: 'VulnSummary';
  criticalCount?: Maybe<Scalars['Int']['output']>;
  highCount?: Maybe<Scalars['Int']['output']>;
  lowCount?: Maybe<Scalars['Int']['output']>;
  mediumCount?: Maybe<Scalars['Int']['output']>;
  noneCount?: Maybe<Scalars['Int']['output']>;
  unknownCount?: Maybe<Scalars['Int']['output']>;
};

export type VulnSummaryAttributes = {
  criticalCount?: InputMaybe<Scalars['Int']['input']>;
  highCount?: InputMaybe<Scalars['Int']['input']>;
  lowCount?: InputMaybe<Scalars['Int']['input']>;
  mediumCount?: InputMaybe<Scalars['Int']['input']>;
  noneCount?: InputMaybe<Scalars['Int']['input']>;
  unknownCount?: InputMaybe<Scalars['Int']['input']>;
};

export enum VulnUserInteraction {
  None = 'NONE',
  Required = 'REQUIRED'
}

export type Vulnerability = {
  __typename?: 'Vulnerability';
  class?: Maybe<Scalars['String']['output']>;
  cvss?: Maybe<CvssBundle>;
  cvssSource?: Maybe<Scalars['String']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  fixedVersion?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  installedVersion?: Maybe<Scalars['String']['output']>;
  lastModifiedDate?: Maybe<Scalars['DateTime']['output']>;
  links?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  packageType?: Maybe<Scalars['String']['output']>;
  pkgPath?: Maybe<Scalars['String']['output']>;
  primaryLink?: Maybe<Scalars['String']['output']>;
  publishedDate?: Maybe<Scalars['DateTime']['output']>;
  resource?: Maybe<Scalars['String']['output']>;
  score?: Maybe<Scalars['Float']['output']>;
  severity?: Maybe<VulnSeverity>;
  target?: Maybe<Scalars['String']['output']>;
  title?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  vulnId?: Maybe<Scalars['String']['output']>;
};

export type VulnerabilityAttributes = {
  class?: InputMaybe<Scalars['String']['input']>;
  cvss?: InputMaybe<CvssBundleAttributes>;
  cvssSource?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  fixedVersion?: InputMaybe<Scalars['String']['input']>;
  installedVersion?: InputMaybe<Scalars['String']['input']>;
  lastModifiedDate?: InputMaybe<Scalars['DateTime']['input']>;
  links?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  packageType?: InputMaybe<Scalars['String']['input']>;
  pkgPath?: InputMaybe<Scalars['String']['input']>;
  primaryLink?: InputMaybe<Scalars['String']['input']>;
  publishedDate?: InputMaybe<Scalars['DateTime']['input']>;
  resource?: InputMaybe<Scalars['String']['input']>;
  score?: InputMaybe<Scalars['Float']['input']>;
  severity?: InputMaybe<VulnSeverity>;
  target?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  vulnId?: InputMaybe<Scalars['String']['input']>;
};

export type VulnerabilityReport = {
  __typename?: 'VulnerabilityReport';
  artifact?: Maybe<VulnArtifact>;
  artifactUrl?: Maybe<Scalars['String']['output']>;
  grade?: Maybe<VulnReportGrade>;
  id: Scalars['ID']['output'];
  insertedAt?: Maybe<Scalars['DateTime']['output']>;
  namespaces?: Maybe<Array<Maybe<NamespaceVuln>>>;
  os?: Maybe<VulnOs>;
  services?: Maybe<Array<Maybe<ServiceVuln>>>;
  summary?: Maybe<VulnSummary>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  vulnerabilities?: Maybe<Array<Maybe<Vulnerability>>>;
};

export type VulnerabilityReportAttributes = {
  artifact?: InputMaybe<VulnArtifactAttributes>;
  artifactUrl?: InputMaybe<Scalars['String']['input']>;
  namespaces?: InputMaybe<Array<InputMaybe<NamespaceVulnAttributes>>>;
  os?: InputMaybe<VulnOsAttributes>;
  services?: InputMaybe<Array<InputMaybe<ServiceVulnAttributes>>>;
  summary?: InputMaybe<VulnSummaryAttributes>;
  vulnerabilities?: InputMaybe<Array<InputMaybe<VulnerabilityAttributes>>>;
};

export type VulnerabilityReportConnection = {
  __typename?: 'VulnerabilityReportConnection';
  edges?: Maybe<Array<Maybe<VulnerabilityReportEdge>>>;
  pageInfo: PageInfo;
};

export type VulnerabilityReportEdge = {
  __typename?: 'VulnerabilityReportEdge';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<VulnerabilityReport>;
};

export type VulnerabilityStatistic = {
  __typename?: 'VulnerabilityStatistic';
  count: Scalars['Int']['output'];
  grade: VulnReportGrade;
};

export type WaitingState = {
  __typename?: 'WaitingState';
  message?: Maybe<Scalars['String']['output']>;
  reason?: Maybe<Scalars['String']['output']>;
};

/** a description of a yaml-merge operation on a file */
export type YamlOverlay = {
  __typename?: 'YamlOverlay';
  /** the filename to apply this yaml overlay on */
  file: Scalars['String']['output'];
  /** configure how list merge should be performed */
  listMerge?: Maybe<ListMerge>;
  /** whether you want to apply liquid templating on the yaml before compiling */
  templated?: Maybe<Scalars['Boolean']['output']>;
  yaml: Scalars['String']['output'];
};

/** a description of a yaml-merge operation on a file */
export type YamlOverlayAttributes = {
  /** the filename to apply this yaml overlay on */
  file: Scalars['String']['input'];
  /** configure how list merge should be performed */
  listMerge?: InputMaybe<ListMerge>;
  /** whether you want to apply liquid templating on the yaml before compiling */
  templated?: InputMaybe<Scalars['Boolean']['input']>;
  yaml: Scalars['String']['input'];
};

export type ChatFragment = { __typename?: 'Chat', id: string, content?: string | null, role: AiRole, seq: number, type: ChatType, confirm?: boolean | null, confirmedAt?: string | null, insertedAt?: string | null, updatedAt?: string | null, attributes?: { __typename?: 'ChatTypeAttributes', file?: { __typename?: 'ChatFile', name?: string | null } | null, tool?: { __typename?: 'ChatTool', name?: string | null, arguments?: Record<string, unknown> | null } | null, prCall?: { __typename?: 'PrCallAttributes', context?: Record<string, unknown> | null, branch?: string | null } | null } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, prAutomation?: { __typename?: 'PrAutomation', id: string, name: string, icon?: string | null, darkIcon?: string | null, documentation?: string | null, addon?: string | null, identifier?: string | null, role?: PrRole | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string } | null, repository?: { __typename?: 'GitRepository', url: string, refs?: Array<string> | null } | null, connection?: { __typename?: 'ScmConnection', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, type: ScmType, username?: string | null, baseUrl?: string | null, apiUrl?: string | null, azure?: { __typename?: 'AzureDevopsConfiguration', username: string, organization: string, project: string } | null } | null, createBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: Array<{ __typename?: 'PrConfiguration', values?: Array<string | null> | null, default?: string | null, documentation?: string | null, displayName?: string | null, longform?: string | null, name: string, optional?: boolean | null, placeholder?: string | null, type: ConfigurationType, page?: number | null, condition?: { __typename?: 'PrConfigurationCondition', field: string, operation: Operation, value?: string | null } | null } | null> | null, confirmation?: { __typename?: 'PrConfirmation', text?: string | null, checklist?: Array<{ __typename?: 'PrChecklist', label: string } | null> | null } | null } | null, server?: { __typename?: 'McpServer', id: string, name: string } | null };

export type ChatThreadTinyFragment = { __typename?: 'ChatThread', id: string, default: boolean, summary: string, insertedAt?: string | null, updatedAt?: string | null, lastMessageAt?: string | null, settings?: { __typename?: 'ChatThreadSettings', memory?: boolean | null } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null, flow?: { __typename?: 'Flow', id: string, name: string, icon?: string | null } | null, session?: { __typename?: 'AgentSession', id: string, type?: AgentSessionType | null, done?: boolean | null, planConfirmed?: boolean | null, thread?: { __typename?: 'ChatThread', id: string, summary: string, insertedAt?: string | null, lastMessageAt?: string | null } | null, connection?: { __typename?: 'CloudConnection', id: string, name: string, provider: Provider } | null, cluster?: { __typename?: 'Cluster', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, url: string } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string } | null } | null } | null };

export type ChatThreadDetailsFragment = { __typename?: 'ChatThread', id: string, default: boolean, summary: string, insertedAt?: string | null, updatedAt?: string | null, lastMessageAt?: string | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null, tools?: Array<{ __typename?: 'McpServerTool', tool?: { __typename?: 'McpTool', name: string, description?: string | null, inputSchema?: Record<string, unknown> | null } | null, server?: { __typename?: 'McpServer', id: string, name: string, url: string, confirm?: boolean | null, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, authentication?: { __typename?: 'McpServerAuthentication', plural?: boolean | null, headers?: Array<{ __typename?: 'McpServerHeader', name: string, value: string } | null> | null } | null } | null } | null> | null, settings?: { __typename?: 'ChatThreadSettings', memory?: boolean | null } | null, flow?: { __typename?: 'Flow', id: string, name: string, icon?: string | null } | null, session?: { __typename?: 'AgentSession', id: string, type?: AgentSessionType | null, done?: boolean | null, planConfirmed?: boolean | null, thread?: { __typename?: 'ChatThread', id: string, summary: string, insertedAt?: string | null, lastMessageAt?: string | null } | null, connection?: { __typename?: 'CloudConnection', id: string, name: string, provider: Provider } | null, cluster?: { __typename?: 'Cluster', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, url: string } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string } | null } | null } | null };

export type ChatThreadMessagesFragment = { __typename?: 'ChatThread', id: string, chats?: { __typename?: 'ChatConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ChatEdge', node?: { __typename?: 'Chat', id: string, content?: string | null, role: AiRole, seq: number, type: ChatType, confirm?: boolean | null, confirmedAt?: string | null, insertedAt?: string | null, updatedAt?: string | null, attributes?: { __typename?: 'ChatTypeAttributes', file?: { __typename?: 'ChatFile', name?: string | null } | null, tool?: { __typename?: 'ChatTool', name?: string | null, arguments?: Record<string, unknown> | null } | null, prCall?: { __typename?: 'PrCallAttributes', context?: Record<string, unknown> | null, branch?: string | null } | null } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, prAutomation?: { __typename?: 'PrAutomation', id: string, name: string, icon?: string | null, darkIcon?: string | null, documentation?: string | null, addon?: string | null, identifier?: string | null, role?: PrRole | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string } | null, repository?: { __typename?: 'GitRepository', url: string, refs?: Array<string> | null } | null, connection?: { __typename?: 'ScmConnection', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, type: ScmType, username?: string | null, baseUrl?: string | null, apiUrl?: string | null, azure?: { __typename?: 'AzureDevopsConfiguration', username: string, organization: string, project: string } | null } | null, createBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: Array<{ __typename?: 'PrConfiguration', values?: Array<string | null> | null, default?: string | null, documentation?: string | null, displayName?: string | null, longform?: string | null, name: string, optional?: boolean | null, placeholder?: string | null, type: ConfigurationType, page?: number | null, condition?: { __typename?: 'PrConfigurationCondition', field: string, operation: Operation, value?: string | null } | null } | null> | null, confirmation?: { __typename?: 'PrConfirmation', text?: string | null, checklist?: Array<{ __typename?: 'PrChecklist', label: string } | null> | null } | null } | null, server?: { __typename?: 'McpServer', id: string, name: string } | null } | null } | null> | null } | null };

export type ChatThreadSettingsFragment = { __typename?: 'ChatThreadSettings', memory?: boolean | null };

export type CloudConnectionTinyFragment = { __typename?: 'CloudConnection', id: string, name: string, provider: Provider };

export type AgentSessionFragment = { __typename?: 'AgentSession', id: string, type?: AgentSessionType | null, done?: boolean | null, planConfirmed?: boolean | null, thread?: { __typename?: 'ChatThread', id: string, summary: string, insertedAt?: string | null, lastMessageAt?: string | null } | null, connection?: { __typename?: 'CloudConnection', id: string, name: string, provider: Provider } | null, cluster?: { __typename?: 'Cluster', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, url: string } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string } | null } | null };

export type ServiceDeploymentChatFragment = { __typename?: 'ServiceDeployment', protect?: boolean | null, id: string, name: string, componentStatus?: string | null, status: ServiceDeploymentStatus, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null };

export type StackChatFragment = { __typename?: 'InfrastructureStack', id?: string | null, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null, name: string, type: StackType, paused?: boolean | null, status: StackStatus, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null, repository?: { __typename?: 'GitRepository', url: string, pulledAt?: string | null } | null };

export type AiDeltaFragment = { __typename?: 'AiDelta', seq: number, message?: number | null, role?: AiRole | null, content: string, tool?: { __typename?: 'ToolDelta', id?: string | null, name?: string | null } | null };

export type ChatThreadsQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
}>;


export type ChatThreadsQuery = { __typename?: 'RootQueryType', chatThreads?: { __typename?: 'ChatThreadConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ChatThreadEdge', node?: { __typename?: 'ChatThread', id: string, default: boolean, summary: string, insertedAt?: string | null, updatedAt?: string | null, lastMessageAt?: string | null, settings?: { __typename?: 'ChatThreadSettings', memory?: boolean | null } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null, flow?: { __typename?: 'Flow', id: string, name: string, icon?: string | null } | null, session?: { __typename?: 'AgentSession', id: string, type?: AgentSessionType | null, done?: boolean | null, planConfirmed?: boolean | null, thread?: { __typename?: 'ChatThread', id: string, summary: string, insertedAt?: string | null, lastMessageAt?: string | null } | null, connection?: { __typename?: 'CloudConnection', id: string, name: string, provider: Provider } | null, cluster?: { __typename?: 'Cluster', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, url: string } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string } | null } | null } | null } | null } | null> | null } | null };

export type ChatAgentSessionQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type ChatAgentSessionQuery = { __typename?: 'RootQueryType', chatThread?: { __typename?: 'ChatThread', id: string, session?: { __typename?: 'AgentSession', id: string, done?: boolean | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, service?: { __typename?: 'ServiceDeployment', protect?: boolean | null, id: string, name: string, componentStatus?: string | null, status: ServiceDeploymentStatus, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null, name: string, type: StackType, paused?: boolean | null, status: StackStatus, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null, repository?: { __typename?: 'GitRepository', url: string, pulledAt?: string | null } | null } | null, pullRequests?: { __typename?: 'PullRequestConnection', edges?: Array<{ __typename?: 'PullRequestEdge', node?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null, serviceDeployments?: { __typename?: 'ServiceDeploymentConnection', edges?: Array<{ __typename?: 'ServiceDeploymentEdge', node?: { __typename?: 'ServiceDeployment', id: string, name: string, componentStatus?: string | null, status: ServiceDeploymentStatus, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null } | null } | null> | null } | null, stacks?: { __typename?: 'InfrastructureStackConnection', edges?: Array<{ __typename?: 'InfrastructureStackEdge', node?: { __typename?: 'InfrastructureStack', id?: string | null, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null, name: string, type: StackType, paused?: boolean | null, status: StackStatus, repository?: { __typename?: 'GitRepository', url: string, pulledAt?: string | null } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null } | null> | null } | null } | null } | null };

export type ChatThreadDetailsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type ChatThreadDetailsQuery = { __typename?: 'RootQueryType', chatThread?: { __typename?: 'ChatThread', id: string, default: boolean, summary: string, insertedAt?: string | null, updatedAt?: string | null, lastMessageAt?: string | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null, tools?: Array<{ __typename?: 'McpServerTool', tool?: { __typename?: 'McpTool', name: string, description?: string | null, inputSchema?: Record<string, unknown> | null } | null, server?: { __typename?: 'McpServer', id: string, name: string, url: string, confirm?: boolean | null, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, authentication?: { __typename?: 'McpServerAuthentication', plural?: boolean | null, headers?: Array<{ __typename?: 'McpServerHeader', name: string, value: string } | null> | null } | null } | null } | null> | null, settings?: { __typename?: 'ChatThreadSettings', memory?: boolean | null } | null, flow?: { __typename?: 'Flow', id: string, name: string, icon?: string | null } | null, session?: { __typename?: 'AgentSession', id: string, type?: AgentSessionType | null, done?: boolean | null, planConfirmed?: boolean | null, thread?: { __typename?: 'ChatThread', id: string, summary: string, insertedAt?: string | null, lastMessageAt?: string | null } | null, connection?: { __typename?: 'CloudConnection', id: string, name: string, provider: Provider } | null, cluster?: { __typename?: 'Cluster', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, url: string } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string } | null } | null } | null } | null };

export type ChatThreadMessagesQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type ChatThreadMessagesQuery = { __typename?: 'RootQueryType', chatThread?: { __typename?: 'ChatThread', id: string, chats?: { __typename?: 'ChatConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ChatEdge', node?: { __typename?: 'Chat', id: string, content?: string | null, role: AiRole, seq: number, type: ChatType, confirm?: boolean | null, confirmedAt?: string | null, insertedAt?: string | null, updatedAt?: string | null, attributes?: { __typename?: 'ChatTypeAttributes', file?: { __typename?: 'ChatFile', name?: string | null } | null, tool?: { __typename?: 'ChatTool', name?: string | null, arguments?: Record<string, unknown> | null } | null, prCall?: { __typename?: 'PrCallAttributes', context?: Record<string, unknown> | null, branch?: string | null } | null } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, prAutomation?: { __typename?: 'PrAutomation', id: string, name: string, icon?: string | null, darkIcon?: string | null, documentation?: string | null, addon?: string | null, identifier?: string | null, role?: PrRole | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string } | null, repository?: { __typename?: 'GitRepository', url: string, refs?: Array<string> | null } | null, connection?: { __typename?: 'ScmConnection', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, type: ScmType, username?: string | null, baseUrl?: string | null, apiUrl?: string | null, azure?: { __typename?: 'AzureDevopsConfiguration', username: string, organization: string, project: string } | null } | null, createBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: Array<{ __typename?: 'PrConfiguration', values?: Array<string | null> | null, default?: string | null, documentation?: string | null, displayName?: string | null, longform?: string | null, name: string, optional?: boolean | null, placeholder?: string | null, type: ConfigurationType, page?: number | null, condition?: { __typename?: 'PrConfigurationCondition', field: string, operation: Operation, value?: string | null } | null } | null> | null, confirmation?: { __typename?: 'PrConfirmation', text?: string | null, checklist?: Array<{ __typename?: 'PrChecklist', label: string } | null> | null } | null } | null, server?: { __typename?: 'McpServer', id: string, name: string } | null } | null } | null> | null } | null } | null };

export type AgentSessionsQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
}>;


export type AgentSessionsQuery = { __typename?: 'RootQueryType', agentSessions?: { __typename?: 'AgentSessionConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'AgentSessionEdge', node?: { __typename?: 'AgentSession', id: string, type?: AgentSessionType | null, done?: boolean | null, planConfirmed?: boolean | null, thread?: { __typename?: 'ChatThread', id: string, summary: string, insertedAt?: string | null, lastMessageAt?: string | null } | null, connection?: { __typename?: 'CloudConnection', id: string, name: string, provider: Provider } | null, cluster?: { __typename?: 'Cluster', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, url: string } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string } | null } | null } | null } | null> | null } | null };

export type CloudConnectionsQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
}>;


export type CloudConnectionsQuery = { __typename?: 'RootQueryType', cloudConnections?: { __typename?: 'CloudConnectionConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'CloudConnectionEdge', node?: { __typename?: 'CloudConnection', id: string, name: string, provider: Provider } | null } | null> | null } | null };

export type HybridChatMutationVariables = Exact<{
  messages?: InputMaybe<Array<InputMaybe<ChatMessage>> | InputMaybe<ChatMessage>>;
  threadId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type HybridChatMutation = { __typename?: 'RootMutationType', hybridChat?: Array<{ __typename?: 'Chat', id: string, content?: string | null, role: AiRole, seq: number, type: ChatType, confirm?: boolean | null, confirmedAt?: string | null, insertedAt?: string | null, updatedAt?: string | null, attributes?: { __typename?: 'ChatTypeAttributes', file?: { __typename?: 'ChatFile', name?: string | null } | null, tool?: { __typename?: 'ChatTool', name?: string | null, arguments?: Record<string, unknown> | null } | null, prCall?: { __typename?: 'PrCallAttributes', context?: Record<string, unknown> | null, branch?: string | null } | null } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, prAutomation?: { __typename?: 'PrAutomation', id: string, name: string, icon?: string | null, darkIcon?: string | null, documentation?: string | null, addon?: string | null, identifier?: string | null, role?: PrRole | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string } | null, repository?: { __typename?: 'GitRepository', url: string, refs?: Array<string> | null } | null, connection?: { __typename?: 'ScmConnection', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, type: ScmType, username?: string | null, baseUrl?: string | null, apiUrl?: string | null, azure?: { __typename?: 'AzureDevopsConfiguration', username: string, organization: string, project: string } | null } | null, createBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: Array<{ __typename?: 'PrConfiguration', values?: Array<string | null> | null, default?: string | null, documentation?: string | null, displayName?: string | null, longform?: string | null, name: string, optional?: boolean | null, placeholder?: string | null, type: ConfigurationType, page?: number | null, condition?: { __typename?: 'PrConfigurationCondition', field: string, operation: Operation, value?: string | null } | null } | null> | null, confirmation?: { __typename?: 'PrConfirmation', text?: string | null, checklist?: Array<{ __typename?: 'PrChecklist', label: string } | null> | null } | null } | null, server?: { __typename?: 'McpServer', id: string, name: string } | null } | null> | null };

export type ConfirmChatMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type ConfirmChatMutation = { __typename?: 'RootMutationType', confirmChat?: { __typename?: 'Chat', id: string, content?: string | null, role: AiRole, seq: number, type: ChatType, confirm?: boolean | null, confirmedAt?: string | null, insertedAt?: string | null, updatedAt?: string | null, attributes?: { __typename?: 'ChatTypeAttributes', file?: { __typename?: 'ChatFile', name?: string | null } | null, tool?: { __typename?: 'ChatTool', name?: string | null, arguments?: Record<string, unknown> | null } | null, prCall?: { __typename?: 'PrCallAttributes', context?: Record<string, unknown> | null, branch?: string | null } | null } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, prAutomation?: { __typename?: 'PrAutomation', id: string, name: string, icon?: string | null, darkIcon?: string | null, documentation?: string | null, addon?: string | null, identifier?: string | null, role?: PrRole | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string } | null, repository?: { __typename?: 'GitRepository', url: string, refs?: Array<string> | null } | null, connection?: { __typename?: 'ScmConnection', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, type: ScmType, username?: string | null, baseUrl?: string | null, apiUrl?: string | null, azure?: { __typename?: 'AzureDevopsConfiguration', username: string, organization: string, project: string } | null } | null, createBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: Array<{ __typename?: 'PrConfiguration', values?: Array<string | null> | null, default?: string | null, documentation?: string | null, displayName?: string | null, longform?: string | null, name: string, optional?: boolean | null, placeholder?: string | null, type: ConfigurationType, page?: number | null, condition?: { __typename?: 'PrConfigurationCondition', field: string, operation: Operation, value?: string | null } | null } | null> | null, confirmation?: { __typename?: 'PrConfirmation', text?: string | null, checklist?: Array<{ __typename?: 'PrChecklist', label: string } | null> | null } | null } | null, server?: { __typename?: 'McpServer', id: string, name: string } | null } | null };

export type ConfirmChatPlanMutationVariables = Exact<{
  threadId: Scalars['ID']['input'];
}>;


export type ConfirmChatPlanMutation = { __typename?: 'RootMutationType', confirmPlan?: Array<{ __typename?: 'Chat', id: string, content?: string | null, role: AiRole, seq: number, type: ChatType, confirm?: boolean | null, confirmedAt?: string | null, insertedAt?: string | null, updatedAt?: string | null, attributes?: { __typename?: 'ChatTypeAttributes', file?: { __typename?: 'ChatFile', name?: string | null } | null, tool?: { __typename?: 'ChatTool', name?: string | null, arguments?: Record<string, unknown> | null } | null, prCall?: { __typename?: 'PrCallAttributes', context?: Record<string, unknown> | null, branch?: string | null } | null } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, prAutomation?: { __typename?: 'PrAutomation', id: string, name: string, icon?: string | null, darkIcon?: string | null, documentation?: string | null, addon?: string | null, identifier?: string | null, role?: PrRole | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string } | null, repository?: { __typename?: 'GitRepository', url: string, refs?: Array<string> | null } | null, connection?: { __typename?: 'ScmConnection', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, type: ScmType, username?: string | null, baseUrl?: string | null, apiUrl?: string | null, azure?: { __typename?: 'AzureDevopsConfiguration', username: string, organization: string, project: string } | null } | null, createBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: Array<{ __typename?: 'PrConfiguration', values?: Array<string | null> | null, default?: string | null, documentation?: string | null, displayName?: string | null, longform?: string | null, name: string, optional?: boolean | null, placeholder?: string | null, type: ConfigurationType, page?: number | null, condition?: { __typename?: 'PrConfigurationCondition', field: string, operation: Operation, value?: string | null } | null } | null> | null, confirmation?: { __typename?: 'PrConfirmation', text?: string | null, checklist?: Array<{ __typename?: 'PrChecklist', label: string } | null> | null } | null } | null, server?: { __typename?: 'McpServer', id: string, name: string } | null } | null> | null };

export type DeleteChatMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteChatMutation = { __typename?: 'RootMutationType', deleteChat?: { __typename?: 'Chat', id: string, content?: string | null, role: AiRole, seq: number, type: ChatType, confirm?: boolean | null, confirmedAt?: string | null, insertedAt?: string | null, updatedAt?: string | null, attributes?: { __typename?: 'ChatTypeAttributes', file?: { __typename?: 'ChatFile', name?: string | null } | null, tool?: { __typename?: 'ChatTool', name?: string | null, arguments?: Record<string, unknown> | null } | null, prCall?: { __typename?: 'PrCallAttributes', context?: Record<string, unknown> | null, branch?: string | null } | null } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, prAutomation?: { __typename?: 'PrAutomation', id: string, name: string, icon?: string | null, darkIcon?: string | null, documentation?: string | null, addon?: string | null, identifier?: string | null, role?: PrRole | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string } | null, repository?: { __typename?: 'GitRepository', url: string, refs?: Array<string> | null } | null, connection?: { __typename?: 'ScmConnection', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, type: ScmType, username?: string | null, baseUrl?: string | null, apiUrl?: string | null, azure?: { __typename?: 'AzureDevopsConfiguration', username: string, organization: string, project: string } | null } | null, createBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: Array<{ __typename?: 'PrConfiguration', values?: Array<string | null> | null, default?: string | null, documentation?: string | null, displayName?: string | null, longform?: string | null, name: string, optional?: boolean | null, placeholder?: string | null, type: ConfigurationType, page?: number | null, condition?: { __typename?: 'PrConfigurationCondition', field: string, operation: Operation, value?: string | null } | null } | null> | null, confirmation?: { __typename?: 'PrConfirmation', text?: string | null, checklist?: Array<{ __typename?: 'PrChecklist', label: string } | null> | null } | null } | null, server?: { __typename?: 'McpServer', id: string, name: string } | null } | null };

export type CreateChatThreadMutationVariables = Exact<{
  attributes: ChatThreadAttributes;
}>;


export type CreateChatThreadMutation = { __typename?: 'RootMutationType', createThread?: { __typename?: 'ChatThread', id: string, default: boolean, summary: string, insertedAt?: string | null, updatedAt?: string | null, lastMessageAt?: string | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null, tools?: Array<{ __typename?: 'McpServerTool', tool?: { __typename?: 'McpTool', name: string, description?: string | null, inputSchema?: Record<string, unknown> | null } | null, server?: { __typename?: 'McpServer', id: string, name: string, url: string, confirm?: boolean | null, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, authentication?: { __typename?: 'McpServerAuthentication', plural?: boolean | null, headers?: Array<{ __typename?: 'McpServerHeader', name: string, value: string } | null> | null } | null } | null } | null> | null, settings?: { __typename?: 'ChatThreadSettings', memory?: boolean | null } | null, flow?: { __typename?: 'Flow', id: string, name: string, icon?: string | null } | null, session?: { __typename?: 'AgentSession', id: string, type?: AgentSessionType | null, done?: boolean | null, planConfirmed?: boolean | null, thread?: { __typename?: 'ChatThread', id: string, summary: string, insertedAt?: string | null, lastMessageAt?: string | null } | null, connection?: { __typename?: 'CloudConnection', id: string, name: string, provider: Provider } | null, cluster?: { __typename?: 'Cluster', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, url: string } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string } | null } | null } | null } | null };

export type UpdateChatThreadMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  attributes: ChatThreadAttributes;
}>;


export type UpdateChatThreadMutation = { __typename?: 'RootMutationType', updateThread?: { __typename?: 'ChatThread', id: string, default: boolean, summary: string, insertedAt?: string | null, updatedAt?: string | null, lastMessageAt?: string | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null, tools?: Array<{ __typename?: 'McpServerTool', tool?: { __typename?: 'McpTool', name: string, description?: string | null, inputSchema?: Record<string, unknown> | null } | null, server?: { __typename?: 'McpServer', id: string, name: string, url: string, confirm?: boolean | null, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, authentication?: { __typename?: 'McpServerAuthentication', plural?: boolean | null, headers?: Array<{ __typename?: 'McpServerHeader', name: string, value: string } | null> | null } | null } | null } | null> | null, settings?: { __typename?: 'ChatThreadSettings', memory?: boolean | null } | null, flow?: { __typename?: 'Flow', id: string, name: string, icon?: string | null } | null, session?: { __typename?: 'AgentSession', id: string, type?: AgentSessionType | null, done?: boolean | null, planConfirmed?: boolean | null, thread?: { __typename?: 'ChatThread', id: string, summary: string, insertedAt?: string | null, lastMessageAt?: string | null } | null, connection?: { __typename?: 'CloudConnection', id: string, name: string, provider: Provider } | null, cluster?: { __typename?: 'Cluster', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, url: string } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string } | null } | null } | null } | null };

export type DeleteChatThreadMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteChatThreadMutation = { __typename?: 'RootMutationType', deleteThread?: { __typename?: 'ChatThread', id: string, default: boolean, summary: string, insertedAt?: string | null, updatedAt?: string | null, lastMessageAt?: string | null, settings?: { __typename?: 'ChatThreadSettings', memory?: boolean | null } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null, flow?: { __typename?: 'Flow', id: string, name: string, icon?: string | null } | null, session?: { __typename?: 'AgentSession', id: string, type?: AgentSessionType | null, done?: boolean | null, planConfirmed?: boolean | null, thread?: { __typename?: 'ChatThread', id: string, summary: string, insertedAt?: string | null, lastMessageAt?: string | null } | null, connection?: { __typename?: 'CloudConnection', id: string, name: string, provider: Provider } | null, cluster?: { __typename?: 'Cluster', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, url: string } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string } | null } | null } | null } | null };

export type CloneChatThreadMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  seq?: InputMaybe<Scalars['Int']['input']>;
}>;


export type CloneChatThreadMutation = { __typename?: 'RootMutationType', cloneThread?: { __typename?: 'ChatThread', id: string, default: boolean, summary: string, insertedAt?: string | null, updatedAt?: string | null, lastMessageAt?: string | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null, tools?: Array<{ __typename?: 'McpServerTool', tool?: { __typename?: 'McpTool', name: string, description?: string | null, inputSchema?: Record<string, unknown> | null } | null, server?: { __typename?: 'McpServer', id: string, name: string, url: string, confirm?: boolean | null, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, authentication?: { __typename?: 'McpServerAuthentication', plural?: boolean | null, headers?: Array<{ __typename?: 'McpServerHeader', name: string, value: string } | null> | null } | null } | null } | null> | null, settings?: { __typename?: 'ChatThreadSettings', memory?: boolean | null } | null, flow?: { __typename?: 'Flow', id: string, name: string, icon?: string | null } | null, session?: { __typename?: 'AgentSession', id: string, type?: AgentSessionType | null, done?: boolean | null, planConfirmed?: boolean | null, thread?: { __typename?: 'ChatThread', id: string, summary: string, insertedAt?: string | null, lastMessageAt?: string | null } | null, connection?: { __typename?: 'CloudConnection', id: string, name: string, provider: Provider } | null, cluster?: { __typename?: 'Cluster', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, url: string } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string } | null } | null } | null } | null };

export type AddChatContextMutationVariables = Exact<{
  source: ContextSource;
  sourceId?: InputMaybe<Scalars['ID']['input']>;
  threadId: Scalars['ID']['input'];
}>;


export type AddChatContextMutation = { __typename?: 'RootMutationType', addChatContext?: Array<{ __typename?: 'Chat', id: string, content?: string | null, role: AiRole, seq: number, type: ChatType, confirm?: boolean | null, confirmedAt?: string | null, insertedAt?: string | null, updatedAt?: string | null, attributes?: { __typename?: 'ChatTypeAttributes', file?: { __typename?: 'ChatFile', name?: string | null } | null, tool?: { __typename?: 'ChatTool', name?: string | null, arguments?: Record<string, unknown> | null } | null, prCall?: { __typename?: 'PrCallAttributes', context?: Record<string, unknown> | null, branch?: string | null } | null } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, prAutomation?: { __typename?: 'PrAutomation', id: string, name: string, icon?: string | null, darkIcon?: string | null, documentation?: string | null, addon?: string | null, identifier?: string | null, role?: PrRole | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string } | null, repository?: { __typename?: 'GitRepository', url: string, refs?: Array<string> | null } | null, connection?: { __typename?: 'ScmConnection', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, type: ScmType, username?: string | null, baseUrl?: string | null, apiUrl?: string | null, azure?: { __typename?: 'AzureDevopsConfiguration', username: string, organization: string, project: string } | null } | null, createBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: Array<{ __typename?: 'PrConfiguration', values?: Array<string | null> | null, default?: string | null, documentation?: string | null, displayName?: string | null, longform?: string | null, name: string, optional?: boolean | null, placeholder?: string | null, type: ConfigurationType, page?: number | null, condition?: { __typename?: 'PrConfigurationCondition', field: string, operation: Operation, value?: string | null } | null } | null> | null, confirmation?: { __typename?: 'PrConfirmation', text?: string | null, checklist?: Array<{ __typename?: 'PrChecklist', label: string } | null> | null } | null } | null, server?: { __typename?: 'McpServer', id: string, name: string } | null } | null> | null };

export type CreateAgentSessionMutationVariables = Exact<{
  attributes: AgentSessionAttributes;
}>;


export type CreateAgentSessionMutation = { __typename?: 'RootMutationType', createAgentSession?: { __typename?: 'ChatThread', id: string, default: boolean, summary: string, insertedAt?: string | null, updatedAt?: string | null, lastMessageAt?: string | null, settings?: { __typename?: 'ChatThreadSettings', memory?: boolean | null } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null, flow?: { __typename?: 'Flow', id: string, name: string, icon?: string | null } | null, session?: { __typename?: 'AgentSession', id: string, type?: AgentSessionType | null, done?: boolean | null, planConfirmed?: boolean | null, thread?: { __typename?: 'ChatThread', id: string, summary: string, insertedAt?: string | null, lastMessageAt?: string | null } | null, connection?: { __typename?: 'CloudConnection', id: string, name: string, provider: Provider } | null, cluster?: { __typename?: 'Cluster', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, url: string } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string } | null } | null } | null } | null };

export type AiChatStreamSubscriptionVariables = Exact<{
  threadId?: InputMaybe<Scalars['ID']['input']>;
  insightId?: InputMaybe<Scalars['ID']['input']>;
  scopeId?: InputMaybe<Scalars['String']['input']>;
  recommendationId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type AiChatStreamSubscription = { __typename?: 'RootSubscriptionType', aiStream?: { __typename?: 'AiDelta', seq: number, message?: number | null, role?: AiRole | null, content: string, tool?: { __typename?: 'ToolDelta', id?: string | null, name?: string | null } | null } | null };

export type AiInsightFragment = { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null };

export type AiInsightSummaryFragment = { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null };

export type AiInsightContextFragment = { __typename?: 'AiInsight', evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null };

export type AiInsightEvidenceFragment = { __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null };

export type LogsEvidenceFragment = { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null };

export type PullRequestEvidenceFragment = { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null };

export type AlertEvidenceFragment = { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null };

export type KnowledgeEvidenceFragment = { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null };

export type ClusterInsightComponentFragment = { __typename?: 'ClusterInsightComponent', id: string, kind: string, name: string, namespace?: string | null, group?: string | null, version: string, priority?: InsightComponentPriority | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null };

export type ClusterInsightComponentDetailFragment = { __typename?: 'ClusterInsightComponent', id: string, kind: string, name: string, namespace?: string | null, group?: string | null, version: string, priority?: InsightComponentPriority | null, resource?: { __typename?: 'KubernetesUnstructured', raw?: Record<string, unknown> | null } | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null };

export type AiInsightQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type AiInsightQuery = { __typename?: 'RootQueryType', aiInsight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null };

export type AiCompletionQueryVariables = Exact<{
  system: Scalars['String']['input'];
  input?: InputMaybe<Scalars['String']['input']>;
  chat?: InputMaybe<Array<InputMaybe<ChatMessage>> | InputMaybe<ChatMessage>>;
  scopeId?: InputMaybe<Scalars['String']['input']>;
}>;


export type AiCompletionQuery = { __typename?: 'RootQueryType', aiCompletion?: string | null };

export type AiSuggestedFixQueryVariables = Exact<{
  insightID: Scalars['ID']['input'];
}>;


export type AiSuggestedFixQuery = { __typename?: 'RootQueryType', aiSuggestedFix?: string | null };

export type ClusterInsightComponentQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type ClusterInsightComponentQuery = { __typename?: 'RootQueryType', clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, kind: string, name: string, namespace?: string | null, group?: string | null, version: string, priority?: InsightComponentPriority | null, resource?: { __typename?: 'KubernetesUnstructured', raw?: Record<string, unknown> | null } | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null };

export type AiFixPrMutationVariables = Exact<{
  insightId: Scalars['ID']['input'];
  messages?: InputMaybe<Array<InputMaybe<ChatMessage>> | InputMaybe<ChatMessage>>;
}>;


export type AiFixPrMutation = { __typename?: 'RootMutationType', aiFixPr?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null };

export type RefreshInsightMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type RefreshInsightMutation = { __typename?: 'RootMutationType', refreshInsight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null };

export type McpServerFragment = { __typename?: 'McpServer', id: string, name: string, url: string, confirm?: boolean | null, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, authentication?: { __typename?: 'McpServerAuthentication', plural?: boolean | null, headers?: Array<{ __typename?: 'McpServerHeader', name: string, value: string } | null> | null } | null };

export type McpServerAuditFragment = { __typename?: 'McpServerAudit', id: string, arguments?: Record<string, unknown> | null, tool: string, insertedAt?: string | null, updatedAt?: string | null, actor?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null };

export type McpToolFragment = { __typename?: 'McpTool', name: string, description?: string | null, inputSchema?: Record<string, unknown> | null };

export type McpServerToolFragment = { __typename?: 'McpServerTool', tool?: { __typename?: 'McpTool', name: string, description?: string | null, inputSchema?: Record<string, unknown> | null } | null, server?: { __typename?: 'McpServer', id: string, name: string, url: string, confirm?: boolean | null, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, authentication?: { __typename?: 'McpServerAuthentication', plural?: boolean | null, headers?: Array<{ __typename?: 'McpServerHeader', name: string, value: string } | null> | null } | null } | null };

export type McpServerConnectionFragment = { __typename?: 'McpServerConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'McpServerEdge', node?: { __typename?: 'McpServer', id: string, name: string, url: string, confirm?: boolean | null, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, authentication?: { __typename?: 'McpServerAuthentication', plural?: boolean | null, headers?: Array<{ __typename?: 'McpServerHeader', name: string, value: string } | null> | null } | null } | null } | null> | null };

export type McpServersQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
}>;


export type McpServersQuery = { __typename?: 'RootQueryType', mcpServers?: { __typename?: 'McpServerConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'McpServerEdge', node?: { __typename?: 'McpServer', id: string, name: string, url: string, confirm?: boolean | null, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, authentication?: { __typename?: 'McpServerAuthentication', plural?: boolean | null, headers?: Array<{ __typename?: 'McpServerHeader', name: string, value: string } | null> | null } | null } | null } | null> | null } | null };

export type McpServerQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type McpServerQuery = { __typename?: 'RootQueryType', mcpServer?: { __typename?: 'McpServer', id: string, name: string, url: string, confirm?: boolean | null, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, authentication?: { __typename?: 'McpServerAuthentication', plural?: boolean | null, headers?: Array<{ __typename?: 'McpServerHeader', name: string, value: string } | null> | null } | null } | null };

export type McpServerAuditsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
}>;


export type McpServerAuditsQuery = { __typename?: 'RootQueryType', mcpServer?: { __typename?: 'McpServer', id: string, audits?: { __typename?: 'McpServerAuditConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'McpServerAuditEdge', node?: { __typename?: 'McpServerAudit', id: string, arguments?: Record<string, unknown> | null, tool: string, insertedAt?: string | null, updatedAt?: string | null, actor?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null } | null } | null> | null } | null } | null };

export type GenerateMcpTokenQueryVariables = Exact<{ [key: string]: never; }>;


export type GenerateMcpTokenQuery = { __typename?: 'RootQueryType', mcpToken?: string | null };

export type UpsertMcpServerMutationVariables = Exact<{
  attributes: McpServerAttributes;
}>;


export type UpsertMcpServerMutation = { __typename?: 'RootMutationType', upsertMcpServer?: { __typename?: 'McpServer', id: string, name: string, url: string, confirm?: boolean | null, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, authentication?: { __typename?: 'McpServerAuthentication', plural?: boolean | null, headers?: Array<{ __typename?: 'McpServerHeader', name: string, value: string } | null> | null } | null } | null };

export type DeleteMcpServerMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteMcpServerMutation = { __typename?: 'RootMutationType', deleteMcpServer?: { __typename?: 'McpServer', id: string } | null };

export type AlertFragment = { __typename?: 'Alert', id: string, title?: string | null, message?: string | null, type: ObservabilityWebhookType, severity: AlertSeverity, state: AlertState, fingerprint?: string | null, url?: string | null, annotations?: Record<string, unknown> | null, updatedAt?: string | null, tags?: Array<{ __typename?: 'Tag', id: string, name: string, value: string } | null> | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null, resolution?: { __typename?: 'AlertResolution', resolution: string } | null };

export type AlertResolutionFragment = { __typename?: 'AlertResolution', resolution: string };

export type AlertConnectionFragment = { __typename?: 'AlertConnection', edges?: Array<{ __typename?: 'AlertEdge', node?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null, type: ObservabilityWebhookType, severity: AlertSeverity, state: AlertState, fingerprint?: string | null, url?: string | null, annotations?: Record<string, unknown> | null, updatedAt?: string | null, tags?: Array<{ __typename?: 'Tag', id: string, name: string, value: string } | null> | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null, resolution?: { __typename?: 'AlertResolution', resolution: string } | null } | null } | null> | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null } };

export type ClusterAlertsQueryVariables = Exact<{
  clusterId: Scalars['ID']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
}>;


export type ClusterAlertsQuery = { __typename?: 'RootQueryType', cluster?: { __typename?: 'Cluster', id: string, alerts?: { __typename?: 'AlertConnection', edges?: Array<{ __typename?: 'AlertEdge', node?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null, type: ObservabilityWebhookType, severity: AlertSeverity, state: AlertState, fingerprint?: string | null, url?: string | null, annotations?: Record<string, unknown> | null, updatedAt?: string | null, tags?: Array<{ __typename?: 'Tag', id: string, name: string, value: string } | null> | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null, resolution?: { __typename?: 'AlertResolution', resolution: string } | null } | null } | null> | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null } } | null } | null };

export type ServiceAlertsQueryVariables = Exact<{
  serviceId: Scalars['ID']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
}>;


export type ServiceAlertsQuery = { __typename?: 'RootQueryType', serviceDeployment?: { __typename?: 'ServiceDeployment', id: string, alerts?: { __typename?: 'AlertConnection', edges?: Array<{ __typename?: 'AlertEdge', node?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null, type: ObservabilityWebhookType, severity: AlertSeverity, state: AlertState, fingerprint?: string | null, url?: string | null, annotations?: Record<string, unknown> | null, updatedAt?: string | null, tags?: Array<{ __typename?: 'Tag', id: string, name: string, value: string } | null> | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null, resolution?: { __typename?: 'AlertResolution', resolution: string } | null } | null } | null> | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null } } | null } | null };

export type UpsertAlertResolutionMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  attributes: AlertResolutionAttributes;
}>;


export type UpsertAlertResolutionMutation = { __typename?: 'RootMutationType', createAlertResolution?: { __typename?: 'AlertResolution', resolution: string } | null };

export type AuditFragment = { __typename?: 'Audit', id: string, type: AuditType, action: AuditAction, repository?: string | null, ip?: string | null, city?: string | null, country?: string | null, latitude?: string | null, longitude?: string | null, insertedAt?: string | null, actor?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null };

export type AuditsQueryVariables = Exact<{
  repo?: InputMaybe<Scalars['String']['input']>;
  cursor?: InputMaybe<Scalars['String']['input']>;
}>;


export type AuditsQuery = { __typename?: 'RootQueryType', audits?: { __typename?: 'AuditConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'AuditEdge', node?: { __typename?: 'Audit', id: string, type: AuditType, action: AuditAction, repository?: string | null, ip?: string | null, city?: string | null, country?: string | null, latitude?: string | null, longitude?: string | null, insertedAt?: string | null, actor?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null } | null } | null> | null } | null };

export type AuditMetricsQueryVariables = Exact<{ [key: string]: never; }>;


export type AuditMetricsQuery = { __typename?: 'RootQueryType', auditMetrics?: Array<{ __typename?: 'AuditMetric', country?: string | null, count?: number | null } | null> | null };

export type PrAutomationFragment = { __typename?: 'PrAutomation', id: string, name: string, icon?: string | null, darkIcon?: string | null, documentation?: string | null, addon?: string | null, identifier?: string | null, role?: PrRole | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string } | null, repository?: { __typename?: 'GitRepository', url: string, refs?: Array<string> | null } | null, connection?: { __typename?: 'ScmConnection', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, type: ScmType, username?: string | null, baseUrl?: string | null, apiUrl?: string | null, azure?: { __typename?: 'AzureDevopsConfiguration', username: string, organization: string, project: string } | null } | null, createBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: Array<{ __typename?: 'PrConfiguration', values?: Array<string | null> | null, default?: string | null, documentation?: string | null, displayName?: string | null, longform?: string | null, name: string, optional?: boolean | null, placeholder?: string | null, type: ConfigurationType, page?: number | null, condition?: { __typename?: 'PrConfigurationCondition', field: string, operation: Operation, value?: string | null } | null } | null> | null, confirmation?: { __typename?: 'PrConfirmation', text?: string | null, checklist?: Array<{ __typename?: 'PrChecklist', label: string } | null> | null } | null };

export type PrConfigurationFragment = { __typename?: 'PrConfiguration', values?: Array<string | null> | null, default?: string | null, documentation?: string | null, displayName?: string | null, longform?: string | null, name: string, optional?: boolean | null, placeholder?: string | null, type: ConfigurationType, page?: number | null, condition?: { __typename?: 'PrConfigurationCondition', field: string, operation: Operation, value?: string | null } | null };

export type PrConfirmationFragment = { __typename?: 'PrConfirmation', text?: string | null, checklist?: Array<{ __typename?: 'PrChecklist', label: string } | null> | null };

export type PrAutomationsQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  catalogId?: InputMaybe<Scalars['ID']['input']>;
  role?: InputMaybe<PrRole>;
  q?: InputMaybe<Scalars['String']['input']>;
}>;


export type PrAutomationsQuery = { __typename?: 'RootQueryType', prAutomations?: { __typename?: 'PrAutomationConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'PrAutomationEdge', node?: { __typename?: 'PrAutomation', id: string, name: string, icon?: string | null, darkIcon?: string | null, documentation?: string | null, addon?: string | null, identifier?: string | null, role?: PrRole | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string } | null, repository?: { __typename?: 'GitRepository', url: string, refs?: Array<string> | null } | null, connection?: { __typename?: 'ScmConnection', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, type: ScmType, username?: string | null, baseUrl?: string | null, apiUrl?: string | null, azure?: { __typename?: 'AzureDevopsConfiguration', username: string, organization: string, project: string } | null } | null, createBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: Array<{ __typename?: 'PrConfiguration', values?: Array<string | null> | null, default?: string | null, documentation?: string | null, displayName?: string | null, longform?: string | null, name: string, optional?: boolean | null, placeholder?: string | null, type: ConfigurationType, page?: number | null, condition?: { __typename?: 'PrConfigurationCondition', field: string, operation: Operation, value?: string | null } | null } | null> | null, confirmation?: { __typename?: 'PrConfirmation', text?: string | null, checklist?: Array<{ __typename?: 'PrChecklist', label: string } | null> | null } | null } | null } | null> | null } | null };

export type CreatePrAutomationMutationVariables = Exact<{
  attributes: PrAutomationAttributes;
}>;


export type CreatePrAutomationMutation = { __typename?: 'RootMutationType', createPrAutomation?: { __typename?: 'PrAutomation', id: string, name: string, icon?: string | null, darkIcon?: string | null, documentation?: string | null, addon?: string | null, identifier?: string | null, role?: PrRole | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string } | null, repository?: { __typename?: 'GitRepository', url: string, refs?: Array<string> | null } | null, connection?: { __typename?: 'ScmConnection', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, type: ScmType, username?: string | null, baseUrl?: string | null, apiUrl?: string | null, azure?: { __typename?: 'AzureDevopsConfiguration', username: string, organization: string, project: string } | null } | null, createBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: Array<{ __typename?: 'PrConfiguration', values?: Array<string | null> | null, default?: string | null, documentation?: string | null, displayName?: string | null, longform?: string | null, name: string, optional?: boolean | null, placeholder?: string | null, type: ConfigurationType, page?: number | null, condition?: { __typename?: 'PrConfigurationCondition', field: string, operation: Operation, value?: string | null } | null } | null> | null, confirmation?: { __typename?: 'PrConfirmation', text?: string | null, checklist?: Array<{ __typename?: 'PrChecklist', label: string } | null> | null } | null } | null };

export type UpdatePrAutomationMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  attributes: PrAutomationAttributes;
}>;


export type UpdatePrAutomationMutation = { __typename?: 'RootMutationType', updatePrAutomation?: { __typename?: 'PrAutomation', id: string, name: string, icon?: string | null, darkIcon?: string | null, documentation?: string | null, addon?: string | null, identifier?: string | null, role?: PrRole | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string } | null, repository?: { __typename?: 'GitRepository', url: string, refs?: Array<string> | null } | null, connection?: { __typename?: 'ScmConnection', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, type: ScmType, username?: string | null, baseUrl?: string | null, apiUrl?: string | null, azure?: { __typename?: 'AzureDevopsConfiguration', username: string, organization: string, project: string } | null } | null, createBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: Array<{ __typename?: 'PrConfiguration', values?: Array<string | null> | null, default?: string | null, documentation?: string | null, displayName?: string | null, longform?: string | null, name: string, optional?: boolean | null, placeholder?: string | null, type: ConfigurationType, page?: number | null, condition?: { __typename?: 'PrConfigurationCondition', field: string, operation: Operation, value?: string | null } | null } | null> | null, confirmation?: { __typename?: 'PrConfirmation', text?: string | null, checklist?: Array<{ __typename?: 'PrChecklist', label: string } | null> | null } | null } | null };

export type DeletePrAutomationMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeletePrAutomationMutation = { __typename?: 'RootMutationType', deletePrAutomation?: { __typename?: 'PrAutomation', id: string, name: string, icon?: string | null, darkIcon?: string | null, documentation?: string | null, addon?: string | null, identifier?: string | null, role?: PrRole | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string } | null, repository?: { __typename?: 'GitRepository', url: string, refs?: Array<string> | null } | null, connection?: { __typename?: 'ScmConnection', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, type: ScmType, username?: string | null, baseUrl?: string | null, apiUrl?: string | null, azure?: { __typename?: 'AzureDevopsConfiguration', username: string, organization: string, project: string } | null } | null, createBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: Array<{ __typename?: 'PrConfiguration', values?: Array<string | null> | null, default?: string | null, documentation?: string | null, displayName?: string | null, longform?: string | null, name: string, optional?: boolean | null, placeholder?: string | null, type: ConfigurationType, page?: number | null, condition?: { __typename?: 'PrConfigurationCondition', field: string, operation: Operation, value?: string | null } | null } | null> | null, confirmation?: { __typename?: 'PrConfirmation', text?: string | null, checklist?: Array<{ __typename?: 'PrChecklist', label: string } | null> | null } | null } | null };

export type ScmConnectionFragment = { __typename?: 'ScmConnection', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, type: ScmType, username?: string | null, baseUrl?: string | null, apiUrl?: string | null, azure?: { __typename?: 'AzureDevopsConfiguration', username: string, organization: string, project: string } | null };

export type ScmConnectionsQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
}>;


export type ScmConnectionsQuery = { __typename?: 'RootQueryType', scmConnections?: { __typename?: 'ScmConnectionConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ScmConnectionEdge', node?: { __typename?: 'ScmConnection', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, type: ScmType, username?: string | null, baseUrl?: string | null, apiUrl?: string | null, azure?: { __typename?: 'AzureDevopsConfiguration', username: string, organization: string, project: string } | null } | null } | null> | null } | null };

export type ScmConnectionQueryVariables = Exact<{
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
}>;


export type ScmConnectionQuery = { __typename?: 'RootQueryType', scmConnection?: { __typename?: 'ScmConnection', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, type: ScmType, username?: string | null, baseUrl?: string | null, apiUrl?: string | null, azure?: { __typename?: 'AzureDevopsConfiguration', username: string, organization: string, project: string } | null } | null };

export type CreateScmConnectionMutationVariables = Exact<{
  attributes: ScmConnectionAttributes;
}>;


export type CreateScmConnectionMutation = { __typename?: 'RootMutationType', createScmConnection?: { __typename?: 'ScmConnection', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, type: ScmType, username?: string | null, baseUrl?: string | null, apiUrl?: string | null, azure?: { __typename?: 'AzureDevopsConfiguration', username: string, organization: string, project: string } | null } | null };

export type UpdateScmConnectionMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  attributes: ScmConnectionAttributes;
}>;


export type UpdateScmConnectionMutation = { __typename?: 'RootMutationType', updateScmConnection?: { __typename?: 'ScmConnection', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, type: ScmType, username?: string | null, baseUrl?: string | null, apiUrl?: string | null, azure?: { __typename?: 'AzureDevopsConfiguration', username: string, organization: string, project: string } | null } | null };

export type DeleteScmConnectionMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteScmConnectionMutation = { __typename?: 'RootMutationType', deleteScmConnection?: { __typename?: 'ScmConnection', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, type: ScmType, username?: string | null, baseUrl?: string | null, apiUrl?: string | null, azure?: { __typename?: 'AzureDevopsConfiguration', username: string, organization: string, project: string } | null } | null };

export type SetupRenovateMutationVariables = Exact<{
  connectionId: Scalars['ID']['input'];
  repos: Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
}>;


export type SetupRenovateMutation = { __typename?: 'RootMutationType', setupRenovate?: { __typename?: 'ServiceDeployment', id: string } | null };

export type ScmWebhookFragment = { __typename?: 'ScmWebhook', id: string, name: string, owner: string, type: ScmType, url: string, insertedAt?: string | null, updatedAt?: string | null };

export type ScmWebhooksQueryVariables = Exact<{
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
}>;


export type ScmWebhooksQuery = { __typename?: 'RootQueryType', scmWebhooks?: { __typename?: 'ScmWebhookConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ScmWebhookEdge', node?: { __typename?: 'ScmWebhook', id: string, name: string, owner: string, type: ScmType, url: string, insertedAt?: string | null, updatedAt?: string | null } | null } | null> | null } | null };

export type CreateScmWebhookMutationVariables = Exact<{
  connectionId: Scalars['ID']['input'];
  owner: Scalars['String']['input'];
}>;


export type CreateScmWebhookMutation = { __typename?: 'RootMutationType', createScmWebhook?: { __typename?: 'ScmWebhook', id: string, name: string, owner: string, type: ScmType, url: string, insertedAt?: string | null, updatedAt?: string | null } | null };

export type DeleteScmWebhookMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteScmWebhookMutation = { __typename?: 'RootMutationType', deleteScmWebhook?: { __typename?: 'ScmWebhook', id: string, name: string, owner: string, type: ScmType, url: string, insertedAt?: string | null, updatedAt?: string | null } | null };

export type CreateScmWebhookPointerMutationVariables = Exact<{
  attributes: ScmWebhookAttributes;
}>;


export type CreateScmWebhookPointerMutation = { __typename?: 'RootMutationType', createScmWebhookPointer?: { __typename?: 'ScmWebhook', id: string, name: string, owner: string, type: ScmType, url: string, insertedAt?: string | null, updatedAt?: string | null } | null };

export type RegisterGitHubAppMutationVariables = Exact<{
  installationId: Scalars['String']['input'];
  name: Scalars['String']['input'];
}>;


export type RegisterGitHubAppMutation = { __typename?: 'RootMutationType', registerGithubApp?: { __typename?: 'ScmConnection', id: string } | null };

export type ObjectStoreFragment = { __typename?: 'ObjectStore', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, s3?: { __typename?: 'S3Store', bucket: string, region?: string | null, endpoint?: string | null, accessKeyId: string } | null, azure?: { __typename?: 'AzureStore', container: string, storageAccount: string, resourceGroup: string, subscriptionId: string, clientId: string, tenantId: string } | null, gcs?: { __typename?: 'GcsStore', bucket: string } | null };

export type ClustersObjectStoresFragment = { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, objectStore?: { __typename?: 'ObjectStore', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, s3?: { __typename?: 'S3Store', bucket: string, region?: string | null, endpoint?: string | null, accessKeyId: string } | null, azure?: { __typename?: 'AzureStore', container: string, storageAccount: string, resourceGroup: string, subscriptionId: string, clientId: string, tenantId: string } | null, gcs?: { __typename?: 'GcsStore', bucket: string } | null } | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null };

export type ClusterBackupFragment = { __typename?: 'ClusterBackup', id: string, garbageCollected?: boolean | null, insertedAt?: string | null, updatedAt?: string | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null };

export type ClusterRestoreFragment = { __typename?: 'ClusterRestore', id: string, status: RestoreStatus, insertedAt?: string | null, updatedAt?: string | null, backup?: { __typename?: 'ClusterBackup', id: string, garbageCollected?: boolean | null, insertedAt?: string | null, updatedAt?: string | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null };

export type ObjectStoresQueryVariables = Exact<{
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
}>;


export type ObjectStoresQuery = { __typename?: 'RootQueryType', objectStores?: { __typename?: 'ObjectStoreConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ObjectStoreEdge', node?: { __typename?: 'ObjectStore', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, s3?: { __typename?: 'S3Store', bucket: string, region?: string | null, endpoint?: string | null, accessKeyId: string } | null, azure?: { __typename?: 'AzureStore', container: string, storageAccount: string, resourceGroup: string, subscriptionId: string, clientId: string, tenantId: string } | null, gcs?: { __typename?: 'GcsStore', bucket: string } | null } | null } | null> | null } | null };

export type ClustersObjectStoresQueryVariables = Exact<{
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  backups?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type ClustersObjectStoresQuery = { __typename?: 'RootQueryType', clusters?: { __typename?: 'ClusterConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ClusterEdge', node?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, objectStore?: { __typename?: 'ObjectStore', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, s3?: { __typename?: 'S3Store', bucket: string, region?: string | null, endpoint?: string | null, accessKeyId: string } | null, azure?: { __typename?: 'AzureStore', container: string, storageAccount: string, resourceGroup: string, subscriptionId: string, clientId: string, tenantId: string } | null, gcs?: { __typename?: 'GcsStore', bucket: string } | null } | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null } | null };

export type ClusterBackupQueryVariables = Exact<{
  id?: InputMaybe<Scalars['ID']['input']>;
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
}>;


export type ClusterBackupQuery = { __typename?: 'RootQueryType', clusterBackup?: { __typename?: 'ClusterBackup', id: string, garbageCollected?: boolean | null, insertedAt?: string | null, updatedAt?: string | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null };

export type ClusterBackupsQueryVariables = Exact<{
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  clusterId: Scalars['ID']['input'];
}>;


export type ClusterBackupsQuery = { __typename?: 'RootQueryType', clusterBackups?: { __typename?: 'ClusterBackupConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ClusterBackupEdge', node?: { __typename?: 'ClusterBackup', id: string, garbageCollected?: boolean | null, insertedAt?: string | null, updatedAt?: string | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null };

export type ClusterRestoresQueryVariables = Exact<{
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  clusterId: Scalars['ID']['input'];
}>;


export type ClusterRestoresQuery = { __typename?: 'RootQueryType', clusterRestores?: { __typename?: 'ClusterRestoreConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ClusterRestoreEdge', node?: { __typename?: 'ClusterRestore', id: string, status: RestoreStatus, insertedAt?: string | null, updatedAt?: string | null, backup?: { __typename?: 'ClusterBackup', id: string, garbageCollected?: boolean | null, insertedAt?: string | null, updatedAt?: string | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null } | null> | null } | null };

export type CreateObjectStoreMutationVariables = Exact<{
  attributes: ObjectStoreAttributes;
}>;


export type CreateObjectStoreMutation = { __typename?: 'RootMutationType', createObjectStore?: { __typename?: 'ObjectStore', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, s3?: { __typename?: 'S3Store', bucket: string, region?: string | null, endpoint?: string | null, accessKeyId: string } | null, azure?: { __typename?: 'AzureStore', container: string, storageAccount: string, resourceGroup: string, subscriptionId: string, clientId: string, tenantId: string } | null, gcs?: { __typename?: 'GcsStore', bucket: string } | null } | null };

export type UpdateObjectStoreMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  attributes: ObjectStoreAttributes;
}>;


export type UpdateObjectStoreMutation = { __typename?: 'RootMutationType', updateObjectStore?: { __typename?: 'ObjectStore', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, s3?: { __typename?: 'S3Store', bucket: string, region?: string | null, endpoint?: string | null, accessKeyId: string } | null, azure?: { __typename?: 'AzureStore', container: string, storageAccount: string, resourceGroup: string, subscriptionId: string, clientId: string, tenantId: string } | null, gcs?: { __typename?: 'GcsStore', bucket: string } | null } | null };

export type DeleteObjectStoreMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteObjectStoreMutation = { __typename?: 'RootMutationType', deleteObjectStore?: { __typename?: 'ObjectStore', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, s3?: { __typename?: 'S3Store', bucket: string, region?: string | null, endpoint?: string | null, accessKeyId: string } | null, azure?: { __typename?: 'AzureStore', container: string, storageAccount: string, resourceGroup: string, subscriptionId: string, clientId: string, tenantId: string } | null, gcs?: { __typename?: 'GcsStore', bucket: string } | null } | null };

export type ConfigureBackupsMutationVariables = Exact<{
  clusterId: Scalars['ID']['input'];
  storeId: Scalars['ID']['input'];
}>;


export type ConfigureBackupsMutation = { __typename?: 'RootMutationType', configureBackups?: { __typename?: 'Cluster', self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null };

export type DelinkBackupsMutationVariables = Exact<{
  clusterId: Scalars['ID']['input'];
}>;


export type DelinkBackupsMutation = { __typename?: 'RootMutationType', delinkBackups?: { __typename?: 'Cluster', self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null };

export type CreateClusterRestoreMutationVariables = Exact<{
  backupId: Scalars['ID']['input'];
}>;


export type CreateClusterRestoreMutation = { __typename?: 'RootMutationType', createClusterRestore?: { __typename?: 'ClusterRestore', id: string, status: RestoreStatus, insertedAt?: string | null, updatedAt?: string | null, backup?: { __typename?: 'ClusterBackup', id: string, garbageCollected?: boolean | null, insertedAt?: string | null, updatedAt?: string | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null };

export type PageInfoFragment = { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null };

export type CatalogFragment = { __typename?: 'Catalog', id: string, name: string, author?: string | null, description?: string | null, category?: string | null, icon?: string | null, darkIcon?: string | null, createBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null };

export type CatalogsQueryVariables = Exact<{
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
}>;


export type CatalogsQuery = { __typename?: 'RootQueryType', catalogs?: { __typename?: 'CatalogConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'CatalogEdge', node?: { __typename?: 'Catalog', id: string, name: string, author?: string | null, description?: string | null, category?: string | null, icon?: string | null, darkIcon?: string | null, createBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null } | null } | null> | null } | null };

export type CatalogQueryVariables = Exact<{
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
}>;


export type CatalogQuery = { __typename?: 'RootQueryType', catalog?: { __typename?: 'Catalog', id: string, name: string, author?: string | null, description?: string | null, category?: string | null, icon?: string | null, darkIcon?: string | null, createBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null } | null };

export type UpsertCatalogMutationVariables = Exact<{
  attributes?: InputMaybe<CatalogAttributes>;
}>;


export type UpsertCatalogMutation = { __typename?: 'RootMutationType', upsertCatalog?: { __typename?: 'Catalog', id: string, name: string, author?: string | null, description?: string | null, category?: string | null, icon?: string | null, darkIcon?: string | null, createBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null } | null };

export type DeleteCatalogMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteCatalogMutation = { __typename?: 'RootMutationType', deleteCatalog?: { __typename?: 'Catalog', id: string, name: string, author?: string | null, description?: string | null, category?: string | null, icon?: string | null, darkIcon?: string | null, createBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null } | null };

export type ClusterNodeFragment = { __typename?: 'Node', metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'NodeStatus', phase?: string | null, allocatable?: Record<string, unknown> | null, capacity?: Record<string, unknown> | null, conditions?: Array<{ __typename?: 'NodeCondition', type?: string | null, status?: string | null, message?: string | null } | null> | null }, spec: { __typename?: 'NodeSpec', podCidr?: string | null, providerId?: string | null } };

export type ClusterConditionFragment = { __typename?: 'ClusterCondition', lastTransitionTime?: string | null, message?: string | null, reason?: string | null, severity?: string | null, status?: string | null, type?: string | null };

export type TaintFragment = { __typename?: 'Taint', effect: string, key: string, value: string };

export type NodePoolFragment = { __typename?: 'NodePool', id: string, name: string, minSize: number, maxSize: number, instanceType: string, spot?: boolean | null, labels?: Record<string, unknown> | null, taints?: Array<{ __typename?: 'Taint', effect: string, key: string, value: string } | null> | null };

export type ApiDeprecationFragment = { __typename?: 'ApiDeprecation', availableIn?: string | null, blocking?: boolean | null, deprecatedIn?: string | null, removedIn?: string | null, replacement?: string | null, component?: { __typename?: 'ServiceComponent', group?: string | null, version?: string | null, kind: string, name: string, namespace?: string | null, service?: { __typename?: 'ServiceDeployment', git?: { __typename?: 'GitRef', ref: string, folder: string } | null, repository?: { __typename?: 'GitRepository', httpsPath?: string | null, urlFormat?: string | null } | null } | null } | null };

export type UpgradeInsightFragment = { __typename?: 'UpgradeInsight', id: string, name: string, description?: string | null, refreshedAt?: string | null, transitionedAt?: string | null, version?: string | null, status?: UpgradeInsightStatus | null, details?: Array<{ __typename?: 'UpgradeInsightDetail', id: string, removedIn?: string | null, replacedIn?: string | null, replacement?: string | null, status?: UpgradeInsightStatus | null, used?: string | null, clientInfo?: Array<{ __typename?: 'InsightClientInfo', userAgent?: string | null, count?: string | null, lastRequestAt?: string | null } | null> | null } | null> | null };

export type UpgradeInsightDetailFragment = { __typename?: 'UpgradeInsightDetail', id: string, removedIn?: string | null, replacedIn?: string | null, replacement?: string | null, status?: UpgradeInsightStatus | null, used?: string | null, clientInfo?: Array<{ __typename?: 'InsightClientInfo', userAgent?: string | null, count?: string | null, lastRequestAt?: string | null } | null> | null };

export type InsightClientInfoFragment = { __typename?: 'InsightClientInfo', userAgent?: string | null, count?: string | null, lastRequestAt?: string | null };

export type RuntimeServiceFragment = { __typename?: 'RuntimeService', id: string, name: string, version: string, addon?: { __typename?: 'RuntimeAddon', icon?: string | null, versions?: Array<{ __typename?: 'AddonVersion', version?: string | null, kube?: Array<string | null> | null, chartVersion?: string | null, incompatibilities?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null, requirements?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null } | null> | null } | null, service?: { __typename?: 'ServiceDeployment', git?: { __typename?: 'GitRef', ref: string, folder: string } | null, repository?: { __typename?: 'GitRepository', httpsPath?: string | null, urlFormat?: string | null } | null, helm?: { __typename?: 'HelmSpec', version?: string | null } | null } | null, addonVersion?: { __typename?: 'AddonVersion', blocking?: boolean | null, version?: string | null, kube?: Array<string | null> | null, chartVersion?: string | null, incompatibilities?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null, requirements?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null } | null };

export type RuntimeServiceDetailsFragment = { __typename?: 'RuntimeService', id: string, name: string, version: string, addon?: { __typename?: 'RuntimeAddon', icon?: string | null, releaseUrl?: string | null, readme?: string | null, versions?: Array<{ __typename?: 'AddonVersion', version?: string | null, kube?: Array<string | null> | null, chartVersion?: string | null, incompatibilities?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null, requirements?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null } | null> | null } | null, addonVersion?: { __typename?: 'AddonVersion', blocking?: boolean | null, version?: string | null, kube?: Array<string | null> | null, chartVersion?: string | null, incompatibilities?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null, requirements?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null } | null };

export type AddonVersionFragment = { __typename?: 'AddonVersion', version?: string | null, kube?: Array<string | null> | null, chartVersion?: string | null, incompatibilities?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null, requirements?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null };

export type AddonVersionBlockingFragment = { __typename?: 'AddonVersion', blocking?: boolean | null };

export type ClustersRowFragment = { __typename?: 'Cluster', currentVersion?: string | null, id: string, self?: boolean | null, healthy?: boolean | null, healthScore?: number | null, protect?: boolean | null, name: string, handle?: string | null, distro?: ClusterDistro | null, cpuTotal?: number | null, memoryTotal?: number | null, cpuUtil?: number | null, nodeCount?: number | null, namespaceCount?: number | null, availabilityZones?: Array<string | null> | null, podCount?: number | null, memoryUtil?: number | null, installed?: boolean | null, pingedAt?: string | null, deletedAt?: string | null, version?: string | null, kubeletVersion?: string | null, virtual?: boolean | null, provider?: { __typename?: 'ClusterProvider', id: string, cloud: string, name: string, namespace: string, supportedVersions?: Array<string | null> | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, repository?: { __typename?: 'GitRepository', url: string } | null } | null, tags?: Array<{ __typename?: 'Tag', name: string, value: string } | null> | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null, kubeletSkew?: boolean | null } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null };

export type ClusterUpgradePlanFragment = { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null, kubeletSkew?: boolean | null };

export type ClusterNodeMetricsFragment = { __typename?: 'Cluster', id: string, clusterNodeMetrics?: { __typename?: 'ClusterNodeMetrics', cpu?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null, cpuUsage?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null, memory?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null, memoryUsage?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null } | null };

export type ClusterFragment = { __typename?: 'Cluster', currentVersion?: string | null, id: string, name: string, handle?: string | null, metadata?: Record<string, unknown> | null, pingedAt?: string | null, self?: boolean | null, version?: string | null, healthy?: boolean | null, healthScore?: number | null, protect?: boolean | null, distro?: ClusterDistro | null, cpuTotal?: number | null, memoryTotal?: number | null, cpuUtil?: number | null, nodeCount?: number | null, namespaceCount?: number | null, availabilityZones?: Array<string | null> | null, podCount?: number | null, memoryUtil?: number | null, installed?: boolean | null, deletedAt?: string | null, kubeletVersion?: string | null, virtual?: boolean | null, apiDeprecations?: Array<{ __typename?: 'ApiDeprecation', availableIn?: string | null, blocking?: boolean | null, deprecatedIn?: string | null, removedIn?: string | null, replacement?: string | null, component?: { __typename?: 'ServiceComponent', group?: string | null, version?: string | null, kind: string, name: string, namespace?: string | null, service?: { __typename?: 'ServiceDeployment', git?: { __typename?: 'GitRef', ref: string, folder: string } | null, repository?: { __typename?: 'GitRepository', httpsPath?: string | null, urlFormat?: string | null } | null } | null } | null } | null> | null, nodePools?: Array<{ __typename?: 'NodePool', id: string, name: string, minSize: number, maxSize: number, instanceType: string, spot?: boolean | null, labels?: Record<string, unknown> | null, taints?: Array<{ __typename?: 'Taint', effect: string, key: string, value: string } | null> | null } | null> | null, provider?: { __typename?: 'ClusterProvider', id: string, cloud: string, name: string, namespace: string, supportedVersions?: Array<string | null> | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, repository?: { __typename?: 'GitRepository', url: string } | null } | null, tags?: Array<{ __typename?: 'Tag', name: string, value: string } | null> | null, parentCluster?: { __typename?: 'Cluster', currentVersion?: string | null, id: string, self?: boolean | null, healthy?: boolean | null, healthScore?: number | null, protect?: boolean | null, name: string, handle?: string | null, distro?: ClusterDistro | null, cpuTotal?: number | null, memoryTotal?: number | null, cpuUtil?: number | null, nodeCount?: number | null, namespaceCount?: number | null, availabilityZones?: Array<string | null> | null, podCount?: number | null, memoryUtil?: number | null, installed?: boolean | null, pingedAt?: string | null, deletedAt?: string | null, version?: string | null, kubeletVersion?: string | null, virtual?: boolean | null, provider?: { __typename?: 'ClusterProvider', id: string, cloud: string, name: string, namespace: string, supportedVersions?: Array<string | null> | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, repository?: { __typename?: 'GitRepository', url: string } | null } | null, tags?: Array<{ __typename?: 'Tag', name: string, value: string } | null> | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null, kubeletSkew?: boolean | null } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null, operationalLayout?: { __typename?: 'OperationalLayout', serviceMesh?: ServiceMesh | null } | null, alerts?: { __typename?: 'AlertConnection', edges?: Array<{ __typename?: 'AlertEdge', node?: { __typename?: 'Alert', id: string } | null } | null> | null } | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null, kubeletSkew?: boolean | null } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null };

export type ClusterInsightFragment = { __typename?: 'Cluster', id: string, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null, insightComponents?: Array<{ __typename?: 'ClusterInsightComponent', id: string, kind: string, name: string, namespace?: string | null, group?: string | null, version: string, priority?: InsightComponentPriority | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null> | null };

export type CloudAddonFragment = { __typename?: 'CloudAddon', id: string, insertedAt?: string | null, updatedAt?: string | null, name: string, distro: ClusterDistro, version: string, info?: { __typename?: 'CloudAddonInformation', name?: string | null, publisher?: string | null, versions?: Array<{ __typename?: 'CloudAddonVersionInformation', version?: string | null, compatibilities?: Array<string | null> | null, blocking?: boolean | null } | null> | null } | null, versionInfo?: { __typename?: 'CloudAddonVersionInformation', version?: string | null, compatibilities?: Array<string | null> | null, blocking?: boolean | null } | null };

export type CloudAddonVersionInformationFragment = { __typename?: 'CloudAddonVersionInformation', blocking?: boolean | null };

export type ClustersQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
  healthy?: InputMaybe<Scalars['Boolean']['input']>;
  tagQuery?: InputMaybe<TagQuery>;
  projectId?: InputMaybe<Scalars['ID']['input']>;
  upgradeable?: InputMaybe<Scalars['Boolean']['input']>;
  compliance?: InputMaybe<VersionCompliance>;
  healthRange?: InputMaybe<HealthRange>;
}>;


export type ClustersQuery = { __typename?: 'RootQueryType', tags?: Array<string | null> | null, clusters?: { __typename?: 'ClusterConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ClusterEdge', node?: { __typename?: 'Cluster', currentVersion?: string | null, id: string, self?: boolean | null, healthy?: boolean | null, healthScore?: number | null, protect?: boolean | null, name: string, handle?: string | null, distro?: ClusterDistro | null, cpuTotal?: number | null, memoryTotal?: number | null, cpuUtil?: number | null, nodeCount?: number | null, namespaceCount?: number | null, availabilityZones?: Array<string | null> | null, podCount?: number | null, memoryUtil?: number | null, installed?: boolean | null, pingedAt?: string | null, deletedAt?: string | null, version?: string | null, kubeletVersion?: string | null, virtual?: boolean | null, provider?: { __typename?: 'ClusterProvider', id: string, cloud: string, name: string, namespace: string, supportedVersions?: Array<string | null> | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, repository?: { __typename?: 'GitRepository', url: string } | null } | null, tags?: Array<{ __typename?: 'Tag', name: string, value: string } | null> | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null, kubeletSkew?: boolean | null } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null } | null> | null } | null, clusterStatuses?: Array<{ __typename?: 'ClusterStatusInfo', count?: number | null, healthy?: boolean | null } | null> | null, upgradeStatistics?: { __typename?: 'UpgradeStatistics', upgradeable?: number | null, count?: number | null } | null };

export type ClusterMinimalFragment = { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null };

export type ClusterTinyFragment = { __typename?: 'Cluster', self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null };

export type ClusterBasicFragment = { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null };

export type ClusterRuntimeServicesFragment = { __typename?: 'Cluster', id: string, name: string, currentVersion?: string | null, version?: string | null, runtimeServices?: Array<{ __typename?: 'RuntimeService', id: string, name: string, version: string, addon?: { __typename?: 'RuntimeAddon', icon?: string | null, versions?: Array<{ __typename?: 'AddonVersion', version?: string | null, kube?: Array<string | null> | null, chartVersion?: string | null, incompatibilities?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null, requirements?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null } | null> | null } | null, service?: { __typename?: 'ServiceDeployment', git?: { __typename?: 'GitRef', ref: string, folder: string } | null, repository?: { __typename?: 'GitRepository', httpsPath?: string | null, urlFormat?: string | null } | null, helm?: { __typename?: 'HelmSpec', version?: string | null } | null } | null, addonVersion?: { __typename?: 'AddonVersion', blocking?: boolean | null, version?: string | null, kube?: Array<string | null> | null, chartVersion?: string | null, incompatibilities?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null, requirements?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null } | null } | null> | null, apiDeprecations?: Array<{ __typename?: 'ApiDeprecation', availableIn?: string | null, blocking?: boolean | null, deprecatedIn?: string | null, removedIn?: string | null, replacement?: string | null, component?: { __typename?: 'ServiceComponent', group?: string | null, version?: string | null, kind: string, name: string, namespace?: string | null, service?: { __typename?: 'ServiceDeployment', git?: { __typename?: 'GitRef', ref: string, folder: string } | null, repository?: { __typename?: 'GitRepository', httpsPath?: string | null, urlFormat?: string | null } | null } | null } | null } | null> | null, upgradeInsights?: Array<{ __typename?: 'UpgradeInsight', id: string, name: string, description?: string | null, refreshedAt?: string | null, transitionedAt?: string | null, version?: string | null, status?: UpgradeInsightStatus | null, details?: Array<{ __typename?: 'UpgradeInsightDetail', id: string, removedIn?: string | null, replacedIn?: string | null, replacement?: string | null, status?: UpgradeInsightStatus | null, used?: string | null, clientInfo?: Array<{ __typename?: 'InsightClientInfo', userAgent?: string | null, count?: string | null, lastRequestAt?: string | null } | null> | null } | null> | null } | null> | null, cloudAddons?: Array<{ __typename?: 'CloudAddon', id: string, insertedAt?: string | null, updatedAt?: string | null, name: string, distro: ClusterDistro, version: string, info?: { __typename?: 'CloudAddonInformation', name?: string | null, publisher?: string | null, versions?: Array<{ __typename?: 'CloudAddonVersionInformation', version?: string | null, compatibilities?: Array<string | null> | null, blocking?: boolean | null } | null> | null } | null, versionInfo?: { __typename?: 'CloudAddonVersionInformation', version?: string | null, compatibilities?: Array<string | null> | null, blocking?: boolean | null } | null } | null> | null };

export type ClusterWithNodesFragment = { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, nodes?: Array<{ __typename?: 'Node', metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'NodeStatus', phase?: string | null, allocatable?: Record<string, unknown> | null, capacity?: Record<string, unknown> | null, conditions?: Array<{ __typename?: 'NodeCondition', type?: string | null, status?: string | null, message?: string | null } | null> | null }, spec: { __typename?: 'NodeSpec', podCidr?: string | null, providerId?: string | null } } | null> | null, nodeMetrics?: Array<{ __typename?: 'NodeMetric', timestamp?: string | null, window?: string | null, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, usage?: { __typename?: 'NodeUsage', cpu?: string | null, memory?: string | null } | null } | null> | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null };

export type ClusterWithMetricsFragment = { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, clusterMetrics?: { __typename?: 'ClusterMetrics', cpu?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null, cpuUsage?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null, cpuRequests?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null, cpuLimits?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null, memory?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null, memoryUsage?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null, memoryRequests?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null, memoryLimits?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null, pods?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null } | null, nodes?: Array<{ __typename?: 'Node', metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'NodeStatus', phase?: string | null, allocatable?: Record<string, unknown> | null, capacity?: Record<string, unknown> | null, conditions?: Array<{ __typename?: 'NodeCondition', type?: string | null, status?: string | null, message?: string | null } | null> | null }, spec: { __typename?: 'NodeSpec', podCidr?: string | null, providerId?: string | null } } | null> | null, nodeMetrics?: Array<{ __typename?: 'NodeMetric', timestamp?: string | null, window?: string | null, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, usage?: { __typename?: 'NodeUsage', cpu?: string | null, memory?: string | null } | null } | null> | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null };

export type ClustersTinyQueryVariables = Exact<{
  projectId?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
}>;


export type ClustersTinyQuery = { __typename?: 'RootQueryType', clusters?: { __typename?: 'ClusterConnection', edges?: Array<{ __typename?: 'ClusterEdge', node?: { __typename?: 'Cluster', self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null } | null };

export type VClustersQueryVariables = Exact<{
  parentId: Scalars['ID']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
  healthy?: InputMaybe<Scalars['Boolean']['input']>;
  projectId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type VClustersQuery = { __typename?: 'RootQueryType', tags?: Array<string | null> | null, clusters?: { __typename?: 'ClusterConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ClusterEdge', node?: { __typename?: 'Cluster', currentVersion?: string | null, id: string, self?: boolean | null, healthy?: boolean | null, healthScore?: number | null, protect?: boolean | null, name: string, handle?: string | null, distro?: ClusterDistro | null, cpuTotal?: number | null, memoryTotal?: number | null, cpuUtil?: number | null, nodeCount?: number | null, namespaceCount?: number | null, availabilityZones?: Array<string | null> | null, podCount?: number | null, memoryUtil?: number | null, installed?: boolean | null, pingedAt?: string | null, deletedAt?: string | null, version?: string | null, kubeletVersion?: string | null, virtual?: boolean | null, provider?: { __typename?: 'ClusterProvider', id: string, cloud: string, name: string, namespace: string, supportedVersions?: Array<string | null> | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, repository?: { __typename?: 'GitRepository', url: string } | null } | null, tags?: Array<{ __typename?: 'Tag', name: string, value: string } | null> | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null, kubeletSkew?: boolean | null } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null } | null> | null } | null };

export type ClusterSelectorQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
  currentClusterId?: InputMaybe<Scalars['ID']['input']>;
  projectId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type ClusterSelectorQuery = { __typename?: 'RootQueryType', clusters?: { __typename?: 'ClusterConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ClusterEdge', node?: { __typename?: 'Cluster', self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null } | null, cluster?: { __typename?: 'Cluster', self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null };

export type ClusterQueryVariables = Exact<{
  id?: InputMaybe<Scalars['ID']['input']>;
  handle?: InputMaybe<Scalars['String']['input']>;
}>;


export type ClusterQuery = { __typename?: 'RootQueryType', cluster?: { __typename?: 'Cluster', currentVersion?: string | null, id: string, name: string, handle?: string | null, metadata?: Record<string, unknown> | null, pingedAt?: string | null, self?: boolean | null, version?: string | null, healthy?: boolean | null, healthScore?: number | null, protect?: boolean | null, distro?: ClusterDistro | null, cpuTotal?: number | null, memoryTotal?: number | null, cpuUtil?: number | null, nodeCount?: number | null, namespaceCount?: number | null, availabilityZones?: Array<string | null> | null, podCount?: number | null, memoryUtil?: number | null, installed?: boolean | null, deletedAt?: string | null, kubeletVersion?: string | null, virtual?: boolean | null, apiDeprecations?: Array<{ __typename?: 'ApiDeprecation', availableIn?: string | null, blocking?: boolean | null, deprecatedIn?: string | null, removedIn?: string | null, replacement?: string | null, component?: { __typename?: 'ServiceComponent', group?: string | null, version?: string | null, kind: string, name: string, namespace?: string | null, service?: { __typename?: 'ServiceDeployment', git?: { __typename?: 'GitRef', ref: string, folder: string } | null, repository?: { __typename?: 'GitRepository', httpsPath?: string | null, urlFormat?: string | null } | null } | null } | null } | null> | null, nodePools?: Array<{ __typename?: 'NodePool', id: string, name: string, minSize: number, maxSize: number, instanceType: string, spot?: boolean | null, labels?: Record<string, unknown> | null, taints?: Array<{ __typename?: 'Taint', effect: string, key: string, value: string } | null> | null } | null> | null, provider?: { __typename?: 'ClusterProvider', id: string, cloud: string, name: string, namespace: string, supportedVersions?: Array<string | null> | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, repository?: { __typename?: 'GitRepository', url: string } | null } | null, tags?: Array<{ __typename?: 'Tag', name: string, value: string } | null> | null, parentCluster?: { __typename?: 'Cluster', currentVersion?: string | null, id: string, self?: boolean | null, healthy?: boolean | null, healthScore?: number | null, protect?: boolean | null, name: string, handle?: string | null, distro?: ClusterDistro | null, cpuTotal?: number | null, memoryTotal?: number | null, cpuUtil?: number | null, nodeCount?: number | null, namespaceCount?: number | null, availabilityZones?: Array<string | null> | null, podCount?: number | null, memoryUtil?: number | null, installed?: boolean | null, pingedAt?: string | null, deletedAt?: string | null, version?: string | null, kubeletVersion?: string | null, virtual?: boolean | null, provider?: { __typename?: 'ClusterProvider', id: string, cloud: string, name: string, namespace: string, supportedVersions?: Array<string | null> | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, repository?: { __typename?: 'GitRepository', url: string } | null } | null, tags?: Array<{ __typename?: 'Tag', name: string, value: string } | null> | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null, kubeletSkew?: boolean | null } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null, operationalLayout?: { __typename?: 'OperationalLayout', serviceMesh?: ServiceMesh | null } | null, alerts?: { __typename?: 'AlertConnection', edges?: Array<{ __typename?: 'AlertEdge', node?: { __typename?: 'Alert', id: string } | null } | null> | null } | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null, kubeletSkew?: boolean | null } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null };

export type ClusterBasicQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type ClusterBasicQuery = { __typename?: 'RootQueryType', cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null };

export type ClusterInsightQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type ClusterInsightQuery = { __typename?: 'RootQueryType', cluster?: { __typename?: 'Cluster', id: string, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null, insightComponents?: Array<{ __typename?: 'ClusterInsightComponent', id: string, kind: string, name: string, namespace?: string | null, group?: string | null, version: string, priority?: InsightComponentPriority | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null> | null } | null };

export type ClusterNodesQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type ClusterNodesQuery = { __typename?: 'RootQueryType', cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, nodes?: Array<{ __typename?: 'Node', metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'NodeStatus', phase?: string | null, allocatable?: Record<string, unknown> | null, capacity?: Record<string, unknown> | null, conditions?: Array<{ __typename?: 'NodeCondition', type?: string | null, status?: string | null, message?: string | null } | null> | null }, spec: { __typename?: 'NodeSpec', podCidr?: string | null, providerId?: string | null } } | null> | null, nodeMetrics?: Array<{ __typename?: 'NodeMetric', timestamp?: string | null, window?: string | null, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, usage?: { __typename?: 'NodeUsage', cpu?: string | null, memory?: string | null } | null } | null> | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null };

export type ClusterPodsQueryVariables = Exact<{
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
}>;


export type ClusterPodsQuery = { __typename?: 'RootQueryType', pods?: { __typename?: 'PodConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'PodEdge', node?: { __typename?: 'Pod', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'PodStatus', phase?: string | null, podIp?: string | null, reason?: string | null, containerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, initContainerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, conditions?: Array<{ __typename?: 'PodCondition', lastProbeTime?: string | null, lastTransitionTime?: string | null, message?: string | null, reason?: string | null, status?: string | null, type?: string | null } | null> | null }, spec: { __typename?: 'PodSpec', nodeName?: string | null, serviceAccountName?: string | null, containers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null, initContainers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null } } | null } | null> | null } | null };

export type ClusterNamespacesQueryVariables = Exact<{
  clusterId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type ClusterNamespacesQuery = { __typename?: 'RootQueryType', namespaces?: Array<{ __typename?: 'Namespace', metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null } } | null> | null };

export type PolicyBindingFragment = { __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null };

export type ClusterBindingsFragment = { __typename?: 'Cluster', id: string, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null };

export type ClusterBindingsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type ClusterBindingsQuery = { __typename?: 'RootQueryType', cluster?: { __typename?: 'Cluster', id: string, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null } | null };

export type RuntimeServicesQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  kubeVersion: Scalars['String']['input'];
  hasKubeVersion: Scalars['Boolean']['input'];
}>;


export type RuntimeServicesQuery = { __typename?: 'RootQueryType', cluster?: { __typename?: 'Cluster', id: string, name: string, currentVersion?: string | null, version?: string | null, runtimeServices?: Array<{ __typename?: 'RuntimeService', id: string, name: string, version: string, addon?: { __typename?: 'RuntimeAddon', icon?: string | null, versions?: Array<{ __typename?: 'AddonVersion', version?: string | null, kube?: Array<string | null> | null, chartVersion?: string | null, incompatibilities?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null, requirements?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null } | null> | null } | null, service?: { __typename?: 'ServiceDeployment', git?: { __typename?: 'GitRef', ref: string, folder: string } | null, repository?: { __typename?: 'GitRepository', httpsPath?: string | null, urlFormat?: string | null } | null, helm?: { __typename?: 'HelmSpec', version?: string | null } | null } | null, addonVersion?: { __typename?: 'AddonVersion', blocking?: boolean | null, version?: string | null, kube?: Array<string | null> | null, chartVersion?: string | null, incompatibilities?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null, requirements?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null } | null } | null> | null, apiDeprecations?: Array<{ __typename?: 'ApiDeprecation', availableIn?: string | null, blocking?: boolean | null, deprecatedIn?: string | null, removedIn?: string | null, replacement?: string | null, component?: { __typename?: 'ServiceComponent', group?: string | null, version?: string | null, kind: string, name: string, namespace?: string | null, service?: { __typename?: 'ServiceDeployment', git?: { __typename?: 'GitRef', ref: string, folder: string } | null, repository?: { __typename?: 'GitRepository', httpsPath?: string | null, urlFormat?: string | null } | null } | null } | null } | null> | null, upgradeInsights?: Array<{ __typename?: 'UpgradeInsight', id: string, name: string, description?: string | null, refreshedAt?: string | null, transitionedAt?: string | null, version?: string | null, status?: UpgradeInsightStatus | null, details?: Array<{ __typename?: 'UpgradeInsightDetail', id: string, removedIn?: string | null, replacedIn?: string | null, replacement?: string | null, status?: UpgradeInsightStatus | null, used?: string | null, clientInfo?: Array<{ __typename?: 'InsightClientInfo', userAgent?: string | null, count?: string | null, lastRequestAt?: string | null } | null> | null } | null> | null } | null> | null, cloudAddons?: Array<{ __typename?: 'CloudAddon', id: string, insertedAt?: string | null, updatedAt?: string | null, name: string, distro: ClusterDistro, version: string, info?: { __typename?: 'CloudAddonInformation', name?: string | null, publisher?: string | null, versions?: Array<{ __typename?: 'CloudAddonVersionInformation', version?: string | null, compatibilities?: Array<string | null> | null, blocking?: boolean | null } | null> | null } | null, versionInfo?: { __typename?: 'CloudAddonVersionInformation', version?: string | null, compatibilities?: Array<string | null> | null, blocking?: boolean | null } | null } | null> | null } | null };

export type RuntimeServiceQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  version: Scalars['String']['input'];
  kubeVersion: Scalars['String']['input'];
  hasKubeVersion: Scalars['Boolean']['input'];
}>;


export type RuntimeServiceQuery = { __typename?: 'RootQueryType', runtimeService?: { __typename?: 'RuntimeService', id: string, name: string, version: string, addon?: { __typename?: 'RuntimeAddon', icon?: string | null, releaseUrl?: string | null, readme?: string | null, versions?: Array<{ __typename?: 'AddonVersion', version?: string | null, kube?: Array<string | null> | null, chartVersion?: string | null, incompatibilities?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null, requirements?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null } | null> | null } | null, addonVersion?: { __typename?: 'AddonVersion', blocking?: boolean | null, version?: string | null, kube?: Array<string | null> | null, chartVersion?: string | null, incompatibilities?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null, requirements?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null } | null } | null };

export type UpdateClusterBindingsMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  rbac: RbacAttributes;
}>;


export type UpdateClusterBindingsMutation = { __typename?: 'RootMutationType', updateRbac?: boolean | null };

export type UpdateClusterMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  attributes: ClusterUpdateAttributes;
}>;


export type UpdateClusterMutation = { __typename?: 'RootMutationType', updateCluster?: { __typename?: 'Cluster', currentVersion?: string | null, id: string, name: string, handle?: string | null, metadata?: Record<string, unknown> | null, pingedAt?: string | null, self?: boolean | null, version?: string | null, healthy?: boolean | null, healthScore?: number | null, protect?: boolean | null, distro?: ClusterDistro | null, cpuTotal?: number | null, memoryTotal?: number | null, cpuUtil?: number | null, nodeCount?: number | null, namespaceCount?: number | null, availabilityZones?: Array<string | null> | null, podCount?: number | null, memoryUtil?: number | null, installed?: boolean | null, deletedAt?: string | null, kubeletVersion?: string | null, virtual?: boolean | null, apiDeprecations?: Array<{ __typename?: 'ApiDeprecation', availableIn?: string | null, blocking?: boolean | null, deprecatedIn?: string | null, removedIn?: string | null, replacement?: string | null, component?: { __typename?: 'ServiceComponent', group?: string | null, version?: string | null, kind: string, name: string, namespace?: string | null, service?: { __typename?: 'ServiceDeployment', git?: { __typename?: 'GitRef', ref: string, folder: string } | null, repository?: { __typename?: 'GitRepository', httpsPath?: string | null, urlFormat?: string | null } | null } | null } | null } | null> | null, nodePools?: Array<{ __typename?: 'NodePool', id: string, name: string, minSize: number, maxSize: number, instanceType: string, spot?: boolean | null, labels?: Record<string, unknown> | null, taints?: Array<{ __typename?: 'Taint', effect: string, key: string, value: string } | null> | null } | null> | null, provider?: { __typename?: 'ClusterProvider', id: string, cloud: string, name: string, namespace: string, supportedVersions?: Array<string | null> | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, repository?: { __typename?: 'GitRepository', url: string } | null } | null, tags?: Array<{ __typename?: 'Tag', name: string, value: string } | null> | null, parentCluster?: { __typename?: 'Cluster', currentVersion?: string | null, id: string, self?: boolean | null, healthy?: boolean | null, healthScore?: number | null, protect?: boolean | null, name: string, handle?: string | null, distro?: ClusterDistro | null, cpuTotal?: number | null, memoryTotal?: number | null, cpuUtil?: number | null, nodeCount?: number | null, namespaceCount?: number | null, availabilityZones?: Array<string | null> | null, podCount?: number | null, memoryUtil?: number | null, installed?: boolean | null, pingedAt?: string | null, deletedAt?: string | null, version?: string | null, kubeletVersion?: string | null, virtual?: boolean | null, provider?: { __typename?: 'ClusterProvider', id: string, cloud: string, name: string, namespace: string, supportedVersions?: Array<string | null> | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, repository?: { __typename?: 'GitRepository', url: string } | null } | null, tags?: Array<{ __typename?: 'Tag', name: string, value: string } | null> | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null, kubeletSkew?: boolean | null } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null, operationalLayout?: { __typename?: 'OperationalLayout', serviceMesh?: ServiceMesh | null } | null, alerts?: { __typename?: 'AlertConnection', edges?: Array<{ __typename?: 'AlertEdge', node?: { __typename?: 'Alert', id: string } | null } | null> | null } | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null, kubeletSkew?: boolean | null } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null };

export type CreateClusterMutationVariables = Exact<{
  attributes: ClusterAttributes;
}>;


export type CreateClusterMutation = { __typename?: 'RootMutationType', createCluster?: { __typename?: 'Cluster', deployToken?: string | null, currentVersion?: string | null, id: string, name: string, handle?: string | null, metadata?: Record<string, unknown> | null, pingedAt?: string | null, self?: boolean | null, version?: string | null, healthy?: boolean | null, healthScore?: number | null, protect?: boolean | null, distro?: ClusterDistro | null, cpuTotal?: number | null, memoryTotal?: number | null, cpuUtil?: number | null, nodeCount?: number | null, namespaceCount?: number | null, availabilityZones?: Array<string | null> | null, podCount?: number | null, memoryUtil?: number | null, installed?: boolean | null, deletedAt?: string | null, kubeletVersion?: string | null, virtual?: boolean | null, apiDeprecations?: Array<{ __typename?: 'ApiDeprecation', availableIn?: string | null, blocking?: boolean | null, deprecatedIn?: string | null, removedIn?: string | null, replacement?: string | null, component?: { __typename?: 'ServiceComponent', group?: string | null, version?: string | null, kind: string, name: string, namespace?: string | null, service?: { __typename?: 'ServiceDeployment', git?: { __typename?: 'GitRef', ref: string, folder: string } | null, repository?: { __typename?: 'GitRepository', httpsPath?: string | null, urlFormat?: string | null } | null } | null } | null } | null> | null, nodePools?: Array<{ __typename?: 'NodePool', id: string, name: string, minSize: number, maxSize: number, instanceType: string, spot?: boolean | null, labels?: Record<string, unknown> | null, taints?: Array<{ __typename?: 'Taint', effect: string, key: string, value: string } | null> | null } | null> | null, provider?: { __typename?: 'ClusterProvider', id: string, cloud: string, name: string, namespace: string, supportedVersions?: Array<string | null> | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, repository?: { __typename?: 'GitRepository', url: string } | null } | null, tags?: Array<{ __typename?: 'Tag', name: string, value: string } | null> | null, parentCluster?: { __typename?: 'Cluster', currentVersion?: string | null, id: string, self?: boolean | null, healthy?: boolean | null, healthScore?: number | null, protect?: boolean | null, name: string, handle?: string | null, distro?: ClusterDistro | null, cpuTotal?: number | null, memoryTotal?: number | null, cpuUtil?: number | null, nodeCount?: number | null, namespaceCount?: number | null, availabilityZones?: Array<string | null> | null, podCount?: number | null, memoryUtil?: number | null, installed?: boolean | null, pingedAt?: string | null, deletedAt?: string | null, version?: string | null, kubeletVersion?: string | null, virtual?: boolean | null, provider?: { __typename?: 'ClusterProvider', id: string, cloud: string, name: string, namespace: string, supportedVersions?: Array<string | null> | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, repository?: { __typename?: 'GitRepository', url: string } | null } | null, tags?: Array<{ __typename?: 'Tag', name: string, value: string } | null> | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null, kubeletSkew?: boolean | null } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null, operationalLayout?: { __typename?: 'OperationalLayout', serviceMesh?: ServiceMesh | null } | null, alerts?: { __typename?: 'AlertConnection', edges?: Array<{ __typename?: 'AlertEdge', node?: { __typename?: 'Alert', id: string } | null } | null> | null } | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null, kubeletSkew?: boolean | null } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null };

export type DeleteClusterMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteClusterMutation = { __typename?: 'RootMutationType', deleteCluster?: { __typename?: 'Cluster', currentVersion?: string | null, id: string, name: string, handle?: string | null, metadata?: Record<string, unknown> | null, pingedAt?: string | null, self?: boolean | null, version?: string | null, healthy?: boolean | null, healthScore?: number | null, protect?: boolean | null, distro?: ClusterDistro | null, cpuTotal?: number | null, memoryTotal?: number | null, cpuUtil?: number | null, nodeCount?: number | null, namespaceCount?: number | null, availabilityZones?: Array<string | null> | null, podCount?: number | null, memoryUtil?: number | null, installed?: boolean | null, deletedAt?: string | null, kubeletVersion?: string | null, virtual?: boolean | null, apiDeprecations?: Array<{ __typename?: 'ApiDeprecation', availableIn?: string | null, blocking?: boolean | null, deprecatedIn?: string | null, removedIn?: string | null, replacement?: string | null, component?: { __typename?: 'ServiceComponent', group?: string | null, version?: string | null, kind: string, name: string, namespace?: string | null, service?: { __typename?: 'ServiceDeployment', git?: { __typename?: 'GitRef', ref: string, folder: string } | null, repository?: { __typename?: 'GitRepository', httpsPath?: string | null, urlFormat?: string | null } | null } | null } | null } | null> | null, nodePools?: Array<{ __typename?: 'NodePool', id: string, name: string, minSize: number, maxSize: number, instanceType: string, spot?: boolean | null, labels?: Record<string, unknown> | null, taints?: Array<{ __typename?: 'Taint', effect: string, key: string, value: string } | null> | null } | null> | null, provider?: { __typename?: 'ClusterProvider', id: string, cloud: string, name: string, namespace: string, supportedVersions?: Array<string | null> | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, repository?: { __typename?: 'GitRepository', url: string } | null } | null, tags?: Array<{ __typename?: 'Tag', name: string, value: string } | null> | null, parentCluster?: { __typename?: 'Cluster', currentVersion?: string | null, id: string, self?: boolean | null, healthy?: boolean | null, healthScore?: number | null, protect?: boolean | null, name: string, handle?: string | null, distro?: ClusterDistro | null, cpuTotal?: number | null, memoryTotal?: number | null, cpuUtil?: number | null, nodeCount?: number | null, namespaceCount?: number | null, availabilityZones?: Array<string | null> | null, podCount?: number | null, memoryUtil?: number | null, installed?: boolean | null, pingedAt?: string | null, deletedAt?: string | null, version?: string | null, kubeletVersion?: string | null, virtual?: boolean | null, provider?: { __typename?: 'ClusterProvider', id: string, cloud: string, name: string, namespace: string, supportedVersions?: Array<string | null> | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, repository?: { __typename?: 'GitRepository', url: string } | null } | null, tags?: Array<{ __typename?: 'Tag', name: string, value: string } | null> | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null, kubeletSkew?: boolean | null } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null, operationalLayout?: { __typename?: 'OperationalLayout', serviceMesh?: ServiceMesh | null } | null, alerts?: { __typename?: 'AlertConnection', edges?: Array<{ __typename?: 'AlertEdge', node?: { __typename?: 'Alert', id: string } | null } | null> | null } | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null, kubeletSkew?: boolean | null } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null };

export type DetachClusterMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DetachClusterMutation = { __typename?: 'RootMutationType', detachCluster?: { __typename?: 'Cluster', currentVersion?: string | null, id: string, name: string, handle?: string | null, metadata?: Record<string, unknown> | null, pingedAt?: string | null, self?: boolean | null, version?: string | null, healthy?: boolean | null, healthScore?: number | null, protect?: boolean | null, distro?: ClusterDistro | null, cpuTotal?: number | null, memoryTotal?: number | null, cpuUtil?: number | null, nodeCount?: number | null, namespaceCount?: number | null, availabilityZones?: Array<string | null> | null, podCount?: number | null, memoryUtil?: number | null, installed?: boolean | null, deletedAt?: string | null, kubeletVersion?: string | null, virtual?: boolean | null, apiDeprecations?: Array<{ __typename?: 'ApiDeprecation', availableIn?: string | null, blocking?: boolean | null, deprecatedIn?: string | null, removedIn?: string | null, replacement?: string | null, component?: { __typename?: 'ServiceComponent', group?: string | null, version?: string | null, kind: string, name: string, namespace?: string | null, service?: { __typename?: 'ServiceDeployment', git?: { __typename?: 'GitRef', ref: string, folder: string } | null, repository?: { __typename?: 'GitRepository', httpsPath?: string | null, urlFormat?: string | null } | null } | null } | null } | null> | null, nodePools?: Array<{ __typename?: 'NodePool', id: string, name: string, minSize: number, maxSize: number, instanceType: string, spot?: boolean | null, labels?: Record<string, unknown> | null, taints?: Array<{ __typename?: 'Taint', effect: string, key: string, value: string } | null> | null } | null> | null, provider?: { __typename?: 'ClusterProvider', id: string, cloud: string, name: string, namespace: string, supportedVersions?: Array<string | null> | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, repository?: { __typename?: 'GitRepository', url: string } | null } | null, tags?: Array<{ __typename?: 'Tag', name: string, value: string } | null> | null, parentCluster?: { __typename?: 'Cluster', currentVersion?: string | null, id: string, self?: boolean | null, healthy?: boolean | null, healthScore?: number | null, protect?: boolean | null, name: string, handle?: string | null, distro?: ClusterDistro | null, cpuTotal?: number | null, memoryTotal?: number | null, cpuUtil?: number | null, nodeCount?: number | null, namespaceCount?: number | null, availabilityZones?: Array<string | null> | null, podCount?: number | null, memoryUtil?: number | null, installed?: boolean | null, pingedAt?: string | null, deletedAt?: string | null, version?: string | null, kubeletVersion?: string | null, virtual?: boolean | null, provider?: { __typename?: 'ClusterProvider', id: string, cloud: string, name: string, namespace: string, supportedVersions?: Array<string | null> | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, repository?: { __typename?: 'GitRepository', url: string } | null } | null, tags?: Array<{ __typename?: 'Tag', name: string, value: string } | null> | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null, kubeletSkew?: boolean | null } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null, operationalLayout?: { __typename?: 'OperationalLayout', serviceMesh?: ServiceMesh | null } | null, alerts?: { __typename?: 'AlertConnection', edges?: Array<{ __typename?: 'AlertEdge', node?: { __typename?: 'Alert', id: string } | null } | null> | null } | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null, kubeletSkew?: boolean | null } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null };

export type ClusterStatusInfoFragment = { __typename?: 'ClusterStatusInfo', count?: number | null, healthy?: boolean | null };

export type ClusterStatusesQueryVariables = Exact<{ [key: string]: never; }>;


export type ClusterStatusesQuery = { __typename?: 'RootQueryType', clusterStatuses?: Array<{ __typename?: 'ClusterStatusInfo', count?: number | null, healthy?: boolean | null } | null> | null };

export type TagPairsQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
  tag?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<TagType>;
}>;


export type TagPairsQuery = { __typename?: 'RootQueryType', tagPairs?: { __typename?: 'TagConnection', edges?: Array<{ __typename?: 'TagEdge', node?: { __typename?: 'Tag', name: string, value: string, id: string } | null } | null> | null } | null };

export type ClusterMetricsQueryVariables = Exact<{
  clusterId: Scalars['ID']['input'];
  start?: InputMaybe<Scalars['DateTime']['input']>;
  stop?: InputMaybe<Scalars['DateTime']['input']>;
  step?: InputMaybe<Scalars['String']['input']>;
}>;


export type ClusterMetricsQuery = { __typename?: 'RootQueryType', cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, clusterMetrics?: { __typename?: 'ClusterMetrics', cpu?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null, cpuUsage?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null, cpuRequests?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null, cpuLimits?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null, memory?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null, memoryUsage?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null, memoryRequests?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null, memoryLimits?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null, pods?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null } | null, nodes?: Array<{ __typename?: 'Node', metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'NodeStatus', phase?: string | null, allocatable?: Record<string, unknown> | null, capacity?: Record<string, unknown> | null, conditions?: Array<{ __typename?: 'NodeCondition', type?: string | null, status?: string | null, message?: string | null } | null> | null }, spec: { __typename?: 'NodeSpec', podCidr?: string | null, providerId?: string | null } } | null> | null, nodeMetrics?: Array<{ __typename?: 'NodeMetric', timestamp?: string | null, window?: string | null, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, usage?: { __typename?: 'NodeUsage', cpu?: string | null, memory?: string | null } | null } | null> | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null };

export type ClusterNodeMetricsQueryVariables = Exact<{
  clusterId: Scalars['ID']['input'];
  node: Scalars['String']['input'];
  start?: InputMaybe<Scalars['DateTime']['input']>;
  stop?: InputMaybe<Scalars['DateTime']['input']>;
  step?: InputMaybe<Scalars['String']['input']>;
}>;


export type ClusterNodeMetricsQuery = { __typename?: 'RootQueryType', cluster?: { __typename?: 'Cluster', id: string, clusterNodeMetrics?: { __typename?: 'ClusterNodeMetrics', cpu?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null, cpuUsage?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null, memory?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null, memoryUsage?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null } | null } | null };

export type NetworkMeshWorkloadFragment = { __typename?: 'NetworkMeshWorkload', id: string, name: string, namespace?: string | null, service?: string | null };

export type NetworkMeshStatisticsFragment = { __typename?: 'NetworkMeshStatistics', bytes?: number | null, packets?: number | null, connections?: number | null, http200?: number | null, http400?: number | null, http500?: number | null, httpClientLatency?: number | null };

export type NetworkMeshEdgeFragment = { __typename?: 'NetworkMeshEdge', id: string, from: { __typename?: 'NetworkMeshWorkload', id: string, name: string, namespace?: string | null, service?: string | null }, to: { __typename?: 'NetworkMeshWorkload', id: string, name: string, namespace?: string | null, service?: string | null }, statistics: { __typename?: 'NetworkMeshStatistics', bytes?: number | null, packets?: number | null, connections?: number | null, http200?: number | null, http400?: number | null, http500?: number | null, httpClientLatency?: number | null } };

export type ClusterNetworkGraphQueryVariables = Exact<{
  clusterId: Scalars['ID']['input'];
  time?: InputMaybe<Scalars['DateTime']['input']>;
}>;


export type ClusterNetworkGraphQuery = { __typename?: 'RootQueryType', cluster?: { __typename?: 'Cluster', id: string, networkGraph?: Array<{ __typename?: 'NetworkMeshEdge', id: string, from: { __typename?: 'NetworkMeshWorkload', id: string, name: string, namespace?: string | null, service?: string | null }, to: { __typename?: 'NetworkMeshWorkload', id: string, name: string, namespace?: string | null, service?: string | null }, statistics: { __typename?: 'NetworkMeshStatistics', bytes?: number | null, packets?: number | null, connections?: number | null, http200?: number | null, http400?: number | null, http500?: number | null, httpClientLatency?: number | null } } | null> | null } | null };

export type ComponentMetricsFragmentFragment = { __typename?: 'ServiceDeployment', componentMetrics?: { __typename?: 'ServiceComponentMetrics', cpu?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null, mem?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null, podCpu?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null, podMem?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null } | null };

export type ServiceDeploymentComponentMetricsQueryVariables = Exact<{
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  cluster?: InputMaybe<Scalars['String']['input']>;
  componentId: Scalars['ID']['input'];
  start?: InputMaybe<Scalars['DateTime']['input']>;
  stop?: InputMaybe<Scalars['DateTime']['input']>;
  step?: InputMaybe<Scalars['String']['input']>;
}>;


export type ServiceDeploymentComponentMetricsQuery = { __typename?: 'RootQueryType', serviceDeployment?: { __typename?: 'ServiceDeployment', componentMetrics?: { __typename?: 'ServiceComponentMetrics', cpu?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null, mem?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null, podCpu?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null, podMem?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null } | null } | null };

export type UsageQueryVariables = Exact<{
  cpu: Scalars['String']['input'];
  mem: Scalars['String']['input'];
  podCpu: Scalars['String']['input'];
  podMem: Scalars['String']['input'];
  step: Scalars['String']['input'];
  offset: Scalars['Int']['input'];
  clusterId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type UsageQuery = { __typename?: 'RootQueryType', cpu?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null, mem?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null, podCpu?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null, podMem?: Array<{ __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null } | null> | null };

export type GitRepositoryFragment = { __typename?: 'GitRepository', id: string, url: string, health?: GitHealth | null, authMethod?: AuthMethod | null, editable?: boolean | null, error?: string | null, insertedAt?: string | null, pulledAt?: string | null, updatedAt?: string | null, urlFormat?: string | null, httpsPath?: string | null };

export type HelmRepositoryFragment = { __typename?: 'HelmRepository', id: string, url: string, health?: GitHealth | null, provider?: HelmAuthProvider | null, insertedAt?: string | null, pulledAt?: string | null, updatedAt?: string | null };

export type FluxHelmRepositoryFragment = { __typename?: 'FluxHelmRepository', metadata: { __typename?: 'Metadata', namespace?: string | null, name: string }, spec: { __typename?: 'HelmRepositorySpec', url: string, type?: string | null, provider?: string | null }, status?: { __typename?: 'HelmRepositoryStatus', ready?: boolean | null, message?: string | null } | null };

export type HelmChartVersionFragment = { __typename?: 'HelmChartVersion', name?: string | null, appVersion?: string | null, version?: string | null, digest?: string | null };

export type GitRepositoriesQueryVariables = Exact<{ [key: string]: never; }>;


export type GitRepositoriesQuery = { __typename?: 'RootQueryType', gitRepositories?: { __typename?: 'GitRepositoryConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'GitRepositoryEdge', node?: { __typename?: 'GitRepository', id: string, url: string, health?: GitHealth | null, authMethod?: AuthMethod | null, editable?: boolean | null, error?: string | null, insertedAt?: string | null, pulledAt?: string | null, updatedAt?: string | null, urlFormat?: string | null, httpsPath?: string | null } | null } | null> | null } | null };

export type HelmRepositoriesQueryVariables = Exact<{ [key: string]: never; }>;


export type HelmRepositoriesQuery = { __typename?: 'RootQueryType', helmRepositories?: { __typename?: 'HelmRepositoryConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'HelmRepositoryEdge', node?: { __typename?: 'HelmRepository', id: string, url: string, health?: GitHealth | null, provider?: HelmAuthProvider | null, insertedAt?: string | null, pulledAt?: string | null, updatedAt?: string | null } | null } | null> | null } | null };

export type FluxHelmRepositoriesQueryVariables = Exact<{ [key: string]: never; }>;


export type FluxHelmRepositoriesQuery = { __typename?: 'RootQueryType', fluxHelmRepositories?: Array<{ __typename?: 'FluxHelmRepository', metadata: { __typename?: 'Metadata', namespace?: string | null, name: string }, spec: { __typename?: 'HelmRepositorySpec', url: string, type?: string | null, provider?: string | null }, status?: { __typename?: 'HelmRepositoryStatus', ready?: boolean | null, message?: string | null } | null } | null> | null };

export type FluxHelmRepositoryQueryVariables = Exact<{
  namespace: Scalars['String']['input'];
  name: Scalars['String']['input'];
}>;


export type FluxHelmRepositoryQuery = { __typename?: 'RootQueryType', fluxHelmRepository?: { __typename?: 'FluxHelmRepository', charts?: Array<{ __typename?: 'HelmChartEntry', name?: string | null, versions?: Array<{ __typename?: 'HelmChartVersion', name?: string | null, appVersion?: string | null, version?: string | null, digest?: string | null } | null> | null } | null> | null, metadata: { __typename?: 'Metadata', namespace?: string | null, name: string }, spec: { __typename?: 'HelmRepositorySpec', url: string, type?: string | null, provider?: string | null }, status?: { __typename?: 'HelmRepositoryStatus', ready?: boolean | null, message?: string | null } | null } | null };

export type GitRepositoryQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GitRepositoryQuery = { __typename?: 'RootQueryType', gitRepository?: { __typename?: 'GitRepository', refs?: Array<string> | null } | null };

export type CreateGitRepositoryMutationVariables = Exact<{
  attributes: GitAttributes;
}>;


export type CreateGitRepositoryMutation = { __typename?: 'RootMutationType', createGitRepository?: { __typename?: 'GitRepository', id: string, url: string, health?: GitHealth | null, authMethod?: AuthMethod | null, editable?: boolean | null, error?: string | null, insertedAt?: string | null, pulledAt?: string | null, updatedAt?: string | null, urlFormat?: string | null, httpsPath?: string | null } | null };

export type DeleteGitRepositoryMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteGitRepositoryMutation = { __typename?: 'RootMutationType', deleteGitRepository?: { __typename?: 'GitRepository', id: string } | null };

export type UpdateGitRepositoryMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  attributes: GitAttributes;
}>;


export type UpdateGitRepositoryMutation = { __typename?: 'RootMutationType', updateGitRepository?: { __typename?: 'GitRepository', id: string, url: string, health?: GitHealth | null, authMethod?: AuthMethod | null, editable?: boolean | null, error?: string | null, insertedAt?: string | null, pulledAt?: string | null, updatedAt?: string | null, urlFormat?: string | null, httpsPath?: string | null } | null };

export type GlobalServiceFragment = { __typename?: 'GlobalService', id: string, distro?: ClusterDistro | null, name: string, reparent?: boolean | null, insertedAt?: string | null, updatedAt?: string | null, mgmt?: boolean | null, project?: { __typename?: 'Project', id: string, name: string, default?: boolean | null, description?: string | null } | null, cascade?: { __typename?: 'Cascade', delete?: boolean | null, detach?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', id: string, name: string, cloud: string, namespace: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, promotion?: ServicePromotion | null, message?: string | null, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null, componentStatus?: string | null, status: ServiceDeploymentStatus, dryRun?: boolean | null, git?: { __typename?: 'GitRef', ref: string, folder: string } | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, version?: string | null, url?: string | null, repository?: { __typename?: 'ObjectReference', namespace?: string | null, name?: string | null } | null } | null, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, helmRepository?: { __typename?: 'FluxHelmRepository', spec: { __typename?: 'HelmRepositorySpec', url: string }, status?: { __typename?: 'HelmRepositoryStatus', ready?: boolean | null, message?: string | null } | null } | null, repository?: { __typename?: 'GitRepository', id: string, url: string } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string, warning?: boolean | null } | null> | null, globalService?: { __typename?: 'GlobalService', id: string, name: string } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null, tags?: Array<{ __typename?: 'Tag', name: string, value: string } | null> | null, template?: { __typename?: 'ServiceTemplate', contexts?: Array<string | null> | null, name?: string | null, namespace?: string | null, repositoryId?: string | null, templated?: boolean | null, dependencies?: Array<{ __typename?: 'ServiceDependency', id: string, name: string, status?: ServiceDeploymentStatus | null } | null> | null, git?: { __typename?: 'GitRef', folder: string, ref: string } | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, ignoreCrds?: boolean | null, ignoreHooks?: boolean | null, release?: string | null, url?: string | null, values?: string | null, valuesFiles?: Array<string | null> | null, version?: string | null, git?: { __typename?: 'GitRef', folder: string, ref: string } | null, repository?: { __typename?: 'ObjectReference', name?: string | null, namespace?: string | null } | null, set?: Array<{ __typename?: 'HelmValue', name: string, value: string } | null> | null } | null, kustomize?: { __typename?: 'Kustomize', path: string, enableHelm?: boolean | null } | null, repository?: { __typename?: 'GitRepository', id: string, url: string, health?: GitHealth | null, authMethod?: AuthMethod | null, editable?: boolean | null, error?: string | null, insertedAt?: string | null, pulledAt?: string | null, updatedAt?: string | null, urlFormat?: string | null, httpsPath?: string | null } | null, syncConfig?: { __typename?: 'SyncConfig', createNamespace?: boolean | null, enforceNamespace?: boolean | null, namespaceMetadata?: { __typename?: 'NamespaceMetadata', annotations?: Record<string, unknown> | null, labels?: Record<string, unknown> | null } | null } | null } | null, parent?: { __typename?: 'ServiceDeployment', id: string, name: string } | null };

export type ServiceTemplateWithoutConfigurationFragment = { __typename?: 'ServiceTemplate', contexts?: Array<string | null> | null, name?: string | null, namespace?: string | null, repositoryId?: string | null, templated?: boolean | null, dependencies?: Array<{ __typename?: 'ServiceDependency', id: string, name: string, status?: ServiceDeploymentStatus | null } | null> | null, git?: { __typename?: 'GitRef', folder: string, ref: string } | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, ignoreCrds?: boolean | null, ignoreHooks?: boolean | null, release?: string | null, url?: string | null, values?: string | null, valuesFiles?: Array<string | null> | null, version?: string | null, git?: { __typename?: 'GitRef', folder: string, ref: string } | null, repository?: { __typename?: 'ObjectReference', name?: string | null, namespace?: string | null } | null, set?: Array<{ __typename?: 'HelmValue', name: string, value: string } | null> | null } | null, kustomize?: { __typename?: 'Kustomize', path: string, enableHelm?: boolean | null } | null, repository?: { __typename?: 'GitRepository', id: string, url: string, health?: GitHealth | null, authMethod?: AuthMethod | null, editable?: boolean | null, error?: string | null, insertedAt?: string | null, pulledAt?: string | null, updatedAt?: string | null, urlFormat?: string | null, httpsPath?: string | null } | null, syncConfig?: { __typename?: 'SyncConfig', createNamespace?: boolean | null, enforceNamespace?: boolean | null, namespaceMetadata?: { __typename?: 'NamespaceMetadata', annotations?: Record<string, unknown> | null, labels?: Record<string, unknown> | null } | null } | null };

export type CreateGlobalServiceMutationVariables = Exact<{
  attributes: GlobalServiceAttributes;
  cluster?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  serviceId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type CreateGlobalServiceMutation = { __typename?: 'RootMutationType', createGlobalService?: { __typename?: 'GlobalService', id: string, distro?: ClusterDistro | null, name: string, reparent?: boolean | null, insertedAt?: string | null, updatedAt?: string | null, mgmt?: boolean | null, project?: { __typename?: 'Project', id: string, name: string, default?: boolean | null, description?: string | null } | null, cascade?: { __typename?: 'Cascade', delete?: boolean | null, detach?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', id: string, name: string, cloud: string, namespace: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, promotion?: ServicePromotion | null, message?: string | null, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null, componentStatus?: string | null, status: ServiceDeploymentStatus, dryRun?: boolean | null, git?: { __typename?: 'GitRef', ref: string, folder: string } | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, version?: string | null, url?: string | null, repository?: { __typename?: 'ObjectReference', namespace?: string | null, name?: string | null } | null } | null, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, helmRepository?: { __typename?: 'FluxHelmRepository', spec: { __typename?: 'HelmRepositorySpec', url: string }, status?: { __typename?: 'HelmRepositoryStatus', ready?: boolean | null, message?: string | null } | null } | null, repository?: { __typename?: 'GitRepository', id: string, url: string } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string, warning?: boolean | null } | null> | null, globalService?: { __typename?: 'GlobalService', id: string, name: string } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null, tags?: Array<{ __typename?: 'Tag', name: string, value: string } | null> | null, template?: { __typename?: 'ServiceTemplate', contexts?: Array<string | null> | null, name?: string | null, namespace?: string | null, repositoryId?: string | null, templated?: boolean | null, dependencies?: Array<{ __typename?: 'ServiceDependency', id: string, name: string, status?: ServiceDeploymentStatus | null } | null> | null, git?: { __typename?: 'GitRef', folder: string, ref: string } | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, ignoreCrds?: boolean | null, ignoreHooks?: boolean | null, release?: string | null, url?: string | null, values?: string | null, valuesFiles?: Array<string | null> | null, version?: string | null, git?: { __typename?: 'GitRef', folder: string, ref: string } | null, repository?: { __typename?: 'ObjectReference', name?: string | null, namespace?: string | null } | null, set?: Array<{ __typename?: 'HelmValue', name: string, value: string } | null> | null } | null, kustomize?: { __typename?: 'Kustomize', path: string, enableHelm?: boolean | null } | null, repository?: { __typename?: 'GitRepository', id: string, url: string, health?: GitHealth | null, authMethod?: AuthMethod | null, editable?: boolean | null, error?: string | null, insertedAt?: string | null, pulledAt?: string | null, updatedAt?: string | null, urlFormat?: string | null, httpsPath?: string | null } | null, syncConfig?: { __typename?: 'SyncConfig', createNamespace?: boolean | null, enforceNamespace?: boolean | null, namespaceMetadata?: { __typename?: 'NamespaceMetadata', annotations?: Record<string, unknown> | null, labels?: Record<string, unknown> | null } | null } | null } | null, parent?: { __typename?: 'ServiceDeployment', id: string, name: string } | null } | null };

export type UpdateGlobalServiceMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  attributes: GlobalServiceAttributes;
}>;


export type UpdateGlobalServiceMutation = { __typename?: 'RootMutationType', updateGlobalService?: { __typename?: 'GlobalService', id: string } | null };

export type DeleteGlobalServiceMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteGlobalServiceMutation = { __typename?: 'RootMutationType', deleteGlobalService?: { __typename?: 'GlobalService', id: string } | null };

export type GlobalServicesQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  projectId?: InputMaybe<Scalars['ID']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
}>;


export type GlobalServicesQuery = { __typename?: 'RootQueryType', globalServices?: { __typename?: 'GlobalServiceConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'GlobalServiceEdge', node?: { __typename?: 'GlobalService', id: string, distro?: ClusterDistro | null, name: string, reparent?: boolean | null, insertedAt?: string | null, updatedAt?: string | null, mgmt?: boolean | null, project?: { __typename?: 'Project', id: string, name: string, default?: boolean | null, description?: string | null } | null, cascade?: { __typename?: 'Cascade', delete?: boolean | null, detach?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', id: string, name: string, cloud: string, namespace: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, promotion?: ServicePromotion | null, message?: string | null, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null, componentStatus?: string | null, status: ServiceDeploymentStatus, dryRun?: boolean | null, git?: { __typename?: 'GitRef', ref: string, folder: string } | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, version?: string | null, url?: string | null, repository?: { __typename?: 'ObjectReference', namespace?: string | null, name?: string | null } | null } | null, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, helmRepository?: { __typename?: 'FluxHelmRepository', spec: { __typename?: 'HelmRepositorySpec', url: string }, status?: { __typename?: 'HelmRepositoryStatus', ready?: boolean | null, message?: string | null } | null } | null, repository?: { __typename?: 'GitRepository', id: string, url: string } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string, warning?: boolean | null } | null> | null, globalService?: { __typename?: 'GlobalService', id: string, name: string } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null, tags?: Array<{ __typename?: 'Tag', name: string, value: string } | null> | null, template?: { __typename?: 'ServiceTemplate', contexts?: Array<string | null> | null, name?: string | null, namespace?: string | null, repositoryId?: string | null, templated?: boolean | null, dependencies?: Array<{ __typename?: 'ServiceDependency', id: string, name: string, status?: ServiceDeploymentStatus | null } | null> | null, git?: { __typename?: 'GitRef', folder: string, ref: string } | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, ignoreCrds?: boolean | null, ignoreHooks?: boolean | null, release?: string | null, url?: string | null, values?: string | null, valuesFiles?: Array<string | null> | null, version?: string | null, git?: { __typename?: 'GitRef', folder: string, ref: string } | null, repository?: { __typename?: 'ObjectReference', name?: string | null, namespace?: string | null } | null, set?: Array<{ __typename?: 'HelmValue', name: string, value: string } | null> | null } | null, kustomize?: { __typename?: 'Kustomize', path: string, enableHelm?: boolean | null } | null, repository?: { __typename?: 'GitRepository', id: string, url: string, health?: GitHealth | null, authMethod?: AuthMethod | null, editable?: boolean | null, error?: string | null, insertedAt?: string | null, pulledAt?: string | null, updatedAt?: string | null, urlFormat?: string | null, httpsPath?: string | null } | null, syncConfig?: { __typename?: 'SyncConfig', createNamespace?: boolean | null, enforceNamespace?: boolean | null, namespaceMetadata?: { __typename?: 'NamespaceMetadata', annotations?: Record<string, unknown> | null, labels?: Record<string, unknown> | null } | null } | null } | null, parent?: { __typename?: 'ServiceDeployment', id: string, name: string } | null } | null } | null> | null } | null };

export type GetGlobalServiceQueryVariables = Exact<{
  serviceId: Scalars['ID']['input'];
}>;


export type GetGlobalServiceQuery = { __typename?: 'RootQueryType', globalService?: { __typename?: 'GlobalService', id: string, distro?: ClusterDistro | null, name: string, reparent?: boolean | null, insertedAt?: string | null, updatedAt?: string | null, mgmt?: boolean | null, project?: { __typename?: 'Project', id: string, name: string, default?: boolean | null, description?: string | null } | null, cascade?: { __typename?: 'Cascade', delete?: boolean | null, detach?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', id: string, name: string, cloud: string, namespace: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, promotion?: ServicePromotion | null, message?: string | null, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null, componentStatus?: string | null, status: ServiceDeploymentStatus, dryRun?: boolean | null, git?: { __typename?: 'GitRef', ref: string, folder: string } | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, version?: string | null, url?: string | null, repository?: { __typename?: 'ObjectReference', namespace?: string | null, name?: string | null } | null } | null, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, helmRepository?: { __typename?: 'FluxHelmRepository', spec: { __typename?: 'HelmRepositorySpec', url: string }, status?: { __typename?: 'HelmRepositoryStatus', ready?: boolean | null, message?: string | null } | null } | null, repository?: { __typename?: 'GitRepository', id: string, url: string } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string, warning?: boolean | null } | null> | null, globalService?: { __typename?: 'GlobalService', id: string, name: string } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null, tags?: Array<{ __typename?: 'Tag', name: string, value: string } | null> | null, template?: { __typename?: 'ServiceTemplate', contexts?: Array<string | null> | null, name?: string | null, namespace?: string | null, repositoryId?: string | null, templated?: boolean | null, dependencies?: Array<{ __typename?: 'ServiceDependency', id: string, name: string, status?: ServiceDeploymentStatus | null } | null> | null, git?: { __typename?: 'GitRef', folder: string, ref: string } | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, ignoreCrds?: boolean | null, ignoreHooks?: boolean | null, release?: string | null, url?: string | null, values?: string | null, valuesFiles?: Array<string | null> | null, version?: string | null, git?: { __typename?: 'GitRef', folder: string, ref: string } | null, repository?: { __typename?: 'ObjectReference', name?: string | null, namespace?: string | null } | null, set?: Array<{ __typename?: 'HelmValue', name: string, value: string } | null> | null } | null, kustomize?: { __typename?: 'Kustomize', path: string, enableHelm?: boolean | null } | null, repository?: { __typename?: 'GitRepository', id: string, url: string, health?: GitHealth | null, authMethod?: AuthMethod | null, editable?: boolean | null, error?: string | null, insertedAt?: string | null, pulledAt?: string | null, updatedAt?: string | null, urlFormat?: string | null, httpsPath?: string | null } | null, syncConfig?: { __typename?: 'SyncConfig', createNamespace?: boolean | null, enforceNamespace?: boolean | null, namespaceMetadata?: { __typename?: 'NamespaceMetadata', annotations?: Record<string, unknown> | null, labels?: Record<string, unknown> | null } | null } | null } | null, parent?: { __typename?: 'ServiceDeployment', id: string, name: string } | null } | null };

export type GetGlobalServiceServicesQueryVariables = Exact<{
  serviceId: Scalars['ID']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetGlobalServiceServicesQuery = { __typename?: 'RootQueryType', globalService?: { __typename?: 'GlobalService', services?: { __typename?: 'ServiceDeploymentConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ServiceDeploymentEdge', node?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, promotion?: ServicePromotion | null, message?: string | null, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null, componentStatus?: string | null, status: ServiceDeploymentStatus, dryRun?: boolean | null, git?: { __typename?: 'GitRef', ref: string, folder: string } | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, version?: string | null, url?: string | null, repository?: { __typename?: 'ObjectReference', namespace?: string | null, name?: string | null } | null } | null, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, helmRepository?: { __typename?: 'FluxHelmRepository', spec: { __typename?: 'HelmRepositorySpec', url: string }, status?: { __typename?: 'HelmRepositoryStatus', ready?: boolean | null, message?: string | null } | null } | null, repository?: { __typename?: 'GitRepository', id: string, url: string } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string, warning?: boolean | null } | null> | null, globalService?: { __typename?: 'GlobalService', id: string, name: string } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null } | null> | null } | null } | null };

export type SyncGlobalServiceMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type SyncGlobalServiceMutation = { __typename?: 'RootMutationType', syncGlobalService?: { __typename?: 'GlobalService', id: string, distro?: ClusterDistro | null, name: string, reparent?: boolean | null, insertedAt?: string | null, updatedAt?: string | null, mgmt?: boolean | null, project?: { __typename?: 'Project', id: string, name: string, default?: boolean | null, description?: string | null } | null, cascade?: { __typename?: 'Cascade', delete?: boolean | null, detach?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', id: string, name: string, cloud: string, namespace: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, promotion?: ServicePromotion | null, message?: string | null, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null, componentStatus?: string | null, status: ServiceDeploymentStatus, dryRun?: boolean | null, git?: { __typename?: 'GitRef', ref: string, folder: string } | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, version?: string | null, url?: string | null, repository?: { __typename?: 'ObjectReference', namespace?: string | null, name?: string | null } | null } | null, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, helmRepository?: { __typename?: 'FluxHelmRepository', spec: { __typename?: 'HelmRepositorySpec', url: string }, status?: { __typename?: 'HelmRepositoryStatus', ready?: boolean | null, message?: string | null } | null } | null, repository?: { __typename?: 'GitRepository', id: string, url: string } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string, warning?: boolean | null } | null> | null, globalService?: { __typename?: 'GlobalService', id: string, name: string } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null, tags?: Array<{ __typename?: 'Tag', name: string, value: string } | null> | null, template?: { __typename?: 'ServiceTemplate', contexts?: Array<string | null> | null, name?: string | null, namespace?: string | null, repositoryId?: string | null, templated?: boolean | null, dependencies?: Array<{ __typename?: 'ServiceDependency', id: string, name: string, status?: ServiceDeploymentStatus | null } | null> | null, git?: { __typename?: 'GitRef', folder: string, ref: string } | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, ignoreCrds?: boolean | null, ignoreHooks?: boolean | null, release?: string | null, url?: string | null, values?: string | null, valuesFiles?: Array<string | null> | null, version?: string | null, git?: { __typename?: 'GitRef', folder: string, ref: string } | null, repository?: { __typename?: 'ObjectReference', name?: string | null, namespace?: string | null } | null, set?: Array<{ __typename?: 'HelmValue', name: string, value: string } | null> | null } | null, kustomize?: { __typename?: 'Kustomize', path: string, enableHelm?: boolean | null } | null, repository?: { __typename?: 'GitRepository', id: string, url: string, health?: GitHealth | null, authMethod?: AuthMethod | null, editable?: boolean | null, error?: string | null, insertedAt?: string | null, pulledAt?: string | null, updatedAt?: string | null, urlFormat?: string | null, httpsPath?: string | null } | null, syncConfig?: { __typename?: 'SyncConfig', createNamespace?: boolean | null, enforceNamespace?: boolean | null, namespaceMetadata?: { __typename?: 'NamespaceMetadata', annotations?: Record<string, unknown> | null, labels?: Record<string, unknown> | null } | null } | null } | null, parent?: { __typename?: 'ServiceDeployment', id: string, name: string } | null } | null };

export type HttpConnectionFragment = { __typename?: 'HttpConnection', host: string, user?: string | null };

export type SmtpSettingsFragment = { __typename?: 'SmtpSettings', server: string, port: number, sender: string, user: string, ssl: boolean };

export type AiSettingsFragment = { __typename?: 'AiSettings', enabled?: boolean | null, toolsEnabled?: boolean | null, provider?: AiProvider | null, anthropic?: { __typename?: 'AnthropicSettings', model?: string | null } | null, openai?: { __typename?: 'OpenaiSettings', model?: string | null, embeddingModel?: string | null } | null, azure?: { __typename?: 'AzureOpenaiSettings', apiVersion?: string | null, endpoint: string, model?: string | null, embeddingModel?: string | null } | null, ollama?: { __typename?: 'OllamaSettings', model: string, url: string } | null, bedrock?: { __typename?: 'BedrockAiSettings', region?: string | null, modelId: string, embeddingModel?: string | null } | null, vertex?: { __typename?: 'VertexAiSettings', model?: string | null, embeddingModel?: string | null, project: string, location: string } | null };

export type DeploymentSettingsFragment = { __typename?: 'DeploymentSettings', id: string, name: string, enabled: boolean, selfManaged?: boolean | null, insertedAt?: string | null, updatedAt?: string | null, onboarded?: boolean | null, agentHelmValues?: string | null, logging?: { __typename?: 'LoggingSettings', enabled?: boolean | null, driver?: LogDriver | null } | null, lokiConnection?: { __typename?: 'HttpConnection', host: string, user?: string | null } | null, prometheusConnection?: { __typename?: 'HttpConnection', host: string, user?: string | null } | null, artifactRepository?: { __typename?: 'GitRepository', id: string, url: string, health?: GitHealth | null, authMethod?: AuthMethod | null, editable?: boolean | null, error?: string | null, insertedAt?: string | null, pulledAt?: string | null, updatedAt?: string | null, urlFormat?: string | null, httpsPath?: string | null } | null, deployerRepository?: { __typename?: 'GitRepository', id: string, url: string, health?: GitHealth | null, authMethod?: AuthMethod | null, editable?: boolean | null, error?: string | null, insertedAt?: string | null, pulledAt?: string | null, updatedAt?: string | null, urlFormat?: string | null, httpsPath?: string | null } | null, createBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, smtp?: { __typename?: 'SmtpSettings', server: string, port: number, sender: string, user: string, ssl: boolean } | null, ai?: { __typename?: 'AiSettings', enabled?: boolean | null, toolsEnabled?: boolean | null, provider?: AiProvider | null, anthropic?: { __typename?: 'AnthropicSettings', model?: string | null } | null, openai?: { __typename?: 'OpenaiSettings', model?: string | null, embeddingModel?: string | null } | null, azure?: { __typename?: 'AzureOpenaiSettings', apiVersion?: string | null, endpoint: string, model?: string | null, embeddingModel?: string | null } | null, ollama?: { __typename?: 'OllamaSettings', model: string, url: string } | null, bedrock?: { __typename?: 'BedrockAiSettings', region?: string | null, modelId: string, embeddingModel?: string | null } | null, vertex?: { __typename?: 'VertexAiSettings', model?: string | null, embeddingModel?: string | null, project: string, location: string } | null } | null, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, gitBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null };

export type ObservabilityProviderFragment = { __typename?: 'ObservabilityProvider', id: string, name: string, type: ObservabilityProviderType, insertedAt?: string | null, updatedAt?: string | null };

export type ObservabilityWebhookFragment = { __typename?: 'ObservabilityWebhook', id: string, name: string, type: ObservabilityWebhookType, url: string, insertedAt?: string | null, updatedAt?: string | null };

export type DeploymentSettingsQueryVariables = Exact<{ [key: string]: never; }>;


export type DeploymentSettingsQuery = { __typename?: 'RootQueryType', deploymentSettings?: { __typename?: 'DeploymentSettings', id: string, name: string, enabled: boolean, selfManaged?: boolean | null, insertedAt?: string | null, updatedAt?: string | null, onboarded?: boolean | null, agentHelmValues?: string | null, logging?: { __typename?: 'LoggingSettings', enabled?: boolean | null, driver?: LogDriver | null } | null, lokiConnection?: { __typename?: 'HttpConnection', host: string, user?: string | null } | null, prometheusConnection?: { __typename?: 'HttpConnection', host: string, user?: string | null } | null, artifactRepository?: { __typename?: 'GitRepository', id: string, url: string, health?: GitHealth | null, authMethod?: AuthMethod | null, editable?: boolean | null, error?: string | null, insertedAt?: string | null, pulledAt?: string | null, updatedAt?: string | null, urlFormat?: string | null, httpsPath?: string | null } | null, deployerRepository?: { __typename?: 'GitRepository', id: string, url: string, health?: GitHealth | null, authMethod?: AuthMethod | null, editable?: boolean | null, error?: string | null, insertedAt?: string | null, pulledAt?: string | null, updatedAt?: string | null, urlFormat?: string | null, httpsPath?: string | null } | null, createBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, smtp?: { __typename?: 'SmtpSettings', server: string, port: number, sender: string, user: string, ssl: boolean } | null, ai?: { __typename?: 'AiSettings', enabled?: boolean | null, toolsEnabled?: boolean | null, provider?: AiProvider | null, anthropic?: { __typename?: 'AnthropicSettings', model?: string | null } | null, openai?: { __typename?: 'OpenaiSettings', model?: string | null, embeddingModel?: string | null } | null, azure?: { __typename?: 'AzureOpenaiSettings', apiVersion?: string | null, endpoint: string, model?: string | null, embeddingModel?: string | null } | null, ollama?: { __typename?: 'OllamaSettings', model: string, url: string } | null, bedrock?: { __typename?: 'BedrockAiSettings', region?: string | null, modelId: string, embeddingModel?: string | null } | null, vertex?: { __typename?: 'VertexAiSettings', model?: string | null, embeddingModel?: string | null, project: string, location: string } | null } | null, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, gitBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null } | null };

export type ObservabilityProvidersQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
}>;


export type ObservabilityProvidersQuery = { __typename?: 'RootQueryType', observabilityProviders?: { __typename?: 'ObservabilityProviderConnection', edges?: Array<{ __typename?: 'ObservabilityProviderEdge', node?: { __typename?: 'ObservabilityProvider', id: string, name: string, type: ObservabilityProviderType, insertedAt?: string | null, updatedAt?: string | null } | null } | null> | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null } } | null };

export type ObservabilityWebhooksQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
}>;


export type ObservabilityWebhooksQuery = { __typename?: 'RootQueryType', observabilityWebhooks?: { __typename?: 'ObservabilityWebhookConnection', edges?: Array<{ __typename?: 'ObservabilityWebhookEdge', node?: { __typename?: 'ObservabilityWebhook', id: string, name: string, type: ObservabilityWebhookType, url: string, insertedAt?: string | null, updatedAt?: string | null } | null } | null> | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null } } | null };

export type UpdateDeploymentSettingsMutationVariables = Exact<{
  attributes: DeploymentSettingsAttributes;
}>;


export type UpdateDeploymentSettingsMutation = { __typename?: 'RootMutationType', updateDeploymentSettings?: { __typename?: 'DeploymentSettings', id: string, name: string, enabled: boolean, selfManaged?: boolean | null, insertedAt?: string | null, updatedAt?: string | null, onboarded?: boolean | null, agentHelmValues?: string | null, logging?: { __typename?: 'LoggingSettings', enabled?: boolean | null, driver?: LogDriver | null } | null, lokiConnection?: { __typename?: 'HttpConnection', host: string, user?: string | null } | null, prometheusConnection?: { __typename?: 'HttpConnection', host: string, user?: string | null } | null, artifactRepository?: { __typename?: 'GitRepository', id: string, url: string, health?: GitHealth | null, authMethod?: AuthMethod | null, editable?: boolean | null, error?: string | null, insertedAt?: string | null, pulledAt?: string | null, updatedAt?: string | null, urlFormat?: string | null, httpsPath?: string | null } | null, deployerRepository?: { __typename?: 'GitRepository', id: string, url: string, health?: GitHealth | null, authMethod?: AuthMethod | null, editable?: boolean | null, error?: string | null, insertedAt?: string | null, pulledAt?: string | null, updatedAt?: string | null, urlFormat?: string | null, httpsPath?: string | null } | null, createBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, smtp?: { __typename?: 'SmtpSettings', server: string, port: number, sender: string, user: string, ssl: boolean } | null, ai?: { __typename?: 'AiSettings', enabled?: boolean | null, toolsEnabled?: boolean | null, provider?: AiProvider | null, anthropic?: { __typename?: 'AnthropicSettings', model?: string | null } | null, openai?: { __typename?: 'OpenaiSettings', model?: string | null, embeddingModel?: string | null } | null, azure?: { __typename?: 'AzureOpenaiSettings', apiVersion?: string | null, endpoint: string, model?: string | null, embeddingModel?: string | null } | null, ollama?: { __typename?: 'OllamaSettings', model: string, url: string } | null, bedrock?: { __typename?: 'BedrockAiSettings', region?: string | null, modelId: string, embeddingModel?: string | null } | null, vertex?: { __typename?: 'VertexAiSettings', model?: string | null, embeddingModel?: string | null, project: string, location: string } | null } | null, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, gitBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null } | null };

export type UpsertObservabilityProviderMutationVariables = Exact<{
  attributes: ObservabilityProviderAttributes;
}>;


export type UpsertObservabilityProviderMutation = { __typename?: 'RootMutationType', upsertObservabilityProvider?: { __typename?: 'ObservabilityProvider', id: string, name: string, type: ObservabilityProviderType, insertedAt?: string | null, updatedAt?: string | null } | null };

export type UpsertObservabilityWebhookMutationVariables = Exact<{
  attributes: ObservabilityWebhookAttributes;
}>;


export type UpsertObservabilityWebhookMutation = { __typename?: 'RootMutationType', upsertObservabilityWebhook?: { __typename?: 'ObservabilityWebhook', id: string, name: string, type: ObservabilityWebhookType, url: string, insertedAt?: string | null, updatedAt?: string | null } | null };

export type DeleteObservabilityProviderMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteObservabilityProviderMutation = { __typename?: 'RootMutationType', deleteObservabilityProvider?: { __typename?: 'ObservabilityProvider', id: string, name: string, type: ObservabilityProviderType, insertedAt?: string | null, updatedAt?: string | null } | null };

export type DeleteObservabilityWebhookMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteObservabilityWebhookMutation = { __typename?: 'RootMutationType', deleteObservabilityWebhook?: { __typename?: 'ObservabilityWebhook', id: string, name: string, type: ObservabilityWebhookType, url: string, insertedAt?: string | null, updatedAt?: string | null } | null };

export type DissmissOnboardingMutationVariables = Exact<{ [key: string]: never; }>;


export type DissmissOnboardingMutation = { __typename?: 'RootMutationType', dismissOnboarding?: { __typename?: 'DeploymentSettings', onboarded?: boolean | null } | null };

export type ManagedNamespaceFragment = { __typename?: 'ManagedNamespace', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null, description?: string | null, labels?: Record<string, unknown> | null, annotations?: Record<string, unknown> | null, pullSecrets?: Array<string | null> | null, cascade?: { __typename?: 'Cascade', delete?: boolean | null, detach?: boolean | null } | null, target?: { __typename?: 'ClusterTarget', distro?: ClusterDistro | null, tags?: Record<string, unknown> | null } | null, project?: { __typename?: 'Project', id: string, name: string, default?: boolean | null, description?: string | null } | null, service?: { __typename?: 'ServiceTemplate', contexts?: Array<string | null> | null, name?: string | null, namespace?: string | null, repositoryId?: string | null, templated?: boolean | null, dependencies?: Array<{ __typename?: 'ServiceDependency', id: string, name: string, status?: ServiceDeploymentStatus | null } | null> | null, git?: { __typename?: 'GitRef', folder: string, ref: string } | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, ignoreCrds?: boolean | null, ignoreHooks?: boolean | null, release?: string | null, url?: string | null, values?: string | null, valuesFiles?: Array<string | null> | null, version?: string | null, git?: { __typename?: 'GitRef', folder: string, ref: string } | null, repository?: { __typename?: 'ObjectReference', name?: string | null, namespace?: string | null } | null, set?: Array<{ __typename?: 'HelmValue', name: string, value: string } | null> | null } | null, kustomize?: { __typename?: 'Kustomize', path: string, enableHelm?: boolean | null } | null, repository?: { __typename?: 'GitRepository', id: string, url: string, health?: GitHealth | null, authMethod?: AuthMethod | null, editable?: boolean | null, error?: string | null, insertedAt?: string | null, pulledAt?: string | null, updatedAt?: string | null, urlFormat?: string | null, httpsPath?: string | null } | null, syncConfig?: { __typename?: 'SyncConfig', createNamespace?: boolean | null, enforceNamespace?: boolean | null, namespaceMetadata?: { __typename?: 'NamespaceMetadata', annotations?: Record<string, unknown> | null, labels?: Record<string, unknown> | null } | null } | null } | null };

export type ServiceTemplateFragment = { __typename?: 'ServiceTemplate', contexts?: Array<string | null> | null, name?: string | null, namespace?: string | null, repositoryId?: string | null, templated?: boolean | null, configuration?: Array<{ __typename?: 'ServiceConfiguration', name: string, value: string } | null> | null, git?: { __typename?: 'GitRef', folder: string, ref: string } | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, valuesFiles?: Array<string | null> | null, version?: string | null, repository?: { __typename?: 'ObjectReference', name?: string | null, namespace?: string | null } | null, set?: Array<{ __typename?: 'HelmValue', name: string, value: string } | null> | null } | null, kustomize?: { __typename?: 'Kustomize', path: string } | null, repository?: { __typename?: 'GitRepository', id: string, url: string, health?: GitHealth | null, authMethod?: AuthMethod | null, editable?: boolean | null, error?: string | null, insertedAt?: string | null, pulledAt?: string | null, updatedAt?: string | null, urlFormat?: string | null, httpsPath?: string | null } | null, syncConfig?: { __typename?: 'SyncConfig', createNamespace?: boolean | null, namespaceMetadata?: { __typename?: 'NamespaceMetadata', annotations?: Record<string, unknown> | null, labels?: Record<string, unknown> | null } | null } | null };

export type ManagedNamespacesQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  projectId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type ManagedNamespacesQuery = { __typename?: 'RootQueryType', managedNamespaces?: { __typename?: 'ManagedNamespaceConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ManagedNamespaceEdge', node?: { __typename?: 'ManagedNamespace', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null, description?: string | null, labels?: Record<string, unknown> | null, annotations?: Record<string, unknown> | null, pullSecrets?: Array<string | null> | null, cascade?: { __typename?: 'Cascade', delete?: boolean | null, detach?: boolean | null } | null, target?: { __typename?: 'ClusterTarget', distro?: ClusterDistro | null, tags?: Record<string, unknown> | null } | null, project?: { __typename?: 'Project', id: string, name: string, default?: boolean | null, description?: string | null } | null, service?: { __typename?: 'ServiceTemplate', contexts?: Array<string | null> | null, name?: string | null, namespace?: string | null, repositoryId?: string | null, templated?: boolean | null, dependencies?: Array<{ __typename?: 'ServiceDependency', id: string, name: string, status?: ServiceDeploymentStatus | null } | null> | null, git?: { __typename?: 'GitRef', folder: string, ref: string } | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, ignoreCrds?: boolean | null, ignoreHooks?: boolean | null, release?: string | null, url?: string | null, values?: string | null, valuesFiles?: Array<string | null> | null, version?: string | null, git?: { __typename?: 'GitRef', folder: string, ref: string } | null, repository?: { __typename?: 'ObjectReference', name?: string | null, namespace?: string | null } | null, set?: Array<{ __typename?: 'HelmValue', name: string, value: string } | null> | null } | null, kustomize?: { __typename?: 'Kustomize', path: string, enableHelm?: boolean | null } | null, repository?: { __typename?: 'GitRepository', id: string, url: string, health?: GitHealth | null, authMethod?: AuthMethod | null, editable?: boolean | null, error?: string | null, insertedAt?: string | null, pulledAt?: string | null, updatedAt?: string | null, urlFormat?: string | null, httpsPath?: string | null } | null, syncConfig?: { __typename?: 'SyncConfig', createNamespace?: boolean | null, enforceNamespace?: boolean | null, namespaceMetadata?: { __typename?: 'NamespaceMetadata', annotations?: Record<string, unknown> | null, labels?: Record<string, unknown> | null } | null } | null } | null } | null } | null> | null } | null };

export type GetManagedNamespaceNameQueryVariables = Exact<{
  namespaceId: Scalars['ID']['input'];
}>;


export type GetManagedNamespaceNameQuery = { __typename?: 'RootQueryType', managedNamespace?: { __typename?: 'ManagedNamespace', name: string } | null };

export type GetManagedNamespaceQueryVariables = Exact<{
  namespaceId: Scalars['ID']['input'];
}>;


export type GetManagedNamespaceQuery = { __typename?: 'RootQueryType', managedNamespace?: { __typename?: 'ManagedNamespace', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null, description?: string | null, labels?: Record<string, unknown> | null, annotations?: Record<string, unknown> | null, pullSecrets?: Array<string | null> | null, cascade?: { __typename?: 'Cascade', delete?: boolean | null, detach?: boolean | null } | null, target?: { __typename?: 'ClusterTarget', distro?: ClusterDistro | null, tags?: Record<string, unknown> | null } | null, project?: { __typename?: 'Project', id: string, name: string, default?: boolean | null, description?: string | null } | null, service?: { __typename?: 'ServiceTemplate', contexts?: Array<string | null> | null, name?: string | null, namespace?: string | null, repositoryId?: string | null, templated?: boolean | null, dependencies?: Array<{ __typename?: 'ServiceDependency', id: string, name: string, status?: ServiceDeploymentStatus | null } | null> | null, git?: { __typename?: 'GitRef', folder: string, ref: string } | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, ignoreCrds?: boolean | null, ignoreHooks?: boolean | null, release?: string | null, url?: string | null, values?: string | null, valuesFiles?: Array<string | null> | null, version?: string | null, git?: { __typename?: 'GitRef', folder: string, ref: string } | null, repository?: { __typename?: 'ObjectReference', name?: string | null, namespace?: string | null } | null, set?: Array<{ __typename?: 'HelmValue', name: string, value: string } | null> | null } | null, kustomize?: { __typename?: 'Kustomize', path: string, enableHelm?: boolean | null } | null, repository?: { __typename?: 'GitRepository', id: string, url: string, health?: GitHealth | null, authMethod?: AuthMethod | null, editable?: boolean | null, error?: string | null, insertedAt?: string | null, pulledAt?: string | null, updatedAt?: string | null, urlFormat?: string | null, httpsPath?: string | null } | null, syncConfig?: { __typename?: 'SyncConfig', createNamespace?: boolean | null, enforceNamespace?: boolean | null, namespaceMetadata?: { __typename?: 'NamespaceMetadata', annotations?: Record<string, unknown> | null, labels?: Record<string, unknown> | null } | null } | null } | null } | null };

export type GetManagedNamespaceServicesQueryVariables = Exact<{
  namespaceId: Scalars['ID']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetManagedNamespaceServicesQuery = { __typename?: 'RootQueryType', managedNamespace?: { __typename?: 'ManagedNamespace', services?: { __typename?: 'ServiceDeploymentConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ServiceDeploymentEdge', node?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, promotion?: ServicePromotion | null, message?: string | null, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null, componentStatus?: string | null, status: ServiceDeploymentStatus, dryRun?: boolean | null, git?: { __typename?: 'GitRef', ref: string, folder: string } | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, version?: string | null, url?: string | null, repository?: { __typename?: 'ObjectReference', namespace?: string | null, name?: string | null } | null } | null, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, helmRepository?: { __typename?: 'FluxHelmRepository', spec: { __typename?: 'HelmRepositorySpec', url: string }, status?: { __typename?: 'HelmRepositoryStatus', ready?: boolean | null, message?: string | null } | null } | null, repository?: { __typename?: 'GitRepository', id: string, url: string } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string, warning?: boolean | null } | null> | null, globalService?: { __typename?: 'GlobalService', id: string, name: string } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null } | null> | null } | null } | null };

export type ObserverFragment = { __typename?: 'Observer', id: string, insertedAt?: string | null, updatedAt?: string | null, name: string, crontab: string, status: ObserverStatus, lastRunAt: string, nextRunAt: string, lastValue?: string | null, project?: { __typename?: 'Project', id: string, name: string, default?: boolean | null, description?: string | null } | null, target: { __typename?: 'ObserverTarget', target: ObserverTargetType, format?: string | null, order: ObserverTargetOrder, git?: { __typename?: 'ObserverGitRepo', type: ObserverGitTargetType, repositoryId: string } | null, helm?: { __typename?: 'ObserverHelmRepo', url: string, provider?: HelmAuthProvider | null, chart: string } | null, oci?: { __typename?: 'ObserverOciRepo', provider?: HelmAuthProvider | null, url: string } | null }, errors?: Array<{ __typename?: 'ServiceError', source: string, message: string, warning?: boolean | null } | null> | null };

export type ObserverTargetFragment = { __typename?: 'ObserverTarget', target: ObserverTargetType, format?: string | null, order: ObserverTargetOrder, git?: { __typename?: 'ObserverGitRepo', type: ObserverGitTargetType, repositoryId: string } | null, helm?: { __typename?: 'ObserverHelmRepo', url: string, provider?: HelmAuthProvider | null, chart: string } | null, oci?: { __typename?: 'ObserverOciRepo', provider?: HelmAuthProvider | null, url: string } | null };

export type ServiceErrorFragment = { __typename?: 'ServiceError', source: string, message: string, warning?: boolean | null };

export type ObserversQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  projectId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type ObserversQuery = { __typename?: 'RootQueryType', observers?: { __typename?: 'ObserverConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ObserverEdge', node?: { __typename?: 'Observer', id: string, insertedAt?: string | null, updatedAt?: string | null, name: string, crontab: string, status: ObserverStatus, lastRunAt: string, nextRunAt: string, lastValue?: string | null, project?: { __typename?: 'Project', id: string, name: string, default?: boolean | null, description?: string | null } | null, target: { __typename?: 'ObserverTarget', target: ObserverTargetType, format?: string | null, order: ObserverTargetOrder, git?: { __typename?: 'ObserverGitRepo', type: ObserverGitTargetType, repositoryId: string } | null, helm?: { __typename?: 'ObserverHelmRepo', url: string, provider?: HelmAuthProvider | null, chart: string } | null, oci?: { __typename?: 'ObserverOciRepo', provider?: HelmAuthProvider | null, url: string } | null }, errors?: Array<{ __typename?: 'ServiceError', source: string, message: string, warning?: boolean | null } | null> | null } | null } | null> | null } | null };

export type ObserverQueryVariables = Exact<{
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
}>;


export type ObserverQuery = { __typename?: 'RootQueryType', observer?: { __typename?: 'Observer', id: string, insertedAt?: string | null, updatedAt?: string | null, name: string, crontab: string, status: ObserverStatus, lastRunAt: string, nextRunAt: string, lastValue?: string | null, project?: { __typename?: 'Project', id: string, name: string, default?: boolean | null, description?: string | null } | null, target: { __typename?: 'ObserverTarget', target: ObserverTargetType, format?: string | null, order: ObserverTargetOrder, git?: { __typename?: 'ObserverGitRepo', type: ObserverGitTargetType, repositoryId: string } | null, helm?: { __typename?: 'ObserverHelmRepo', url: string, provider?: HelmAuthProvider | null, chart: string } | null, oci?: { __typename?: 'ObserverOciRepo', provider?: HelmAuthProvider | null, url: string } | null }, errors?: Array<{ __typename?: 'ServiceError', source: string, message: string, warning?: boolean | null } | null> | null } | null };

export type UpsertObserverMutationVariables = Exact<{
  attrs?: InputMaybe<ObserverAttributes>;
}>;


export type UpsertObserverMutation = { __typename?: 'RootMutationType', upsertObserver?: { __typename?: 'Observer', id: string, insertedAt?: string | null, updatedAt?: string | null, name: string, crontab: string, status: ObserverStatus, lastRunAt: string, nextRunAt: string, lastValue?: string | null, project?: { __typename?: 'Project', id: string, name: string, default?: boolean | null, description?: string | null } | null, target: { __typename?: 'ObserverTarget', target: ObserverTargetType, format?: string | null, order: ObserverTargetOrder, git?: { __typename?: 'ObserverGitRepo', type: ObserverGitTargetType, repositoryId: string } | null, helm?: { __typename?: 'ObserverHelmRepo', url: string, provider?: HelmAuthProvider | null, chart: string } | null, oci?: { __typename?: 'ObserverOciRepo', provider?: HelmAuthProvider | null, url: string } | null }, errors?: Array<{ __typename?: 'ServiceError', source: string, message: string, warning?: boolean | null } | null> | null } | null };

export type DeleteObserverMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteObserverMutation = { __typename?: 'RootMutationType', deleteObserver?: { __typename?: 'Observer', id: string, insertedAt?: string | null, updatedAt?: string | null, name: string, crontab: string, status: ObserverStatus, lastRunAt: string, nextRunAt: string, lastValue?: string | null, project?: { __typename?: 'Project', id: string, name: string, default?: boolean | null, description?: string | null } | null, target: { __typename?: 'ObserverTarget', target: ObserverTargetType, format?: string | null, order: ObserverTargetOrder, git?: { __typename?: 'ObserverGitRepo', type: ObserverGitTargetType, repositoryId: string } | null, helm?: { __typename?: 'ObserverHelmRepo', url: string, provider?: HelmAuthProvider | null, chart: string } | null, oci?: { __typename?: 'ObserverOciRepo', provider?: HelmAuthProvider | null, url: string } | null }, errors?: Array<{ __typename?: 'ServiceError', source: string, message: string, warning?: boolean | null } | null> | null } | null };

export type KickObserverMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type KickObserverMutation = { __typename?: 'RootMutationType', kickObserver?: { __typename?: 'Observer', id: string, insertedAt?: string | null, updatedAt?: string | null, name: string, crontab: string, status: ObserverStatus, lastRunAt: string, nextRunAt: string, lastValue?: string | null, project?: { __typename?: 'Project', id: string, name: string, default?: boolean | null, description?: string | null } | null, target: { __typename?: 'ObserverTarget', target: ObserverTargetType, format?: string | null, order: ObserverTargetOrder, git?: { __typename?: 'ObserverGitRepo', type: ObserverGitTargetType, repositoryId: string } | null, helm?: { __typename?: 'ObserverHelmRepo', url: string, provider?: HelmAuthProvider | null, chart: string } | null, oci?: { __typename?: 'ObserverOciRepo', provider?: HelmAuthProvider | null, url: string } | null }, errors?: Array<{ __typename?: 'ServiceError', source: string, message: string, warning?: boolean | null } | null> | null } | null };

export type PipelineServiceDeploymentFragment = { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null };

export type ContainerSpecFragment = { __typename?: 'ContainerSpec', args?: Array<string | null> | null, image: string, env?: Array<{ __typename?: 'ContainerEnv', name: string, value: string } | null> | null, envFrom?: Array<{ __typename?: 'ContainerEnvFrom', configMap: string, secret: string } | null> | null };

export type JobGateSpecFragment = { __typename?: 'JobGateSpec', annotations?: Record<string, unknown> | null, labels?: Record<string, unknown> | null, namespace: string, raw?: string | null, serviceAccount?: string | null, containers?: Array<{ __typename?: 'ContainerSpec', args?: Array<string | null> | null, image: string, env?: Array<{ __typename?: 'ContainerEnv', name: string, value: string } | null> | null, envFrom?: Array<{ __typename?: 'ContainerEnvFrom', configMap: string, secret: string } | null> | null } | null> | null };

export type PipelineGateFragment = { __typename?: 'PipelineGate', id: string, name: string, state: GateState, type: GateType, insertedAt?: string | null, updatedAt?: string | null, cluster?: { __typename?: 'Cluster', id: string } | null, approver?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null, edge?: { __typename?: 'PipelineStageEdge', pipeline?: { __typename?: 'Pipeline', id: string, name: string } | null } | null, spec?: { __typename?: 'GateSpec', job?: { __typename?: 'JobGateSpec', annotations?: Record<string, unknown> | null, labels?: Record<string, unknown> | null, namespace: string, raw?: string | null, serviceAccount?: string | null, containers?: Array<{ __typename?: 'ContainerSpec', args?: Array<string | null> | null, image: string, env?: Array<{ __typename?: 'ContainerEnv', name: string, value: string } | null> | null, envFrom?: Array<{ __typename?: 'ContainerEnvFrom', configMap: string, secret: string } | null> | null } | null> | null } | null } | null };

export type RevisionFragment = { __typename?: 'Revision', id: string, insertedAt?: string | null, updatedAt?: string | null, message?: string | null, sha?: string | null, version: string, git?: { __typename?: 'GitRef', ref: string, folder: string } | null };

export type PromotionServiceFragment = { __typename?: 'PromotionService', id: string, insertedAt?: string | null, updatedAt?: string | null, revision?: { __typename?: 'Revision', id: string, insertedAt?: string | null, updatedAt?: string | null, message?: string | null, sha?: string | null, version: string, git?: { __typename?: 'GitRef', ref: string, folder: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null };

export type PipelinePromotionFragment = { __typename?: 'PipelinePromotion', id: string, insertedAt?: string | null, updatedAt?: string | null, promotedAt?: string | null, revisedAt?: string | null, services?: Array<{ __typename?: 'PromotionService', id: string, insertedAt?: string | null, updatedAt?: string | null, revision?: { __typename?: 'Revision', id: string, insertedAt?: string | null, updatedAt?: string | null, message?: string | null, sha?: string | null, version: string, git?: { __typename?: 'GitRef', ref: string, folder: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null };

export type PromotionCriteriaFragment = { __typename?: 'PromotionCriteria', id: string, secrets?: Array<string | null> | null, insertedAt?: string | null, updatedAt?: string | null, source?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null };

export type StageServiceFragment = { __typename?: 'StageService', id: string, insertedAt?: string | null, updatedAt?: string | null, criteria?: { __typename?: 'PromotionCriteria', id: string, secrets?: Array<string | null> | null, insertedAt?: string | null, updatedAt?: string | null, source?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null };

export type PipelineStageFragment = { __typename?: 'PipelineStage', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, promotion?: { __typename?: 'PipelinePromotion', id: string, insertedAt?: string | null, updatedAt?: string | null, promotedAt?: string | null, revisedAt?: string | null, services?: Array<{ __typename?: 'PromotionService', id: string, insertedAt?: string | null, updatedAt?: string | null, revision?: { __typename?: 'Revision', id: string, insertedAt?: string | null, updatedAt?: string | null, message?: string | null, sha?: string | null, version: string, git?: { __typename?: 'GitRef', ref: string, folder: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null } | null, services?: Array<{ __typename?: 'StageService', id: string, insertedAt?: string | null, updatedAt?: string | null, criteria?: { __typename?: 'PromotionCriteria', id: string, secrets?: Array<string | null> | null, insertedAt?: string | null, updatedAt?: string | null, source?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null, context?: { __typename?: 'PipelineContext', id: string, context: Record<string, unknown>, insertedAt?: string | null, updatedAt?: string | null, pullRequests?: Array<{ __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null, pipelinePullRequests?: Array<{ __typename?: 'PipelinePullRequest', id: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, stage?: { __typename?: 'PipelineStage', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null };

export type PipelineStageEdgeFragment = { __typename?: 'PipelineStageEdge', id: string, insertedAt?: string | null, promotedAt?: string | null, updatedAt?: string | null, gates?: Array<{ __typename?: 'PipelineGate', id: string, name: string, state: GateState, type: GateType, insertedAt?: string | null, updatedAt?: string | null, cluster?: { __typename?: 'Cluster', id: string } | null, approver?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null, edge?: { __typename?: 'PipelineStageEdge', pipeline?: { __typename?: 'Pipeline', id: string, name: string } | null } | null, spec?: { __typename?: 'GateSpec', job?: { __typename?: 'JobGateSpec', annotations?: Record<string, unknown> | null, labels?: Record<string, unknown> | null, namespace: string, raw?: string | null, serviceAccount?: string | null, containers?: Array<{ __typename?: 'ContainerSpec', args?: Array<string | null> | null, image: string, env?: Array<{ __typename?: 'ContainerEnv', name: string, value: string } | null> | null, envFrom?: Array<{ __typename?: 'ContainerEnvFrom', configMap: string, secret: string } | null> | null } | null> | null } | null } | null } | null> | null, from: { __typename?: 'PipelineStage', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, promotion?: { __typename?: 'PipelinePromotion', id: string, insertedAt?: string | null, updatedAt?: string | null, promotedAt?: string | null, revisedAt?: string | null, services?: Array<{ __typename?: 'PromotionService', id: string, insertedAt?: string | null, updatedAt?: string | null, revision?: { __typename?: 'Revision', id: string, insertedAt?: string | null, updatedAt?: string | null, message?: string | null, sha?: string | null, version: string, git?: { __typename?: 'GitRef', ref: string, folder: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null } | null, services?: Array<{ __typename?: 'StageService', id: string, insertedAt?: string | null, updatedAt?: string | null, criteria?: { __typename?: 'PromotionCriteria', id: string, secrets?: Array<string | null> | null, insertedAt?: string | null, updatedAt?: string | null, source?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null, context?: { __typename?: 'PipelineContext', id: string, context: Record<string, unknown>, insertedAt?: string | null, updatedAt?: string | null, pullRequests?: Array<{ __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null, pipelinePullRequests?: Array<{ __typename?: 'PipelinePullRequest', id: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, stage?: { __typename?: 'PipelineStage', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null }, to: { __typename?: 'PipelineStage', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, promotion?: { __typename?: 'PipelinePromotion', id: string, insertedAt?: string | null, updatedAt?: string | null, promotedAt?: string | null, revisedAt?: string | null, services?: Array<{ __typename?: 'PromotionService', id: string, insertedAt?: string | null, updatedAt?: string | null, revision?: { __typename?: 'Revision', id: string, insertedAt?: string | null, updatedAt?: string | null, message?: string | null, sha?: string | null, version: string, git?: { __typename?: 'GitRef', ref: string, folder: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null } | null, services?: Array<{ __typename?: 'StageService', id: string, insertedAt?: string | null, updatedAt?: string | null, criteria?: { __typename?: 'PromotionCriteria', id: string, secrets?: Array<string | null> | null, insertedAt?: string | null, updatedAt?: string | null, source?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null, context?: { __typename?: 'PipelineContext', id: string, context: Record<string, unknown>, insertedAt?: string | null, updatedAt?: string | null, pullRequests?: Array<{ __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null, pipelinePullRequests?: Array<{ __typename?: 'PipelinePullRequest', id: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, stage?: { __typename?: 'PipelineStage', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null } };

export type PipelineStatusFragment = { __typename?: 'PipelineStatus', closed?: number | null, pending?: number | null, running?: number | null };

export type PipelinePullRequestFragment = { __typename?: 'PipelinePullRequest', id: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, stage?: { __typename?: 'PipelineStage', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null };

export type PipelineContextFragment = { __typename?: 'PipelineContext', id: string, context: Record<string, unknown>, insertedAt?: string | null, updatedAt?: string | null, pullRequests?: Array<{ __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null, pipelinePullRequests?: Array<{ __typename?: 'PipelinePullRequest', id: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, stage?: { __typename?: 'PipelineStage', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null };

export type PipelineFragment = { __typename?: 'Pipeline', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, edges?: Array<{ __typename?: 'PipelineStageEdge', id: string, insertedAt?: string | null, promotedAt?: string | null, updatedAt?: string | null, gates?: Array<{ __typename?: 'PipelineGate', id: string, name: string, state: GateState, type: GateType, insertedAt?: string | null, updatedAt?: string | null, cluster?: { __typename?: 'Cluster', id: string } | null, approver?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null, edge?: { __typename?: 'PipelineStageEdge', pipeline?: { __typename?: 'Pipeline', id: string, name: string } | null } | null, spec?: { __typename?: 'GateSpec', job?: { __typename?: 'JobGateSpec', annotations?: Record<string, unknown> | null, labels?: Record<string, unknown> | null, namespace: string, raw?: string | null, serviceAccount?: string | null, containers?: Array<{ __typename?: 'ContainerSpec', args?: Array<string | null> | null, image: string, env?: Array<{ __typename?: 'ContainerEnv', name: string, value: string } | null> | null, envFrom?: Array<{ __typename?: 'ContainerEnvFrom', configMap: string, secret: string } | null> | null } | null> | null } | null } | null } | null> | null, from: { __typename?: 'PipelineStage', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, promotion?: { __typename?: 'PipelinePromotion', id: string, insertedAt?: string | null, updatedAt?: string | null, promotedAt?: string | null, revisedAt?: string | null, services?: Array<{ __typename?: 'PromotionService', id: string, insertedAt?: string | null, updatedAt?: string | null, revision?: { __typename?: 'Revision', id: string, insertedAt?: string | null, updatedAt?: string | null, message?: string | null, sha?: string | null, version: string, git?: { __typename?: 'GitRef', ref: string, folder: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null } | null, services?: Array<{ __typename?: 'StageService', id: string, insertedAt?: string | null, updatedAt?: string | null, criteria?: { __typename?: 'PromotionCriteria', id: string, secrets?: Array<string | null> | null, insertedAt?: string | null, updatedAt?: string | null, source?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null, context?: { __typename?: 'PipelineContext', id: string, context: Record<string, unknown>, insertedAt?: string | null, updatedAt?: string | null, pullRequests?: Array<{ __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null, pipelinePullRequests?: Array<{ __typename?: 'PipelinePullRequest', id: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, stage?: { __typename?: 'PipelineStage', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null }, to: { __typename?: 'PipelineStage', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, promotion?: { __typename?: 'PipelinePromotion', id: string, insertedAt?: string | null, updatedAt?: string | null, promotedAt?: string | null, revisedAt?: string | null, services?: Array<{ __typename?: 'PromotionService', id: string, insertedAt?: string | null, updatedAt?: string | null, revision?: { __typename?: 'Revision', id: string, insertedAt?: string | null, updatedAt?: string | null, message?: string | null, sha?: string | null, version: string, git?: { __typename?: 'GitRef', ref: string, folder: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null } | null, services?: Array<{ __typename?: 'StageService', id: string, insertedAt?: string | null, updatedAt?: string | null, criteria?: { __typename?: 'PromotionCriteria', id: string, secrets?: Array<string | null> | null, insertedAt?: string | null, updatedAt?: string | null, source?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null, context?: { __typename?: 'PipelineContext', id: string, context: Record<string, unknown>, insertedAt?: string | null, updatedAt?: string | null, pullRequests?: Array<{ __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null, pipelinePullRequests?: Array<{ __typename?: 'PipelinePullRequest', id: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, stage?: { __typename?: 'PipelineStage', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null } } | null> | null, stages?: Array<{ __typename?: 'PipelineStage', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, promotion?: { __typename?: 'PipelinePromotion', id: string, insertedAt?: string | null, updatedAt?: string | null, promotedAt?: string | null, revisedAt?: string | null, services?: Array<{ __typename?: 'PromotionService', id: string, insertedAt?: string | null, updatedAt?: string | null, revision?: { __typename?: 'Revision', id: string, insertedAt?: string | null, updatedAt?: string | null, message?: string | null, sha?: string | null, version: string, git?: { __typename?: 'GitRef', ref: string, folder: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null } | null, services?: Array<{ __typename?: 'StageService', id: string, insertedAt?: string | null, updatedAt?: string | null, criteria?: { __typename?: 'PromotionCriteria', id: string, secrets?: Array<string | null> | null, insertedAt?: string | null, updatedAt?: string | null, source?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null, context?: { __typename?: 'PipelineContext', id: string, context: Record<string, unknown>, insertedAt?: string | null, updatedAt?: string | null, pullRequests?: Array<{ __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null, pipelinePullRequests?: Array<{ __typename?: 'PipelinePullRequest', id: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, stage?: { __typename?: 'PipelineStage', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null } | null> | null, status?: { __typename?: 'PipelineStatus', closed?: number | null, pending?: number | null, running?: number | null } | null };

export type PipelineConnectionFragment = { __typename?: 'PipelineConnection', edges?: Array<{ __typename?: 'PipelineEdge', node?: { __typename?: 'Pipeline', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, edges?: Array<{ __typename?: 'PipelineStageEdge', id: string, insertedAt?: string | null, promotedAt?: string | null, updatedAt?: string | null, gates?: Array<{ __typename?: 'PipelineGate', id: string, name: string, state: GateState, type: GateType, insertedAt?: string | null, updatedAt?: string | null, cluster?: { __typename?: 'Cluster', id: string } | null, approver?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null, edge?: { __typename?: 'PipelineStageEdge', pipeline?: { __typename?: 'Pipeline', id: string, name: string } | null } | null, spec?: { __typename?: 'GateSpec', job?: { __typename?: 'JobGateSpec', annotations?: Record<string, unknown> | null, labels?: Record<string, unknown> | null, namespace: string, raw?: string | null, serviceAccount?: string | null, containers?: Array<{ __typename?: 'ContainerSpec', args?: Array<string | null> | null, image: string, env?: Array<{ __typename?: 'ContainerEnv', name: string, value: string } | null> | null, envFrom?: Array<{ __typename?: 'ContainerEnvFrom', configMap: string, secret: string } | null> | null } | null> | null } | null } | null } | null> | null, from: { __typename?: 'PipelineStage', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, promotion?: { __typename?: 'PipelinePromotion', id: string, insertedAt?: string | null, updatedAt?: string | null, promotedAt?: string | null, revisedAt?: string | null, services?: Array<{ __typename?: 'PromotionService', id: string, insertedAt?: string | null, updatedAt?: string | null, revision?: { __typename?: 'Revision', id: string, insertedAt?: string | null, updatedAt?: string | null, message?: string | null, sha?: string | null, version: string, git?: { __typename?: 'GitRef', ref: string, folder: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null } | null, services?: Array<{ __typename?: 'StageService', id: string, insertedAt?: string | null, updatedAt?: string | null, criteria?: { __typename?: 'PromotionCriteria', id: string, secrets?: Array<string | null> | null, insertedAt?: string | null, updatedAt?: string | null, source?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null, context?: { __typename?: 'PipelineContext', id: string, context: Record<string, unknown>, insertedAt?: string | null, updatedAt?: string | null, pullRequests?: Array<{ __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null, pipelinePullRequests?: Array<{ __typename?: 'PipelinePullRequest', id: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, stage?: { __typename?: 'PipelineStage', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null }, to: { __typename?: 'PipelineStage', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, promotion?: { __typename?: 'PipelinePromotion', id: string, insertedAt?: string | null, updatedAt?: string | null, promotedAt?: string | null, revisedAt?: string | null, services?: Array<{ __typename?: 'PromotionService', id: string, insertedAt?: string | null, updatedAt?: string | null, revision?: { __typename?: 'Revision', id: string, insertedAt?: string | null, updatedAt?: string | null, message?: string | null, sha?: string | null, version: string, git?: { __typename?: 'GitRef', ref: string, folder: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null } | null, services?: Array<{ __typename?: 'StageService', id: string, insertedAt?: string | null, updatedAt?: string | null, criteria?: { __typename?: 'PromotionCriteria', id: string, secrets?: Array<string | null> | null, insertedAt?: string | null, updatedAt?: string | null, source?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null, context?: { __typename?: 'PipelineContext', id: string, context: Record<string, unknown>, insertedAt?: string | null, updatedAt?: string | null, pullRequests?: Array<{ __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null, pipelinePullRequests?: Array<{ __typename?: 'PipelinePullRequest', id: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, stage?: { __typename?: 'PipelineStage', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null } } | null> | null, stages?: Array<{ __typename?: 'PipelineStage', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, promotion?: { __typename?: 'PipelinePromotion', id: string, insertedAt?: string | null, updatedAt?: string | null, promotedAt?: string | null, revisedAt?: string | null, services?: Array<{ __typename?: 'PromotionService', id: string, insertedAt?: string | null, updatedAt?: string | null, revision?: { __typename?: 'Revision', id: string, insertedAt?: string | null, updatedAt?: string | null, message?: string | null, sha?: string | null, version: string, git?: { __typename?: 'GitRef', ref: string, folder: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null } | null, services?: Array<{ __typename?: 'StageService', id: string, insertedAt?: string | null, updatedAt?: string | null, criteria?: { __typename?: 'PromotionCriteria', id: string, secrets?: Array<string | null> | null, insertedAt?: string | null, updatedAt?: string | null, source?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null, context?: { __typename?: 'PipelineContext', id: string, context: Record<string, unknown>, insertedAt?: string | null, updatedAt?: string | null, pullRequests?: Array<{ __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null, pipelinePullRequests?: Array<{ __typename?: 'PipelinePullRequest', id: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, stage?: { __typename?: 'PipelineStage', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null } | null> | null, status?: { __typename?: 'PipelineStatus', closed?: number | null, pending?: number | null, running?: number | null } | null } | null } | null> | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null } };

export type PipelinesQueryVariables = Exact<{
  q?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  projectId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type PipelinesQuery = { __typename?: 'RootQueryType', pipelines?: { __typename?: 'PipelineConnection', edges?: Array<{ __typename?: 'PipelineEdge', node?: { __typename?: 'Pipeline', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, edges?: Array<{ __typename?: 'PipelineStageEdge', id: string, insertedAt?: string | null, promotedAt?: string | null, updatedAt?: string | null, gates?: Array<{ __typename?: 'PipelineGate', id: string, name: string, state: GateState, type: GateType, insertedAt?: string | null, updatedAt?: string | null, cluster?: { __typename?: 'Cluster', id: string } | null, approver?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null, edge?: { __typename?: 'PipelineStageEdge', pipeline?: { __typename?: 'Pipeline', id: string, name: string } | null } | null, spec?: { __typename?: 'GateSpec', job?: { __typename?: 'JobGateSpec', annotations?: Record<string, unknown> | null, labels?: Record<string, unknown> | null, namespace: string, raw?: string | null, serviceAccount?: string | null, containers?: Array<{ __typename?: 'ContainerSpec', args?: Array<string | null> | null, image: string, env?: Array<{ __typename?: 'ContainerEnv', name: string, value: string } | null> | null, envFrom?: Array<{ __typename?: 'ContainerEnvFrom', configMap: string, secret: string } | null> | null } | null> | null } | null } | null } | null> | null, from: { __typename?: 'PipelineStage', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, promotion?: { __typename?: 'PipelinePromotion', id: string, insertedAt?: string | null, updatedAt?: string | null, promotedAt?: string | null, revisedAt?: string | null, services?: Array<{ __typename?: 'PromotionService', id: string, insertedAt?: string | null, updatedAt?: string | null, revision?: { __typename?: 'Revision', id: string, insertedAt?: string | null, updatedAt?: string | null, message?: string | null, sha?: string | null, version: string, git?: { __typename?: 'GitRef', ref: string, folder: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null } | null, services?: Array<{ __typename?: 'StageService', id: string, insertedAt?: string | null, updatedAt?: string | null, criteria?: { __typename?: 'PromotionCriteria', id: string, secrets?: Array<string | null> | null, insertedAt?: string | null, updatedAt?: string | null, source?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null, context?: { __typename?: 'PipelineContext', id: string, context: Record<string, unknown>, insertedAt?: string | null, updatedAt?: string | null, pullRequests?: Array<{ __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null, pipelinePullRequests?: Array<{ __typename?: 'PipelinePullRequest', id: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, stage?: { __typename?: 'PipelineStage', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null }, to: { __typename?: 'PipelineStage', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, promotion?: { __typename?: 'PipelinePromotion', id: string, insertedAt?: string | null, updatedAt?: string | null, promotedAt?: string | null, revisedAt?: string | null, services?: Array<{ __typename?: 'PromotionService', id: string, insertedAt?: string | null, updatedAt?: string | null, revision?: { __typename?: 'Revision', id: string, insertedAt?: string | null, updatedAt?: string | null, message?: string | null, sha?: string | null, version: string, git?: { __typename?: 'GitRef', ref: string, folder: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null } | null, services?: Array<{ __typename?: 'StageService', id: string, insertedAt?: string | null, updatedAt?: string | null, criteria?: { __typename?: 'PromotionCriteria', id: string, secrets?: Array<string | null> | null, insertedAt?: string | null, updatedAt?: string | null, source?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null, context?: { __typename?: 'PipelineContext', id: string, context: Record<string, unknown>, insertedAt?: string | null, updatedAt?: string | null, pullRequests?: Array<{ __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null, pipelinePullRequests?: Array<{ __typename?: 'PipelinePullRequest', id: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, stage?: { __typename?: 'PipelineStage', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null } } | null> | null, stages?: Array<{ __typename?: 'PipelineStage', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, promotion?: { __typename?: 'PipelinePromotion', id: string, insertedAt?: string | null, updatedAt?: string | null, promotedAt?: string | null, revisedAt?: string | null, services?: Array<{ __typename?: 'PromotionService', id: string, insertedAt?: string | null, updatedAt?: string | null, revision?: { __typename?: 'Revision', id: string, insertedAt?: string | null, updatedAt?: string | null, message?: string | null, sha?: string | null, version: string, git?: { __typename?: 'GitRef', ref: string, folder: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null } | null, services?: Array<{ __typename?: 'StageService', id: string, insertedAt?: string | null, updatedAt?: string | null, criteria?: { __typename?: 'PromotionCriteria', id: string, secrets?: Array<string | null> | null, insertedAt?: string | null, updatedAt?: string | null, source?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null, context?: { __typename?: 'PipelineContext', id: string, context: Record<string, unknown>, insertedAt?: string | null, updatedAt?: string | null, pullRequests?: Array<{ __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null, pipelinePullRequests?: Array<{ __typename?: 'PipelinePullRequest', id: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, stage?: { __typename?: 'PipelineStage', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null } | null> | null, status?: { __typename?: 'PipelineStatus', closed?: number | null, pending?: number | null, running?: number | null } | null } | null } | null> | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null } } | null };

export type PipelineBindingsFragment = { __typename?: 'Pipeline', readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null };

export type PipelineBindingsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type PipelineBindingsQuery = { __typename?: 'RootQueryType', pipeline?: { __typename?: 'Pipeline', readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null } | null };

export type PipelineGateJobFragment = { __typename?: 'Job', raw: string, events?: Array<{ __typename?: 'Event', action?: string | null, count?: number | null, eventTime?: string | null, lastTimestamp?: string | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, pods?: Array<{ __typename?: 'Pod', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'PodStatus', phase?: string | null, podIp?: string | null, reason?: string | null, containerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, initContainerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, conditions?: Array<{ __typename?: 'PodCondition', lastProbeTime?: string | null, lastTransitionTime?: string | null, message?: string | null, reason?: string | null, status?: string | null, type?: string | null } | null> | null }, spec: { __typename?: 'PodSpec', nodeName?: string | null, serviceAccountName?: string | null, containers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null, initContainers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null } } | null> | null, spec: { __typename?: 'JobSpec', activeDeadlineSeconds?: number | null, backoffLimit?: number | null, parallelism?: number | null }, status: { __typename?: 'JobStatus', active?: number | null, completionTime?: string | null, failed?: number | null, startTime?: string | null, succeeded?: number | null } };

export type JobGateQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type JobGateQuery = { __typename?: 'RootQueryType', pipelineGate?: { __typename?: 'PipelineGate', id: string, name: string, state: GateState, type: GateType, insertedAt?: string | null, updatedAt?: string | null, job?: { __typename?: 'Job', raw: string, events?: Array<{ __typename?: 'Event', action?: string | null, count?: number | null, eventTime?: string | null, lastTimestamp?: string | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, pods?: Array<{ __typename?: 'Pod', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'PodStatus', phase?: string | null, podIp?: string | null, reason?: string | null, containerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, initContainerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, conditions?: Array<{ __typename?: 'PodCondition', lastProbeTime?: string | null, lastTransitionTime?: string | null, message?: string | null, reason?: string | null, status?: string | null, type?: string | null } | null> | null }, spec: { __typename?: 'PodSpec', nodeName?: string | null, serviceAccountName?: string | null, containers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null, initContainers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null } } | null> | null, spec: { __typename?: 'JobSpec', activeDeadlineSeconds?: number | null, backoffLimit?: number | null, parallelism?: number | null }, status: { __typename?: 'JobStatus', active?: number | null, completionTime?: string | null, failed?: number | null, startTime?: string | null, succeeded?: number | null } } | null, cluster?: { __typename?: 'Cluster', id: string } | null, approver?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null, edge?: { __typename?: 'PipelineStageEdge', pipeline?: { __typename?: 'Pipeline', id: string, name: string } | null } | null, spec?: { __typename?: 'GateSpec', job?: { __typename?: 'JobGateSpec', annotations?: Record<string, unknown> | null, labels?: Record<string, unknown> | null, namespace: string, raw?: string | null, serviceAccount?: string | null, containers?: Array<{ __typename?: 'ContainerSpec', args?: Array<string | null> | null, image: string, env?: Array<{ __typename?: 'ContainerEnv', name: string, value: string } | null> | null, envFrom?: Array<{ __typename?: 'ContainerEnvFrom', configMap: string, secret: string } | null> | null } | null> | null } | null } | null } | null };

export type JobGateLogsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  container: Scalars['String']['input'];
  sinceSeconds: Scalars['Int']['input'];
}>;


export type JobGateLogsQuery = { __typename?: 'RootQueryType', pipelineGate?: { __typename?: 'PipelineGate', job?: { __typename?: 'Job', logs?: Array<string | null> | null } | null } | null };

export type PipelineQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type PipelineQuery = { __typename?: 'RootQueryType', pipeline?: { __typename?: 'Pipeline', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, edges?: Array<{ __typename?: 'PipelineStageEdge', id: string, insertedAt?: string | null, promotedAt?: string | null, updatedAt?: string | null, gates?: Array<{ __typename?: 'PipelineGate', id: string, name: string, state: GateState, type: GateType, insertedAt?: string | null, updatedAt?: string | null, cluster?: { __typename?: 'Cluster', id: string } | null, approver?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null, edge?: { __typename?: 'PipelineStageEdge', pipeline?: { __typename?: 'Pipeline', id: string, name: string } | null } | null, spec?: { __typename?: 'GateSpec', job?: { __typename?: 'JobGateSpec', annotations?: Record<string, unknown> | null, labels?: Record<string, unknown> | null, namespace: string, raw?: string | null, serviceAccount?: string | null, containers?: Array<{ __typename?: 'ContainerSpec', args?: Array<string | null> | null, image: string, env?: Array<{ __typename?: 'ContainerEnv', name: string, value: string } | null> | null, envFrom?: Array<{ __typename?: 'ContainerEnvFrom', configMap: string, secret: string } | null> | null } | null> | null } | null } | null } | null> | null, from: { __typename?: 'PipelineStage', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, promotion?: { __typename?: 'PipelinePromotion', id: string, insertedAt?: string | null, updatedAt?: string | null, promotedAt?: string | null, revisedAt?: string | null, services?: Array<{ __typename?: 'PromotionService', id: string, insertedAt?: string | null, updatedAt?: string | null, revision?: { __typename?: 'Revision', id: string, insertedAt?: string | null, updatedAt?: string | null, message?: string | null, sha?: string | null, version: string, git?: { __typename?: 'GitRef', ref: string, folder: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null } | null, services?: Array<{ __typename?: 'StageService', id: string, insertedAt?: string | null, updatedAt?: string | null, criteria?: { __typename?: 'PromotionCriteria', id: string, secrets?: Array<string | null> | null, insertedAt?: string | null, updatedAt?: string | null, source?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null, context?: { __typename?: 'PipelineContext', id: string, context: Record<string, unknown>, insertedAt?: string | null, updatedAt?: string | null, pullRequests?: Array<{ __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null, pipelinePullRequests?: Array<{ __typename?: 'PipelinePullRequest', id: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, stage?: { __typename?: 'PipelineStage', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null }, to: { __typename?: 'PipelineStage', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, promotion?: { __typename?: 'PipelinePromotion', id: string, insertedAt?: string | null, updatedAt?: string | null, promotedAt?: string | null, revisedAt?: string | null, services?: Array<{ __typename?: 'PromotionService', id: string, insertedAt?: string | null, updatedAt?: string | null, revision?: { __typename?: 'Revision', id: string, insertedAt?: string | null, updatedAt?: string | null, message?: string | null, sha?: string | null, version: string, git?: { __typename?: 'GitRef', ref: string, folder: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null } | null, services?: Array<{ __typename?: 'StageService', id: string, insertedAt?: string | null, updatedAt?: string | null, criteria?: { __typename?: 'PromotionCriteria', id: string, secrets?: Array<string | null> | null, insertedAt?: string | null, updatedAt?: string | null, source?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null, context?: { __typename?: 'PipelineContext', id: string, context: Record<string, unknown>, insertedAt?: string | null, updatedAt?: string | null, pullRequests?: Array<{ __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null, pipelinePullRequests?: Array<{ __typename?: 'PipelinePullRequest', id: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, stage?: { __typename?: 'PipelineStage', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null } } | null> | null, stages?: Array<{ __typename?: 'PipelineStage', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, promotion?: { __typename?: 'PipelinePromotion', id: string, insertedAt?: string | null, updatedAt?: string | null, promotedAt?: string | null, revisedAt?: string | null, services?: Array<{ __typename?: 'PromotionService', id: string, insertedAt?: string | null, updatedAt?: string | null, revision?: { __typename?: 'Revision', id: string, insertedAt?: string | null, updatedAt?: string | null, message?: string | null, sha?: string | null, version: string, git?: { __typename?: 'GitRef', ref: string, folder: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null } | null, services?: Array<{ __typename?: 'StageService', id: string, insertedAt?: string | null, updatedAt?: string | null, criteria?: { __typename?: 'PromotionCriteria', id: string, secrets?: Array<string | null> | null, insertedAt?: string | null, updatedAt?: string | null, source?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null, context?: { __typename?: 'PipelineContext', id: string, context: Record<string, unknown>, insertedAt?: string | null, updatedAt?: string | null, pullRequests?: Array<{ __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null, pipelinePullRequests?: Array<{ __typename?: 'PipelinePullRequest', id: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, stage?: { __typename?: 'PipelineStage', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null } | null> | null, status?: { __typename?: 'PipelineStatus', closed?: number | null, pending?: number | null, running?: number | null } | null } | null };

export type PipelineContextsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  before?: InputMaybe<Scalars['String']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  first: Scalars['Int']['input'];
  last?: InputMaybe<Scalars['Int']['input']>;
}>;


export type PipelineContextsQuery = { __typename?: 'RootQueryType', pipeline?: { __typename?: 'Pipeline', id: string, contexts?: { __typename?: 'PipelineContextConnection', edges?: Array<{ __typename?: 'PipelineContextEdge', node?: { __typename?: 'PipelineContext', id: string, context: Record<string, unknown>, insertedAt?: string | null, updatedAt?: string | null, pullRequests?: Array<{ __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null, pipelinePullRequests?: Array<{ __typename?: 'PipelinePullRequest', id: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, stage?: { __typename?: 'PipelineStage', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null } | null> | null } | null } | null };

export type PipelineContextQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type PipelineContextQuery = { __typename?: 'RootQueryType', pipelineContext?: { __typename?: 'PipelineContext', id: string, context: Record<string, unknown>, insertedAt?: string | null, updatedAt?: string | null, pipeline?: { __typename?: 'Pipeline', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, edges?: Array<{ __typename?: 'PipelineStageEdge', id: string, insertedAt?: string | null, promotedAt?: string | null, updatedAt?: string | null, gates?: Array<{ __typename?: 'PipelineGate', id: string, name: string, state: GateState, type: GateType, insertedAt?: string | null, updatedAt?: string | null, cluster?: { __typename?: 'Cluster', id: string } | null, approver?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null, edge?: { __typename?: 'PipelineStageEdge', pipeline?: { __typename?: 'Pipeline', id: string, name: string } | null } | null, spec?: { __typename?: 'GateSpec', job?: { __typename?: 'JobGateSpec', annotations?: Record<string, unknown> | null, labels?: Record<string, unknown> | null, namespace: string, raw?: string | null, serviceAccount?: string | null, containers?: Array<{ __typename?: 'ContainerSpec', args?: Array<string | null> | null, image: string, env?: Array<{ __typename?: 'ContainerEnv', name: string, value: string } | null> | null, envFrom?: Array<{ __typename?: 'ContainerEnvFrom', configMap: string, secret: string } | null> | null } | null> | null } | null } | null } | null> | null, from: { __typename?: 'PipelineStage', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, promotion?: { __typename?: 'PipelinePromotion', id: string, insertedAt?: string | null, updatedAt?: string | null, promotedAt?: string | null, revisedAt?: string | null, services?: Array<{ __typename?: 'PromotionService', id: string, insertedAt?: string | null, updatedAt?: string | null, revision?: { __typename?: 'Revision', id: string, insertedAt?: string | null, updatedAt?: string | null, message?: string | null, sha?: string | null, version: string, git?: { __typename?: 'GitRef', ref: string, folder: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null } | null, services?: Array<{ __typename?: 'StageService', id: string, insertedAt?: string | null, updatedAt?: string | null, criteria?: { __typename?: 'PromotionCriteria', id: string, secrets?: Array<string | null> | null, insertedAt?: string | null, updatedAt?: string | null, source?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null, context?: { __typename?: 'PipelineContext', id: string, context: Record<string, unknown>, insertedAt?: string | null, updatedAt?: string | null, pullRequests?: Array<{ __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null, pipelinePullRequests?: Array<{ __typename?: 'PipelinePullRequest', id: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, stage?: { __typename?: 'PipelineStage', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null }, to: { __typename?: 'PipelineStage', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, promotion?: { __typename?: 'PipelinePromotion', id: string, insertedAt?: string | null, updatedAt?: string | null, promotedAt?: string | null, revisedAt?: string | null, services?: Array<{ __typename?: 'PromotionService', id: string, insertedAt?: string | null, updatedAt?: string | null, revision?: { __typename?: 'Revision', id: string, insertedAt?: string | null, updatedAt?: string | null, message?: string | null, sha?: string | null, version: string, git?: { __typename?: 'GitRef', ref: string, folder: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null } | null, services?: Array<{ __typename?: 'StageService', id: string, insertedAt?: string | null, updatedAt?: string | null, criteria?: { __typename?: 'PromotionCriteria', id: string, secrets?: Array<string | null> | null, insertedAt?: string | null, updatedAt?: string | null, source?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null, context?: { __typename?: 'PipelineContext', id: string, context: Record<string, unknown>, insertedAt?: string | null, updatedAt?: string | null, pullRequests?: Array<{ __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null, pipelinePullRequests?: Array<{ __typename?: 'PipelinePullRequest', id: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, stage?: { __typename?: 'PipelineStage', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null } } | null> | null, stages?: Array<{ __typename?: 'PipelineStage', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, promotion?: { __typename?: 'PipelinePromotion', id: string, insertedAt?: string | null, updatedAt?: string | null, promotedAt?: string | null, revisedAt?: string | null, services?: Array<{ __typename?: 'PromotionService', id: string, insertedAt?: string | null, updatedAt?: string | null, revision?: { __typename?: 'Revision', id: string, insertedAt?: string | null, updatedAt?: string | null, message?: string | null, sha?: string | null, version: string, git?: { __typename?: 'GitRef', ref: string, folder: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null } | null, services?: Array<{ __typename?: 'StageService', id: string, insertedAt?: string | null, updatedAt?: string | null, criteria?: { __typename?: 'PromotionCriteria', id: string, secrets?: Array<string | null> | null, insertedAt?: string | null, updatedAt?: string | null, source?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null, context?: { __typename?: 'PipelineContext', id: string, context: Record<string, unknown>, insertedAt?: string | null, updatedAt?: string | null, pullRequests?: Array<{ __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null, pipelinePullRequests?: Array<{ __typename?: 'PipelinePullRequest', id: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, stage?: { __typename?: 'PipelineStage', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null } | null> | null, status?: { __typename?: 'PipelineStatus', closed?: number | null, pending?: number | null, running?: number | null } | null } | null, pullRequests?: Array<{ __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null, pipelinePullRequests?: Array<{ __typename?: 'PipelinePullRequest', id: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, stage?: { __typename?: 'PipelineStage', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null };

export type DeletePipelineMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeletePipelineMutation = { __typename?: 'RootMutationType', deletePipeline?: { __typename?: 'Pipeline', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, edges?: Array<{ __typename?: 'PipelineStageEdge', id: string, insertedAt?: string | null, promotedAt?: string | null, updatedAt?: string | null, gates?: Array<{ __typename?: 'PipelineGate', id: string, name: string, state: GateState, type: GateType, insertedAt?: string | null, updatedAt?: string | null, cluster?: { __typename?: 'Cluster', id: string } | null, approver?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null, edge?: { __typename?: 'PipelineStageEdge', pipeline?: { __typename?: 'Pipeline', id: string, name: string } | null } | null, spec?: { __typename?: 'GateSpec', job?: { __typename?: 'JobGateSpec', annotations?: Record<string, unknown> | null, labels?: Record<string, unknown> | null, namespace: string, raw?: string | null, serviceAccount?: string | null, containers?: Array<{ __typename?: 'ContainerSpec', args?: Array<string | null> | null, image: string, env?: Array<{ __typename?: 'ContainerEnv', name: string, value: string } | null> | null, envFrom?: Array<{ __typename?: 'ContainerEnvFrom', configMap: string, secret: string } | null> | null } | null> | null } | null } | null } | null> | null, from: { __typename?: 'PipelineStage', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, promotion?: { __typename?: 'PipelinePromotion', id: string, insertedAt?: string | null, updatedAt?: string | null, promotedAt?: string | null, revisedAt?: string | null, services?: Array<{ __typename?: 'PromotionService', id: string, insertedAt?: string | null, updatedAt?: string | null, revision?: { __typename?: 'Revision', id: string, insertedAt?: string | null, updatedAt?: string | null, message?: string | null, sha?: string | null, version: string, git?: { __typename?: 'GitRef', ref: string, folder: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null } | null, services?: Array<{ __typename?: 'StageService', id: string, insertedAt?: string | null, updatedAt?: string | null, criteria?: { __typename?: 'PromotionCriteria', id: string, secrets?: Array<string | null> | null, insertedAt?: string | null, updatedAt?: string | null, source?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null, context?: { __typename?: 'PipelineContext', id: string, context: Record<string, unknown>, insertedAt?: string | null, updatedAt?: string | null, pullRequests?: Array<{ __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null, pipelinePullRequests?: Array<{ __typename?: 'PipelinePullRequest', id: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, stage?: { __typename?: 'PipelineStage', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null }, to: { __typename?: 'PipelineStage', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, promotion?: { __typename?: 'PipelinePromotion', id: string, insertedAt?: string | null, updatedAt?: string | null, promotedAt?: string | null, revisedAt?: string | null, services?: Array<{ __typename?: 'PromotionService', id: string, insertedAt?: string | null, updatedAt?: string | null, revision?: { __typename?: 'Revision', id: string, insertedAt?: string | null, updatedAt?: string | null, message?: string | null, sha?: string | null, version: string, git?: { __typename?: 'GitRef', ref: string, folder: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null } | null, services?: Array<{ __typename?: 'StageService', id: string, insertedAt?: string | null, updatedAt?: string | null, criteria?: { __typename?: 'PromotionCriteria', id: string, secrets?: Array<string | null> | null, insertedAt?: string | null, updatedAt?: string | null, source?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null, context?: { __typename?: 'PipelineContext', id: string, context: Record<string, unknown>, insertedAt?: string | null, updatedAt?: string | null, pullRequests?: Array<{ __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null, pipelinePullRequests?: Array<{ __typename?: 'PipelinePullRequest', id: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, stage?: { __typename?: 'PipelineStage', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null } } | null> | null, stages?: Array<{ __typename?: 'PipelineStage', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, promotion?: { __typename?: 'PipelinePromotion', id: string, insertedAt?: string | null, updatedAt?: string | null, promotedAt?: string | null, revisedAt?: string | null, services?: Array<{ __typename?: 'PromotionService', id: string, insertedAt?: string | null, updatedAt?: string | null, revision?: { __typename?: 'Revision', id: string, insertedAt?: string | null, updatedAt?: string | null, message?: string | null, sha?: string | null, version: string, git?: { __typename?: 'GitRef', ref: string, folder: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null } | null, services?: Array<{ __typename?: 'StageService', id: string, insertedAt?: string | null, updatedAt?: string | null, criteria?: { __typename?: 'PromotionCriteria', id: string, secrets?: Array<string | null> | null, insertedAt?: string | null, updatedAt?: string | null, source?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null, context?: { __typename?: 'PipelineContext', id: string, context: Record<string, unknown>, insertedAt?: string | null, updatedAt?: string | null, pullRequests?: Array<{ __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null, pipelinePullRequests?: Array<{ __typename?: 'PipelinePullRequest', id: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, stage?: { __typename?: 'PipelineStage', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null } | null> | null, status?: { __typename?: 'PipelineStatus', closed?: number | null, pending?: number | null, running?: number | null } | null } | null };

export type ApproveGateMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type ApproveGateMutation = { __typename?: 'RootMutationType', approveGate?: { __typename?: 'PipelineGate', id: string, name: string, state: GateState, type: GateType, insertedAt?: string | null, updatedAt?: string | null, cluster?: { __typename?: 'Cluster', id: string } | null, approver?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null, edge?: { __typename?: 'PipelineStageEdge', pipeline?: { __typename?: 'Pipeline', id: string, name: string } | null } | null, spec?: { __typename?: 'GateSpec', job?: { __typename?: 'JobGateSpec', annotations?: Record<string, unknown> | null, labels?: Record<string, unknown> | null, namespace: string, raw?: string | null, serviceAccount?: string | null, containers?: Array<{ __typename?: 'ContainerSpec', args?: Array<string | null> | null, image: string, env?: Array<{ __typename?: 'ContainerEnv', name: string, value: string } | null> | null, envFrom?: Array<{ __typename?: 'ContainerEnvFrom', configMap: string, secret: string } | null> | null } | null> | null } | null } | null } | null };

export type CreatePipelineContextMutationVariables = Exact<{
  pipelineId: Scalars['ID']['input'];
  attributes: PipelineContextAttributes;
}>;


export type CreatePipelineContextMutation = { __typename?: 'RootMutationType', createPipelineContext?: { __typename?: 'PipelineContext', id: string, context: Record<string, unknown>, insertedAt?: string | null, updatedAt?: string | null, pipeline?: { __typename?: 'Pipeline', id: string } | null, pullRequests?: Array<{ __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null, pipelinePullRequests?: Array<{ __typename?: 'PipelinePullRequest', id: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, stage?: { __typename?: 'PipelineStage', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null };

export type ForceGateMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  state?: InputMaybe<GateState>;
}>;


export type ForceGateMutation = { __typename?: 'RootMutationType', forceGate?: { __typename?: 'PipelineGate', id: string, name: string, state: GateState, type: GateType, insertedAt?: string | null, updatedAt?: string | null, cluster?: { __typename?: 'Cluster', id: string } | null, approver?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null, edge?: { __typename?: 'PipelineStageEdge', pipeline?: { __typename?: 'Pipeline', id: string, name: string } | null } | null, spec?: { __typename?: 'GateSpec', job?: { __typename?: 'JobGateSpec', annotations?: Record<string, unknown> | null, labels?: Record<string, unknown> | null, namespace: string, raw?: string | null, serviceAccount?: string | null, containers?: Array<{ __typename?: 'ContainerSpec', args?: Array<string | null> | null, image: string, env?: Array<{ __typename?: 'ContainerEnv', name: string, value: string } | null> | null, envFrom?: Array<{ __typename?: 'ContainerEnvFrom', configMap: string, secret: string } | null> | null } | null> | null } | null } | null } | null };

export type ProviderCredentialFragment = { __typename?: 'ProviderCredential', id: string, insertedAt?: string | null, kind: string, name: string, namespace: string, updatedAt?: string | null };

export type ClusterProviderFragment = { __typename?: 'ClusterProvider', id: string, name: string, namespace: string, cloud: string, editable?: boolean | null, supportedVersions?: Array<string | null> | null, deletedAt?: string | null, insertedAt?: string | null, updatedAt?: string | null, git: { __typename?: 'GitRef', folder: string, ref: string }, repository?: { __typename?: 'GitRepository', id: string, url: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string } | null, credentials?: Array<{ __typename?: 'ProviderCredential', id: string, insertedAt?: string | null, kind: string, name: string, namespace: string, updatedAt?: string | null } | null> | null };

export type ClusterProvidersQueryVariables = Exact<{ [key: string]: never; }>;


export type ClusterProvidersQuery = { __typename?: 'RootQueryType', clusterProviders?: { __typename?: 'ClusterProviderConnection', edges?: Array<{ __typename?: 'ClusterProviderEdge', node?: { __typename?: 'ClusterProvider', id: string, name: string, namespace: string, cloud: string, editable?: boolean | null, supportedVersions?: Array<string | null> | null, deletedAt?: string | null, insertedAt?: string | null, updatedAt?: string | null, git: { __typename?: 'GitRef', folder: string, ref: string }, repository?: { __typename?: 'GitRepository', id: string, url: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string } | null, credentials?: Array<{ __typename?: 'ProviderCredential', id: string, insertedAt?: string | null, kind: string, name: string, namespace: string, updatedAt?: string | null } | null> | null } | null } | null> | null } | null };

export type CreateClusterProviderMutationVariables = Exact<{
  attributes: ClusterProviderAttributes;
}>;


export type CreateClusterProviderMutation = { __typename?: 'RootMutationType', createClusterProvider?: { __typename?: 'ClusterProvider', id: string, name: string, namespace: string, cloud: string, editable?: boolean | null, supportedVersions?: Array<string | null> | null, deletedAt?: string | null, insertedAt?: string | null, updatedAt?: string | null, git: { __typename?: 'GitRef', folder: string, ref: string }, repository?: { __typename?: 'GitRepository', id: string, url: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string } | null, credentials?: Array<{ __typename?: 'ProviderCredential', id: string, insertedAt?: string | null, kind: string, name: string, namespace: string, updatedAt?: string | null } | null> | null } | null };

export type UpdateClusterProviderMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  attributes: ClusterProviderUpdateAttributes;
}>;


export type UpdateClusterProviderMutation = { __typename?: 'RootMutationType', updateClusterProvider?: { __typename?: 'ClusterProvider', id: string, name: string, namespace: string, cloud: string, editable?: boolean | null, supportedVersions?: Array<string | null> | null, deletedAt?: string | null, insertedAt?: string | null, updatedAt?: string | null, git: { __typename?: 'GitRef', folder: string, ref: string }, repository?: { __typename?: 'GitRepository', id: string, url: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string } | null, credentials?: Array<{ __typename?: 'ProviderCredential', id: string, insertedAt?: string | null, kind: string, name: string, namespace: string, updatedAt?: string | null } | null> | null } | null };

export type DeleteClusterProviderMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteClusterProviderMutation = { __typename?: 'RootMutationType', deleteClusterProvider?: { __typename?: 'ClusterProvider', id: string, name: string, namespace: string, cloud: string, editable?: boolean | null, supportedVersions?: Array<string | null> | null, deletedAt?: string | null, insertedAt?: string | null, updatedAt?: string | null, git: { __typename?: 'GitRef', folder: string, ref: string }, repository?: { __typename?: 'GitRepository', id: string, url: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string } | null, credentials?: Array<{ __typename?: 'ProviderCredential', id: string, insertedAt?: string | null, kind: string, name: string, namespace: string, updatedAt?: string | null } | null> | null } | null };

export type PullRequestFragment = { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null };

export type CreatePullRequestMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  branch: Scalars['String']['input'];
  identifier?: InputMaybe<Scalars['String']['input']>;
  context: Scalars['Json']['input'];
  threadId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type CreatePullRequestMutation = { __typename?: 'RootMutationType', createPullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null };

export type UpdatePullRequestMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  attributes?: InputMaybe<PullRequestUpdateAttributes>;
}>;


export type UpdatePullRequestMutation = { __typename?: 'RootMutationType', updatePullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null };

export type DeletePullRequestMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeletePullRequestMutation = { __typename?: 'RootMutationType', deletePullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null };

export type PullRequestConnectionFragment = { __typename?: 'PullRequestConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'PullRequestEdge', node?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null };

export type PullRequestsQueryVariables = Exact<{
  q?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  serviceId?: InputMaybe<Scalars['ID']['input']>;
  open?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type PullRequestsQuery = { __typename?: 'RootQueryType', pullRequests?: { __typename?: 'PullRequestConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'PullRequestEdge', node?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null };

export type ServiceDeploymentRevisionFragment = { __typename?: 'Revision', id: string, sha?: string | null, version: string, message?: string | null, updatedAt?: string | null, insertedAt?: string | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, version?: string | null } | null, git?: { __typename?: 'GitRef', folder: string, ref: string } | null };

export type ServiceDeploymentsRowFragment = { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, promotion?: ServicePromotion | null, message?: string | null, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null, componentStatus?: string | null, status: ServiceDeploymentStatus, dryRun?: boolean | null, git?: { __typename?: 'GitRef', ref: string, folder: string } | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, version?: string | null, url?: string | null, repository?: { __typename?: 'ObjectReference', namespace?: string | null, name?: string | null } | null } | null, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, helmRepository?: { __typename?: 'FluxHelmRepository', spec: { __typename?: 'HelmRepositorySpec', url: string }, status?: { __typename?: 'HelmRepositoryStatus', ready?: boolean | null, message?: string | null } | null } | null, repository?: { __typename?: 'GitRepository', id: string, url: string } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string, warning?: boolean | null } | null> | null, globalService?: { __typename?: 'GlobalService', id: string, name: string } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null };

export type ServiceDeploymentDetailsFragment = { __typename?: 'ServiceDeployment', namespace: string, message?: string | null, version: string, id: string, name: string, protect?: boolean | null, promotion?: ServicePromotion | null, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null, componentStatus?: string | null, status: ServiceDeploymentStatus, dryRun?: boolean | null, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, operationalLayout?: { __typename?: 'OperationalLayout', serviceMesh?: ServiceMesh | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, helm?: { __typename?: 'HelmSpec', values?: string | null, valuesFiles?: Array<string | null> | null, chart?: string | null, version?: string | null, url?: string | null, repository?: { __typename?: 'ObjectReference', namespace?: string | null, name?: string | null } | null } | null, components?: Array<{ __typename?: 'ServiceComponent', id: string, uid?: string | null, name: string, group?: string | null, kind: string, namespace?: string | null, state?: ComponentState | null, synced: boolean, version?: string | null, apiDeprecations?: Array<{ __typename?: 'ApiDeprecation', availableIn?: string | null, blocking?: boolean | null, deprecatedIn?: string | null, removedIn?: string | null, replacement?: string | null, component?: { __typename?: 'ServiceComponent', group?: string | null, version?: string | null, kind: string, name: string, namespace?: string | null, service?: { __typename?: 'ServiceDeployment', git?: { __typename?: 'GitRef', ref: string, folder: string } | null, repository?: { __typename?: 'GitRepository', httpsPath?: string | null, urlFormat?: string | null } | null } | null } | null } | null> | null, content?: { __typename?: 'ComponentContent', desired?: string | null, live?: string | null } | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null> | null, contexts?: Array<{ __typename?: 'ServiceContext', id: string, configuration?: Record<string, unknown> | null, name: string, insertedAt?: string | null, updatedAt?: string | null, project?: { __typename?: 'Project', id: string, name: string } | null, secrets?: Array<{ __typename?: 'ServiceConfiguration', name: string, value: string } | null> | null } | null> | null, dependencies?: Array<{ __typename?: 'ServiceDependency', id: string, name: string, status?: ServiceDeploymentStatus | null, updatedAt?: string | null } | null> | null, repository?: { __typename?: 'GitRepository', pulledAt?: string | null, id: string, url: string } | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null, imports?: Array<{ __typename?: 'ServiceImport', stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType, status: StackStatus, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null } | null } | null> | null, parent?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string } | null } | null, alerts?: { __typename?: 'AlertConnection', edges?: Array<{ __typename?: 'AlertEdge', node?: { __typename?: 'Alert', id: string } | null } | null> | null } | null, scalingRecommendations?: Array<{ __typename?: 'ClusterScalingRecommendation', id: string, namespace?: string | null, name?: string | null, type?: ScalingRecommendationType | null, container?: string | null, cpuCost?: number | null, cpuRequest?: number | null, cpuRecommendation?: number | null, memoryCost?: number | null, memoryRequest?: number | null, memoryRecommendation?: number | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, componentStatus?: string | null, status: ServiceDeploymentStatus, cluster?: { __typename?: 'Cluster', distro?: ClusterDistro | null, id: string, name: string, handle?: string | null, provider?: { __typename?: 'ClusterProvider', id: string, cloud: string, name: string, namespace: string, supportedVersions?: Array<string | null> | null } | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null } | null } | null> | null, git?: { __typename?: 'GitRef', ref: string, folder: string } | null, helmRepository?: { __typename?: 'FluxHelmRepository', spec: { __typename?: 'HelmRepositorySpec', url: string }, status?: { __typename?: 'HelmRepositoryStatus', ready?: boolean | null, message?: string | null } | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string, warning?: boolean | null } | null> | null, globalService?: { __typename?: 'GlobalService', id: string, name: string } | null };

export type ServiceDeploymentComponentFragment = { __typename?: 'ServiceComponent', id: string, uid?: string | null, name: string, group?: string | null, kind: string, namespace?: string | null, state?: ComponentState | null, synced: boolean, version?: string | null, apiDeprecations?: Array<{ __typename?: 'ApiDeprecation', availableIn?: string | null, blocking?: boolean | null, deprecatedIn?: string | null, removedIn?: string | null, replacement?: string | null, component?: { __typename?: 'ServiceComponent', group?: string | null, version?: string | null, kind: string, name: string, namespace?: string | null, service?: { __typename?: 'ServiceDeployment', git?: { __typename?: 'GitRef', ref: string, folder: string } | null, repository?: { __typename?: 'GitRepository', httpsPath?: string | null, urlFormat?: string | null } | null } | null } | null } | null> | null, content?: { __typename?: 'ComponentContent', desired?: string | null, live?: string | null } | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null };

export type ServiceDeploymentComponentWithChildrenFragment = { __typename?: 'ServiceComponent', id: string, uid?: string | null, name: string, group?: string | null, kind: string, namespace?: string | null, state?: ComponentState | null, synced: boolean, version?: string | null, children?: Array<{ __typename?: 'ServiceComponentChild', id: string, group?: string | null, kind: string, version: string, name: string, namespace?: string | null, parentUid?: string | null, uid: string, state?: ComponentState | null, insertedAt?: string | null, updatedAt?: string | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null> | null, apiDeprecations?: Array<{ __typename?: 'ApiDeprecation', availableIn?: string | null, blocking?: boolean | null, deprecatedIn?: string | null, removedIn?: string | null, replacement?: string | null, component?: { __typename?: 'ServiceComponent', group?: string | null, version?: string | null, kind: string, name: string, namespace?: string | null, service?: { __typename?: 'ServiceDeployment', git?: { __typename?: 'GitRef', ref: string, folder: string } | null, repository?: { __typename?: 'GitRepository', httpsPath?: string | null, urlFormat?: string | null } | null } | null } | null } | null> | null, content?: { __typename?: 'ComponentContent', desired?: string | null, live?: string | null } | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null };

export type ServiceComponentChildFragment = { __typename?: 'ServiceComponentChild', id: string, group?: string | null, kind: string, version: string, name: string, namespace?: string | null, parentUid?: string | null, uid: string, state?: ComponentState | null, insertedAt?: string | null, updatedAt?: string | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null };

export type ServiceDeploymentRevisionsFragment = { __typename?: 'ServiceDeployment', revision?: { __typename?: 'Revision', id: string, sha?: string | null, version: string, message?: string | null, updatedAt?: string | null, insertedAt?: string | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, version?: string | null } | null, git?: { __typename?: 'GitRef', folder: string, ref: string } | null } | null, revisions?: { __typename?: 'RevisionConnection', edges?: Array<{ __typename?: 'RevisionEdge', node?: { __typename?: 'Revision', id: string, sha?: string | null, version: string, message?: string | null, updatedAt?: string | null, insertedAt?: string | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, version?: string | null } | null, git?: { __typename?: 'GitRef', folder: string, ref: string } | null } | null } | null> | null } | null };

export type ServiceDeploymentTinyFragment = { __typename?: 'ServiceDeployment', id: string, name: string, componentStatus?: string | null, status: ServiceDeploymentStatus, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null };

export type ServiceTreeNodeFragment = { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, updatedAt?: string | null, status: ServiceDeploymentStatus, componentStatus?: string | null, components?: Array<{ __typename?: 'ServiceComponent', id: string, uid?: string | null, name: string, group?: string | null, kind: string, namespace?: string | null, state?: ComponentState | null, synced: boolean, version?: string | null, apiDeprecations?: Array<{ __typename?: 'ApiDeprecation', availableIn?: string | null, blocking?: boolean | null, deprecatedIn?: string | null, removedIn?: string | null, replacement?: string | null, component?: { __typename?: 'ServiceComponent', group?: string | null, version?: string | null, kind: string, name: string, namespace?: string | null, service?: { __typename?: 'ServiceDeployment', git?: { __typename?: 'GitRef', ref: string, folder: string } | null, repository?: { __typename?: 'GitRepository', httpsPath?: string | null, urlFormat?: string | null } | null } | null } | null } | null> | null, content?: { __typename?: 'ComponentContent', desired?: string | null, live?: string | null } | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, repository?: { __typename?: 'GitRepository', url: string, pulledAt?: string | null } | null, git?: { __typename?: 'GitRef', ref: string, folder: string } | null, helmRepository?: { __typename?: 'FluxHelmRepository', spec: { __typename?: 'HelmRepositorySpec', url: string } } | null, parent?: { __typename?: 'ServiceDeployment', id: string, name: string } | null, owner?: { __typename?: 'GlobalService', id: string, name: string } | null, errors?: Array<{ __typename?: 'ServiceError', source: string, message: string } | null> | null };

export type ServiceDeploymentsConnectionFragment = { __typename?: 'ServiceDeploymentConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ServiceDeploymentEdge', node?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, promotion?: ServicePromotion | null, message?: string | null, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null, componentStatus?: string | null, status: ServiceDeploymentStatus, dryRun?: boolean | null, git?: { __typename?: 'GitRef', ref: string, folder: string } | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, version?: string | null, url?: string | null, repository?: { __typename?: 'ObjectReference', namespace?: string | null, name?: string | null } | null } | null, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, helmRepository?: { __typename?: 'FluxHelmRepository', spec: { __typename?: 'HelmRepositorySpec', url: string }, status?: { __typename?: 'HelmRepositoryStatus', ready?: boolean | null, message?: string | null } | null } | null, repository?: { __typename?: 'GitRepository', id: string, url: string } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string, warning?: boolean | null } | null> | null, globalService?: { __typename?: 'GlobalService', id: string, name: string } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null } | null> | null };

export type ServiceContextFragment = { __typename?: 'ServiceContext', id: string, configuration?: Record<string, unknown> | null, name: string, insertedAt?: string | null, updatedAt?: string | null, project?: { __typename?: 'Project', id: string, name: string } | null, secrets?: Array<{ __typename?: 'ServiceConfiguration', name: string, value: string } | null> | null };

export type ServiceDependencyFragment = { __typename?: 'ServiceDependency', id: string, name: string, status?: ServiceDeploymentStatus | null, updatedAt?: string | null };

export type ServiceDeploymentsQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
  cluster?: InputMaybe<Scalars['String']['input']>;
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  status?: InputMaybe<ServiceDeploymentStatus>;
  projectId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type ServiceDeploymentsQuery = { __typename?: 'RootQueryType', serviceDeployments?: { __typename?: 'ServiceDeploymentConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ServiceDeploymentEdge', node?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, promotion?: ServicePromotion | null, message?: string | null, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null, componentStatus?: string | null, status: ServiceDeploymentStatus, dryRun?: boolean | null, git?: { __typename?: 'GitRef', ref: string, folder: string } | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, version?: string | null, url?: string | null, repository?: { __typename?: 'ObjectReference', namespace?: string | null, name?: string | null } | null } | null, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, helmRepository?: { __typename?: 'FluxHelmRepository', spec: { __typename?: 'HelmRepositorySpec', url: string }, status?: { __typename?: 'HelmRepositoryStatus', ready?: boolean | null, message?: string | null } | null } | null, repository?: { __typename?: 'GitRepository', id: string, url: string } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string, warning?: boolean | null } | null> | null, globalService?: { __typename?: 'GlobalService', id: string, name: string } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null } | null> | null } | null, serviceStatuses?: Array<{ __typename?: 'ServiceStatusCount', count: number, status: ServiceDeploymentStatus } | null> | null };

export type ServiceDeploymentsTinyQueryVariables = Exact<{
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  projectId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type ServiceDeploymentsTinyQuery = { __typename?: 'RootQueryType', serviceDeployments?: { __typename?: 'ServiceDeploymentConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ServiceDeploymentEdge', node?: { __typename?: 'ServiceDeployment', id: string, name: string, componentStatus?: string | null, status: ServiceDeploymentStatus, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null } | null } | null> | null } | null };

export type ServiceTreeQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ServiceDeploymentStatus>;
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  projectId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type ServiceTreeQuery = { __typename?: 'RootQueryType', serviceTree?: { __typename?: 'ServiceDeploymentConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ServiceDeploymentEdge', node?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, updatedAt?: string | null, status: ServiceDeploymentStatus, componentStatus?: string | null, components?: Array<{ __typename?: 'ServiceComponent', id: string, uid?: string | null, name: string, group?: string | null, kind: string, namespace?: string | null, state?: ComponentState | null, synced: boolean, version?: string | null, apiDeprecations?: Array<{ __typename?: 'ApiDeprecation', availableIn?: string | null, blocking?: boolean | null, deprecatedIn?: string | null, removedIn?: string | null, replacement?: string | null, component?: { __typename?: 'ServiceComponent', group?: string | null, version?: string | null, kind: string, name: string, namespace?: string | null, service?: { __typename?: 'ServiceDeployment', git?: { __typename?: 'GitRef', ref: string, folder: string } | null, repository?: { __typename?: 'GitRepository', httpsPath?: string | null, urlFormat?: string | null } | null } | null } | null } | null> | null, content?: { __typename?: 'ComponentContent', desired?: string | null, live?: string | null } | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, repository?: { __typename?: 'GitRepository', url: string, pulledAt?: string | null } | null, git?: { __typename?: 'GitRef', ref: string, folder: string } | null, helmRepository?: { __typename?: 'FluxHelmRepository', spec: { __typename?: 'HelmRepositorySpec', url: string } } | null, parent?: { __typename?: 'ServiceDeployment', id: string, name: string } | null, owner?: { __typename?: 'GlobalService', id: string, name: string } | null, errors?: Array<{ __typename?: 'ServiceError', source: string, message: string } | null> | null } | null } | null> | null } | null };

export type ServiceDeploymentQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type ServiceDeploymentQuery = { __typename?: 'RootQueryType', serviceDeployment?: { __typename?: 'ServiceDeployment', namespace: string, message?: string | null, version: string, id: string, name: string, protect?: boolean | null, promotion?: ServicePromotion | null, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null, componentStatus?: string | null, status: ServiceDeploymentStatus, dryRun?: boolean | null, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, operationalLayout?: { __typename?: 'OperationalLayout', serviceMesh?: ServiceMesh | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, helm?: { __typename?: 'HelmSpec', values?: string | null, valuesFiles?: Array<string | null> | null, chart?: string | null, version?: string | null, url?: string | null, repository?: { __typename?: 'ObjectReference', namespace?: string | null, name?: string | null } | null } | null, components?: Array<{ __typename?: 'ServiceComponent', id: string, uid?: string | null, name: string, group?: string | null, kind: string, namespace?: string | null, state?: ComponentState | null, synced: boolean, version?: string | null, apiDeprecations?: Array<{ __typename?: 'ApiDeprecation', availableIn?: string | null, blocking?: boolean | null, deprecatedIn?: string | null, removedIn?: string | null, replacement?: string | null, component?: { __typename?: 'ServiceComponent', group?: string | null, version?: string | null, kind: string, name: string, namespace?: string | null, service?: { __typename?: 'ServiceDeployment', git?: { __typename?: 'GitRef', ref: string, folder: string } | null, repository?: { __typename?: 'GitRepository', httpsPath?: string | null, urlFormat?: string | null } | null } | null } | null } | null> | null, content?: { __typename?: 'ComponentContent', desired?: string | null, live?: string | null } | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null> | null, contexts?: Array<{ __typename?: 'ServiceContext', id: string, configuration?: Record<string, unknown> | null, name: string, insertedAt?: string | null, updatedAt?: string | null, project?: { __typename?: 'Project', id: string, name: string } | null, secrets?: Array<{ __typename?: 'ServiceConfiguration', name: string, value: string } | null> | null } | null> | null, dependencies?: Array<{ __typename?: 'ServiceDependency', id: string, name: string, status?: ServiceDeploymentStatus | null, updatedAt?: string | null } | null> | null, repository?: { __typename?: 'GitRepository', pulledAt?: string | null, id: string, url: string } | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null, imports?: Array<{ __typename?: 'ServiceImport', stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType, status: StackStatus, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null } | null } | null> | null, parent?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string } | null } | null, alerts?: { __typename?: 'AlertConnection', edges?: Array<{ __typename?: 'AlertEdge', node?: { __typename?: 'Alert', id: string } | null } | null> | null } | null, scalingRecommendations?: Array<{ __typename?: 'ClusterScalingRecommendation', id: string, namespace?: string | null, name?: string | null, type?: ScalingRecommendationType | null, container?: string | null, cpuCost?: number | null, cpuRequest?: number | null, cpuRecommendation?: number | null, memoryCost?: number | null, memoryRequest?: number | null, memoryRecommendation?: number | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, componentStatus?: string | null, status: ServiceDeploymentStatus, cluster?: { __typename?: 'Cluster', distro?: ClusterDistro | null, id: string, name: string, handle?: string | null, provider?: { __typename?: 'ClusterProvider', id: string, cloud: string, name: string, namespace: string, supportedVersions?: Array<string | null> | null } | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null } | null } | null> | null, git?: { __typename?: 'GitRef', ref: string, folder: string } | null, helmRepository?: { __typename?: 'FluxHelmRepository', spec: { __typename?: 'HelmRepositorySpec', url: string }, status?: { __typename?: 'HelmRepositoryStatus', ready?: boolean | null, message?: string | null } | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string, warning?: boolean | null } | null> | null, globalService?: { __typename?: 'GlobalService', id: string, name: string } | null } | null };

export type ServiceDeploymentTinyQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type ServiceDeploymentTinyQuery = { __typename?: 'RootQueryType', serviceDeployment?: { __typename?: 'ServiceDeployment', id: string, name: string, componentStatus?: string | null, status: ServiceDeploymentStatus, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null } | null };

export type ServiceDeploymentComponentsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type ServiceDeploymentComponentsQuery = { __typename?: 'RootQueryType', serviceDeployment?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null } | null, components?: Array<{ __typename?: 'ServiceComponent', id: string, uid?: string | null, name: string, group?: string | null, kind: string, namespace?: string | null, state?: ComponentState | null, synced: boolean, version?: string | null, apiDeprecations?: Array<{ __typename?: 'ApiDeprecation', availableIn?: string | null, blocking?: boolean | null, deprecatedIn?: string | null, removedIn?: string | null, replacement?: string | null, component?: { __typename?: 'ServiceComponent', group?: string | null, version?: string | null, kind: string, name: string, namespace?: string | null, service?: { __typename?: 'ServiceDeployment', git?: { __typename?: 'GitRef', ref: string, folder: string } | null, repository?: { __typename?: 'GitRepository', httpsPath?: string | null, urlFormat?: string | null } | null } | null } | null } | null> | null, content?: { __typename?: 'ComponentContent', desired?: string | null, live?: string | null } | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null> | null } | null };

export type ServiceDeploymentComponentsWithChildrenQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type ServiceDeploymentComponentsWithChildrenQuery = { __typename?: 'RootQueryType', serviceDeployment?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null } | null, components?: Array<{ __typename?: 'ServiceComponent', id: string, uid?: string | null, name: string, group?: string | null, kind: string, namespace?: string | null, state?: ComponentState | null, synced: boolean, version?: string | null, children?: Array<{ __typename?: 'ServiceComponentChild', id: string, group?: string | null, kind: string, version: string, name: string, namespace?: string | null, parentUid?: string | null, uid: string, state?: ComponentState | null, insertedAt?: string | null, updatedAt?: string | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null> | null, apiDeprecations?: Array<{ __typename?: 'ApiDeprecation', availableIn?: string | null, blocking?: boolean | null, deprecatedIn?: string | null, removedIn?: string | null, replacement?: string | null, component?: { __typename?: 'ServiceComponent', group?: string | null, version?: string | null, kind: string, name: string, namespace?: string | null, service?: { __typename?: 'ServiceDeployment', git?: { __typename?: 'GitRef', ref: string, folder: string } | null, repository?: { __typename?: 'GitRepository', httpsPath?: string | null, urlFormat?: string | null } | null } | null } | null } | null> | null, content?: { __typename?: 'ComponentContent', desired?: string | null, live?: string | null } | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null> | null } | null };

export type ServiceDeploymentSecretsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type ServiceDeploymentSecretsQuery = { __typename?: 'RootQueryType', serviceDeployment?: { __typename?: 'ServiceDeployment', configuration?: Array<{ __typename?: 'ServiceConfiguration', name: string, value: string } | null> | null, helm?: { __typename?: 'HelmSpec', values?: string | null } | null } | null };

export type ServiceDeploymentRevisionsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type ServiceDeploymentRevisionsQuery = { __typename?: 'RootQueryType', serviceDeployment?: { __typename?: 'ServiceDeployment', revision?: { __typename?: 'Revision', id: string, sha?: string | null, version: string, message?: string | null, updatedAt?: string | null, insertedAt?: string | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, version?: string | null } | null, git?: { __typename?: 'GitRef', folder: string, ref: string } | null } | null, revisions?: { __typename?: 'RevisionConnection', edges?: Array<{ __typename?: 'RevisionEdge', node?: { __typename?: 'Revision', id: string, sha?: string | null, version: string, message?: string | null, updatedAt?: string | null, insertedAt?: string | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, version?: string | null } | null, git?: { __typename?: 'GitRef', folder: string, ref: string } | null } | null } | null> | null } | null } | null };

export type CreateServiceDeploymentMutationVariables = Exact<{
  attributes: ServiceDeploymentAttributes;
  cluster?: InputMaybe<Scalars['String']['input']>;
  clusterId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type CreateServiceDeploymentMutation = { __typename?: 'RootMutationType', createServiceDeployment?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, promotion?: ServicePromotion | null, message?: string | null, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null, componentStatus?: string | null, status: ServiceDeploymentStatus, dryRun?: boolean | null, git?: { __typename?: 'GitRef', ref: string, folder: string } | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, version?: string | null, url?: string | null, repository?: { __typename?: 'ObjectReference', namespace?: string | null, name?: string | null } | null } | null, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, helmRepository?: { __typename?: 'FluxHelmRepository', spec: { __typename?: 'HelmRepositorySpec', url: string }, status?: { __typename?: 'HelmRepositoryStatus', ready?: boolean | null, message?: string | null } | null } | null, repository?: { __typename?: 'GitRepository', id: string, url: string } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string, warning?: boolean | null } | null> | null, globalService?: { __typename?: 'GlobalService', id: string, name: string } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null };

export type UpdateServiceDeploymentMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  attributes: ServiceUpdateAttributes;
}>;


export type UpdateServiceDeploymentMutation = { __typename?: 'RootMutationType', updateServiceDeployment?: { __typename?: 'ServiceDeployment', namespace: string, message?: string | null, version: string, id: string, name: string, protect?: boolean | null, promotion?: ServicePromotion | null, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null, componentStatus?: string | null, status: ServiceDeploymentStatus, dryRun?: boolean | null, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, operationalLayout?: { __typename?: 'OperationalLayout', serviceMesh?: ServiceMesh | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, helm?: { __typename?: 'HelmSpec', values?: string | null, valuesFiles?: Array<string | null> | null, chart?: string | null, version?: string | null, url?: string | null, repository?: { __typename?: 'ObjectReference', namespace?: string | null, name?: string | null } | null } | null, components?: Array<{ __typename?: 'ServiceComponent', id: string, uid?: string | null, name: string, group?: string | null, kind: string, namespace?: string | null, state?: ComponentState | null, synced: boolean, version?: string | null, apiDeprecations?: Array<{ __typename?: 'ApiDeprecation', availableIn?: string | null, blocking?: boolean | null, deprecatedIn?: string | null, removedIn?: string | null, replacement?: string | null, component?: { __typename?: 'ServiceComponent', group?: string | null, version?: string | null, kind: string, name: string, namespace?: string | null, service?: { __typename?: 'ServiceDeployment', git?: { __typename?: 'GitRef', ref: string, folder: string } | null, repository?: { __typename?: 'GitRepository', httpsPath?: string | null, urlFormat?: string | null } | null } | null } | null } | null> | null, content?: { __typename?: 'ComponentContent', desired?: string | null, live?: string | null } | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null> | null, contexts?: Array<{ __typename?: 'ServiceContext', id: string, configuration?: Record<string, unknown> | null, name: string, insertedAt?: string | null, updatedAt?: string | null, project?: { __typename?: 'Project', id: string, name: string } | null, secrets?: Array<{ __typename?: 'ServiceConfiguration', name: string, value: string } | null> | null } | null> | null, dependencies?: Array<{ __typename?: 'ServiceDependency', id: string, name: string, status?: ServiceDeploymentStatus | null, updatedAt?: string | null } | null> | null, repository?: { __typename?: 'GitRepository', pulledAt?: string | null, id: string, url: string } | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null, imports?: Array<{ __typename?: 'ServiceImport', stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType, status: StackStatus, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null } | null } | null> | null, parent?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string } | null } | null, alerts?: { __typename?: 'AlertConnection', edges?: Array<{ __typename?: 'AlertEdge', node?: { __typename?: 'Alert', id: string } | null } | null> | null } | null, scalingRecommendations?: Array<{ __typename?: 'ClusterScalingRecommendation', id: string, namespace?: string | null, name?: string | null, type?: ScalingRecommendationType | null, container?: string | null, cpuCost?: number | null, cpuRequest?: number | null, cpuRecommendation?: number | null, memoryCost?: number | null, memoryRequest?: number | null, memoryRecommendation?: number | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, componentStatus?: string | null, status: ServiceDeploymentStatus, cluster?: { __typename?: 'Cluster', distro?: ClusterDistro | null, id: string, name: string, handle?: string | null, provider?: { __typename?: 'ClusterProvider', id: string, cloud: string, name: string, namespace: string, supportedVersions?: Array<string | null> | null } | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null } | null } | null> | null, git?: { __typename?: 'GitRef', ref: string, folder: string } | null, helmRepository?: { __typename?: 'FluxHelmRepository', spec: { __typename?: 'HelmRepositorySpec', url: string }, status?: { __typename?: 'HelmRepositoryStatus', ready?: boolean | null, message?: string | null } | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string, warning?: boolean | null } | null> | null, globalService?: { __typename?: 'GlobalService', id: string, name: string } | null } | null };

export type MergeServiceMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  configuration?: InputMaybe<Array<InputMaybe<ConfigAttributes>> | InputMaybe<ConfigAttributes>>;
}>;


export type MergeServiceMutation = { __typename?: 'RootMutationType', mergeService?: { __typename?: 'ServiceDeployment', configuration?: Array<{ __typename?: 'ServiceConfiguration', name: string, value: string } | null> | null } | null };

export type DeleteServiceDeploymentMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteServiceDeploymentMutation = { __typename?: 'RootMutationType', deleteServiceDeployment?: { __typename?: 'ServiceDeployment', id: string } | null };

export type DetachServiceDeploymentMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DetachServiceDeploymentMutation = { __typename?: 'RootMutationType', detachServiceDeployment?: { __typename?: 'ServiceDeployment', id: string } | null };

export type RollbackServiceMutationVariables = Exact<{
  id?: InputMaybe<Scalars['ID']['input']>;
  revisionId: Scalars['ID']['input'];
}>;


export type RollbackServiceMutation = { __typename?: 'RootMutationType', rollbackService?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, promotion?: ServicePromotion | null, message?: string | null, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null, componentStatus?: string | null, status: ServiceDeploymentStatus, dryRun?: boolean | null, git?: { __typename?: 'GitRef', ref: string, folder: string } | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, version?: string | null, url?: string | null, repository?: { __typename?: 'ObjectReference', namespace?: string | null, name?: string | null } | null } | null, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, helmRepository?: { __typename?: 'FluxHelmRepository', spec: { __typename?: 'HelmRepositorySpec', url: string }, status?: { __typename?: 'HelmRepositoryStatus', ready?: boolean | null, message?: string | null } | null } | null, repository?: { __typename?: 'GitRepository', id: string, url: string } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string, warning?: boolean | null } | null> | null, globalService?: { __typename?: 'GlobalService', id: string, name: string } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null };

export type ProceedServiceMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  promotion?: InputMaybe<ServicePromotion>;
}>;


export type ProceedServiceMutation = { __typename?: 'RootMutationType', proceed?: { __typename?: 'ServiceDeployment', namespace: string, message?: string | null, version: string, id: string, name: string, protect?: boolean | null, promotion?: ServicePromotion | null, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null, componentStatus?: string | null, status: ServiceDeploymentStatus, dryRun?: boolean | null, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, operationalLayout?: { __typename?: 'OperationalLayout', serviceMesh?: ServiceMesh | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, helm?: { __typename?: 'HelmSpec', values?: string | null, valuesFiles?: Array<string | null> | null, chart?: string | null, version?: string | null, url?: string | null, repository?: { __typename?: 'ObjectReference', namespace?: string | null, name?: string | null } | null } | null, components?: Array<{ __typename?: 'ServiceComponent', id: string, uid?: string | null, name: string, group?: string | null, kind: string, namespace?: string | null, state?: ComponentState | null, synced: boolean, version?: string | null, apiDeprecations?: Array<{ __typename?: 'ApiDeprecation', availableIn?: string | null, blocking?: boolean | null, deprecatedIn?: string | null, removedIn?: string | null, replacement?: string | null, component?: { __typename?: 'ServiceComponent', group?: string | null, version?: string | null, kind: string, name: string, namespace?: string | null, service?: { __typename?: 'ServiceDeployment', git?: { __typename?: 'GitRef', ref: string, folder: string } | null, repository?: { __typename?: 'GitRepository', httpsPath?: string | null, urlFormat?: string | null } | null } | null } | null } | null> | null, content?: { __typename?: 'ComponentContent', desired?: string | null, live?: string | null } | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null> | null, contexts?: Array<{ __typename?: 'ServiceContext', id: string, configuration?: Record<string, unknown> | null, name: string, insertedAt?: string | null, updatedAt?: string | null, project?: { __typename?: 'Project', id: string, name: string } | null, secrets?: Array<{ __typename?: 'ServiceConfiguration', name: string, value: string } | null> | null } | null> | null, dependencies?: Array<{ __typename?: 'ServiceDependency', id: string, name: string, status?: ServiceDeploymentStatus | null, updatedAt?: string | null } | null> | null, repository?: { __typename?: 'GitRepository', pulledAt?: string | null, id: string, url: string } | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null, imports?: Array<{ __typename?: 'ServiceImport', stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType, status: StackStatus, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null } | null } | null> | null, parent?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string } | null } | null, alerts?: { __typename?: 'AlertConnection', edges?: Array<{ __typename?: 'AlertEdge', node?: { __typename?: 'Alert', id: string } | null } | null> | null } | null, scalingRecommendations?: Array<{ __typename?: 'ClusterScalingRecommendation', id: string, namespace?: string | null, name?: string | null, type?: ScalingRecommendationType | null, container?: string | null, cpuCost?: number | null, cpuRequest?: number | null, cpuRecommendation?: number | null, memoryCost?: number | null, memoryRequest?: number | null, memoryRecommendation?: number | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, componentStatus?: string | null, status: ServiceDeploymentStatus, cluster?: { __typename?: 'Cluster', distro?: ClusterDistro | null, id: string, name: string, handle?: string | null, provider?: { __typename?: 'ClusterProvider', id: string, cloud: string, name: string, namespace: string, supportedVersions?: Array<string | null> | null } | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null } | null } | null> | null, git?: { __typename?: 'GitRef', ref: string, folder: string } | null, helmRepository?: { __typename?: 'FluxHelmRepository', spec: { __typename?: 'HelmRepositorySpec', url: string }, status?: { __typename?: 'HelmRepositoryStatus', ready?: boolean | null, message?: string | null } | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string, warning?: boolean | null } | null> | null, globalService?: { __typename?: 'GlobalService', id: string, name: string } | null } | null };

export type SelfManageMutationVariables = Exact<{
  values: Scalars['String']['input'];
}>;


export type SelfManageMutation = { __typename?: 'RootMutationType', selfManage?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, promotion?: ServicePromotion | null, message?: string | null, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null, componentStatus?: string | null, status: ServiceDeploymentStatus, dryRun?: boolean | null, git?: { __typename?: 'GitRef', ref: string, folder: string } | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, version?: string | null, url?: string | null, repository?: { __typename?: 'ObjectReference', namespace?: string | null, name?: string | null } | null } | null, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, helmRepository?: { __typename?: 'FluxHelmRepository', spec: { __typename?: 'HelmRepositorySpec', url: string }, status?: { __typename?: 'HelmRepositoryStatus', ready?: boolean | null, message?: string | null } | null } | null, repository?: { __typename?: 'GitRepository', id: string, url: string } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string, warning?: boolean | null } | null> | null, globalService?: { __typename?: 'GlobalService', id: string, name: string } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null };

export type KickServiceMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type KickServiceMutation = { __typename?: 'RootMutationType', kickService?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, promotion?: ServicePromotion | null, message?: string | null, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null, componentStatus?: string | null, status: ServiceDeploymentStatus, dryRun?: boolean | null, git?: { __typename?: 'GitRef', ref: string, folder: string } | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, version?: string | null, url?: string | null, repository?: { __typename?: 'ObjectReference', namespace?: string | null, name?: string | null } | null } | null, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, helmRepository?: { __typename?: 'FluxHelmRepository', spec: { __typename?: 'HelmRepositorySpec', url: string }, status?: { __typename?: 'HelmRepositoryStatus', ready?: boolean | null, message?: string | null } | null } | null, repository?: { __typename?: 'GitRepository', id: string, url: string } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string, warning?: boolean | null } | null> | null, globalService?: { __typename?: 'GlobalService', id: string, name: string } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null };

export type ServiceDeploymentBindingsFragment = { __typename?: 'ServiceDeployment', readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null };

export type ServiceDeploymentBindingsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type ServiceDeploymentBindingsQuery = { __typename?: 'RootQueryType', serviceDeployment?: { __typename?: 'ServiceDeployment', id: string, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null } | null };

export type ServiceStatusCountFragment = { __typename?: 'ServiceStatusCount', count: number, status: ServiceDeploymentStatus };

export type ServiceStatusesQueryVariables = Exact<{
  clusterId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type ServiceStatusesQuery = { __typename?: 'RootQueryType', serviceStatuses?: Array<{ __typename?: 'ServiceStatusCount', count: number, status: ServiceDeploymentStatus } | null> | null };

export type ServiceNetworkGraphQueryVariables = Exact<{
  serviceId: Scalars['ID']['input'];
  time?: InputMaybe<Scalars['DateTime']['input']>;
}>;


export type ServiceNetworkGraphQuery = { __typename?: 'RootQueryType', serviceDeployment?: { __typename?: 'ServiceDeployment', id: string, networkGraph?: Array<{ __typename?: 'NetworkMeshEdge', id: string, from: { __typename?: 'NetworkMeshWorkload', id: string, name: string, namespace?: string | null, service?: string | null }, to: { __typename?: 'NetworkMeshWorkload', id: string, name: string, namespace?: string | null, service?: string | null }, statistics: { __typename?: 'NetworkMeshStatistics', bytes?: number | null, packets?: number | null, connections?: number | null, http200?: number | null, http400?: number | null, http500?: number | null, httpClientLatency?: number | null } } | null> | null } | null };

export type ServiceComponentRawQueryVariables = Exact<{
  serviceId: Scalars['ID']['input'];
  componentId?: InputMaybe<Scalars['ID']['input']>;
  childId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type ServiceComponentRawQuery = { __typename?: 'RootQueryType', serviceDeployment?: { __typename?: 'ServiceDeployment', id: string, rawResource?: { __typename?: 'KubernetesUnstructured', raw?: Record<string, unknown> | null, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null } | null } | null };

export type ComponentTreeFragment = { __typename?: 'ComponentTree', root?: { __typename?: 'KubernetesUnstructured', raw?: Record<string, unknown> | null, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null } } | null, edges?: Array<{ __typename?: 'ResourceEdge', from: string, to: string } | null> | null, certificates?: Array<{ __typename?: 'Certificate', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null } } | null> | null, configmaps?: Array<{ __typename?: 'ConfigMap', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null } } | null> | null, cronjobs?: Array<{ __typename?: 'CronJob', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null } } | null> | null, daemonsets?: Array<{ __typename?: 'DaemonSet', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null } } | null> | null, deployments?: Array<{ __typename?: 'Deployment', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null } } | null> | null, ingresses?: Array<{ __typename?: 'Ingress', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null } } | null> | null, secrets?: Array<{ __typename?: 'Secret', metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null } } | null> | null, services?: Array<{ __typename?: 'Service', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null } } | null> | null, statefulsets?: Array<{ __typename?: 'StatefulSet', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null } } | null> | null };

export type ComponentTreeQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type ComponentTreeQuery = { __typename?: 'RootQueryType', componentTree?: { __typename?: 'ComponentTree', root?: { __typename?: 'KubernetesUnstructured', raw?: Record<string, unknown> | null, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null } } | null, edges?: Array<{ __typename?: 'ResourceEdge', from: string, to: string } | null> | null, certificates?: Array<{ __typename?: 'Certificate', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null } } | null> | null, configmaps?: Array<{ __typename?: 'ConfigMap', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null } } | null> | null, cronjobs?: Array<{ __typename?: 'CronJob', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null } } | null> | null, daemonsets?: Array<{ __typename?: 'DaemonSet', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null } } | null> | null, deployments?: Array<{ __typename?: 'Deployment', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null } } | null> | null, ingresses?: Array<{ __typename?: 'Ingress', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null } } | null> | null, secrets?: Array<{ __typename?: 'Secret', metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null } } | null> | null, services?: Array<{ __typename?: 'Service', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null } } | null> | null, statefulsets?: Array<{ __typename?: 'StatefulSet', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null } } | null> | null } | null };

export type ClusterUsageTinyFragment = { __typename?: 'ClusterUsage', id: string, cpu?: number | null, memory?: number | null, gpu?: number | null, storage?: number | null, cpuUtil?: number | null, memUtil?: number | null, cpuCost?: number | null, memoryCost?: number | null, storageCost?: number | null, nodeCost?: number | null, controlPlaneCost?: number | null, ingressCost?: number | null, loadBalancerCost?: number | null, egressCost?: number | null, cluster?: { __typename?: 'Cluster', self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, project?: { __typename?: 'Project', id: string, name: string } | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null };

export type ClusterUsageHistoryFragment = { __typename?: 'ClusterUsageHistory', id: string, timestamp: string, cpuCost?: number | null, memoryCost?: number | null, storageCost?: number | null };

export type ProjectUsageHistoryFragment = { __typename?: 'ProjectUsageHistory', timestamp: string, cpu?: number | null, memory?: number | null, gpu?: number | null, storageCost?: number | null, projectId?: string | null };

export type ClusterNamespaceUsageFragment = { __typename?: 'ClusterNamespaceUsage', id: string, namespace?: string | null, storage?: number | null, cpuCost?: number | null, cpuUtil?: number | null, cpu?: number | null, memoryCost?: number | null, memUtil?: number | null, memory?: number | null, ingressCost?: number | null, loadBalancerCost?: number | null, egressCost?: number | null, storageCost?: number | null };

export type ClusterScalingRecommendationFragment = { __typename?: 'ClusterScalingRecommendation', id: string, namespace?: string | null, name?: string | null, type?: ScalingRecommendationType | null, container?: string | null, cpuCost?: number | null, cpuRequest?: number | null, cpuRecommendation?: number | null, memoryCost?: number | null, memoryRequest?: number | null, memoryRecommendation?: number | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, componentStatus?: string | null, status: ServiceDeploymentStatus, cluster?: { __typename?: 'Cluster', distro?: ClusterDistro | null, id: string, name: string, handle?: string | null, provider?: { __typename?: 'ClusterProvider', id: string, cloud: string, name: string, namespace: string, supportedVersions?: Array<string | null> | null } | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null } | null };

export type ClusterUsagesQueryVariables = Exact<{
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
  tagQuery?: InputMaybe<TagQuery>;
  projectId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type ClusterUsagesQuery = { __typename?: 'RootQueryType', clusterUsages?: { __typename?: 'ClusterUsageConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ClusterUsageEdge', node?: { __typename?: 'ClusterUsage', id: string, cpu?: number | null, memory?: number | null, gpu?: number | null, storage?: number | null, cpuUtil?: number | null, memUtil?: number | null, cpuCost?: number | null, memoryCost?: number | null, storageCost?: number | null, nodeCost?: number | null, controlPlaneCost?: number | null, ingressCost?: number | null, loadBalancerCost?: number | null, egressCost?: number | null, cluster?: { __typename?: 'Cluster', self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, project?: { __typename?: 'Project', id: string, name: string } | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null };

export type ClusterUsageHistoryQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
}>;


export type ClusterUsageHistoryQuery = { __typename?: 'RootQueryType', clusterUsage?: { __typename?: 'ClusterUsage', id: string, cpuCost?: number | null, memoryCost?: number | null, storageCost?: number | null, history?: { __typename?: 'ClusterUsageHistoryConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ClusterUsageHistoryEdge', node?: { __typename?: 'ClusterUsageHistory', id: string, timestamp: string, cpuCost?: number | null, memoryCost?: number | null, storageCost?: number | null } | null } | null> | null } | null } | null };

export type ClusterUsageNamespacesQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
}>;


export type ClusterUsageNamespacesQuery = { __typename?: 'RootQueryType', clusterUsage?: { __typename?: 'ClusterUsage', id: string, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, namespaces?: { __typename?: 'ClusterNamespaceUsageConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ClusterNamespaceUsageEdge', node?: { __typename?: 'ClusterNamespaceUsage', id: string, namespace?: string | null, storage?: number | null, cpuCost?: number | null, cpuUtil?: number | null, cpu?: number | null, memoryCost?: number | null, memUtil?: number | null, memory?: number | null, ingressCost?: number | null, loadBalancerCost?: number | null, egressCost?: number | null, storageCost?: number | null } | null } | null> | null } | null } | null };

export type ClusterUsageScalingRecommendationsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<ScalingRecommendationType>;
}>;


export type ClusterUsageScalingRecommendationsQuery = { __typename?: 'RootQueryType', clusterUsage?: { __typename?: 'ClusterUsage', id: string, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, recommendations?: { __typename?: 'ClusterScalingRecommendationConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ClusterScalingRecommendationEdge', node?: { __typename?: 'ClusterScalingRecommendation', id: string, namespace?: string | null, name?: string | null, type?: ScalingRecommendationType | null, container?: string | null, cpuCost?: number | null, cpuRequest?: number | null, cpuRecommendation?: number | null, memoryCost?: number | null, memoryRequest?: number | null, memoryRecommendation?: number | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, componentStatus?: string | null, status: ServiceDeploymentStatus, cluster?: { __typename?: 'Cluster', distro?: ClusterDistro | null, id: string, name: string, handle?: string | null, provider?: { __typename?: 'ClusterProvider', id: string, cloud: string, name: string, namespace: string, supportedVersions?: Array<string | null> | null } | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null } | null } | null } | null> | null } | null } | null };

export type ProjectUsageHistoryQueryVariables = Exact<{
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
}>;


export type ProjectUsageHistoryQuery = { __typename?: 'RootQueryType', projectUsageHistory?: { __typename?: 'ProjectUsageHistoryConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ProjectUsageHistoryEdge', node?: { __typename?: 'ProjectUsageHistory', timestamp: string, cpu?: number | null, memory?: number | null, gpu?: number | null, storageCost?: number | null, projectId?: string | null } | null } | null> | null } | null };

export type SuggestScalingRecommendationMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type SuggestScalingRecommendationMutation = { __typename?: 'RootMutationType', suggestScalingRecommendation?: string | null };

export type ApplyScalingRecommendationMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type ApplyScalingRecommendationMutation = { __typename?: 'RootMutationType', applyScalingRecommendation?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null };

export type ClusterRegistrationFragment = { __typename?: 'ClusterRegistration', id: string, insertedAt?: string | null, updatedAt?: string | null, machineId: string, name?: string | null, handle?: string | null, metadata?: Record<string, unknown> | null, tags?: Array<{ __typename?: 'Tag', name: string, value: string } | null> | null, creator?: { __typename?: 'User', name: string, email: string, profile?: string | null } | null, project?: { __typename?: 'Project', id: string, name: string, default?: boolean | null, description?: string | null } | null };

export type TagFragment = { __typename?: 'Tag', name: string, value: string };

export type IsoImageFragment = { __typename?: 'ClusterIsoImage', id: string, user?: string | null, password?: string | null, registry: string, image: string, insertedAt?: string | null, project?: { __typename?: 'Project', name: string } | null };

export type ClusterRegistrationQueryVariables = Exact<{
  id?: InputMaybe<Scalars['ID']['input']>;
  machineId?: InputMaybe<Scalars['String']['input']>;
}>;


export type ClusterRegistrationQuery = { __typename?: 'RootQueryType', clusterRegistration?: { __typename?: 'ClusterRegistration', id: string, insertedAt?: string | null, updatedAt?: string | null, machineId: string, name?: string | null, handle?: string | null, metadata?: Record<string, unknown> | null, tags?: Array<{ __typename?: 'Tag', name: string, value: string } | null> | null, creator?: { __typename?: 'User', name: string, email: string, profile?: string | null } | null, project?: { __typename?: 'Project', id: string, name: string, default?: boolean | null, description?: string | null } | null } | null };

export type ClusterRegistrationsQueryVariables = Exact<{
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
}>;


export type ClusterRegistrationsQuery = { __typename?: 'RootQueryType', clusterRegistrations?: { __typename?: 'ClusterRegistrationConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ClusterRegistrationEdge', node?: { __typename?: 'ClusterRegistration', id: string, insertedAt?: string | null, updatedAt?: string | null, machineId: string, name?: string | null, handle?: string | null, metadata?: Record<string, unknown> | null, tags?: Array<{ __typename?: 'Tag', name: string, value: string } | null> | null, creator?: { __typename?: 'User', name: string, email: string, profile?: string | null } | null, project?: { __typename?: 'Project', id: string, name: string, default?: boolean | null, description?: string | null } | null } | null } | null> | null } | null };

export type CreateClusterRegistrationMutationVariables = Exact<{
  attributes: ClusterRegistrationCreateAttributes;
}>;


export type CreateClusterRegistrationMutation = { __typename?: 'RootMutationType', createClusterRegistration?: { __typename?: 'ClusterRegistration', id: string, insertedAt?: string | null, updatedAt?: string | null, machineId: string, name?: string | null, handle?: string | null, metadata?: Record<string, unknown> | null, tags?: Array<{ __typename?: 'Tag', name: string, value: string } | null> | null, creator?: { __typename?: 'User', name: string, email: string, profile?: string | null } | null, project?: { __typename?: 'Project', id: string, name: string, default?: boolean | null, description?: string | null } | null } | null };

export type UpdateClusterRegistrationMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  attributes: ClusterRegistrationUpdateAttributes;
}>;


export type UpdateClusterRegistrationMutation = { __typename?: 'RootMutationType', updateClusterRegistration?: { __typename?: 'ClusterRegistration', id: string, insertedAt?: string | null, updatedAt?: string | null, machineId: string, name?: string | null, handle?: string | null, metadata?: Record<string, unknown> | null, tags?: Array<{ __typename?: 'Tag', name: string, value: string } | null> | null, creator?: { __typename?: 'User', name: string, email: string, profile?: string | null } | null, project?: { __typename?: 'Project', id: string, name: string, default?: boolean | null, description?: string | null } | null } | null };

export type DeleteClusterRegistrationMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteClusterRegistrationMutation = { __typename?: 'RootMutationType', deleteClusterRegistration?: { __typename?: 'ClusterRegistration', id: string, insertedAt?: string | null, updatedAt?: string | null, machineId: string, name?: string | null, handle?: string | null, metadata?: Record<string, unknown> | null, tags?: Array<{ __typename?: 'Tag', name: string, value: string } | null> | null, creator?: { __typename?: 'User', name: string, email: string, profile?: string | null } | null, project?: { __typename?: 'Project', id: string, name: string, default?: boolean | null, description?: string | null } | null } | null };

export type ClusterIsoImagesQueryVariables = Exact<{
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
}>;


export type ClusterIsoImagesQuery = { __typename?: 'RootQueryType', clusterIsoImages?: { __typename?: 'ClusterIsoImageConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ClusterIsoImageEdge', node?: { __typename?: 'ClusterIsoImage', id: string, user?: string | null, password?: string | null, registry: string, image: string, insertedAt?: string | null, project?: { __typename?: 'Project', name: string } | null } | null } | null> | null } | null };

export type FlowBasicFragment = { __typename?: 'Flow', id: string, name: string, description?: string | null, icon?: string | null, alerts?: { __typename?: 'AlertConnection', edges?: Array<{ __typename?: 'AlertEdge', node?: { __typename?: 'Alert', id: string } | null } | null> | null } | null };

export type FlowBasicWithBindingsFragment = { __typename?: 'Flow', id: string, name: string, description?: string | null, icon?: string | null, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, alerts?: { __typename?: 'AlertConnection', edges?: Array<{ __typename?: 'AlertEdge', node?: { __typename?: 'Alert', id: string } | null } | null> | null } | null };

export type PreviewEnvironmentTemplateFragment = { __typename?: 'PreviewEnvironmentTemplate', id: string, name: string, commentTemplate?: string | null, referenceService?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string } | null } | null, template?: { __typename?: 'ServiceTemplate', contexts?: Array<string | null> | null, name?: string | null, namespace?: string | null, repositoryId?: string | null, templated?: boolean | null, dependencies?: Array<{ __typename?: 'ServiceDependency', id: string, name: string, status?: ServiceDeploymentStatus | null } | null> | null, git?: { __typename?: 'GitRef', folder: string, ref: string } | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, ignoreCrds?: boolean | null, ignoreHooks?: boolean | null, release?: string | null, url?: string | null, values?: string | null, valuesFiles?: Array<string | null> | null, version?: string | null, git?: { __typename?: 'GitRef', folder: string, ref: string } | null, repository?: { __typename?: 'ObjectReference', name?: string | null, namespace?: string | null } | null, set?: Array<{ __typename?: 'HelmValue', name: string, value: string } | null> | null } | null, kustomize?: { __typename?: 'Kustomize', path: string, enableHelm?: boolean | null } | null, repository?: { __typename?: 'GitRepository', id: string, url: string, health?: GitHealth | null, authMethod?: AuthMethod | null, editable?: boolean | null, error?: string | null, insertedAt?: string | null, pulledAt?: string | null, updatedAt?: string | null, urlFormat?: string | null, httpsPath?: string | null } | null, syncConfig?: { __typename?: 'SyncConfig', createNamespace?: boolean | null, enforceNamespace?: boolean | null, namespaceMetadata?: { __typename?: 'NamespaceMetadata', annotations?: Record<string, unknown> | null, labels?: Record<string, unknown> | null } | null } | null } | null };

export type PreviewEnvironmentInstanceFragment = { __typename?: 'PreviewEnvironmentInstance', id: string, updatedAt?: string | null, insertedAt?: string | null, pullRequest?: { __typename?: 'PullRequest', url: string } | null, service?: { __typename?: 'ServiceDeployment', protect?: boolean | null, deletedAt?: string | null, id: string, name: string, componentStatus?: string | null, status: ServiceDeploymentStatus, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null } | null, template?: { __typename?: 'PreviewEnvironmentTemplate', id: string, name: string } | null };

export type PreviewEnvironmentInstanceConnectionFragment = { __typename?: 'PreviewEnvironmentInstanceConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'PreviewEnvironmentInstanceEdge', node?: { __typename?: 'PreviewEnvironmentInstance', id: string, updatedAt?: string | null, insertedAt?: string | null, pullRequest?: { __typename?: 'PullRequest', url: string } | null, service?: { __typename?: 'ServiceDeployment', protect?: boolean | null, deletedAt?: string | null, id: string, name: string, componentStatus?: string | null, status: ServiceDeploymentStatus, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null } | null, template?: { __typename?: 'PreviewEnvironmentTemplate', id: string, name: string } | null } | null } | null> | null };

export type PreviewEnvironmentTemplateConnectionFragment = { __typename?: 'PreviewEnvironmentTemplateConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'PreviewEnvironmentTemplateEdge', node?: { __typename?: 'PreviewEnvironmentTemplate', id: string, name: string, commentTemplate?: string | null, referenceService?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string } | null } | null, template?: { __typename?: 'ServiceTemplate', contexts?: Array<string | null> | null, name?: string | null, namespace?: string | null, repositoryId?: string | null, templated?: boolean | null, dependencies?: Array<{ __typename?: 'ServiceDependency', id: string, name: string, status?: ServiceDeploymentStatus | null } | null> | null, git?: { __typename?: 'GitRef', folder: string, ref: string } | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, ignoreCrds?: boolean | null, ignoreHooks?: boolean | null, release?: string | null, url?: string | null, values?: string | null, valuesFiles?: Array<string | null> | null, version?: string | null, git?: { __typename?: 'GitRef', folder: string, ref: string } | null, repository?: { __typename?: 'ObjectReference', name?: string | null, namespace?: string | null } | null, set?: Array<{ __typename?: 'HelmValue', name: string, value: string } | null> | null } | null, kustomize?: { __typename?: 'Kustomize', path: string, enableHelm?: boolean | null } | null, repository?: { __typename?: 'GitRepository', id: string, url: string, health?: GitHealth | null, authMethod?: AuthMethod | null, editable?: boolean | null, error?: string | null, insertedAt?: string | null, pulledAt?: string | null, updatedAt?: string | null, urlFormat?: string | null, httpsPath?: string | null } | null, syncConfig?: { __typename?: 'SyncConfig', createNamespace?: boolean | null, enforceNamespace?: boolean | null, namespaceMetadata?: { __typename?: 'NamespaceMetadata', annotations?: Record<string, unknown> | null, labels?: Record<string, unknown> | null } | null } | null } | null } | null } | null> | null };

export type FlowsQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
}>;


export type FlowsQuery = { __typename?: 'RootQueryType', flows?: { __typename?: 'FlowConnection', edges?: Array<{ __typename?: 'FlowEdge', node?: { __typename?: 'Flow', id: string, name: string, description?: string | null, icon?: string | null, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, alerts?: { __typename?: 'AlertConnection', edges?: Array<{ __typename?: 'AlertEdge', node?: { __typename?: 'Alert', id: string } | null } | null> | null } | null } | null } | null> | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null } } | null };

export type FlowQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type FlowQuery = { __typename?: 'RootQueryType', flow?: { __typename?: 'Flow', id: string, name: string, description?: string | null, icon?: string | null, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, alerts?: { __typename?: 'AlertConnection', edges?: Array<{ __typename?: 'AlertEdge', node?: { __typename?: 'Alert', id: string } | null } | null> | null } | null } | null };

export type FlowServicesQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
}>;


export type FlowServicesQuery = { __typename?: 'RootQueryType', flow?: { __typename?: 'Flow', id: string, name: string, services?: { __typename?: 'ServiceDeploymentConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ServiceDeploymentEdge', node?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, promotion?: ServicePromotion | null, message?: string | null, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null, componentStatus?: string | null, status: ServiceDeploymentStatus, dryRun?: boolean | null, git?: { __typename?: 'GitRef', ref: string, folder: string } | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, version?: string | null, url?: string | null, repository?: { __typename?: 'ObjectReference', namespace?: string | null, name?: string | null } | null } | null, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, helmRepository?: { __typename?: 'FluxHelmRepository', spec: { __typename?: 'HelmRepositorySpec', url: string }, status?: { __typename?: 'HelmRepositoryStatus', ready?: boolean | null, message?: string | null } | null } | null, repository?: { __typename?: 'GitRepository', id: string, url: string } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string, warning?: boolean | null } | null> | null, globalService?: { __typename?: 'GlobalService', id: string, name: string } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null } | null> | null } | null } | null };

export type FlowPipelinesQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
}>;


export type FlowPipelinesQuery = { __typename?: 'RootQueryType', flow?: { __typename?: 'Flow', id: string, pipelines?: { __typename?: 'PipelineConnection', edges?: Array<{ __typename?: 'PipelineEdge', node?: { __typename?: 'Pipeline', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, edges?: Array<{ __typename?: 'PipelineStageEdge', id: string, insertedAt?: string | null, promotedAt?: string | null, updatedAt?: string | null, gates?: Array<{ __typename?: 'PipelineGate', id: string, name: string, state: GateState, type: GateType, insertedAt?: string | null, updatedAt?: string | null, cluster?: { __typename?: 'Cluster', id: string } | null, approver?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null, edge?: { __typename?: 'PipelineStageEdge', pipeline?: { __typename?: 'Pipeline', id: string, name: string } | null } | null, spec?: { __typename?: 'GateSpec', job?: { __typename?: 'JobGateSpec', annotations?: Record<string, unknown> | null, labels?: Record<string, unknown> | null, namespace: string, raw?: string | null, serviceAccount?: string | null, containers?: Array<{ __typename?: 'ContainerSpec', args?: Array<string | null> | null, image: string, env?: Array<{ __typename?: 'ContainerEnv', name: string, value: string } | null> | null, envFrom?: Array<{ __typename?: 'ContainerEnvFrom', configMap: string, secret: string } | null> | null } | null> | null } | null } | null } | null> | null, from: { __typename?: 'PipelineStage', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, promotion?: { __typename?: 'PipelinePromotion', id: string, insertedAt?: string | null, updatedAt?: string | null, promotedAt?: string | null, revisedAt?: string | null, services?: Array<{ __typename?: 'PromotionService', id: string, insertedAt?: string | null, updatedAt?: string | null, revision?: { __typename?: 'Revision', id: string, insertedAt?: string | null, updatedAt?: string | null, message?: string | null, sha?: string | null, version: string, git?: { __typename?: 'GitRef', ref: string, folder: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null } | null, services?: Array<{ __typename?: 'StageService', id: string, insertedAt?: string | null, updatedAt?: string | null, criteria?: { __typename?: 'PromotionCriteria', id: string, secrets?: Array<string | null> | null, insertedAt?: string | null, updatedAt?: string | null, source?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null, context?: { __typename?: 'PipelineContext', id: string, context: Record<string, unknown>, insertedAt?: string | null, updatedAt?: string | null, pullRequests?: Array<{ __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null, pipelinePullRequests?: Array<{ __typename?: 'PipelinePullRequest', id: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, stage?: { __typename?: 'PipelineStage', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null }, to: { __typename?: 'PipelineStage', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, promotion?: { __typename?: 'PipelinePromotion', id: string, insertedAt?: string | null, updatedAt?: string | null, promotedAt?: string | null, revisedAt?: string | null, services?: Array<{ __typename?: 'PromotionService', id: string, insertedAt?: string | null, updatedAt?: string | null, revision?: { __typename?: 'Revision', id: string, insertedAt?: string | null, updatedAt?: string | null, message?: string | null, sha?: string | null, version: string, git?: { __typename?: 'GitRef', ref: string, folder: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null } | null, services?: Array<{ __typename?: 'StageService', id: string, insertedAt?: string | null, updatedAt?: string | null, criteria?: { __typename?: 'PromotionCriteria', id: string, secrets?: Array<string | null> | null, insertedAt?: string | null, updatedAt?: string | null, source?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null, context?: { __typename?: 'PipelineContext', id: string, context: Record<string, unknown>, insertedAt?: string | null, updatedAt?: string | null, pullRequests?: Array<{ __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null, pipelinePullRequests?: Array<{ __typename?: 'PipelinePullRequest', id: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, stage?: { __typename?: 'PipelineStage', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null } } | null> | null, stages?: Array<{ __typename?: 'PipelineStage', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, promotion?: { __typename?: 'PipelinePromotion', id: string, insertedAt?: string | null, updatedAt?: string | null, promotedAt?: string | null, revisedAt?: string | null, services?: Array<{ __typename?: 'PromotionService', id: string, insertedAt?: string | null, updatedAt?: string | null, revision?: { __typename?: 'Revision', id: string, insertedAt?: string | null, updatedAt?: string | null, message?: string | null, sha?: string | null, version: string, git?: { __typename?: 'GitRef', ref: string, folder: string } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null } | null, services?: Array<{ __typename?: 'StageService', id: string, insertedAt?: string | null, updatedAt?: string | null, criteria?: { __typename?: 'PromotionCriteria', id: string, secrets?: Array<string | null> | null, insertedAt?: string | null, updatedAt?: string | null, source?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, namespace: string, status: ServiceDeploymentStatus, componentStatus?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, revision?: { __typename?: 'Revision', id: string } | null } | null } | null> | null, context?: { __typename?: 'PipelineContext', id: string, context: Record<string, unknown>, insertedAt?: string | null, updatedAt?: string | null, pullRequests?: Array<{ __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null, pipelinePullRequests?: Array<{ __typename?: 'PipelinePullRequest', id: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, stage?: { __typename?: 'PipelineStage', id: string } | null, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null } | null> | null, status?: { __typename?: 'PipelineStatus', closed?: number | null, pending?: number | null, running?: number | null } | null } | null } | null> | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null } } | null } | null };

export type FlowAlertsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
}>;


export type FlowAlertsQuery = { __typename?: 'RootQueryType', flow?: { __typename?: 'Flow', id: string, alerts?: { __typename?: 'AlertConnection', edges?: Array<{ __typename?: 'AlertEdge', node?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null, type: ObservabilityWebhookType, severity: AlertSeverity, state: AlertState, fingerprint?: string | null, url?: string | null, annotations?: Record<string, unknown> | null, updatedAt?: string | null, tags?: Array<{ __typename?: 'Tag', id: string, name: string, value: string } | null> | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null, resolution?: { __typename?: 'AlertResolution', resolution: string } | null } | null } | null> | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null } } | null } | null };

export type FlowPrsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
}>;


export type FlowPrsQuery = { __typename?: 'RootQueryType', flow?: { __typename?: 'Flow', id: string, pullRequests?: { __typename?: 'PullRequestConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'PullRequestEdge', node?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null } | null };

export type FlowPreviewEnvironmentInstancesQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
}>;


export type FlowPreviewEnvironmentInstancesQuery = { __typename?: 'RootQueryType', flow?: { __typename?: 'Flow', id: string, previewEnvironmentInstances?: { __typename?: 'PreviewEnvironmentInstanceConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'PreviewEnvironmentInstanceEdge', node?: { __typename?: 'PreviewEnvironmentInstance', id: string, updatedAt?: string | null, insertedAt?: string | null, pullRequest?: { __typename?: 'PullRequest', url: string } | null, service?: { __typename?: 'ServiceDeployment', protect?: boolean | null, deletedAt?: string | null, id: string, name: string, componentStatus?: string | null, status: ServiceDeploymentStatus, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null } | null, template?: { __typename?: 'PreviewEnvironmentTemplate', id: string, name: string } | null } | null } | null> | null } | null } | null };

export type FlowPreviewEnvironmentTemplatesQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
}>;


export type FlowPreviewEnvironmentTemplatesQuery = { __typename?: 'RootQueryType', flow?: { __typename?: 'Flow', id: string, previewEnvironmentTemplates?: { __typename?: 'PreviewEnvironmentTemplateConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'PreviewEnvironmentTemplateEdge', node?: { __typename?: 'PreviewEnvironmentTemplate', id: string, name: string, commentTemplate?: string | null, referenceService?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string } | null } | null, template?: { __typename?: 'ServiceTemplate', contexts?: Array<string | null> | null, name?: string | null, namespace?: string | null, repositoryId?: string | null, templated?: boolean | null, dependencies?: Array<{ __typename?: 'ServiceDependency', id: string, name: string, status?: ServiceDeploymentStatus | null } | null> | null, git?: { __typename?: 'GitRef', folder: string, ref: string } | null, helm?: { __typename?: 'HelmSpec', chart?: string | null, ignoreCrds?: boolean | null, ignoreHooks?: boolean | null, release?: string | null, url?: string | null, values?: string | null, valuesFiles?: Array<string | null> | null, version?: string | null, git?: { __typename?: 'GitRef', folder: string, ref: string } | null, repository?: { __typename?: 'ObjectReference', name?: string | null, namespace?: string | null } | null, set?: Array<{ __typename?: 'HelmValue', name: string, value: string } | null> | null } | null, kustomize?: { __typename?: 'Kustomize', path: string, enableHelm?: boolean | null } | null, repository?: { __typename?: 'GitRepository', id: string, url: string, health?: GitHealth | null, authMethod?: AuthMethod | null, editable?: boolean | null, error?: string | null, insertedAt?: string | null, pulledAt?: string | null, updatedAt?: string | null, urlFormat?: string | null, httpsPath?: string | null } | null, syncConfig?: { __typename?: 'SyncConfig', createNamespace?: boolean | null, enforceNamespace?: boolean | null, namespaceMetadata?: { __typename?: 'NamespaceMetadata', annotations?: Record<string, unknown> | null, labels?: Record<string, unknown> | null } | null } | null } | null } | null } | null> | null } | null } | null };

export type FlowMcpServersQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type FlowMcpServersQuery = { __typename?: 'RootQueryType', flow?: { __typename?: 'Flow', id: string, servers?: Array<{ __typename?: 'McpServer', id: string, name: string, url: string, confirm?: boolean | null, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, authentication?: { __typename?: 'McpServerAuthentication', plural?: boolean | null, headers?: Array<{ __typename?: 'McpServerHeader', name: string, value: string } | null> | null } | null } | null> | null } | null };

export type FlowVulnerabilityReportsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
}>;


export type FlowVulnerabilityReportsQuery = { __typename?: 'RootQueryType', flow?: { __typename?: 'Flow', id: string, vulnerabilityReports?: { __typename?: 'VulnerabilityReportConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'VulnerabilityReportEdge', node?: { __typename?: 'VulnerabilityReport', id: string, artifactUrl?: string | null, services?: Array<{ __typename?: 'ServiceVuln', service?: { __typename?: 'ServiceDeployment', name: string } | null } | null> | null, namespaces?: Array<{ __typename?: 'NamespaceVuln', namespace: string } | null> | null, summary?: { __typename?: 'VulnSummary', criticalCount?: number | null, highCount?: number | null, mediumCount?: number | null, lowCount?: number | null, unknownCount?: number | null, noneCount?: number | null } | null } | null } | null> | null } | null } | null };

export type UpsertFlowMutationVariables = Exact<{
  attributes: FlowAttributes;
}>;


export type UpsertFlowMutation = { __typename?: 'RootMutationType', upsertFlow?: { __typename?: 'Flow', id: string, name: string, description?: string | null, icon?: string | null, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, alerts?: { __typename?: 'AlertConnection', edges?: Array<{ __typename?: 'AlertEdge', node?: { __typename?: 'Alert', id: string } | null } | null> | null } | null } | null };

export type GroupMemberFragment = { __typename?: 'GroupMember', user?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null, group?: { __typename?: 'Group', id: string, name: string, description?: string | null, global?: boolean | null, insertedAt?: string | null, updatedAt?: string | null } | null };

export type GroupFragment = { __typename?: 'Group', id: string, name: string, description?: string | null, global?: boolean | null, insertedAt?: string | null, updatedAt?: string | null };

export type GroupsQueryVariables = Exact<{
  q?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
}>;


export type GroupsQuery = { __typename?: 'RootQueryType', groups?: { __typename?: 'GroupConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'GroupEdge', node?: { __typename?: 'Group', id: string, name: string, description?: string | null, global?: boolean | null, insertedAt?: string | null, updatedAt?: string | null } | null } | null> | null } | null };

export type SearchGroupsQueryVariables = Exact<{
  q?: InputMaybe<Scalars['String']['input']>;
  cursor?: InputMaybe<Scalars['String']['input']>;
}>;


export type SearchGroupsQuery = { __typename?: 'RootQueryType', groups?: { __typename?: 'GroupConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'GroupEdge', node?: { __typename?: 'Group', id: string, name: string, description?: string | null, global?: boolean | null, insertedAt?: string | null, updatedAt?: string | null } | null } | null> | null } | null };

export type GroupMembersQueryVariables = Exact<{
  cursor?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
}>;


export type GroupMembersQuery = { __typename?: 'RootQueryType', groupMembers?: { __typename?: 'GroupMemberConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'GroupMemberEdge', node?: { __typename?: 'GroupMember', user?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null, group?: { __typename?: 'Group', id: string, name: string, description?: string | null, global?: boolean | null, insertedAt?: string | null, updatedAt?: string | null } | null } | null } | null> | null } | null };

export type CreateGroupMemberMutationVariables = Exact<{
  groupId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
}>;


export type CreateGroupMemberMutation = { __typename?: 'RootMutationType', createGroupMember?: { __typename?: 'GroupMember', user?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null, group?: { __typename?: 'Group', id: string, name: string, description?: string | null, global?: boolean | null, insertedAt?: string | null, updatedAt?: string | null } | null } | null };

export type DeleteGroupMemberMutationVariables = Exact<{
  groupId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
}>;


export type DeleteGroupMemberMutation = { __typename?: 'RootMutationType', deleteGroupMember?: { __typename?: 'GroupMember', user?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null, group?: { __typename?: 'Group', id: string, name: string, description?: string | null, global?: boolean | null, insertedAt?: string | null, updatedAt?: string | null } | null } | null };

export type CreateGroupMutationVariables = Exact<{
  attributes: GroupAttributes;
}>;


export type CreateGroupMutation = { __typename?: 'RootMutationType', createGroup?: { __typename?: 'Group', id: string, name: string, description?: string | null, global?: boolean | null, insertedAt?: string | null, updatedAt?: string | null } | null };

export type UpdateGroupMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  attributes: GroupAttributes;
}>;


export type UpdateGroupMutation = { __typename?: 'RootMutationType', updateGroup?: { __typename?: 'Group', id: string, name: string, description?: string | null, global?: boolean | null, insertedAt?: string | null, updatedAt?: string | null } | null };

export type DeleteGroupMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteGroupMutation = { __typename?: 'RootMutationType', deleteGroup?: { __typename?: 'Group', id: string, name: string, description?: string | null, global?: boolean | null, insertedAt?: string | null, updatedAt?: string | null } | null };

export type UpgradeStatisticsFragment = { __typename?: 'UpgradeStatistics', upgradeable?: number | null, count?: number | null, latest?: number | null, compliant?: number | null };

export type NodeStatisticFragment = { __typename?: 'NodeStatistic', id: string, name: string, pendingPods?: number | null, health?: NodeStatisticHealth | null, insertedAt?: string | null, updatedAt?: string | null, cluster?: { __typename?: 'Cluster', id: string } | null };

export type ClusterUpgradeDeprecatedCustomResourceFragment = { __typename?: 'DeprecatedCustomResource', name?: string | null, group: string, kind: string, namespace?: string | null, version: string, nextVersion: string };

export type ClusterUpgradeFragment = { __typename?: 'Cluster', id: string, name: string, currentVersion?: string | null, version?: string | null, prAutomations?: Array<{ __typename?: 'PrAutomation', id: string } | null> | null, deprecatedCustomResources?: Array<{ __typename?: 'DeprecatedCustomResource', name?: string | null, group: string, kind: string, namespace?: string | null, version: string, nextVersion: string } | null> | null, runtimeServices?: Array<{ __typename?: 'RuntimeService', id: string, name: string, version: string, addon?: { __typename?: 'RuntimeAddon', icon?: string | null, versions?: Array<{ __typename?: 'AddonVersion', version?: string | null, kube?: Array<string | null> | null, chartVersion?: string | null, incompatibilities?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null, requirements?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null } | null> | null } | null, service?: { __typename?: 'ServiceDeployment', git?: { __typename?: 'GitRef', ref: string, folder: string } | null, repository?: { __typename?: 'GitRepository', httpsPath?: string | null, urlFormat?: string | null } | null, helm?: { __typename?: 'HelmSpec', version?: string | null } | null } | null, addonVersion?: { __typename?: 'AddonVersion', blocking?: boolean | null, version?: string | null, kube?: Array<string | null> | null, chartVersion?: string | null, incompatibilities?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null, requirements?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null } | null } | null> | null, apiDeprecations?: Array<{ __typename?: 'ApiDeprecation', availableIn?: string | null, blocking?: boolean | null, deprecatedIn?: string | null, removedIn?: string | null, replacement?: string | null, component?: { __typename?: 'ServiceComponent', group?: string | null, version?: string | null, kind: string, name: string, namespace?: string | null, service?: { __typename?: 'ServiceDeployment', git?: { __typename?: 'GitRef', ref: string, folder: string } | null, repository?: { __typename?: 'GitRepository', httpsPath?: string | null, urlFormat?: string | null } | null } | null } | null } | null> | null, upgradeInsights?: Array<{ __typename?: 'UpgradeInsight', id: string, name: string, description?: string | null, refreshedAt?: string | null, transitionedAt?: string | null, version?: string | null, status?: UpgradeInsightStatus | null, details?: Array<{ __typename?: 'UpgradeInsightDetail', id: string, removedIn?: string | null, replacedIn?: string | null, replacement?: string | null, status?: UpgradeInsightStatus | null, used?: string | null, clientInfo?: Array<{ __typename?: 'InsightClientInfo', userAgent?: string | null, count?: string | null, lastRequestAt?: string | null } | null> | null } | null> | null } | null> | null, cloudAddons?: Array<{ __typename?: 'CloudAddon', id: string, insertedAt?: string | null, updatedAt?: string | null, name: string, distro: ClusterDistro, version: string, info?: { __typename?: 'CloudAddonInformation', name?: string | null, publisher?: string | null, versions?: Array<{ __typename?: 'CloudAddonVersionInformation', version?: string | null, compatibilities?: Array<string | null> | null, blocking?: boolean | null } | null> | null } | null, versionInfo?: { __typename?: 'CloudAddonVersionInformation', version?: string | null, compatibilities?: Array<string | null> | null, blocking?: boolean | null } | null } | null> | null };

export type ClusterOverviewDetailsFragment = { __typename?: 'Cluster', currentVersion?: string | null, id: string, self?: boolean | null, healthy?: boolean | null, healthScore?: number | null, protect?: boolean | null, name: string, handle?: string | null, distro?: ClusterDistro | null, cpuTotal?: number | null, memoryTotal?: number | null, cpuUtil?: number | null, nodeCount?: number | null, namespaceCount?: number | null, availabilityZones?: Array<string | null> | null, podCount?: number | null, memoryUtil?: number | null, installed?: boolean | null, pingedAt?: string | null, deletedAt?: string | null, version?: string | null, kubeletVersion?: string | null, virtual?: boolean | null, nodeStatistics?: Array<{ __typename?: 'NodeStatistic', id: string, name: string, pendingPods?: number | null, health?: NodeStatisticHealth | null, insertedAt?: string | null, updatedAt?: string | null, cluster?: { __typename?: 'Cluster', id: string } | null } | null> | null, provider?: { __typename?: 'ClusterProvider', id: string, cloud: string, name: string, namespace: string, supportedVersions?: Array<string | null> | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, repository?: { __typename?: 'GitRepository', url: string } | null } | null, tags?: Array<{ __typename?: 'Tag', name: string, value: string } | null> | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null, kubeletSkew?: boolean | null } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, text?: string | null, sha?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null, prAutomations?: Array<{ __typename?: 'PrAutomation', id: string } | null> | null, deprecatedCustomResources?: Array<{ __typename?: 'DeprecatedCustomResource', name?: string | null, group: string, kind: string, namespace?: string | null, version: string, nextVersion: string } | null> | null, insightComponents?: Array<{ __typename?: 'ClusterInsightComponent', id: string, kind: string, name: string, namespace?: string | null, group?: string | null, version: string, priority?: InsightComponentPriority | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null> | null, runtimeServices?: Array<{ __typename?: 'RuntimeService', id: string, name: string, version: string, addon?: { __typename?: 'RuntimeAddon', icon?: string | null, versions?: Array<{ __typename?: 'AddonVersion', version?: string | null, kube?: Array<string | null> | null, chartVersion?: string | null, incompatibilities?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null, requirements?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null } | null> | null } | null, service?: { __typename?: 'ServiceDeployment', git?: { __typename?: 'GitRef', ref: string, folder: string } | null, repository?: { __typename?: 'GitRepository', httpsPath?: string | null, urlFormat?: string | null } | null, helm?: { __typename?: 'HelmSpec', version?: string | null } | null } | null, addonVersion?: { __typename?: 'AddonVersion', blocking?: boolean | null, version?: string | null, kube?: Array<string | null> | null, chartVersion?: string | null, incompatibilities?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null, requirements?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null } | null } | null> | null, apiDeprecations?: Array<{ __typename?: 'ApiDeprecation', availableIn?: string | null, blocking?: boolean | null, deprecatedIn?: string | null, removedIn?: string | null, replacement?: string | null, component?: { __typename?: 'ServiceComponent', group?: string | null, version?: string | null, kind: string, name: string, namespace?: string | null, service?: { __typename?: 'ServiceDeployment', git?: { __typename?: 'GitRef', ref: string, folder: string } | null, repository?: { __typename?: 'GitRepository', httpsPath?: string | null, urlFormat?: string | null } | null } | null } | null } | null> | null, upgradeInsights?: Array<{ __typename?: 'UpgradeInsight', id: string, name: string, description?: string | null, refreshedAt?: string | null, transitionedAt?: string | null, version?: string | null, status?: UpgradeInsightStatus | null, details?: Array<{ __typename?: 'UpgradeInsightDetail', id: string, removedIn?: string | null, replacedIn?: string | null, replacement?: string | null, status?: UpgradeInsightStatus | null, used?: string | null, clientInfo?: Array<{ __typename?: 'InsightClientInfo', userAgent?: string | null, count?: string | null, lastRequestAt?: string | null } | null> | null } | null> | null } | null> | null, cloudAddons?: Array<{ __typename?: 'CloudAddon', id: string, insertedAt?: string | null, updatedAt?: string | null, name: string, distro: ClusterDistro, version: string, info?: { __typename?: 'CloudAddonInformation', name?: string | null, publisher?: string | null, versions?: Array<{ __typename?: 'CloudAddonVersionInformation', version?: string | null, compatibilities?: Array<string | null> | null, blocking?: boolean | null } | null> | null } | null, versionInfo?: { __typename?: 'CloudAddonVersionInformation', version?: string | null, compatibilities?: Array<string | null> | null, blocking?: boolean | null } | null } | null> | null };

export type ClusterHealthScoreFragment = { __typename?: 'Cluster', id: string, name: string, healthScore?: number | null };

export type ClusterOverviewDetailsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  kubeVersion: Scalars['String']['input'];
  hasKubeVersion: Scalars['Boolean']['input'];
}>;


export type ClusterOverviewDetailsQuery = { __typename?: 'RootQueryType', cluster?: { __typename?: 'Cluster', currentVersion?: string | null, id: string, self?: boolean | null, healthy?: boolean | null, healthScore?: number | null, protect?: boolean | null, name: string, handle?: string | null, distro?: ClusterDistro | null, cpuTotal?: number | null, memoryTotal?: number | null, cpuUtil?: number | null, nodeCount?: number | null, namespaceCount?: number | null, availabilityZones?: Array<string | null> | null, podCount?: number | null, memoryUtil?: number | null, installed?: boolean | null, pingedAt?: string | null, deletedAt?: string | null, version?: string | null, kubeletVersion?: string | null, virtual?: boolean | null, nodeStatistics?: Array<{ __typename?: 'NodeStatistic', id: string, name: string, pendingPods?: number | null, health?: NodeStatisticHealth | null, insertedAt?: string | null, updatedAt?: string | null, cluster?: { __typename?: 'Cluster', id: string } | null } | null> | null, provider?: { __typename?: 'ClusterProvider', id: string, cloud: string, name: string, namespace: string, supportedVersions?: Array<string | null> | null } | null, service?: { __typename?: 'ServiceDeployment', id: string, repository?: { __typename?: 'GitRepository', url: string } | null } | null, tags?: Array<{ __typename?: 'Tag', name: string, value: string } | null> | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null, kubeletSkew?: boolean | null } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, text?: string | null, sha?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null, prAutomations?: Array<{ __typename?: 'PrAutomation', id: string } | null> | null, deprecatedCustomResources?: Array<{ __typename?: 'DeprecatedCustomResource', name?: string | null, group: string, kind: string, namespace?: string | null, version: string, nextVersion: string } | null> | null, insightComponents?: Array<{ __typename?: 'ClusterInsightComponent', id: string, kind: string, name: string, namespace?: string | null, group?: string | null, version: string, priority?: InsightComponentPriority | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null> | null, runtimeServices?: Array<{ __typename?: 'RuntimeService', id: string, name: string, version: string, addon?: { __typename?: 'RuntimeAddon', icon?: string | null, versions?: Array<{ __typename?: 'AddonVersion', version?: string | null, kube?: Array<string | null> | null, chartVersion?: string | null, incompatibilities?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null, requirements?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null } | null> | null } | null, service?: { __typename?: 'ServiceDeployment', git?: { __typename?: 'GitRef', ref: string, folder: string } | null, repository?: { __typename?: 'GitRepository', httpsPath?: string | null, urlFormat?: string | null } | null, helm?: { __typename?: 'HelmSpec', version?: string | null } | null } | null, addonVersion?: { __typename?: 'AddonVersion', blocking?: boolean | null, version?: string | null, kube?: Array<string | null> | null, chartVersion?: string | null, incompatibilities?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null, requirements?: Array<{ __typename?: 'VersionReference', version: string, name: string } | null> | null } | null } | null> | null, apiDeprecations?: Array<{ __typename?: 'ApiDeprecation', availableIn?: string | null, blocking?: boolean | null, deprecatedIn?: string | null, removedIn?: string | null, replacement?: string | null, component?: { __typename?: 'ServiceComponent', group?: string | null, version?: string | null, kind: string, name: string, namespace?: string | null, service?: { __typename?: 'ServiceDeployment', git?: { __typename?: 'GitRef', ref: string, folder: string } | null, repository?: { __typename?: 'GitRepository', httpsPath?: string | null, urlFormat?: string | null } | null } | null } | null } | null> | null, upgradeInsights?: Array<{ __typename?: 'UpgradeInsight', id: string, name: string, description?: string | null, refreshedAt?: string | null, transitionedAt?: string | null, version?: string | null, status?: UpgradeInsightStatus | null, details?: Array<{ __typename?: 'UpgradeInsightDetail', id: string, removedIn?: string | null, replacedIn?: string | null, replacement?: string | null, status?: UpgradeInsightStatus | null, used?: string | null, clientInfo?: Array<{ __typename?: 'InsightClientInfo', userAgent?: string | null, count?: string | null, lastRequestAt?: string | null } | null> | null } | null> | null } | null> | null, cloudAddons?: Array<{ __typename?: 'CloudAddon', id: string, insertedAt?: string | null, updatedAt?: string | null, name: string, distro: ClusterDistro, version: string, info?: { __typename?: 'CloudAddonInformation', name?: string | null, publisher?: string | null, versions?: Array<{ __typename?: 'CloudAddonVersionInformation', version?: string | null, compatibilities?: Array<string | null> | null, blocking?: boolean | null } | null> | null } | null, versionInfo?: { __typename?: 'CloudAddonVersionInformation', version?: string | null, compatibilities?: Array<string | null> | null, blocking?: boolean | null } | null } | null> | null } | null };

export type UpgradeStatisticsQueryVariables = Exact<{
  projectId?: InputMaybe<Scalars['ID']['input']>;
  tag?: InputMaybe<TagInput>;
}>;


export type UpgradeStatisticsQuery = { __typename?: 'RootQueryType', upgradeStatistics?: { __typename?: 'UpgradeStatistics', upgradeable?: number | null, count?: number | null, latest?: number | null, compliant?: number | null } | null };

export type ClusterHealthScoresQueryVariables = Exact<{
  projectId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type ClusterHealthScoresQuery = { __typename?: 'RootQueryType', clusters?: { __typename?: 'ClusterConnection', edges?: Array<{ __typename?: 'ClusterEdge', node?: { __typename?: 'Cluster', id: string, name: string, healthScore?: number | null } | null } | null> | null } | null };

export type KubernetesClusterFragment = { __typename?: 'Cluster', self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, project?: { __typename?: 'Project', id: string, name: string, default?: boolean | null, description?: string | null } | null, pinnedCustomResources?: Array<{ __typename?: 'PinnedCustomResource', id: string, name: string, kind: string, version: string, group: string, displayName: string, namespaced?: boolean | null, cluster?: { __typename?: 'Cluster', self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null };

export type PinnedCustomResourceFragment = { __typename?: 'PinnedCustomResource', id: string, name: string, kind: string, version: string, group: string, displayName: string, namespaced?: boolean | null, cluster?: { __typename?: 'Cluster', self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null };

export type KubernetesClustersQueryVariables = Exact<{
  projectId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type KubernetesClustersQuery = { __typename?: 'RootQueryType', clusters?: { __typename?: 'ClusterConnection', edges?: Array<{ __typename?: 'ClusterEdge', node?: { __typename?: 'Cluster', self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, project?: { __typename?: 'Project', id: string, name: string, default?: boolean | null, description?: string | null } | null, pinnedCustomResources?: Array<{ __typename?: 'PinnedCustomResource', id: string, name: string, kind: string, version: string, group: string, displayName: string, namespaced?: boolean | null, cluster?: { __typename?: 'Cluster', self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null> | null } | null };

export type KubernetesClusterAuditLogsQueryVariables = Exact<{
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
}>;


export type KubernetesClusterAuditLogsQuery = { __typename?: 'RootQueryType', cluster?: { __typename?: 'Cluster', auditLogs?: { __typename?: 'ClusterAuditLogConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ClusterAuditLogEdge', node?: { __typename?: 'ClusterAuditLog', id: string, insertedAt?: string | null, method: string, path: string, actor?: { __typename?: 'User', name: string, email: string } | null } | null } | null> | null } | null } | null };

export type PinCustomResourceMutationVariables = Exact<{
  attributes: PinnedCustomResourceAttributes;
}>;


export type PinCustomResourceMutation = { __typename?: 'RootMutationType', createPinnedCustomResource?: { __typename?: 'PinnedCustomResource', id: string, name: string, kind: string, version: string, group: string, displayName: string, namespaced?: boolean | null, cluster?: { __typename?: 'Cluster', self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null };

export type UnpinCustomResourceMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type UnpinCustomResourceMutation = { __typename?: 'RootMutationType', deletePinnedCustomResource?: { __typename?: 'PinnedCustomResource', id: string, name: string, kind: string, version: string, group: string, displayName: string, namespaced?: boolean | null, cluster?: { __typename?: 'Cluster', self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null };

export type ArgoRolloutStatusFragment = { __typename?: 'ArgoRolloutStatus', abort?: boolean | null, phase?: string | null, replicas?: number | null, readyReplicas?: number | null, pauseConditions?: Array<{ __typename?: 'PauseCondition', reason?: string | null, startTime?: string | null } | null> | null, conditions?: Array<{ __typename?: 'StatusCondition', message: string, reason: string, status: string, type: string } | null> | null };

export type ArgoRolloutSpecFragment = { __typename?: 'ArgoRolloutSpec', replicas?: number | null, strategy?: { __typename?: 'ArgoRolloutStrategy', blueGreen?: { __typename?: 'ArgoBlueGreenStrategy', activeService?: string | null, autoPromotionEnabled?: boolean | null, autoPromotionSeconds?: number | null } | null, canary?: { __typename?: 'ArgoCanaryStrategy', steps?: Array<{ __typename?: 'ArgoStrategyStep', setWeight?: number | null, analysis?: { __typename?: 'ArgoAnalysis', templates?: Array<{ __typename?: 'ArgoAnalysisTemplate', templateName?: string | null } | null> | null } | null, experiment?: { __typename?: 'ArgoExperiment', templates?: Array<{ __typename?: 'ArgoExperimentTemplate', name?: string | null } | null> | null } | null, pause?: { __typename?: 'CanaryPause', duration?: string | null } | null } | null> | null } | null } | null };

export type ArgoRolloutFragment = { __typename?: 'ArgoRollout', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'ArgoRolloutStatus', abort?: boolean | null, phase?: string | null, replicas?: number | null, readyReplicas?: number | null, pauseConditions?: Array<{ __typename?: 'PauseCondition', reason?: string | null, startTime?: string | null } | null> | null, conditions?: Array<{ __typename?: 'StatusCondition', message: string, reason: string, status: string, type: string } | null> | null }, spec: { __typename?: 'ArgoRolloutSpec', replicas?: number | null, strategy?: { __typename?: 'ArgoRolloutStrategy', blueGreen?: { __typename?: 'ArgoBlueGreenStrategy', activeService?: string | null, autoPromotionEnabled?: boolean | null, autoPromotionSeconds?: number | null } | null, canary?: { __typename?: 'ArgoCanaryStrategy', steps?: Array<{ __typename?: 'ArgoStrategyStep', setWeight?: number | null, analysis?: { __typename?: 'ArgoAnalysis', templates?: Array<{ __typename?: 'ArgoAnalysisTemplate', templateName?: string | null } | null> | null } | null, experiment?: { __typename?: 'ArgoExperiment', templates?: Array<{ __typename?: 'ArgoExperimentTemplate', name?: string | null } | null> | null } | null, pause?: { __typename?: 'CanaryPause', duration?: string | null } | null } | null> | null } | null } | null }, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null, pods?: Array<{ __typename?: 'Pod', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'PodStatus', phase?: string | null, podIp?: string | null, reason?: string | null, containerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, initContainerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, conditions?: Array<{ __typename?: 'PodCondition', lastProbeTime?: string | null, lastTransitionTime?: string | null, message?: string | null, reason?: string | null, status?: string | null, type?: string | null } | null> | null }, spec: { __typename?: 'PodSpec', nodeName?: string | null, serviceAccountName?: string | null, containers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null, initContainers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null } } | null> | null };

export type ArgoRolloutQueryVariables = Exact<{
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  serviceId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type ArgoRolloutQuery = { __typename?: 'RootQueryType', argoRollout?: { __typename?: 'ArgoRollout', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'ArgoRolloutStatus', abort?: boolean | null, phase?: string | null, replicas?: number | null, readyReplicas?: number | null, pauseConditions?: Array<{ __typename?: 'PauseCondition', reason?: string | null, startTime?: string | null } | null> | null, conditions?: Array<{ __typename?: 'StatusCondition', message: string, reason: string, status: string, type: string } | null> | null }, spec: { __typename?: 'ArgoRolloutSpec', replicas?: number | null, strategy?: { __typename?: 'ArgoRolloutStrategy', blueGreen?: { __typename?: 'ArgoBlueGreenStrategy', activeService?: string | null, autoPromotionEnabled?: boolean | null, autoPromotionSeconds?: number | null } | null, canary?: { __typename?: 'ArgoCanaryStrategy', steps?: Array<{ __typename?: 'ArgoStrategyStep', setWeight?: number | null, analysis?: { __typename?: 'ArgoAnalysis', templates?: Array<{ __typename?: 'ArgoAnalysisTemplate', templateName?: string | null } | null> | null } | null, experiment?: { __typename?: 'ArgoExperiment', templates?: Array<{ __typename?: 'ArgoExperimentTemplate', name?: string | null } | null> | null } | null, pause?: { __typename?: 'CanaryPause', duration?: string | null } | null } | null> | null } | null } | null }, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null, pods?: Array<{ __typename?: 'Pod', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'PodStatus', phase?: string | null, podIp?: string | null, reason?: string | null, containerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, initContainerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, conditions?: Array<{ __typename?: 'PodCondition', lastProbeTime?: string | null, lastTransitionTime?: string | null, message?: string | null, reason?: string | null, status?: string | null, type?: string | null } | null> | null }, spec: { __typename?: 'PodSpec', nodeName?: string | null, serviceAccountName?: string | null, containers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null, initContainers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null } } | null> | null } | null };

export type CanaryStatusFragment = { __typename?: 'CanaryStatus', failedChecks?: number | null, canaryWeight?: number | null, iterations?: number | null, phase?: string | null, conditions?: Array<{ __typename?: 'StatusCondition', message: string, reason: string, status: string, type: string } | null> | null };

export type CanarySpecFragment = { __typename?: 'CanarySpec', provider?: string | null, analysis?: { __typename?: 'CanaryAnalysis', interval?: string | null, maxWeight?: number | null, stepWeight?: number | null, stepWeights?: Array<number | null> | null, threshold?: number | null } | null };

export type CanaryFragment = { __typename?: 'Canary', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'CanaryStatus', failedChecks?: number | null, canaryWeight?: number | null, iterations?: number | null, phase?: string | null, conditions?: Array<{ __typename?: 'StatusCondition', message: string, reason: string, status: string, type: string } | null> | null }, spec: { __typename?: 'CanarySpec', provider?: string | null, analysis?: { __typename?: 'CanaryAnalysis', interval?: string | null, maxWeight?: number | null, stepWeight?: number | null, stepWeights?: Array<number | null> | null, threshold?: number | null } | null }, canaryDeployment?: { __typename?: 'Deployment', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'DeploymentStatus', availableReplicas?: number | null, replicas?: number | null, unavailableReplicas?: number | null, conditions?: Array<{ __typename?: 'StatusCondition', message: string, reason: string, status: string, type: string } | null> | null }, spec: { __typename?: 'DeploymentSpec', replicas?: number | null, strategy?: { __typename?: 'DeploymentStrategy', type?: string | null } | null }, pods?: Array<{ __typename?: 'Pod', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'PodStatus', phase?: string | null, podIp?: string | null, reason?: string | null, containerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, initContainerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, conditions?: Array<{ __typename?: 'PodCondition', lastProbeTime?: string | null, lastTransitionTime?: string | null, message?: string | null, reason?: string | null, status?: string | null, type?: string | null } | null> | null }, spec: { __typename?: 'PodSpec', nodeName?: string | null, serviceAccountName?: string | null, containers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null, initContainers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null } } | null> | null, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null } | null, primaryDeployment?: { __typename?: 'Deployment', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'DeploymentStatus', availableReplicas?: number | null, replicas?: number | null, unavailableReplicas?: number | null, conditions?: Array<{ __typename?: 'StatusCondition', message: string, reason: string, status: string, type: string } | null> | null }, spec: { __typename?: 'DeploymentSpec', replicas?: number | null, strategy?: { __typename?: 'DeploymentStrategy', type?: string | null } | null }, pods?: Array<{ __typename?: 'Pod', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'PodStatus', phase?: string | null, podIp?: string | null, reason?: string | null, containerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, initContainerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, conditions?: Array<{ __typename?: 'PodCondition', lastProbeTime?: string | null, lastTransitionTime?: string | null, message?: string | null, reason?: string | null, status?: string | null, type?: string | null } | null> | null }, spec: { __typename?: 'PodSpec', nodeName?: string | null, serviceAccountName?: string | null, containers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null, initContainers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null } } | null> | null, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null } | null, ingress?: { __typename?: 'Ingress', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'ServiceStatus', loadBalancer?: { __typename?: 'LoadBalancerStatus', ingress?: Array<{ __typename?: 'LoadBalancerIngressStatus', ip?: string | null, hostname?: string | null } | null> | null } | null }, spec: { __typename?: 'IngressSpec', ingressClassName?: string | null, tls?: Array<{ __typename?: 'IngressTls', hosts?: Array<string | null> | null } | null> | null, rules?: Array<{ __typename?: 'IngressRule', host?: string | null, http?: { __typename?: 'HttpIngressRule', paths?: Array<{ __typename?: 'IngressPath', path?: string | null, backend?: { __typename?: 'IngressBackend', serviceName?: string | null, servicePort?: string | null } | null } | null> | null } | null } | null> | null }, certificates?: Array<{ __typename?: 'Certificate', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'CertificateStatus', renewalTime?: string | null, notBefore?: string | null, notAfter?: string | null, conditions?: Array<{ __typename?: 'StatusCondition', message: string, reason: string, status: string, type: string } | null> | null }, spec: { __typename?: 'CertificateSpec', dnsNames?: Array<string | null> | null, secretName: string, issuerRef?: { __typename?: 'IssuerRef', group?: string | null, kind?: string | null, name?: string | null } | null }, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null } | null> | null, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null } | null, ingressCanary?: { __typename?: 'Ingress', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'ServiceStatus', loadBalancer?: { __typename?: 'LoadBalancerStatus', ingress?: Array<{ __typename?: 'LoadBalancerIngressStatus', ip?: string | null, hostname?: string | null } | null> | null } | null }, spec: { __typename?: 'IngressSpec', ingressClassName?: string | null, tls?: Array<{ __typename?: 'IngressTls', hosts?: Array<string | null> | null } | null> | null, rules?: Array<{ __typename?: 'IngressRule', host?: string | null, http?: { __typename?: 'HttpIngressRule', paths?: Array<{ __typename?: 'IngressPath', path?: string | null, backend?: { __typename?: 'IngressBackend', serviceName?: string | null, servicePort?: string | null } | null } | null> | null } | null } | null> | null }, certificates?: Array<{ __typename?: 'Certificate', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'CertificateStatus', renewalTime?: string | null, notBefore?: string | null, notAfter?: string | null, conditions?: Array<{ __typename?: 'StatusCondition', message: string, reason: string, status: string, type: string } | null> | null }, spec: { __typename?: 'CertificateSpec', dnsNames?: Array<string | null> | null, secretName: string, issuerRef?: { __typename?: 'IssuerRef', group?: string | null, kind?: string | null, name?: string | null } | null }, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null } | null> | null, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null } | null, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null };

export type CanaryQueryVariables = Exact<{
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  serviceId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type CanaryQuery = { __typename?: 'RootQueryType', canary?: { __typename?: 'Canary', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'CanaryStatus', failedChecks?: number | null, canaryWeight?: number | null, iterations?: number | null, phase?: string | null, conditions?: Array<{ __typename?: 'StatusCondition', message: string, reason: string, status: string, type: string } | null> | null }, spec: { __typename?: 'CanarySpec', provider?: string | null, analysis?: { __typename?: 'CanaryAnalysis', interval?: string | null, maxWeight?: number | null, stepWeight?: number | null, stepWeights?: Array<number | null> | null, threshold?: number | null } | null }, canaryDeployment?: { __typename?: 'Deployment', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'DeploymentStatus', availableReplicas?: number | null, replicas?: number | null, unavailableReplicas?: number | null, conditions?: Array<{ __typename?: 'StatusCondition', message: string, reason: string, status: string, type: string } | null> | null }, spec: { __typename?: 'DeploymentSpec', replicas?: number | null, strategy?: { __typename?: 'DeploymentStrategy', type?: string | null } | null }, pods?: Array<{ __typename?: 'Pod', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'PodStatus', phase?: string | null, podIp?: string | null, reason?: string | null, containerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, initContainerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, conditions?: Array<{ __typename?: 'PodCondition', lastProbeTime?: string | null, lastTransitionTime?: string | null, message?: string | null, reason?: string | null, status?: string | null, type?: string | null } | null> | null }, spec: { __typename?: 'PodSpec', nodeName?: string | null, serviceAccountName?: string | null, containers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null, initContainers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null } } | null> | null, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null } | null, primaryDeployment?: { __typename?: 'Deployment', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'DeploymentStatus', availableReplicas?: number | null, replicas?: number | null, unavailableReplicas?: number | null, conditions?: Array<{ __typename?: 'StatusCondition', message: string, reason: string, status: string, type: string } | null> | null }, spec: { __typename?: 'DeploymentSpec', replicas?: number | null, strategy?: { __typename?: 'DeploymentStrategy', type?: string | null } | null }, pods?: Array<{ __typename?: 'Pod', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'PodStatus', phase?: string | null, podIp?: string | null, reason?: string | null, containerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, initContainerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, conditions?: Array<{ __typename?: 'PodCondition', lastProbeTime?: string | null, lastTransitionTime?: string | null, message?: string | null, reason?: string | null, status?: string | null, type?: string | null } | null> | null }, spec: { __typename?: 'PodSpec', nodeName?: string | null, serviceAccountName?: string | null, containers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null, initContainers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null } } | null> | null, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null } | null, ingress?: { __typename?: 'Ingress', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'ServiceStatus', loadBalancer?: { __typename?: 'LoadBalancerStatus', ingress?: Array<{ __typename?: 'LoadBalancerIngressStatus', ip?: string | null, hostname?: string | null } | null> | null } | null }, spec: { __typename?: 'IngressSpec', ingressClassName?: string | null, tls?: Array<{ __typename?: 'IngressTls', hosts?: Array<string | null> | null } | null> | null, rules?: Array<{ __typename?: 'IngressRule', host?: string | null, http?: { __typename?: 'HttpIngressRule', paths?: Array<{ __typename?: 'IngressPath', path?: string | null, backend?: { __typename?: 'IngressBackend', serviceName?: string | null, servicePort?: string | null } | null } | null> | null } | null } | null> | null }, certificates?: Array<{ __typename?: 'Certificate', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'CertificateStatus', renewalTime?: string | null, notBefore?: string | null, notAfter?: string | null, conditions?: Array<{ __typename?: 'StatusCondition', message: string, reason: string, status: string, type: string } | null> | null }, spec: { __typename?: 'CertificateSpec', dnsNames?: Array<string | null> | null, secretName: string, issuerRef?: { __typename?: 'IssuerRef', group?: string | null, kind?: string | null, name?: string | null } | null }, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null } | null> | null, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null } | null, ingressCanary?: { __typename?: 'Ingress', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'ServiceStatus', loadBalancer?: { __typename?: 'LoadBalancerStatus', ingress?: Array<{ __typename?: 'LoadBalancerIngressStatus', ip?: string | null, hostname?: string | null } | null> | null } | null }, spec: { __typename?: 'IngressSpec', ingressClassName?: string | null, tls?: Array<{ __typename?: 'IngressTls', hosts?: Array<string | null> | null } | null> | null, rules?: Array<{ __typename?: 'IngressRule', host?: string | null, http?: { __typename?: 'HttpIngressRule', paths?: Array<{ __typename?: 'IngressPath', path?: string | null, backend?: { __typename?: 'IngressBackend', serviceName?: string | null, servicePort?: string | null } | null } | null> | null } | null } | null> | null }, certificates?: Array<{ __typename?: 'Certificate', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'CertificateStatus', renewalTime?: string | null, notBefore?: string | null, notAfter?: string | null, conditions?: Array<{ __typename?: 'StatusCondition', message: string, reason: string, status: string, type: string } | null> | null }, spec: { __typename?: 'CertificateSpec', dnsNames?: Array<string | null> | null, secretName: string, issuerRef?: { __typename?: 'IssuerRef', group?: string | null, kind?: string | null, name?: string | null } | null }, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null } | null> | null, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null } | null, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null } | null };

export type StatusConditionFragment = { __typename?: 'StatusCondition', message: string, reason: string, status: string, type: string };

export type CertificateStatusFragment = { __typename?: 'CertificateStatus', renewalTime?: string | null, notBefore?: string | null, notAfter?: string | null, conditions?: Array<{ __typename?: 'StatusCondition', message: string, reason: string, status: string, type: string } | null> | null };

export type CertificateSpecFragment = { __typename?: 'CertificateSpec', dnsNames?: Array<string | null> | null, secretName: string, issuerRef?: { __typename?: 'IssuerRef', group?: string | null, kind?: string | null, name?: string | null } | null };

export type CertificateFragment = { __typename?: 'Certificate', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'CertificateStatus', renewalTime?: string | null, notBefore?: string | null, notAfter?: string | null, conditions?: Array<{ __typename?: 'StatusCondition', message: string, reason: string, status: string, type: string } | null> | null }, spec: { __typename?: 'CertificateSpec', dnsNames?: Array<string | null> | null, secretName: string, issuerRef?: { __typename?: 'IssuerRef', group?: string | null, kind?: string | null, name?: string | null } | null }, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null };

export type CertificateQueryVariables = Exact<{
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  serviceId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type CertificateQuery = { __typename?: 'RootQueryType', certificate?: { __typename?: 'Certificate', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'CertificateStatus', renewalTime?: string | null, notBefore?: string | null, notAfter?: string | null, conditions?: Array<{ __typename?: 'StatusCondition', message: string, reason: string, status: string, type: string } | null> | null }, spec: { __typename?: 'CertificateSpec', dnsNames?: Array<string | null> | null, secretName: string, issuerRef?: { __typename?: 'IssuerRef', group?: string | null, kind?: string | null, name?: string | null } | null }, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null } | null };

export type CronJobFragment = { __typename?: 'CronJob', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'CronStatus', lastScheduleTime?: string | null }, spec: { __typename?: 'CronSpec', schedule: string, suspend?: boolean | null, concurrencyPolicy?: string | null }, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null, jobs?: Array<{ __typename?: 'Job', metadata: { __typename?: 'Metadata', name: string, namespace?: string | null }, status: { __typename?: 'JobStatus', active?: number | null, completionTime?: string | null, succeeded?: number | null, failed?: number | null, startTime?: string | null } } | null> | null };

export type CronJobJobFragment = { __typename?: 'Job', metadata: { __typename?: 'Metadata', name: string, namespace?: string | null }, status: { __typename?: 'JobStatus', active?: number | null, completionTime?: string | null, succeeded?: number | null, failed?: number | null, startTime?: string | null } };

export type CronJobQueryVariables = Exact<{
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  serviceId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type CronJobQuery = { __typename?: 'RootQueryType', cronJob?: { __typename?: 'CronJob', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'CronStatus', lastScheduleTime?: string | null }, spec: { __typename?: 'CronSpec', schedule: string, suspend?: boolean | null, concurrencyPolicy?: string | null }, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null, jobs?: Array<{ __typename?: 'Job', metadata: { __typename?: 'Metadata', name: string, namespace?: string | null }, status: { __typename?: 'JobStatus', active?: number | null, completionTime?: string | null, succeeded?: number | null, failed?: number | null, startTime?: string | null } } | null> | null } | null };

export type DaemonSetStatusFragment = { __typename?: 'DaemonSetStatus', currentNumberScheduled?: number | null, desiredNumberScheduled?: number | null, numberReady?: number | null };

export type DaemonSetSpecFragment = { __typename?: 'DaemonSetSpec', strategy?: { __typename?: 'DeploymentStrategy', type?: string | null } | null };

export type DaemonSetFragment = { __typename?: 'DaemonSet', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'DaemonSetStatus', currentNumberScheduled?: number | null, desiredNumberScheduled?: number | null, numberReady?: number | null }, spec: { __typename?: 'DaemonSetSpec', strategy?: { __typename?: 'DeploymentStrategy', type?: string | null } | null }, pods?: Array<{ __typename?: 'Pod', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'PodStatus', phase?: string | null, podIp?: string | null, reason?: string | null, containerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, initContainerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, conditions?: Array<{ __typename?: 'PodCondition', lastProbeTime?: string | null, lastTransitionTime?: string | null, message?: string | null, reason?: string | null, status?: string | null, type?: string | null } | null> | null }, spec: { __typename?: 'PodSpec', nodeName?: string | null, serviceAccountName?: string | null, containers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null, initContainers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null } } | null> | null, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null };

export type DaemonSetQueryVariables = Exact<{
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  serviceId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type DaemonSetQuery = { __typename?: 'RootQueryType', daemonSet?: { __typename?: 'DaemonSet', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'DaemonSetStatus', currentNumberScheduled?: number | null, desiredNumberScheduled?: number | null, numberReady?: number | null }, spec: { __typename?: 'DaemonSetSpec', strategy?: { __typename?: 'DeploymentStrategy', type?: string | null } | null }, pods?: Array<{ __typename?: 'Pod', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'PodStatus', phase?: string | null, podIp?: string | null, reason?: string | null, containerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, initContainerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, conditions?: Array<{ __typename?: 'PodCondition', lastProbeTime?: string | null, lastTransitionTime?: string | null, message?: string | null, reason?: string | null, status?: string | null, type?: string | null } | null> | null }, spec: { __typename?: 'PodSpec', nodeName?: string | null, serviceAccountName?: string | null, containers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null, initContainers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null } } | null> | null, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null } | null };

export type DeploymentFragment = { __typename?: 'Deployment', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'DeploymentStatus', availableReplicas?: number | null, replicas?: number | null, unavailableReplicas?: number | null, conditions?: Array<{ __typename?: 'StatusCondition', message: string, reason: string, status: string, type: string } | null> | null }, spec: { __typename?: 'DeploymentSpec', replicas?: number | null, strategy?: { __typename?: 'DeploymentStrategy', type?: string | null } | null }, pods?: Array<{ __typename?: 'Pod', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'PodStatus', phase?: string | null, podIp?: string | null, reason?: string | null, containerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, initContainerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, conditions?: Array<{ __typename?: 'PodCondition', lastProbeTime?: string | null, lastTransitionTime?: string | null, message?: string | null, reason?: string | null, status?: string | null, type?: string | null } | null> | null }, spec: { __typename?: 'PodSpec', nodeName?: string | null, serviceAccountName?: string | null, containers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null, initContainers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null } } | null> | null, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null };

export type DeploymentQueryVariables = Exact<{
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  serviceId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type DeploymentQuery = { __typename?: 'RootQueryType', deployment?: { __typename?: 'Deployment', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'DeploymentStatus', availableReplicas?: number | null, replicas?: number | null, unavailableReplicas?: number | null, conditions?: Array<{ __typename?: 'StatusCondition', message: string, reason: string, status: string, type: string } | null> | null }, spec: { __typename?: 'DeploymentSpec', replicas?: number | null, strategy?: { __typename?: 'DeploymentStrategy', type?: string | null } | null }, pods?: Array<{ __typename?: 'Pod', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'PodStatus', phase?: string | null, podIp?: string | null, reason?: string | null, containerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, initContainerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, conditions?: Array<{ __typename?: 'PodCondition', lastProbeTime?: string | null, lastTransitionTime?: string | null, message?: string | null, reason?: string | null, status?: string | null, type?: string | null } | null> | null }, spec: { __typename?: 'PodSpec', nodeName?: string | null, serviceAccountName?: string | null, containers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null, initContainers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null } } | null> | null, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null } | null };

export type IngressFragment = { __typename?: 'Ingress', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'ServiceStatus', loadBalancer?: { __typename?: 'LoadBalancerStatus', ingress?: Array<{ __typename?: 'LoadBalancerIngressStatus', ip?: string | null, hostname?: string | null } | null> | null } | null }, spec: { __typename?: 'IngressSpec', ingressClassName?: string | null, tls?: Array<{ __typename?: 'IngressTls', hosts?: Array<string | null> | null } | null> | null, rules?: Array<{ __typename?: 'IngressRule', host?: string | null, http?: { __typename?: 'HttpIngressRule', paths?: Array<{ __typename?: 'IngressPath', path?: string | null, backend?: { __typename?: 'IngressBackend', serviceName?: string | null, servicePort?: string | null } | null } | null> | null } | null } | null> | null }, certificates?: Array<{ __typename?: 'Certificate', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'CertificateStatus', renewalTime?: string | null, notBefore?: string | null, notAfter?: string | null, conditions?: Array<{ __typename?: 'StatusCondition', message: string, reason: string, status: string, type: string } | null> | null }, spec: { __typename?: 'CertificateSpec', dnsNames?: Array<string | null> | null, secretName: string, issuerRef?: { __typename?: 'IssuerRef', group?: string | null, kind?: string | null, name?: string | null } | null }, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null } | null> | null, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null };

export type IngressQueryVariables = Exact<{
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  serviceId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type IngressQuery = { __typename?: 'RootQueryType', ingress?: { __typename?: 'Ingress', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'ServiceStatus', loadBalancer?: { __typename?: 'LoadBalancerStatus', ingress?: Array<{ __typename?: 'LoadBalancerIngressStatus', ip?: string | null, hostname?: string | null } | null> | null } | null }, spec: { __typename?: 'IngressSpec', ingressClassName?: string | null, tls?: Array<{ __typename?: 'IngressTls', hosts?: Array<string | null> | null } | null> | null, rules?: Array<{ __typename?: 'IngressRule', host?: string | null, http?: { __typename?: 'HttpIngressRule', paths?: Array<{ __typename?: 'IngressPath', path?: string | null, backend?: { __typename?: 'IngressBackend', serviceName?: string | null, servicePort?: string | null } | null } | null> | null } | null } | null> | null }, certificates?: Array<{ __typename?: 'Certificate', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'CertificateStatus', renewalTime?: string | null, notBefore?: string | null, notAfter?: string | null, conditions?: Array<{ __typename?: 'StatusCondition', message: string, reason: string, status: string, type: string } | null> | null }, spec: { __typename?: 'CertificateSpec', dnsNames?: Array<string | null> | null, secretName: string, issuerRef?: { __typename?: 'IssuerRef', group?: string | null, kind?: string | null, name?: string | null } | null }, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null } | null> | null, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null } | null };

export type JobFragment = { __typename?: 'Job', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'JobStatus', active?: number | null, completionTime?: string | null, succeeded?: number | null, failed?: number | null, startTime?: string | null }, spec: { __typename?: 'JobSpec', backoffLimit?: number | null, parallelism?: number | null, activeDeadlineSeconds?: number | null }, pods?: Array<{ __typename?: 'Pod', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'PodStatus', phase?: string | null, podIp?: string | null, reason?: string | null, containerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, initContainerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, conditions?: Array<{ __typename?: 'PodCondition', lastProbeTime?: string | null, lastTransitionTime?: string | null, message?: string | null, reason?: string | null, status?: string | null, type?: string | null } | null> | null }, spec: { __typename?: 'PodSpec', nodeName?: string | null, serviceAccountName?: string | null, containers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null, initContainers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null } } | null> | null, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null };

export type JobQueryVariables = Exact<{
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  serviceId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type JobQuery = { __typename?: 'RootQueryType', job?: { __typename?: 'Job', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'JobStatus', active?: number | null, completionTime?: string | null, succeeded?: number | null, failed?: number | null, startTime?: string | null }, spec: { __typename?: 'JobSpec', backoffLimit?: number | null, parallelism?: number | null, activeDeadlineSeconds?: number | null }, pods?: Array<{ __typename?: 'Pod', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'PodStatus', phase?: string | null, podIp?: string | null, reason?: string | null, containerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, initContainerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, conditions?: Array<{ __typename?: 'PodCondition', lastProbeTime?: string | null, lastTransitionTime?: string | null, message?: string | null, reason?: string | null, status?: string | null, type?: string | null } | null> | null }, spec: { __typename?: 'PodSpec', nodeName?: string | null, serviceAccountName?: string | null, containers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null, initContainers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null } } | null> | null, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null } | null };

export type DeleteJobMutationVariables = Exact<{
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
}>;


export type DeleteJobMutation = { __typename?: 'RootMutationType', deleteJob?: { __typename?: 'Job', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'JobStatus', active?: number | null, completionTime?: string | null, succeeded?: number | null, failed?: number | null, startTime?: string | null }, spec: { __typename?: 'JobSpec', backoffLimit?: number | null, parallelism?: number | null, activeDeadlineSeconds?: number | null }, pods?: Array<{ __typename?: 'Pod', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'PodStatus', phase?: string | null, podIp?: string | null, reason?: string | null, containerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, initContainerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, conditions?: Array<{ __typename?: 'PodCondition', lastProbeTime?: string | null, lastTransitionTime?: string | null, message?: string | null, reason?: string | null, status?: string | null, type?: string | null } | null> | null }, spec: { __typename?: 'PodSpec', nodeName?: string | null, serviceAccountName?: string | null, containers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null, initContainers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null } } | null> | null, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null } | null };

export type MetadataFragment = { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null };

export type EventFragment = { __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null };

export type ResourceSpecFragment = { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null };

export type ResourcesFragment = { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null };

export type ContainerFragment = { __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null };

export type ContainerStatusFragment = { __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null };

export type PodFragment = { __typename?: 'Pod', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'PodStatus', phase?: string | null, podIp?: string | null, reason?: string | null, containerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, initContainerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, conditions?: Array<{ __typename?: 'PodCondition', lastProbeTime?: string | null, lastTransitionTime?: string | null, message?: string | null, reason?: string | null, status?: string | null, type?: string | null } | null> | null }, spec: { __typename?: 'PodSpec', nodeName?: string | null, serviceAccountName?: string | null, containers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null, initContainers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null } };

export type JobStatusFragment = { __typename?: 'JobStatus', active?: number | null, completionTime?: string | null, succeeded?: number | null, failed?: number | null, startTime?: string | null };

export type NodeFragment = { __typename?: 'Node', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'NodeStatus', phase?: string | null, allocatable?: Record<string, unknown> | null, capacity?: Record<string, unknown> | null, conditions?: Array<{ __typename?: 'NodeCondition', type?: string | null, status?: string | null, message?: string | null } | null> | null }, spec: { __typename?: 'NodeSpec', podCidr?: string | null, providerId?: string | null }, pods?: Array<{ __typename?: 'Pod', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'PodStatus', phase?: string | null, podIp?: string | null, reason?: string | null, containerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, initContainerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, conditions?: Array<{ __typename?: 'PodCondition', lastProbeTime?: string | null, lastTransitionTime?: string | null, message?: string | null, reason?: string | null, status?: string | null, type?: string | null } | null> | null }, spec: { __typename?: 'PodSpec', nodeName?: string | null, serviceAccountName?: string | null, containers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null, initContainers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null } } | null> | null, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null };

export type NodeMetricFragment = { __typename?: 'NodeMetric', timestamp?: string | null, window?: string | null, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, usage?: { __typename?: 'NodeUsage', cpu?: string | null, memory?: string | null } | null };

export type NodeQueryVariables = Exact<{
  name: Scalars['String']['input'];
  clusterId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type NodeQuery = { __typename?: 'RootQueryType', node?: { __typename?: 'Node', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'NodeStatus', phase?: string | null, allocatable?: Record<string, unknown> | null, capacity?: Record<string, unknown> | null, conditions?: Array<{ __typename?: 'NodeCondition', type?: string | null, status?: string | null, message?: string | null } | null> | null }, spec: { __typename?: 'NodeSpec', podCidr?: string | null, providerId?: string | null }, pods?: Array<{ __typename?: 'Pod', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'PodStatus', phase?: string | null, podIp?: string | null, reason?: string | null, containerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, initContainerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, conditions?: Array<{ __typename?: 'PodCondition', lastProbeTime?: string | null, lastTransitionTime?: string | null, message?: string | null, reason?: string | null, status?: string | null, type?: string | null } | null> | null }, spec: { __typename?: 'PodSpec', nodeName?: string | null, serviceAccountName?: string | null, containers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null, initContainers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null } } | null> | null, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null } | null };

export type NodeMetricQueryVariables = Exact<{
  name: Scalars['String']['input'];
  clusterId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type NodeMetricQuery = { __typename?: 'RootQueryType', nodeMetric?: { __typename?: 'NodeMetric', timestamp?: string | null, window?: string | null, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, usage?: { __typename?: 'NodeUsage', cpu?: string | null, memory?: string | null } | null } | null };

export type PluralObjectStatusFragment = { __typename?: 'PluralObjectStatus', id?: string | null, conditions?: Array<{ __typename?: 'StatusCondition', message: string, reason: string, status: string, type: string } | null> | null };

export type PluralServiceDeploymentFragment = { __typename?: 'PluralServiceDeployment', raw: string, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, reference?: { __typename?: 'ServiceDeployment', namespace: string, message?: string | null, version: string, id: string, name: string, protect?: boolean | null, promotion?: ServicePromotion | null, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null, componentStatus?: string | null, status: ServiceDeploymentStatus, dryRun?: boolean | null, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, operationalLayout?: { __typename?: 'OperationalLayout', serviceMesh?: ServiceMesh | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, helm?: { __typename?: 'HelmSpec', values?: string | null, valuesFiles?: Array<string | null> | null, chart?: string | null, version?: string | null, url?: string | null, repository?: { __typename?: 'ObjectReference', namespace?: string | null, name?: string | null } | null } | null, components?: Array<{ __typename?: 'ServiceComponent', id: string, uid?: string | null, name: string, group?: string | null, kind: string, namespace?: string | null, state?: ComponentState | null, synced: boolean, version?: string | null, apiDeprecations?: Array<{ __typename?: 'ApiDeprecation', availableIn?: string | null, blocking?: boolean | null, deprecatedIn?: string | null, removedIn?: string | null, replacement?: string | null, component?: { __typename?: 'ServiceComponent', group?: string | null, version?: string | null, kind: string, name: string, namespace?: string | null, service?: { __typename?: 'ServiceDeployment', git?: { __typename?: 'GitRef', ref: string, folder: string } | null, repository?: { __typename?: 'GitRepository', httpsPath?: string | null, urlFormat?: string | null } | null } | null } | null } | null> | null, content?: { __typename?: 'ComponentContent', desired?: string | null, live?: string | null } | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null> | null, contexts?: Array<{ __typename?: 'ServiceContext', id: string, configuration?: Record<string, unknown> | null, name: string, insertedAt?: string | null, updatedAt?: string | null, project?: { __typename?: 'Project', id: string, name: string } | null, secrets?: Array<{ __typename?: 'ServiceConfiguration', name: string, value: string } | null> | null } | null> | null, dependencies?: Array<{ __typename?: 'ServiceDependency', id: string, name: string, status?: ServiceDeploymentStatus | null, updatedAt?: string | null } | null> | null, repository?: { __typename?: 'GitRepository', pulledAt?: string | null, id: string, url: string } | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null, imports?: Array<{ __typename?: 'ServiceImport', stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType, status: StackStatus, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null } | null } | null> | null, parent?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string } | null } | null, alerts?: { __typename?: 'AlertConnection', edges?: Array<{ __typename?: 'AlertEdge', node?: { __typename?: 'Alert', id: string } | null } | null> | null } | null, scalingRecommendations?: Array<{ __typename?: 'ClusterScalingRecommendation', id: string, namespace?: string | null, name?: string | null, type?: ScalingRecommendationType | null, container?: string | null, cpuCost?: number | null, cpuRequest?: number | null, cpuRecommendation?: number | null, memoryCost?: number | null, memoryRequest?: number | null, memoryRecommendation?: number | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, componentStatus?: string | null, status: ServiceDeploymentStatus, cluster?: { __typename?: 'Cluster', distro?: ClusterDistro | null, id: string, name: string, handle?: string | null, provider?: { __typename?: 'ClusterProvider', id: string, cloud: string, name: string, namespace: string, supportedVersions?: Array<string | null> | null } | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null } | null } | null> | null, git?: { __typename?: 'GitRef', ref: string, folder: string } | null, helmRepository?: { __typename?: 'FluxHelmRepository', spec: { __typename?: 'HelmRepositorySpec', url: string }, status?: { __typename?: 'HelmRepositoryStatus', ready?: boolean | null, message?: string | null } | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string, warning?: boolean | null } | null> | null, globalService?: { __typename?: 'GlobalService', id: string, name: string } | null } | null, status: { __typename?: 'PluralObjectStatus', id?: string | null, conditions?: Array<{ __typename?: 'StatusCondition', message: string, reason: string, status: string, type: string } | null> | null } };

export type PluralServiceDeploymentQueryVariables = Exact<{
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  serviceId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type PluralServiceDeploymentQuery = { __typename?: 'RootQueryType', pluralServiceDeployment?: { __typename?: 'PluralServiceDeployment', raw: string, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, reference?: { __typename?: 'ServiceDeployment', namespace: string, message?: string | null, version: string, id: string, name: string, protect?: boolean | null, promotion?: ServicePromotion | null, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null, componentStatus?: string | null, status: ServiceDeploymentStatus, dryRun?: boolean | null, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, operationalLayout?: { __typename?: 'OperationalLayout', serviceMesh?: ServiceMesh | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, helm?: { __typename?: 'HelmSpec', values?: string | null, valuesFiles?: Array<string | null> | null, chart?: string | null, version?: string | null, url?: string | null, repository?: { __typename?: 'ObjectReference', namespace?: string | null, name?: string | null } | null } | null, components?: Array<{ __typename?: 'ServiceComponent', id: string, uid?: string | null, name: string, group?: string | null, kind: string, namespace?: string | null, state?: ComponentState | null, synced: boolean, version?: string | null, apiDeprecations?: Array<{ __typename?: 'ApiDeprecation', availableIn?: string | null, blocking?: boolean | null, deprecatedIn?: string | null, removedIn?: string | null, replacement?: string | null, component?: { __typename?: 'ServiceComponent', group?: string | null, version?: string | null, kind: string, name: string, namespace?: string | null, service?: { __typename?: 'ServiceDeployment', git?: { __typename?: 'GitRef', ref: string, folder: string } | null, repository?: { __typename?: 'GitRepository', httpsPath?: string | null, urlFormat?: string | null } | null } | null } | null } | null> | null, content?: { __typename?: 'ComponentContent', desired?: string | null, live?: string | null } | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null> | null, contexts?: Array<{ __typename?: 'ServiceContext', id: string, configuration?: Record<string, unknown> | null, name: string, insertedAt?: string | null, updatedAt?: string | null, project?: { __typename?: 'Project', id: string, name: string } | null, secrets?: Array<{ __typename?: 'ServiceConfiguration', name: string, value: string } | null> | null } | null> | null, dependencies?: Array<{ __typename?: 'ServiceDependency', id: string, name: string, status?: ServiceDeploymentStatus | null, updatedAt?: string | null } | null> | null, repository?: { __typename?: 'GitRepository', pulledAt?: string | null, id: string, url: string } | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null, imports?: Array<{ __typename?: 'ServiceImport', stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType, status: StackStatus, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null } | null } | null> | null, parent?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string } | null } | null, alerts?: { __typename?: 'AlertConnection', edges?: Array<{ __typename?: 'AlertEdge', node?: { __typename?: 'Alert', id: string } | null } | null> | null } | null, scalingRecommendations?: Array<{ __typename?: 'ClusterScalingRecommendation', id: string, namespace?: string | null, name?: string | null, type?: ScalingRecommendationType | null, container?: string | null, cpuCost?: number | null, cpuRequest?: number | null, cpuRecommendation?: number | null, memoryCost?: number | null, memoryRequest?: number | null, memoryRecommendation?: number | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, componentStatus?: string | null, status: ServiceDeploymentStatus, cluster?: { __typename?: 'Cluster', distro?: ClusterDistro | null, id: string, name: string, handle?: string | null, provider?: { __typename?: 'ClusterProvider', id: string, cloud: string, name: string, namespace: string, supportedVersions?: Array<string | null> | null } | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null } | null } | null> | null, git?: { __typename?: 'GitRef', ref: string, folder: string } | null, helmRepository?: { __typename?: 'FluxHelmRepository', spec: { __typename?: 'HelmRepositorySpec', url: string }, status?: { __typename?: 'HelmRepositoryStatus', ready?: boolean | null, message?: string | null } | null } | null, errors?: Array<{ __typename?: 'ServiceError', message: string, source: string, warning?: boolean | null } | null> | null, globalService?: { __typename?: 'GlobalService', id: string, name: string } | null } | null, status: { __typename?: 'PluralObjectStatus', id?: string | null, conditions?: Array<{ __typename?: 'StatusCondition', message: string, reason: string, status: string, type: string } | null> | null } } | null };

export type PodWithEventsFragment = { __typename?: 'Pod', raw: string, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'PodStatus', phase?: string | null, podIp?: string | null, reason?: string | null, containerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, initContainerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, conditions?: Array<{ __typename?: 'PodCondition', lastProbeTime?: string | null, lastTransitionTime?: string | null, message?: string | null, reason?: string | null, status?: string | null, type?: string | null } | null> | null }, spec: { __typename?: 'PodSpec', nodeName?: string | null, serviceAccountName?: string | null, containers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null, initContainers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null } };

export type PodQueryVariables = Exact<{
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  serviceId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type PodQuery = { __typename?: 'RootQueryType', pod?: { __typename?: 'Pod', raw: string, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'PodStatus', phase?: string | null, podIp?: string | null, reason?: string | null, containerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, initContainerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, conditions?: Array<{ __typename?: 'PodCondition', lastProbeTime?: string | null, lastTransitionTime?: string | null, message?: string | null, reason?: string | null, status?: string | null, type?: string | null } | null> | null }, spec: { __typename?: 'PodSpec', nodeName?: string | null, serviceAccountName?: string | null, containers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null, initContainers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null } } | null };

export type PodLogsQueryVariables = Exact<{
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  serviceId?: InputMaybe<Scalars['ID']['input']>;
  container: Scalars['String']['input'];
  sinceSeconds: Scalars['Int']['input'];
}>;


export type PodLogsQuery = { __typename?: 'RootQueryType', pod?: { __typename?: 'Pod', logs?: Array<string | null> | null } | null };

export type DeletePodMutationVariables = Exact<{
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  serviceId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type DeletePodMutation = { __typename?: 'RootMutationType', deletePod?: { __typename?: 'Pod', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'PodStatus', phase?: string | null, podIp?: string | null, reason?: string | null, containerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, initContainerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, conditions?: Array<{ __typename?: 'PodCondition', lastProbeTime?: string | null, lastTransitionTime?: string | null, message?: string | null, reason?: string | null, status?: string | null, type?: string | null } | null> | null }, spec: { __typename?: 'PodSpec', nodeName?: string | null, serviceAccountName?: string | null, containers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null, initContainers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null } } | null };

export type ServiceFragment = { __typename?: 'Service', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'ServiceStatus', loadBalancer?: { __typename?: 'LoadBalancerStatus', ingress?: Array<{ __typename?: 'LoadBalancerIngressStatus', ip?: string | null } | null> | null } | null }, spec: { __typename?: 'ServiceSpec', type?: string | null, clusterIp?: string | null, ports?: Array<{ __typename?: 'ServicePort', name?: string | null, protocol?: string | null, port?: number | null, targetPort?: string | null } | null> | null }, pods?: Array<{ __typename?: 'Pod', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'PodStatus', phase?: string | null, podIp?: string | null, reason?: string | null, containerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, initContainerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, conditions?: Array<{ __typename?: 'PodCondition', lastProbeTime?: string | null, lastTransitionTime?: string | null, message?: string | null, reason?: string | null, status?: string | null, type?: string | null } | null> | null }, spec: { __typename?: 'PodSpec', nodeName?: string | null, serviceAccountName?: string | null, containers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null, initContainers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null } } | null> | null, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null };

export type ServiceQueryVariables = Exact<{
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  serviceId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type ServiceQuery = { __typename?: 'RootQueryType', service?: { __typename?: 'Service', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'ServiceStatus', loadBalancer?: { __typename?: 'LoadBalancerStatus', ingress?: Array<{ __typename?: 'LoadBalancerIngressStatus', ip?: string | null } | null> | null } | null }, spec: { __typename?: 'ServiceSpec', type?: string | null, clusterIp?: string | null, ports?: Array<{ __typename?: 'ServicePort', name?: string | null, protocol?: string | null, port?: number | null, targetPort?: string | null } | null> | null }, pods?: Array<{ __typename?: 'Pod', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'PodStatus', phase?: string | null, podIp?: string | null, reason?: string | null, containerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, initContainerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, conditions?: Array<{ __typename?: 'PodCondition', lastProbeTime?: string | null, lastTransitionTime?: string | null, message?: string | null, reason?: string | null, status?: string | null, type?: string | null } | null> | null }, spec: { __typename?: 'PodSpec', nodeName?: string | null, serviceAccountName?: string | null, containers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null, initContainers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null } } | null> | null, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null } | null };

export type StatefulSetFragment = { __typename?: 'StatefulSet', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'StatefulSetStatus', replicas?: number | null, currentReplicas?: number | null, readyReplicas?: number | null, updatedReplicas?: number | null, conditions?: Array<{ __typename?: 'StatusCondition', message: string, reason: string, status: string, type: string } | null> | null }, spec: { __typename?: 'StatefulSetSpec', replicas?: number | null, serviceName?: string | null }, pods?: Array<{ __typename?: 'Pod', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'PodStatus', phase?: string | null, podIp?: string | null, reason?: string | null, containerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, initContainerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, conditions?: Array<{ __typename?: 'PodCondition', lastProbeTime?: string | null, lastTransitionTime?: string | null, message?: string | null, reason?: string | null, status?: string | null, type?: string | null } | null> | null }, spec: { __typename?: 'PodSpec', nodeName?: string | null, serviceAccountName?: string | null, containers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null, initContainers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null } } | null> | null, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null };

export type StatefulSetQueryVariables = Exact<{
  name: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  serviceId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type StatefulSetQuery = { __typename?: 'RootQueryType', statefulSet?: { __typename?: 'StatefulSet', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'StatefulSetStatus', replicas?: number | null, currentReplicas?: number | null, readyReplicas?: number | null, updatedReplicas?: number | null, conditions?: Array<{ __typename?: 'StatusCondition', message: string, reason: string, status: string, type: string } | null> | null }, spec: { __typename?: 'StatefulSetSpec', replicas?: number | null, serviceName?: string | null }, pods?: Array<{ __typename?: 'Pod', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'PodStatus', phase?: string | null, podIp?: string | null, reason?: string | null, containerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, initContainerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, conditions?: Array<{ __typename?: 'PodCondition', lastProbeTime?: string | null, lastTransitionTime?: string | null, message?: string | null, reason?: string | null, status?: string | null, type?: string | null } | null> | null }, spec: { __typename?: 'PodSpec', nodeName?: string | null, serviceAccountName?: string | null, containers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null, initContainers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null } } | null> | null, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null } | null };

export type UnstructuredResourceFragment = { __typename?: 'KubernetesUnstructured', raw?: Record<string, unknown> | null, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null };

export type UnstructuredResourceQueryVariables = Exact<{
  group?: InputMaybe<Scalars['String']['input']>;
  kind: Scalars['String']['input'];
  name: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
  serviceId: Scalars['ID']['input'];
  version: Scalars['String']['input'];
}>;


export type UnstructuredResourceQuery = { __typename?: 'RootQueryType', unstructuredResource?: { __typename?: 'KubernetesUnstructured', raw?: Record<string, unknown> | null, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, events?: Array<{ __typename?: 'Event', action?: string | null, lastTimestamp?: string | null, count?: number | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null } | null };

export type RefreshTokenFragment = { __typename?: 'RefreshToken', id: string, token: string, insertedAt?: string | null, updatedAt?: string | null };

export type AccountFragment = { __typename?: 'Account', grandfatheredUntil?: string | null, delinquentAt?: string | null, availableFeatures?: { __typename?: 'AvailableFeatures', audits?: boolean | null, userManagement?: boolean | null, databaseManagement?: boolean | null } | null, subscription?: { __typename?: 'PluralSubscription', id?: string | null, plan?: { __typename?: 'Plan', id?: string | null, name?: string | null, period?: string | null } | null } | null };

export type SubscriptionQueryVariables = Exact<{ [key: string]: never; }>;


export type SubscriptionQuery = { __typename?: 'RootQueryType', account?: { __typename?: 'Account', grandfatheredUntil?: string | null, delinquentAt?: string | null, availableFeatures?: { __typename?: 'AvailableFeatures', audits?: boolean | null, userManagement?: boolean | null, databaseManagement?: boolean | null } | null, subscription?: { __typename?: 'PluralSubscription', id?: string | null, plan?: { __typename?: 'Plan', id?: string | null, name?: string | null, period?: string | null } | null } | null } | null };

export type MeGroupsQueryVariables = Exact<{ [key: string]: never; }>;


export type MeGroupsQuery = { __typename?: 'RootQueryType', me?: { __typename?: 'User', id: string, groups?: Array<{ __typename?: 'Group', id: string, name: string, description?: string | null, global?: boolean | null, insertedAt?: string | null, updatedAt?: string | null } | null> | null } | null };

export type MeQueryVariables = Exact<{ [key: string]: never; }>;


export type MeQuery = { __typename?: 'RootQueryType', me?: { __typename?: 'User', unreadNotifications?: number | null, id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, boundRoles?: Array<{ __typename?: 'Role', id: string, name: string, description?: string | null, repositories?: Array<string | null> | null, permissions?: Array<Permission | null> | null, roleBindings?: Array<{ __typename?: 'RoleBinding', id: string, user?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null, group?: { __typename?: 'Group', id: string, name: string, description?: string | null, global?: boolean | null, insertedAt?: string | null, updatedAt?: string | null } | null } | null> | null } | null> | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null, clusterInfo?: { __typename?: 'ClusterInfo', version?: string | null, platform?: string | null, gitCommit?: string | null } | null, configuration?: { __typename?: 'ConsoleConfiguration', gitCommit?: string | null, isDemoProject?: boolean | null, isSandbox?: boolean | null, pluralLogin?: boolean | null, byok?: boolean | null, externalOidc?: boolean | null, cloud?: boolean | null, installed?: boolean | null, consoleVersion?: string | null, sentryEnabled?: boolean | null, manifest?: { __typename?: 'PluralManifest', cluster?: string | null, bucketPrefix?: string | null, network?: { __typename?: 'ManifestNetwork', pluralDns?: boolean | null, subdomain?: string | null } | null } | null, gitStatus?: { __typename?: 'GitStatus', cloned?: boolean | null, output?: string | null } | null, features?: { __typename?: 'AvailableFeatures', audits?: boolean | null, cd?: boolean | null, databaseManagement?: boolean | null, userManagement?: boolean | null } | null } | null };

export type LoginInfoQueryVariables = Exact<{
  redirect?: InputMaybe<Scalars['String']['input']>;
}>;


export type LoginInfoQuery = { __typename?: 'RootQueryType', loginInfo?: { __typename?: 'LoginInfo', oidcUri?: string | null, external?: boolean | null, oidcName?: string | null } | null };

export type InviteQueryVariables = Exact<{
  id: Scalars['String']['input'];
}>;


export type InviteQuery = { __typename?: 'RootQueryType', invite?: { __typename?: 'Invite', email?: string | null } | null };

export type RefreshQueryVariables = Exact<{
  token: Scalars['String']['input'];
}>;


export type RefreshQuery = { __typename?: 'RootQueryType', refresh?: { __typename?: 'User', jwt?: string | null, id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null };

export type TemporaryTokenQueryVariables = Exact<{ [key: string]: never; }>;


export type TemporaryTokenQuery = { __typename?: 'RootQueryType', temporaryToken?: string | null };

export type SignInMutationVariables = Exact<{
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
}>;


export type SignInMutation = { __typename?: 'RootMutationType', signIn?: { __typename?: 'User', jwt?: string | null, id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, refreshToken?: { __typename?: 'RefreshToken', id: string, token: string, insertedAt?: string | null, updatedAt?: string | null } | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null };

export type OauthCallbackMutationVariables = Exact<{
  code: Scalars['String']['input'];
  redirect?: InputMaybe<Scalars['String']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
}>;


export type OauthCallbackMutation = { __typename?: 'RootMutationType', oauthCallback?: { __typename?: 'User', jwt?: string | null, refreshToken?: { __typename?: 'RefreshToken', id: string, token: string, insertedAt?: string | null, updatedAt?: string | null } | null } | null };

export type LogoutMutationVariables = Exact<{ [key: string]: never; }>;


export type LogoutMutation = { __typename?: 'RootMutationType', logout?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null };

export type SignUpMutationVariables = Exact<{
  inviteId: Scalars['String']['input'];
  attributes: UserAttributes;
}>;


export type SignUpMutation = { __typename?: 'RootMutationType', signup?: { __typename?: 'User', jwt?: string | null, id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, refreshToken?: { __typename?: 'RefreshToken', id: string, token: string, insertedAt?: string | null, updatedAt?: string | null } | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null };

export type LoginLinkMutationVariables = Exact<{
  key: Scalars['String']['input'];
}>;


export type LoginLinkMutation = { __typename?: 'RootMutationType', loginLink?: { __typename?: 'User', jwt?: string | null, id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, refreshToken?: { __typename?: 'RefreshToken', id: string, token: string, insertedAt?: string | null, updatedAt?: string | null } | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null };

export type LogLineFragment = { __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null };

export type LogAggregationQueryVariables = Exact<{
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  serviceId?: InputMaybe<Scalars['ID']['input']>;
  time?: InputMaybe<LogTimeRange>;
  facets?: InputMaybe<Array<InputMaybe<LogFacetInput>> | InputMaybe<LogFacetInput>>;
}>;


export type LogAggregationQuery = { __typename?: 'RootQueryType', logAggregation?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null };

export type MetricResponseFragment = { __typename?: 'MetricResponse', metric?: Record<string, unknown> | null, values?: Array<{ __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null> | null };

export type MetricPointResponseFragment = { __typename?: 'MetricPointResponse', metric?: Record<string, unknown> | null, value?: { __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null };

export type UtilizationHeatMapFragment = { __typename?: 'UtilizationHeatMap', cpu?: Array<{ __typename?: 'MetricPointResponse', metric?: Record<string, unknown> | null, value?: { __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null } | null> | null, memory?: Array<{ __typename?: 'MetricPointResponse', metric?: Record<string, unknown> | null, value?: { __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null } | null> | null };

export type ClusterHeatMapQueryVariables = Exact<{
  clusterId: Scalars['ID']['input'];
  flavor: HeatMapFlavor;
}>;


export type ClusterHeatMapQuery = { __typename?: 'RootQueryType', cluster?: { __typename?: 'Cluster', id: string, heatMap?: { __typename?: 'UtilizationHeatMap', cpu?: Array<{ __typename?: 'MetricPointResponse', metric?: Record<string, unknown> | null, value?: { __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null } | null> | null, memory?: Array<{ __typename?: 'MetricPointResponse', metric?: Record<string, unknown> | null, value?: { __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null } | null> | null } | null } | null };

export type ClusterNoisyNeighborsQueryVariables = Exact<{
  clusterId: Scalars['ID']['input'];
}>;


export type ClusterNoisyNeighborsQuery = { __typename?: 'RootQueryType', cluster?: { __typename?: 'Cluster', id: string, noisyNeighbors?: { __typename?: 'UtilizationHeatMap', cpu?: Array<{ __typename?: 'MetricPointResponse', metric?: Record<string, unknown> | null, value?: { __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null } | null> | null, memory?: Array<{ __typename?: 'MetricPointResponse', metric?: Record<string, unknown> | null, value?: { __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null } | null> | null } | null } | null };

export type ServiceHeatMapQueryVariables = Exact<{
  serviceId: Scalars['ID']['input'];
  flavor: HeatMapFlavor;
}>;


export type ServiceHeatMapQuery = { __typename?: 'RootQueryType', serviceDeployment?: { __typename?: 'ServiceDeployment', id: string, heatMap?: { __typename?: 'UtilizationHeatMap', cpu?: Array<{ __typename?: 'MetricPointResponse', metric?: Record<string, unknown> | null, value?: { __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null } | null> | null, memory?: Array<{ __typename?: 'MetricPointResponse', metric?: Record<string, unknown> | null, value?: { __typename?: 'MetricResult', timestamp?: any | null, value?: string | null } | null } | null> | null } | null } | null };

export type UrlSinkConfigurationFragment = { __typename?: 'UrlSinkConfiguration', url: string };

export type SinkConfigurationFragment = { __typename?: 'SinkConfiguration', id: string, slack?: { __typename?: 'UrlSinkConfiguration', url: string } | null, teams?: { __typename?: 'UrlSinkConfiguration', url: string } | null };

export type NotificationSinkFragment = { __typename?: 'NotificationSink', id: string, name: string, type: SinkType, insertedAt?: string | null, updatedAt?: string | null, configuration: { __typename?: 'SinkConfiguration', id: string, slack?: { __typename?: 'UrlSinkConfiguration', url: string } | null, teams?: { __typename?: 'UrlSinkConfiguration', url: string } | null } };

export type NotificationFilterFragment = { __typename?: 'NotificationFilter', id: string, regex?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, pipeline?: { __typename?: 'Pipeline', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string } | null };

export type NotificationRouterFragment = { __typename?: 'NotificationRouter', id: string, name: string, events?: Array<string> | null, insertedAt?: string | null, updatedAt?: string | null, sinks?: Array<{ __typename?: 'NotificationSink', id: string, name: string, type: SinkType, insertedAt?: string | null, updatedAt?: string | null, configuration: { __typename?: 'SinkConfiguration', id: string, slack?: { __typename?: 'UrlSinkConfiguration', url: string } | null, teams?: { __typename?: 'UrlSinkConfiguration', url: string } | null } } | null> | null, filters?: Array<{ __typename?: 'NotificationFilter', id: string, regex?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, pipeline?: { __typename?: 'Pipeline', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string } | null } | null> | null };

export type AppNotificationFragment = { __typename?: 'AppNotification', id: string, insertedAt?: string | null, updatedAt?: string | null, readAt?: string | null, priority?: NotificationPriority | null, text?: string | null };

export type UpsertNotificationRouterMutationVariables = Exact<{
  attributes: NotificationRouterAttributes;
}>;


export type UpsertNotificationRouterMutation = { __typename?: 'RootMutationType', upsertNotificationRouter?: { __typename?: 'NotificationRouter', id: string, name: string, events?: Array<string> | null, insertedAt?: string | null, updatedAt?: string | null, sinks?: Array<{ __typename?: 'NotificationSink', id: string, name: string, type: SinkType, insertedAt?: string | null, updatedAt?: string | null, configuration: { __typename?: 'SinkConfiguration', id: string, slack?: { __typename?: 'UrlSinkConfiguration', url: string } | null, teams?: { __typename?: 'UrlSinkConfiguration', url: string } | null } } | null> | null, filters?: Array<{ __typename?: 'NotificationFilter', id: string, regex?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, pipeline?: { __typename?: 'Pipeline', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string } | null } | null> | null } | null };

export type NotificationRoutersQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
}>;


export type NotificationRoutersQuery = { __typename?: 'RootQueryType', notificationRouters?: { __typename?: 'NotificationRouterConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'NotificationRouterEdge', node?: { __typename?: 'NotificationRouter', id: string, name: string, events?: Array<string> | null, insertedAt?: string | null, updatedAt?: string | null, sinks?: Array<{ __typename?: 'NotificationSink', id: string, name: string, type: SinkType, insertedAt?: string | null, updatedAt?: string | null, configuration: { __typename?: 'SinkConfiguration', id: string, slack?: { __typename?: 'UrlSinkConfiguration', url: string } | null, teams?: { __typename?: 'UrlSinkConfiguration', url: string } | null } } | null> | null, filters?: Array<{ __typename?: 'NotificationFilter', id: string, regex?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, pipeline?: { __typename?: 'Pipeline', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string } | null } | null> | null } | null } | null> | null } | null };

export type DeleteNotificationRouterMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteNotificationRouterMutation = { __typename?: 'RootMutationType', deleteNotificationRouter?: { __typename?: 'NotificationRouter', id: string, name: string, events?: Array<string> | null, insertedAt?: string | null, updatedAt?: string | null, sinks?: Array<{ __typename?: 'NotificationSink', id: string, name: string, type: SinkType, insertedAt?: string | null, updatedAt?: string | null, configuration: { __typename?: 'SinkConfiguration', id: string, slack?: { __typename?: 'UrlSinkConfiguration', url: string } | null, teams?: { __typename?: 'UrlSinkConfiguration', url: string } | null } } | null> | null, filters?: Array<{ __typename?: 'NotificationFilter', id: string, regex?: string | null, cluster?: { __typename?: 'Cluster', id: string, name: string } | null, pipeline?: { __typename?: 'Pipeline', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string } | null } | null> | null } | null };

export type UpsertNotificationSinkMutationVariables = Exact<{
  attributes: NotificationSinkAttributes;
}>;


export type UpsertNotificationSinkMutation = { __typename?: 'RootMutationType', upsertNotificationSink?: { __typename?: 'NotificationSink', id: string, name: string, type: SinkType, insertedAt?: string | null, updatedAt?: string | null, configuration: { __typename?: 'SinkConfiguration', id: string, slack?: { __typename?: 'UrlSinkConfiguration', url: string } | null, teams?: { __typename?: 'UrlSinkConfiguration', url: string } | null } } | null };

export type DeleteNotificationSinkMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteNotificationSinkMutation = { __typename?: 'RootMutationType', deleteNotificationSink?: { __typename?: 'NotificationSink', id: string, name: string, type: SinkType, insertedAt?: string | null, updatedAt?: string | null, configuration: { __typename?: 'SinkConfiguration', id: string, slack?: { __typename?: 'UrlSinkConfiguration', url: string } | null, teams?: { __typename?: 'UrlSinkConfiguration', url: string } | null } } | null };

export type NotificationSinksQueryVariables = Exact<{
  q?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
}>;


export type NotificationSinksQuery = { __typename?: 'RootQueryType', notificationSinks?: { __typename?: 'NotificationSinkConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'NotificationSinkEdge', node?: { __typename?: 'NotificationSink', id: string, name: string, type: SinkType, insertedAt?: string | null, updatedAt?: string | null, configuration: { __typename?: 'SinkConfiguration', id: string, slack?: { __typename?: 'UrlSinkConfiguration', url: string } | null, teams?: { __typename?: 'UrlSinkConfiguration', url: string } | null } } | null } | null> | null } | null };

export type UnreadAppNotificationsQueryVariables = Exact<{ [key: string]: never; }>;


export type UnreadAppNotificationsQuery = { __typename?: 'RootQueryType', unreadAppNotifications?: number | null };

export type AppNotificationsQueryVariables = Exact<{
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
}>;


export type AppNotificationsQuery = { __typename?: 'RootQueryType', appNotifications?: { __typename?: 'AppNotificationConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'AppNotificationEdge', node?: { __typename?: 'AppNotification', id: string, insertedAt?: string | null, updatedAt?: string | null, readAt?: string | null, priority?: NotificationPriority | null, text?: string | null } | null } | null> | null } | null };

export type ReadAppNotificationsMutationVariables = Exact<{ [key: string]: never; }>;


export type ReadAppNotificationsMutation = { __typename?: 'RootMutationType', readAppNotifications?: number | null };

export type OidcConsentQueryVariables = Exact<{
  challenge: Scalars['String']['input'];
}>;


export type OidcConsentQuery = { __typename?: 'RootQueryType', oidcConsent?: { __typename?: 'OidcStepResponse', consent?: { __typename?: 'ConsentRequest', requestedScope?: Array<string | null> | null, skip?: boolean | null } | null } | null };

export type ConsentMutationVariables = Exact<{
  challenge: Scalars['String']['input'];
  scopes?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;
}>;


export type ConsentMutation = { __typename?: 'RootMutationType', oauthConsent?: { __typename?: 'OauthResponse', redirectTo: string } | null };

export type AcceptLoginMutationVariables = Exact<{
  challenge: Scalars['String']['input'];
}>;


export type AcceptLoginMutation = { __typename?: 'RootMutationType', acceptLogin?: { __typename?: 'OauthResponse', redirectTo: string } | null };

export type OidcProviderFragment = { __typename?: 'OidcProvider', id: string, name: string, description?: string | null, authMethod?: OidcAuthMethod | null, redirectUris?: Array<string | null> | null, clientId: string, clientSecret: string, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null };

export type OidcProvidersQueryVariables = Exact<{
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
}>;


export type OidcProvidersQuery = { __typename?: 'RootQueryType', oidcProviders?: { __typename?: 'OidcProviderConnection', edges?: Array<{ __typename?: 'OidcProviderEdge', node?: { __typename?: 'OidcProvider', id: string, name: string, description?: string | null, authMethod?: OidcAuthMethod | null, redirectUris?: Array<string | null> | null, clientId: string, clientSecret: string, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null } | null } | null> | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null } } | null };

export type CreateOidcProviderMutationVariables = Exact<{
  type: OidcProviderType;
  attributes: OidcProviderAttributes;
}>;


export type CreateOidcProviderMutation = { __typename?: 'RootMutationType', createOidcProvider?: { __typename?: 'OidcProvider', id: string, name: string, description?: string | null, authMethod?: OidcAuthMethod | null, redirectUris?: Array<string | null> | null, clientId: string, clientSecret: string, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null } | null };

export type UpdateOidcProviderMutationVariables = Exact<{
  type: OidcProviderType;
  id: Scalars['ID']['input'];
  attributes: OidcProviderAttributes;
}>;


export type UpdateOidcProviderMutation = { __typename?: 'RootMutationType', updateOidcProvider?: { __typename?: 'OidcProvider', id: string, name: string, description?: string | null, authMethod?: OidcAuthMethod | null, redirectUris?: Array<string | null> | null, clientId: string, clientSecret: string, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null } | null };

export type DeleteOidcProviderMutationVariables = Exact<{
  type: OidcProviderType;
  id: Scalars['ID']['input'];
}>;


export type DeleteOidcProviderMutation = { __typename?: 'RootMutationType', deleteOidcProvider?: { __typename?: 'OidcProvider', id: string, name: string, description?: string | null, authMethod?: OidcAuthMethod | null, redirectUris?: Array<string | null> | null, clientId: string, clientSecret: string, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null } | null };

export type PersonaConfigurationFragment = { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null };

export type PersonaFragment = { __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null };

export type PersonasQueryVariables = Exact<{
  cursor?: InputMaybe<Scalars['String']['input']>;
}>;


export type PersonasQuery = { __typename?: 'RootQueryType', personas?: { __typename?: 'PersonaConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'PersonaEdge', node?: { __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null } | null> | null } | null };

export type CreatePersonaMutationVariables = Exact<{
  attributes: PersonaAttributes;
}>;


export type CreatePersonaMutation = { __typename?: 'RootMutationType', createPersona?: { __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null };

export type UpdatePersonaMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  attributes: PersonaAttributes;
}>;


export type UpdatePersonaMutation = { __typename?: 'RootMutationType', updatePersona?: { __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null };

export type DeletePersonaMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeletePersonaMutation = { __typename?: 'RootMutationType', deletePersona?: { __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null };

export type PolicyConstraintFragment = { __typename?: 'PolicyConstraint', description?: string | null, id: string, insertedAt?: string | null, name: string, recommendation?: string | null, updatedAt?: string | null, violationCount?: number | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, ref?: { __typename?: 'ConstraintRef', kind: string, name: string } | null };

export type ComplianceReportGeneratorFragment = { __typename?: 'ComplianceReportGenerator', id: string, name: string, format: ComplianceReportFormat, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null };

export type ComplianceReportFragment = { __typename?: 'ComplianceReports', insertedAt?: string | null, id: string, name: string, sha256?: string | null };

export type PolicyConstraintsQueryVariables = Exact<{
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  clusters?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>> | InputMaybe<Scalars['ID']['input']>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  kind?: InputMaybe<Scalars['String']['input']>;
  kinds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  namespaces?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;
  q?: InputMaybe<Scalars['String']['input']>;
  violated?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type PolicyConstraintsQuery = { __typename?: 'RootQueryType', policyConstraints?: { __typename?: 'PolicyConstraintConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'PolicyConstraintEdge', node?: { __typename?: 'PolicyConstraint', description?: string | null, id: string, insertedAt?: string | null, name: string, recommendation?: string | null, updatedAt?: string | null, violationCount?: number | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, ref?: { __typename?: 'ConstraintRef', kind: string, name: string } | null } | null } | null> | null } | null };

export type PolicyConstraintQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type PolicyConstraintQuery = { __typename?: 'RootQueryType', policyConstraint?: { __typename?: 'PolicyConstraint', description?: string | null, id: string, insertedAt?: string | null, name: string, recommendation?: string | null, updatedAt?: string | null, violationCount?: number | null, object?: { __typename?: 'KubernetesUnstructured', kind: string, metadata: { __typename?: 'Metadata', namespace?: string | null } } | null, violations?: Array<{ __typename?: 'Violation', group?: string | null, id: string, insertedAt?: string | null, kind?: string | null, message?: string | null, name?: string | null, namespace?: string | null, updatedAt?: string | null, version?: string | null } | null> | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, ref?: { __typename?: 'ConstraintRef', kind: string, name: string } | null } | null };

export type ViolationStatisticsQueryVariables = Exact<{
  field: ConstraintViolationField;
}>;


export type ViolationStatisticsQuery = { __typename?: 'RootQueryType', violationStatistics?: Array<{ __typename?: 'ViolationStatistic', count?: number | null, value?: string | null, violations?: number | null } | null> | null };

export type PolicyStatisticsQueryVariables = Exact<{
  aggregate: PolicyAggregate;
  clusters?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>> | InputMaybe<Scalars['ID']['input']>>;
  kind?: InputMaybe<Scalars['String']['input']>;
  kinds?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  namespaces?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;
  q?: InputMaybe<Scalars['String']['input']>;
}>;


export type PolicyStatisticsQuery = { __typename?: 'RootQueryType', policyStatistics?: Array<{ __typename?: 'PolicyStatistic', count?: number | null, aggregate?: string | null } | null> | null };

export type ComplianceReportGeneratorsQueryVariables = Exact<{
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
}>;


export type ComplianceReportGeneratorsQuery = { __typename?: 'RootQueryType', complianceReportGenerators?: { __typename?: 'ComplianceReportGeneratorConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ComplianceReportGeneratorEdge', node?: { __typename?: 'ComplianceReportGenerator', id: string, name: string, format: ComplianceReportFormat, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null } | null } | null> | null } | null };

export type ComplianceReportGeneratorQueryVariables = Exact<{
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
}>;


export type ComplianceReportGeneratorQuery = { __typename?: 'RootQueryType', complianceReportGenerator?: { __typename?: 'ComplianceReportGenerator', id: string, name: string, format: ComplianceReportFormat, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null } | null };

export type UpsertComplianceReportGeneratorMutationVariables = Exact<{
  attributes: ComplianceReportGeneratorAttributes;
}>;


export type UpsertComplianceReportGeneratorMutation = { __typename?: 'RootMutationType', upsertComplianceReportGenerator?: { __typename?: 'ComplianceReportGenerator', id: string, name: string, format: ComplianceReportFormat, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null } | null };

export type DeleteComplianceReportMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteComplianceReportMutation = { __typename?: 'RootMutationType', deleteComplianceReportGenerator?: { __typename?: 'ComplianceReportGenerator', id: string, name: string, format: ComplianceReportFormat, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null } | null };

export type ComplianceReportsQueryVariables = Exact<{
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
}>;


export type ComplianceReportsQuery = { __typename?: 'RootQueryType', complianceReportGenerator?: { __typename?: 'ComplianceReportGenerator', complianceReports?: { __typename?: 'ComplianceReportsConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ComplianceReportsEdge', node?: { __typename?: 'ComplianceReports', insertedAt?: string | null, id: string, name: string, sha256?: string | null } | null } | null> | null } | null } | null };

export type ProjectFragment = { __typename?: 'Project', id: string, insertedAt?: string | null, updatedAt?: string | null, name: string, default?: boolean | null, description?: string | null };

export type ProjectTinyFragment = { __typename?: 'Project', id: string, name: string, default?: boolean | null, description?: string | null };

export type ProjectsQueryVariables = Exact<{
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
}>;


export type ProjectsQuery = { __typename?: 'RootQueryType', projects?: { __typename?: 'ProjectConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ProjectEdge', node?: { __typename?: 'Project', id: string, insertedAt?: string | null, updatedAt?: string | null, name: string, default?: boolean | null, description?: string | null } | null } | null> | null } | null };

export type ProjectsTinyQueryVariables = Exact<{
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
}>;


export type ProjectsTinyQuery = { __typename?: 'RootQueryType', projects?: { __typename?: 'ProjectConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'ProjectEdge', node?: { __typename?: 'Project', id: string, name: string, default?: boolean | null, description?: string | null } | null } | null> | null } | null };

export type ProjectQueryVariables = Exact<{
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
}>;


export type ProjectQuery = { __typename?: 'RootQueryType', project?: { __typename?: 'Project', id: string, insertedAt?: string | null, updatedAt?: string | null, name: string, default?: boolean | null, description?: string | null } | null };

export type ProjectBindingsFragment = { __typename?: 'Project', readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null };

export type ProjectBindingsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type ProjectBindingsQuery = { __typename?: 'RootQueryType', project?: { __typename?: 'Project', readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null } | null };

export type CreateProjectMutationVariables = Exact<{
  attributes: ProjectAttributes;
}>;


export type CreateProjectMutation = { __typename?: 'RootMutationType', createProject?: { __typename?: 'Project', id: string, insertedAt?: string | null, updatedAt?: string | null, name: string, default?: boolean | null, description?: string | null } | null };

export type UpdateProjectMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  attributes: ProjectAttributes;
}>;


export type UpdateProjectMutation = { __typename?: 'RootMutationType', updateProject?: { __typename?: 'Project', id: string, insertedAt?: string | null, updatedAt?: string | null, name: string, default?: boolean | null, description?: string | null } | null };

export type DeleteProjectMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteProjectMutation = { __typename?: 'RootMutationType', deleteProject?: { __typename?: 'Project', id: string, insertedAt?: string | null, updatedAt?: string | null, name: string, default?: boolean | null, description?: string | null } | null };

export type UpdateRbacMutationVariables = Exact<{
  serviceId?: InputMaybe<Scalars['ID']['input']>;
  clusterId?: InputMaybe<Scalars['ID']['input']>;
  pipelineId?: InputMaybe<Scalars['ID']['input']>;
  stackId?: InputMaybe<Scalars['ID']['input']>;
  projectId?: InputMaybe<Scalars['ID']['input']>;
  flowId?: InputMaybe<Scalars['ID']['input']>;
  serverId?: InputMaybe<Scalars['ID']['input']>;
  rbac: RbacAttributes;
}>;


export type UpdateRbacMutation = { __typename?: 'RootMutationType', updateRbac?: boolean | null };

export type ServiceAccountsQueryVariables = Exact<{
  q?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
}>;


export type ServiceAccountsQuery = { __typename?: 'RootQueryType', serviceAccounts?: { __typename?: 'UserConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'UserEdge', node?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null } | null> | null } | null };

export type CreateServiceAccountMutationVariables = Exact<{
  attributes: ServiceAccountAttributes;
}>;


export type CreateServiceAccountMutation = { __typename?: 'RootMutationType', createServiceAccount?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null };

export type UpdateServiceAccountMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  attributes: ServiceAccountAttributes;
}>;


export type UpdateServiceAccountMutation = { __typename?: 'RootMutationType', updateServiceAccount?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null };

export type StackPolicyViolationFragment = { __typename?: 'StackPolicyViolation', id: string, insertedAt?: string | null, resolution?: string | null, severity: VulnSeverity, policyUrl?: string | null, policyModule?: string | null, policyId: string, description?: string | null, title: string, causes?: Array<{ __typename?: 'StackViolationCause', filename?: string | null, resource: string, start: number, end: number, lines?: Array<{ __typename?: 'StackViolationCauseLine', line: number, content: string, first?: boolean | null, last?: boolean | null } | null> | null } | null> | null };

export type StackMinimalFragment = { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType, status: StackStatus, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null };

export type StackTinyFragment = { __typename?: 'InfrastructureStack', id?: string | null, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null, name: string, type: StackType, paused?: boolean | null, status: StackStatus, repository?: { __typename?: 'GitRepository', url: string, pulledAt?: string | null } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null };

export type StackFragment = { __typename?: 'InfrastructureStack', id?: string | null, insertedAt?: string | null, deletedAt?: string | null, name: string, type: StackType, paused?: boolean | null, status: StackStatus, approval?: boolean | null, variables?: Record<string, unknown> | null, deleteRun?: { __typename?: 'StackRun', id: string, insertedAt?: string | null, message?: string | null, status: StackStatus, approval?: boolean | null, approvedAt?: string | null, git: { __typename?: 'GitRef', ref: string }, approver?: { __typename?: 'User', name: string, email: string } | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null, configuration: { __typename?: 'StackConfiguration', image?: string | null, version?: string | null, terraform?: { __typename?: 'TerraformConfiguration', parallelism?: number | null, refresh?: boolean | null } | null }, repository?: { __typename?: 'GitRepository', id: string, url: string, pulledAt?: string | null } | null, git: { __typename?: 'GitRef', ref: string, folder: string }, cluster?: { __typename?: 'Cluster', self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, environment?: Array<{ __typename?: 'StackEnvironment', name: string, value: string, secret?: boolean | null } | null> | null, jobSpec?: { __typename?: 'JobGateSpec', namespace: string, raw?: string | null, annotations?: Record<string, unknown> | null, labels?: Record<string, unknown> | null, serviceAccount?: string | null, containers?: Array<{ __typename?: 'ContainerSpec', image: string, args?: Array<string | null> | null, env?: Array<{ __typename?: 'ContainerEnv', value: string, name: string } | null> | null, envFrom?: Array<{ __typename?: 'ContainerEnvFrom', secret: string, configMap: string } | null> | null } | null> | null } | null, tags?: Array<{ __typename?: 'Tag', name: string, value: string } | null> | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null, policyEngine?: { __typename?: 'PolicyEngine', type: PolicyEngineType, maxSeverity?: VulnSeverity | null } | null };

export type StackRunFragment = { __typename?: 'StackRun', id: string, insertedAt?: string | null, message?: string | null, status: StackStatus, approval?: boolean | null, approvedAt?: string | null, git: { __typename?: 'GitRef', ref: string }, approver?: { __typename?: 'User', name: string, email: string } | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null };

export type ObservableMetricFragment = { __typename?: 'ObservableMetric', identifier: string, provider?: { __typename?: 'ObservabilityProvider', name: string, type: ObservabilityProviderType } | null };

export type StackRunDetailsFragment = { __typename?: 'StackRun', id: string, status: StackStatus, updatedAt?: string | null, insertedAt?: string | null, type: StackType, message?: string | null, approval?: boolean | null, approvedAt?: string | null, cancellationReason?: string | null, approver?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null, stack?: { __typename?: 'InfrastructureStack', name: string, deleteRun?: { __typename?: 'StackRun', id: string } | null, observableMetrics?: Array<{ __typename?: 'ObservableMetric', identifier: string, provider?: { __typename?: 'ObservabilityProvider', name: string, type: ObservabilityProviderType } | null } | null> | null } | null, configuration: { __typename?: 'StackConfiguration', version?: string | null, image?: string | null, terraform?: { __typename?: 'TerraformConfiguration', parallelism?: number | null, refresh?: boolean | null } | null }, state?: { __typename?: 'StackState', id: string, plan?: string | null, state?: Array<{ __typename?: 'StackStateResource', name: string, resource: string, identifier: string, links?: Array<string | null> | null, configuration?: Record<string, unknown> | null } | null> | null } | null, repository?: { __typename?: 'GitRepository', id: string, url: string, health?: GitHealth | null, authMethod?: AuthMethod | null, editable?: boolean | null, error?: string | null, insertedAt?: string | null, pulledAt?: string | null, updatedAt?: string | null, urlFormat?: string | null, httpsPath?: string | null } | null, git: { __typename?: 'GitRef', files?: Array<string> | null, ref: string, folder: string }, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, output?: Array<{ __typename?: 'StackOutput', name: string, value: string, secret?: boolean | null } | null> | null, cluster?: { __typename?: 'Cluster', self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, environment?: Array<{ __typename?: 'StackEnvironment', name: string, value: string, secret?: boolean | null } | null> | null, errors?: Array<{ __typename?: 'ServiceError', source: string, message: string, warning?: boolean | null } | null> | null, files?: Array<{ __typename?: 'StackFile', path: string, content: string } | null> | null, jobSpec?: { __typename?: 'JobGateSpec', annotations?: Record<string, unknown> | null, labels?: Record<string, unknown> | null, namespace: string, raw?: string | null, serviceAccount?: string | null, containers?: Array<{ __typename?: 'ContainerSpec', args?: Array<string | null> | null, image: string, env?: Array<{ __typename?: 'ContainerEnv', name: string, value: string } | null> | null, envFrom?: Array<{ __typename?: 'ContainerEnvFrom', configMap: string, secret: string } | null> | null } | null> | null } | null, steps?: Array<{ __typename?: 'RunStep', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, status: StepStatus, stage: StepStage, args?: Array<string> | null, cmd: string, index: number, logs?: Array<{ __typename?: 'RunLogs', id: string, updatedAt?: string | null, insertedAt?: string | null, logs: string } | null> | null } | null> | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null, violations?: Array<{ __typename?: 'StackPolicyViolation', id: string, insertedAt?: string | null, resolution?: string | null, severity: VulnSeverity, policyUrl?: string | null, policyModule?: string | null, policyId: string, description?: string | null, title: string, causes?: Array<{ __typename?: 'StackViolationCause', filename?: string | null, resource: string, start: number, end: number, lines?: Array<{ __typename?: 'StackViolationCauseLine', line: number, content: string, first?: boolean | null, last?: boolean | null } | null> | null } | null> | null } | null> | null, policyEngine?: { __typename?: 'PolicyEngine', type: PolicyEngineType, maxSeverity?: VulnSeverity | null } | null };

export type CustomStackRunFragment = { __typename?: 'CustomStackRun', id: string, name: string, documentation?: string | null, commands?: Array<{ __typename?: 'StackCommand', args?: Array<string | null> | null, cmd: string } | null> | null, configuration?: Array<{ __typename?: 'PrConfiguration', values?: Array<string | null> | null, default?: string | null, documentation?: string | null, displayName?: string | null, longform?: string | null, name: string, optional?: boolean | null, placeholder?: string | null, type: ConfigurationType, page?: number | null, condition?: { __typename?: 'PrConfigurationCondition', field: string, operation: Operation, value?: string | null } | null } | null> | null };

export type StackConfigurationFragment = { __typename?: 'StackConfiguration', version?: string | null, image?: string | null, terraform?: { __typename?: 'TerraformConfiguration', parallelism?: number | null, refresh?: boolean | null } | null };

export type StackStateResourceFragment = { __typename?: 'StackStateResource', name: string, resource: string, identifier: string, links?: Array<string | null> | null, configuration?: Record<string, unknown> | null };

export type StackStateFragment = { __typename?: 'StackState', id: string, plan?: string | null, state?: Array<{ __typename?: 'StackStateResource', name: string, resource: string, identifier: string, links?: Array<string | null> | null, configuration?: Record<string, unknown> | null } | null> | null };

export type StackOutputFragment = { __typename?: 'StackOutput', name: string, value: string, secret?: boolean | null };

export type StackEnvironmentFragment = { __typename?: 'StackEnvironment', name: string, value: string, secret?: boolean | null };

export type ServiceErrorsFragment = { __typename?: 'ServiceError', source: string, message: string, warning?: boolean | null };

export type StackFileFragment = { __typename?: 'StackFile', path: string, content: string };

export type RunStepFragment = { __typename?: 'RunStep', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, status: StepStatus, stage: StepStage, args?: Array<string> | null, cmd: string, index: number, logs?: Array<{ __typename?: 'RunLogs', id: string, updatedAt?: string | null, insertedAt?: string | null, logs: string } | null> | null };

export type StackPrsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
}>;


export type StackPrsQuery = { __typename?: 'RootQueryType', infrastructureStack?: { __typename?: 'InfrastructureStack', id?: string | null, pullRequests?: { __typename?: 'PullRequestConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'PullRequestEdge', node?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null> | null } | null } | null };

export type StacksQueryVariables = Exact<{
  q?: InputMaybe<Scalars['String']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Scalars['ID']['input']>;
  tagQuery?: InputMaybe<TagQuery>;
}>;


export type StacksQuery = { __typename?: 'RootQueryType', infrastructureStacks?: { __typename?: 'InfrastructureStackConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'InfrastructureStackEdge', node?: { __typename?: 'InfrastructureStack', id?: string | null, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null, name: string, type: StackType, paused?: boolean | null, status: StackStatus, repository?: { __typename?: 'GitRepository', url: string, pulledAt?: string | null } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null } | null> | null } | null };

export type StackQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type StackQuery = { __typename?: 'RootQueryType', infrastructureStack?: { __typename?: 'InfrastructureStack', id?: string | null, insertedAt?: string | null, deletedAt?: string | null, name: string, type: StackType, paused?: boolean | null, status: StackStatus, approval?: boolean | null, variables?: Record<string, unknown> | null, deleteRun?: { __typename?: 'StackRun', id: string, insertedAt?: string | null, message?: string | null, status: StackStatus, approval?: boolean | null, approvedAt?: string | null, git: { __typename?: 'GitRef', ref: string }, approver?: { __typename?: 'User', name: string, email: string } | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null, configuration: { __typename?: 'StackConfiguration', image?: string | null, version?: string | null, terraform?: { __typename?: 'TerraformConfiguration', parallelism?: number | null, refresh?: boolean | null } | null }, repository?: { __typename?: 'GitRepository', id: string, url: string, pulledAt?: string | null } | null, git: { __typename?: 'GitRef', ref: string, folder: string }, cluster?: { __typename?: 'Cluster', self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, environment?: Array<{ __typename?: 'StackEnvironment', name: string, value: string, secret?: boolean | null } | null> | null, jobSpec?: { __typename?: 'JobGateSpec', namespace: string, raw?: string | null, annotations?: Record<string, unknown> | null, labels?: Record<string, unknown> | null, serviceAccount?: string | null, containers?: Array<{ __typename?: 'ContainerSpec', image: string, args?: Array<string | null> | null, env?: Array<{ __typename?: 'ContainerEnv', value: string, name: string } | null> | null, envFrom?: Array<{ __typename?: 'ContainerEnvFrom', secret: string, configMap: string } | null> | null } | null> | null } | null, tags?: Array<{ __typename?: 'Tag', name: string, value: string } | null> | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null, policyEngine?: { __typename?: 'PolicyEngine', type: PolicyEngineType, maxSeverity?: VulnSeverity | null } | null } | null };

export type StackTinyQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type StackTinyQuery = { __typename?: 'RootQueryType', infrastructureStack?: { __typename?: 'InfrastructureStack', id?: string | null, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null, name: string, type: StackType, paused?: boolean | null, status: StackStatus, repository?: { __typename?: 'GitRepository', url: string, pulledAt?: string | null } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null };

export type StackStateQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type StackStateQuery = { __typename?: 'RootQueryType', infrastructureStack?: { __typename?: 'InfrastructureStack', state?: { __typename?: 'StackState', id: string, plan?: string | null, state?: Array<{ __typename?: 'StackStateResource', name: string, identifier: string, configuration?: Record<string, unknown> | null, links?: Array<string | null> | null, resource: string } | null> | null } | null } | null };

export type StackOutputQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type StackOutputQuery = { __typename?: 'RootQueryType', infrastructureStack?: { __typename?: 'InfrastructureStack', output?: Array<{ __typename?: 'StackOutput', name: string, secret?: boolean | null, value: string } | null> | null } | null };

export type StackFilesQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type StackFilesQuery = { __typename?: 'RootQueryType', infrastructureStack?: { __typename?: 'InfrastructureStack', files?: Array<{ __typename?: 'StackFile', path: string, content: string } | null> | null } | null };

export type StackBindingsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type StackBindingsQuery = { __typename?: 'RootQueryType', infrastructureStack?: { __typename?: 'InfrastructureStack', writeBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, readBindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null } | null };

export type StackRunsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  pullRequestId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type StackRunsQuery = { __typename?: 'RootQueryType', infrastructureStack?: { __typename?: 'InfrastructureStack', id?: string | null, runs?: { __typename?: 'StackRunConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'StackRunEdge', node?: { __typename?: 'StackRun', id: string, insertedAt?: string | null, message?: string | null, status: StackStatus, approval?: boolean | null, approvedAt?: string | null, git: { __typename?: 'GitRef', ref: string }, approver?: { __typename?: 'User', name: string, email: string } | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null } | null> | null } | null } | null };

export type StackRunQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type StackRunQuery = { __typename?: 'RootQueryType', stackRun?: { __typename?: 'StackRun', id: string, status: StackStatus, updatedAt?: string | null, insertedAt?: string | null, type: StackType, message?: string | null, approval?: boolean | null, approvedAt?: string | null, cancellationReason?: string | null, approver?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null, stack?: { __typename?: 'InfrastructureStack', name: string, deleteRun?: { __typename?: 'StackRun', id: string } | null, observableMetrics?: Array<{ __typename?: 'ObservableMetric', identifier: string, provider?: { __typename?: 'ObservabilityProvider', name: string, type: ObservabilityProviderType } | null } | null> | null } | null, configuration: { __typename?: 'StackConfiguration', version?: string | null, image?: string | null, terraform?: { __typename?: 'TerraformConfiguration', parallelism?: number | null, refresh?: boolean | null } | null }, state?: { __typename?: 'StackState', id: string, plan?: string | null, state?: Array<{ __typename?: 'StackStateResource', name: string, resource: string, identifier: string, links?: Array<string | null> | null, configuration?: Record<string, unknown> | null } | null> | null } | null, repository?: { __typename?: 'GitRepository', id: string, url: string, health?: GitHealth | null, authMethod?: AuthMethod | null, editable?: boolean | null, error?: string | null, insertedAt?: string | null, pulledAt?: string | null, updatedAt?: string | null, urlFormat?: string | null, httpsPath?: string | null } | null, git: { __typename?: 'GitRef', files?: Array<string> | null, ref: string, folder: string }, pullRequest?: { __typename?: 'PullRequest', id: string, title?: string | null, url: string, labels?: Array<string | null> | null, creator?: string | null, status?: PrStatus | null, patch?: string | null, insertedAt?: string | null, updatedAt?: string | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, protect?: boolean | null, deletedAt?: string | null } | null, cluster?: { __typename?: 'Cluster', protect?: boolean | null, deletedAt?: string | null, version?: string | null, currentVersion?: string | null, self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, output?: Array<{ __typename?: 'StackOutput', name: string, value: string, secret?: boolean | null } | null> | null, cluster?: { __typename?: 'Cluster', self?: boolean | null, virtual?: boolean | null, id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, upgradePlan?: { __typename?: 'ClusterUpgradePlan', compatibilities?: boolean | null, deprecations?: boolean | null, incompatibilities?: boolean | null } | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null, environment?: Array<{ __typename?: 'StackEnvironment', name: string, value: string, secret?: boolean | null } | null> | null, errors?: Array<{ __typename?: 'ServiceError', source: string, message: string, warning?: boolean | null } | null> | null, files?: Array<{ __typename?: 'StackFile', path: string, content: string } | null> | null, jobSpec?: { __typename?: 'JobGateSpec', annotations?: Record<string, unknown> | null, labels?: Record<string, unknown> | null, namespace: string, raw?: string | null, serviceAccount?: string | null, containers?: Array<{ __typename?: 'ContainerSpec', args?: Array<string | null> | null, image: string, env?: Array<{ __typename?: 'ContainerEnv', name: string, value: string } | null> | null, envFrom?: Array<{ __typename?: 'ContainerEnvFrom', configMap: string, secret: string } | null> | null } | null> | null } | null, steps?: Array<{ __typename?: 'RunStep', id: string, name: string, insertedAt?: string | null, updatedAt?: string | null, status: StepStatus, stage: StepStage, args?: Array<string> | null, cmd: string, index: number, logs?: Array<{ __typename?: 'RunLogs', id: string, updatedAt?: string | null, insertedAt?: string | null, logs: string } | null> | null } | null> | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null, violations?: Array<{ __typename?: 'StackPolicyViolation', id: string, insertedAt?: string | null, resolution?: string | null, severity: VulnSeverity, policyUrl?: string | null, policyModule?: string | null, policyId: string, description?: string | null, title: string, causes?: Array<{ __typename?: 'StackViolationCause', filename?: string | null, resource: string, start: number, end: number, lines?: Array<{ __typename?: 'StackViolationCauseLine', line: number, content: string, first?: boolean | null, last?: boolean | null } | null> | null } | null> | null } | null> | null, policyEngine?: { __typename?: 'PolicyEngine', type: PolicyEngineType, maxSeverity?: VulnSeverity | null } | null } | null };

export type StackRunJobQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type StackRunJobQuery = { __typename?: 'RootQueryType', stackRun?: { __typename?: 'StackRun', job?: { __typename?: 'Job', raw: string, events?: Array<{ __typename?: 'Event', action?: string | null, count?: number | null, eventTime?: string | null, lastTimestamp?: string | null, message?: string | null, reason?: string | null, type?: string | null } | null> | null, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, pods?: Array<{ __typename?: 'Pod', raw: string, metadata: { __typename?: 'Metadata', uid?: string | null, name: string, namespace?: string | null, creationTimestamp?: string | null, labels?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null, annotations?: Array<{ __typename?: 'LabelPair', name?: string | null, value?: string | null } | null> | null }, status: { __typename?: 'PodStatus', phase?: string | null, podIp?: string | null, reason?: string | null, containerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, initContainerStatuses?: Array<{ __typename?: 'ContainerStatus', restartCount?: number | null, ready?: boolean | null, name?: string | null, state?: { __typename?: 'ContainerState', running?: { __typename?: 'RunningState', startedAt?: string | null } | null, terminated?: { __typename?: 'TerminatedState', exitCode?: number | null, message?: string | null, reason?: string | null } | null, waiting?: { __typename?: 'WaitingState', message?: string | null, reason?: string | null } | null } | null } | null> | null, conditions?: Array<{ __typename?: 'PodCondition', lastProbeTime?: string | null, lastTransitionTime?: string | null, message?: string | null, reason?: string | null, status?: string | null, type?: string | null } | null> | null }, spec: { __typename?: 'PodSpec', nodeName?: string | null, serviceAccountName?: string | null, containers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null, initContainers?: Array<{ __typename?: 'Container', name?: string | null, image?: string | null, ports?: Array<{ __typename?: 'Port', containerPort?: number | null, protocol?: string | null } | null> | null, resources?: { __typename?: 'Resources', limits?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null, requests?: { __typename?: 'ResourceSpec', cpu?: string | null, memory?: string | null } | null } | null } | null> | null } } | null> | null, spec: { __typename?: 'JobSpec', activeDeadlineSeconds?: number | null, backoffLimit?: number | null, parallelism?: number | null }, status: { __typename?: 'JobStatus', active?: number | null, completionTime?: string | null, failed?: number | null, startTime?: string | null, succeeded?: number | null } } | null } | null };

export type StackRunJobLogsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  container: Scalars['String']['input'];
  sinceSeconds: Scalars['Int']['input'];
}>;


export type StackRunJobLogsQuery = { __typename?: 'RootQueryType', stackRun?: { __typename?: 'StackRun', job?: { __typename?: 'Job', logs?: Array<string | null> | null } | null } | null };

export type CustomStackRunsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
}>;


export type CustomStackRunsQuery = { __typename?: 'RootQueryType', infrastructureStack?: { __typename?: 'InfrastructureStack', id?: string | null, customStackRuns?: { __typename?: 'CustomStackRunConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'CustomStackRunEdge', node?: { __typename?: 'CustomStackRun', id: string, name: string, documentation?: string | null, commands?: Array<{ __typename?: 'StackCommand', args?: Array<string | null> | null, cmd: string } | null> | null, configuration?: Array<{ __typename?: 'PrConfiguration', values?: Array<string | null> | null, default?: string | null, documentation?: string | null, displayName?: string | null, longform?: string | null, name: string, optional?: boolean | null, placeholder?: string | null, type: ConfigurationType, page?: number | null, condition?: { __typename?: 'PrConfigurationCondition', field: string, operation: Operation, value?: string | null } | null } | null> | null } | null } | null> | null } | null } | null };

export type CreateStackMutationVariables = Exact<{
  attributes: StackAttributes;
}>;


export type CreateStackMutation = { __typename?: 'RootMutationType', createStack?: { __typename?: 'InfrastructureStack', id?: string | null } | null };

export type CreateOnDemandRunMutationVariables = Exact<{
  stackId: Scalars['ID']['input'];
  context?: InputMaybe<Scalars['Json']['input']>;
  commands?: InputMaybe<Array<InputMaybe<CommandAttributes>> | InputMaybe<CommandAttributes>>;
}>;


export type CreateOnDemandRunMutation = { __typename?: 'RootMutationType', onDemandRun?: { __typename?: 'StackRun', id: string, insertedAt?: string | null, message?: string | null, status: StackStatus, approval?: boolean | null, approvedAt?: string | null, git: { __typename?: 'GitRef', ref: string }, approver?: { __typename?: 'User', name: string, email: string } | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null };

export type UpdateStackMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  attributes: StackAttributes;
}>;


export type UpdateStackMutation = { __typename?: 'RootMutationType', updateStack?: { __typename?: 'InfrastructureStack', id?: string | null } | null };

export type DetachStackMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DetachStackMutation = { __typename?: 'RootMutationType', detachStack?: { __typename?: 'InfrastructureStack', id?: string | null } | null };

export type DeleteStackMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteStackMutation = { __typename?: 'RootMutationType', deleteStack?: { __typename?: 'InfrastructureStack', id?: string | null } | null };

export type KickStackMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type KickStackMutation = { __typename?: 'RootMutationType', kickStack?: { __typename?: 'StackRun', id: string, insertedAt?: string | null, message?: string | null, status: StackStatus, approval?: boolean | null, approvedAt?: string | null, git: { __typename?: 'GitRef', ref: string }, approver?: { __typename?: 'User', name: string, email: string } | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null };

export type KickStackPullRequestMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type KickStackPullRequestMutation = { __typename?: 'RootMutationType', kickStackPullRequest?: { __typename?: 'StackRun', id: string, insertedAt?: string | null, message?: string | null, status: StackStatus, approval?: boolean | null, approvedAt?: string | null, git: { __typename?: 'GitRef', ref: string }, approver?: { __typename?: 'User', name: string, email: string } | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null };

export type UpdateStackRunMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  attributes: StackRunAttributes;
}>;


export type UpdateStackRunMutation = { __typename?: 'RootMutationType', updateStackRun?: { __typename?: 'StackRun', id: string, insertedAt?: string | null, message?: string | null, status: StackStatus, approval?: boolean | null, approvedAt?: string | null, git: { __typename?: 'GitRef', ref: string }, approver?: { __typename?: 'User', name: string, email: string } | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null };

export type CompleteStackRunMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  attributes: StackRunAttributes;
}>;


export type CompleteStackRunMutation = { __typename?: 'RootMutationType', completeStackRun?: { __typename?: 'StackRun', id: string, insertedAt?: string | null, message?: string | null, status: StackStatus, approval?: boolean | null, approvedAt?: string | null, git: { __typename?: 'GitRef', ref: string }, approver?: { __typename?: 'User', name: string, email: string } | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null };

export type ApproveStackRunMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type ApproveStackRunMutation = { __typename?: 'RootMutationType', approveStackRun?: { __typename?: 'StackRun', id: string, insertedAt?: string | null, message?: string | null, status: StackStatus, approval?: boolean | null, approvedAt?: string | null, git: { __typename?: 'GitRef', ref: string }, approver?: { __typename?: 'User', name: string, email: string } | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null };

export type RestartStackRunMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type RestartStackRunMutation = { __typename?: 'RootMutationType', restartStackRun?: { __typename?: 'StackRun', id: string, insertedAt?: string | null, message?: string | null, status: StackStatus, approval?: boolean | null, approvedAt?: string | null, git: { __typename?: 'GitRef', ref: string }, approver?: { __typename?: 'User', name: string, email: string } | null, insight?: { __typename?: 'AiInsight', id: string, text?: string | null, summary?: string | null, sha?: string | null, freshness?: InsightFreshness | null, updatedAt?: string | null, insertedAt?: string | null, error?: Array<{ __typename?: 'ServiceError', message: string, source: string } | null> | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null };

export type RestoreStackMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type RestoreStackMutation = { __typename?: 'RootMutationType', restoreStack?: { __typename?: 'InfrastructureStack', id?: string | null, insertedAt?: string | null, updatedAt?: string | null, deletedAt?: string | null, name: string, type: StackType, paused?: boolean | null, status: StackStatus, repository?: { __typename?: 'GitRepository', url: string, pulledAt?: string | null } | null, insight?: { __typename?: 'AiInsight', id: string, summary?: string | null, freshness?: InsightFreshness | null, insertedAt?: string | null, updatedAt?: string | null, evidence?: Array<{ __typename?: 'AiInsightEvidence', id: string, type: EvidenceType, insertedAt?: string | null, updatedAt?: string | null, logs?: { __typename?: 'LogsEvidence', clusterId?: string | null, serviceId?: string | null, line?: string | null, lines?: Array<{ __typename?: 'LogLine', log?: string | null, timestamp?: string | null, facets?: Array<{ __typename?: 'LogFacet', key: string, value?: string | null } | null> | null } | null> | null } | null, pullRequest?: { __typename?: 'PullRequestEvidence', contents?: string | null, filename?: string | null, patch?: string | null, repo?: string | null, sha?: string | null, title?: string | null, url?: string | null } | null, alert?: { __typename?: 'AlertEvidence', alertId?: string | null, title?: string | null, resolution?: string | null } | null, knowledge?: { __typename?: 'KnowledgeEvidence', name?: string | null, observations?: Array<string | null> | null, type?: string | null } | null } | null> | null, cluster?: { __typename?: 'Cluster', id: string, name: string, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', cloud: string } | null } | null, clusterInsightComponent?: { __typename?: 'ClusterInsightComponent', id: string, name: string } | null, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null, serviceComponent?: { __typename?: 'ServiceComponent', id: string, name: string, service?: { __typename?: 'ServiceDeployment', id: string, name: string, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, distro?: ClusterDistro | null, provider?: { __typename?: 'ClusterProvider', name: string, cloud: string } | null } | null } | null } | null, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string, type: StackType } | null, stackRun?: { __typename?: 'StackRun', id: string, message?: string | null, type: StackType, stack?: { __typename?: 'InfrastructureStack', id?: string | null, name: string } | null } | null, alert?: { __typename?: 'Alert', id: string, title?: string | null, message?: string | null } | null } | null } | null };

export type LogsDeltaSubscriptionVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type LogsDeltaSubscription = { __typename?: 'RootSubscriptionType', runLogsDelta?: { __typename?: 'RunLogsDelta', delta?: Delta | null, payload?: { __typename?: 'RunLogs', id: string, logs: string, insertedAt?: string | null, updatedAt?: string | null } | null } | null };

export type AccessTokenFragment = { __typename?: 'AccessToken', id?: string | null, insertedAt?: string | null, updatedAt?: string | null, scopes?: Array<{ __typename?: 'AccessTokenScope', api?: string | null, apis?: Array<string> | null, identifier?: string | null, ids?: Array<string> | null } | null> | null };

export type AccessTokenAuditFragment = { __typename?: 'AccessTokenAudit', id?: string | null, city?: string | null, count?: number | null, country?: string | null, insertedAt?: string | null, ip?: string | null, latitude?: string | null, longitude?: string | null, timestamp?: string | null, updatedAt?: string | null };

export type SharedSecretFragment = { __typename?: 'SharedSecret', secret: string, handle: string, name: string, insertedAt?: string | null, updatedAt?: string | null };

export type AccessTokensQueryVariables = Exact<{ [key: string]: never; }>;


export type AccessTokensQuery = { __typename?: 'RootQueryType', accessTokens?: { __typename?: 'AccessTokenConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'AccessTokenEdge', node?: { __typename?: 'AccessToken', id?: string | null, insertedAt?: string | null, updatedAt?: string | null, scopes?: Array<{ __typename?: 'AccessTokenScope', api?: string | null, apis?: Array<string> | null, identifier?: string | null, ids?: Array<string> | null } | null> | null } | null } | null> | null } | null };

export type TokenAuditsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  cursor?: InputMaybe<Scalars['String']['input']>;
}>;


export type TokenAuditsQuery = { __typename?: 'RootQueryType', accessToken?: { __typename?: 'AccessToken', id?: string | null, audits?: { __typename?: 'AccessTokenAuditConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'AccessTokenAuditEdge', node?: { __typename?: 'AccessTokenAudit', id?: string | null, city?: string | null, count?: number | null, country?: string | null, insertedAt?: string | null, ip?: string | null, latitude?: string | null, longitude?: string | null, timestamp?: string | null, updatedAt?: string | null } | null } | null> | null } | null } | null };

export type CreateAccessTokenMutationVariables = Exact<{
  scopes?: InputMaybe<Array<InputMaybe<ScopeAttributes>> | InputMaybe<ScopeAttributes>>;
}>;


export type CreateAccessTokenMutation = { __typename?: 'RootMutationType', createAccessToken?: { __typename?: 'AccessToken', token?: string | null, id?: string | null, insertedAt?: string | null, updatedAt?: string | null, scopes?: Array<{ __typename?: 'AccessTokenScope', api?: string | null, apis?: Array<string> | null, identifier?: string | null, ids?: Array<string> | null } | null> | null } | null };

export type DeleteAccessTokenMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteAccessTokenMutation = { __typename?: 'RootMutationType', deleteAccessToken?: { __typename?: 'AccessToken', id?: string | null, insertedAt?: string | null, updatedAt?: string | null, scopes?: Array<{ __typename?: 'AccessTokenScope', api?: string | null, apis?: Array<string> | null, identifier?: string | null, ids?: Array<string> | null } | null> | null } | null };

export type ShareSecretMutationVariables = Exact<{
  attributes: SharedSecretAttributes;
}>;


export type ShareSecretMutation = { __typename?: 'RootMutationType', shareSecret?: { __typename?: 'SharedSecret', secret: string, handle: string, name: string, insertedAt?: string | null, updatedAt?: string | null } | null };

export type ConsumeSecretMutationVariables = Exact<{
  handle: Scalars['String']['input'];
}>;


export type ConsumeSecretMutation = { __typename?: 'RootMutationType', consumeSecret?: { __typename?: 'SharedSecret', secret: string, handle: string, name: string, insertedAt?: string | null, updatedAt?: string | null } | null };

export type UserFragment = { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null };

export type UserTinyFragment = { __typename?: 'User', name: string, email: string, profile?: string | null };

export type InviteFragment = { __typename?: 'Invite', secureId: string };

export type RoleBindingFragment = { __typename?: 'RoleBinding', id: string, user?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null, group?: { __typename?: 'Group', id: string, name: string, description?: string | null, global?: boolean | null, insertedAt?: string | null, updatedAt?: string | null } | null };

export type RoleFragment = { __typename?: 'Role', id: string, name: string, description?: string | null, repositories?: Array<string | null> | null, permissions?: Array<Permission | null> | null, roleBindings?: Array<{ __typename?: 'RoleBinding', id: string, user?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null, group?: { __typename?: 'Group', id: string, name: string, description?: string | null, global?: boolean | null, insertedAt?: string | null, updatedAt?: string | null } | null } | null> | null };

export type AvailableFeaturesFragment = { __typename?: 'AvailableFeatures', audits?: boolean | null, cd?: boolean | null, databaseManagement?: boolean | null, userManagement?: boolean | null };

export type ManifestFragment = { __typename?: 'PluralManifest', cluster?: string | null, bucketPrefix?: string | null, network?: { __typename?: 'ManifestNetwork', pluralDns?: boolean | null, subdomain?: string | null } | null };

export type UsersQueryVariables = Exact<{
  q?: InputMaybe<Scalars['String']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
}>;


export type UsersQuery = { __typename?: 'RootQueryType', users?: { __typename?: 'UserConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'UserEdge', node?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null } | null> | null } | null };

export type SearchUsersQueryVariables = Exact<{
  q?: InputMaybe<Scalars['String']['input']>;
  cursor?: InputMaybe<Scalars['String']['input']>;
}>;


export type SearchUsersQuery = { __typename?: 'RootQueryType', users?: { __typename?: 'UserConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'UserEdge', node?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null } | null> | null } | null };

export type UpdateUserMutationVariables = Exact<{
  id?: InputMaybe<Scalars['ID']['input']>;
  attributes: UserAttributes;
}>;


export type UpdateUserMutation = { __typename?: 'RootMutationType', updateUser?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null };

export type DeleteUserMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteUserMutation = { __typename?: 'RootMutationType', deleteUser?: { __typename?: 'User', id: string, pluralId?: string | null, name: string, email: string, profile?: string | null, backgroundColor?: string | null, readTimestamp?: string | null, emailSettings?: { __typename?: 'EmailSettings', digest?: boolean | null } | null, roles?: { __typename?: 'UserRoles', admin?: boolean | null } | null, personas?: Array<{ __typename?: 'Persona', id: string, name: string, description?: string | null, bindings?: Array<{ __typename?: 'PolicyBinding', id?: string | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, group?: { __typename?: 'Group', id: string, name: string } | null } | null> | null, configuration?: { __typename?: 'PersonaConfiguration', all?: boolean | null, deployments?: { __typename?: 'PersonaDeployment', addOns?: boolean | null, clusters?: boolean | null, pipelines?: boolean | null, providers?: boolean | null, repositories?: boolean | null, services?: boolean | null } | null, home?: { __typename?: 'PersonaHome', manager?: boolean | null, security?: boolean | null } | null, sidebar?: { __typename?: 'PersonaSidebar', audits?: boolean | null, kubernetes?: boolean | null, pullRequests?: boolean | null, settings?: boolean | null, backups?: boolean | null, stacks?: boolean | null } | null, services?: { __typename?: 'PersonaServices', configuration?: boolean | null, secrets?: boolean | null } | null, ai?: { __typename?: 'PersonaAi', pr?: boolean | null } | null } | null } | null> | null } | null };

export type CreateInviteMutationVariables = Exact<{
  attributes: InviteAttributes;
}>;


export type CreateInviteMutation = { __typename?: 'RootMutationType', createInvite?: { __typename?: 'Invite', secureId: string } | null };

export type VulnerabilityReportTinyFragment = { __typename?: 'VulnerabilityReport', id: string, artifactUrl?: string | null, services?: Array<{ __typename?: 'ServiceVuln', service?: { __typename?: 'ServiceDeployment', name: string } | null } | null> | null, namespaces?: Array<{ __typename?: 'NamespaceVuln', namespace: string } | null> | null, summary?: { __typename?: 'VulnSummary', criticalCount?: number | null, highCount?: number | null, mediumCount?: number | null, lowCount?: number | null, unknownCount?: number | null, noneCount?: number | null } | null };

export type VulnerabilityReportFragment = { __typename?: 'VulnerabilityReport', id: string, artifactUrl?: string | null, vulnerabilities?: Array<{ __typename?: 'Vulnerability', id: string, title?: string | null, description?: string | null, severity?: VulnSeverity | null, score?: number | null, primaryLink?: string | null, links?: Array<string | null> | null, target?: string | null, class?: string | null, packageType?: string | null, pkgPath?: string | null, publishedDate?: string | null, installedVersion?: string | null, fixedVersion?: string | null, lastModifiedDate?: string | null, cvssSource?: string | null, resource?: string | null, insertedAt?: string | null, updatedAt?: string | null, cvss?: { __typename?: 'CvssBundle', attackComplexity?: VulnSeverity | null, attackVector?: VulnAttackVector | null, availability?: VulnSeverity | null, confidentiality?: VulnSeverity | null, integrity?: VulnSeverity | null, privilegesRequired?: VulnSeverity | null, userInteraction?: VulnUserInteraction | null, nvidia?: { __typename?: 'Cvss', v2Score?: number | null, v2Vector?: string | null, v3Score?: number | null, v3Vector?: string | null, v40Score?: number | null, v40Vector?: string | null } | null, redhat?: { __typename?: 'Cvss', v2Score?: number | null, v2Vector?: string | null, v3Score?: number | null, v3Vector?: string | null, v40Score?: number | null, v40Vector?: string | null } | null } | null } | null> | null, services?: Array<{ __typename?: 'ServiceVuln', service?: { __typename?: 'ServiceDeployment', name: string } | null } | null> | null, namespaces?: Array<{ __typename?: 'NamespaceVuln', namespace: string } | null> | null, summary?: { __typename?: 'VulnSummary', criticalCount?: number | null, highCount?: number | null, mediumCount?: number | null, lowCount?: number | null, unknownCount?: number | null, noneCount?: number | null } | null };

export type VulnerabilityFragment = { __typename?: 'Vulnerability', id: string, title?: string | null, description?: string | null, severity?: VulnSeverity | null, score?: number | null, primaryLink?: string | null, links?: Array<string | null> | null, target?: string | null, class?: string | null, packageType?: string | null, pkgPath?: string | null, publishedDate?: string | null, installedVersion?: string | null, fixedVersion?: string | null, lastModifiedDate?: string | null, cvssSource?: string | null, resource?: string | null, insertedAt?: string | null, updatedAt?: string | null, cvss?: { __typename?: 'CvssBundle', attackComplexity?: VulnSeverity | null, attackVector?: VulnAttackVector | null, availability?: VulnSeverity | null, confidentiality?: VulnSeverity | null, integrity?: VulnSeverity | null, privilegesRequired?: VulnSeverity | null, userInteraction?: VulnUserInteraction | null, nvidia?: { __typename?: 'Cvss', v2Score?: number | null, v2Vector?: string | null, v3Score?: number | null, v3Vector?: string | null, v40Score?: number | null, v40Vector?: string | null } | null, redhat?: { __typename?: 'Cvss', v2Score?: number | null, v2Vector?: string | null, v3Score?: number | null, v3Vector?: string | null, v40Score?: number | null, v40Vector?: string | null } | null } | null };

export type VulnerabilityStatisticFragment = { __typename?: 'VulnerabilityStatistic', count: number, grade: VulnReportGrade };

export type ClusterVulnAggregateFragment = { __typename?: 'ClusterVulnAggregate', count: number, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, project?: { __typename?: 'Project', name: string } | null } | null };

export type CvssBundleFragment = { __typename?: 'CvssBundle', attackComplexity?: VulnSeverity | null, attackVector?: VulnAttackVector | null, availability?: VulnSeverity | null, confidentiality?: VulnSeverity | null, integrity?: VulnSeverity | null, privilegesRequired?: VulnSeverity | null, userInteraction?: VulnUserInteraction | null, nvidia?: { __typename?: 'Cvss', v2Score?: number | null, v2Vector?: string | null, v3Score?: number | null, v3Vector?: string | null, v40Score?: number | null, v40Vector?: string | null } | null, redhat?: { __typename?: 'Cvss', v2Score?: number | null, v2Vector?: string | null, v3Score?: number | null, v3Vector?: string | null, v40Score?: number | null, v40Vector?: string | null } | null };

export type VulnerabilityReportConnectionFragment = { __typename?: 'VulnerabilityReportConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'VulnerabilityReportEdge', node?: { __typename?: 'VulnerabilityReport', id: string, artifactUrl?: string | null, services?: Array<{ __typename?: 'ServiceVuln', service?: { __typename?: 'ServiceDeployment', name: string } | null } | null> | null, namespaces?: Array<{ __typename?: 'NamespaceVuln', namespace: string } | null> | null, summary?: { __typename?: 'VulnSummary', criticalCount?: number | null, highCount?: number | null, mediumCount?: number | null, lowCount?: number | null, unknownCount?: number | null, noneCount?: number | null } | null } | null } | null> | null };

export type VulnerabilityReportsQueryVariables = Exact<{
  clusters?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>> | InputMaybe<Scalars['ID']['input']>>;
  namespaces?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;
  q?: InputMaybe<Scalars['String']['input']>;
  grade?: InputMaybe<VulnReportGrade>;
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
}>;


export type VulnerabilityReportsQuery = { __typename?: 'RootQueryType', vulnerabilityReports?: { __typename?: 'VulnerabilityReportConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null, hasPreviousPage: boolean, startCursor?: string | null }, edges?: Array<{ __typename?: 'VulnerabilityReportEdge', node?: { __typename?: 'VulnerabilityReport', id: string, artifactUrl?: string | null, services?: Array<{ __typename?: 'ServiceVuln', service?: { __typename?: 'ServiceDeployment', name: string } | null } | null> | null, namespaces?: Array<{ __typename?: 'NamespaceVuln', namespace: string } | null> | null, summary?: { __typename?: 'VulnSummary', criticalCount?: number | null, highCount?: number | null, mediumCount?: number | null, lowCount?: number | null, unknownCount?: number | null, noneCount?: number | null } | null } | null } | null> | null } | null };

export type VulnerabilityReportQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type VulnerabilityReportQuery = { __typename?: 'RootQueryType', vulnerabilityReport?: { __typename?: 'VulnerabilityReport', id: string, artifactUrl?: string | null, vulnerabilities?: Array<{ __typename?: 'Vulnerability', id: string, title?: string | null, description?: string | null, severity?: VulnSeverity | null, score?: number | null, primaryLink?: string | null, links?: Array<string | null> | null, target?: string | null, class?: string | null, packageType?: string | null, pkgPath?: string | null, publishedDate?: string | null, installedVersion?: string | null, fixedVersion?: string | null, lastModifiedDate?: string | null, cvssSource?: string | null, resource?: string | null, insertedAt?: string | null, updatedAt?: string | null, cvss?: { __typename?: 'CvssBundle', attackComplexity?: VulnSeverity | null, attackVector?: VulnAttackVector | null, availability?: VulnSeverity | null, confidentiality?: VulnSeverity | null, integrity?: VulnSeverity | null, privilegesRequired?: VulnSeverity | null, userInteraction?: VulnUserInteraction | null, nvidia?: { __typename?: 'Cvss', v2Score?: number | null, v2Vector?: string | null, v3Score?: number | null, v3Vector?: string | null, v40Score?: number | null, v40Vector?: string | null } | null, redhat?: { __typename?: 'Cvss', v2Score?: number | null, v2Vector?: string | null, v3Score?: number | null, v3Vector?: string | null, v40Score?: number | null, v40Vector?: string | null } | null } | null } | null> | null, services?: Array<{ __typename?: 'ServiceVuln', service?: { __typename?: 'ServiceDeployment', name: string } | null } | null> | null, namespaces?: Array<{ __typename?: 'NamespaceVuln', namespace: string } | null> | null, summary?: { __typename?: 'VulnSummary', criticalCount?: number | null, highCount?: number | null, mediumCount?: number | null, lowCount?: number | null, unknownCount?: number | null, noneCount?: number | null } | null } | null };

export type VulnerabilityStatisticsQueryVariables = Exact<{
  clusters?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>> | InputMaybe<Scalars['ID']['input']>>;
  namespaces?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;
  q?: InputMaybe<Scalars['String']['input']>;
}>;


export type VulnerabilityStatisticsQuery = { __typename?: 'RootQueryType', vulnerabilityStatistics?: Array<{ __typename?: 'VulnerabilityStatistic', count: number, grade: VulnReportGrade } | null> | null };

export type ClusterVulnerabilityAggregateQueryVariables = Exact<{
  grade: VulnReportGrade;
}>;


export type ClusterVulnerabilityAggregateQuery = { __typename?: 'RootQueryType', clusterVulnerabilityAggregate?: Array<{ __typename?: 'ClusterVulnAggregate', count: number, cluster?: { __typename?: 'Cluster', id: string, name: string, handle?: string | null, project?: { __typename?: 'Project', name: string } | null } | null } | null> | null };

export const ChatThreadSettingsFragmentDoc = gql`
    fragment ChatThreadSettings on ChatThreadSettings {
  memory
}
    `;
export const LogLineFragmentDoc = gql`
    fragment LogLine on LogLine {
  facets {
    key
    value
  }
  log
  timestamp
}
    `;
export const LogsEvidenceFragmentDoc = gql`
    fragment LogsEvidence on LogsEvidence {
  clusterId
  serviceId
  line
  lines {
    ...LogLine
  }
}
    ${LogLineFragmentDoc}`;
export const PullRequestEvidenceFragmentDoc = gql`
    fragment PullRequestEvidence on PullRequestEvidence {
  contents
  filename
  patch
  repo
  sha
  title
  url
}
    `;
export const AlertEvidenceFragmentDoc = gql`
    fragment AlertEvidence on AlertEvidence {
  alertId
  title
  resolution
}
    `;
export const KnowledgeEvidenceFragmentDoc = gql`
    fragment KnowledgeEvidence on KnowledgeEvidence {
  name
  observations
  type
}
    `;
export const AiInsightEvidenceFragmentDoc = gql`
    fragment AiInsightEvidence on AiInsightEvidence {
  id
  type
  logs {
    ...LogsEvidence
  }
  pullRequest {
    ...PullRequestEvidence
  }
  alert {
    ...AlertEvidence
  }
  knowledge {
    ...KnowledgeEvidence
  }
  insertedAt
  updatedAt
}
    ${LogsEvidenceFragmentDoc}
${PullRequestEvidenceFragmentDoc}
${AlertEvidenceFragmentDoc}
${KnowledgeEvidenceFragmentDoc}`;
export const ClusterMinimalFragmentDoc = gql`
    fragment ClusterMinimal on Cluster {
  id
  name
  handle
  provider {
    name
    cloud
  }
  distro
}
    `;
export const AiInsightContextFragmentDoc = gql`
    fragment AiInsightContext on AiInsight {
  evidence {
    ...AiInsightEvidence
  }
  cluster {
    id
    name
    distro
    provider {
      cloud
    }
  }
  clusterInsightComponent {
    id
    name
  }
  service {
    id
    name
    cluster {
      ...ClusterMinimal
    }
  }
  serviceComponent {
    id
    name
    service {
      id
      name
      cluster {
        ...ClusterMinimal
      }
    }
  }
  stack {
    id
    name
    type
  }
  stackRun {
    id
    message
    type
    stack {
      id
      name
    }
  }
  alert {
    id
    title
    message
  }
}
    ${AiInsightEvidenceFragmentDoc}
${ClusterMinimalFragmentDoc}`;
export const AiInsightSummaryFragmentDoc = gql`
    fragment AiInsightSummary on AiInsight {
  id
  summary
  freshness
  insertedAt
  updatedAt
  ...AiInsightContext
}
    ${AiInsightContextFragmentDoc}`;
export const AgentSessionFragmentDoc = gql`
    fragment AgentSession on AgentSession {
  id
  type
  done
  planConfirmed
  thread {
    id
    summary
    insertedAt
    lastMessageAt
  }
  connection {
    id
    name
    provider
  }
  cluster {
    id
  }
  pullRequest {
    id
    url
  }
  stack {
    id
    name
  }
  service {
    id
    name
    cluster {
      id
    }
  }
}
    `;
export const ChatThreadTinyFragmentDoc = gql`
    fragment ChatThreadTiny on ChatThread {
  id
  default
  summary
  insertedAt
  updatedAt
  lastMessageAt
  settings {
    ...ChatThreadSettings
  }
  insight {
    ...AiInsightSummary
  }
  flow {
    id
    name
    icon
  }
  session {
    ...AgentSession
  }
}
    ${ChatThreadSettingsFragmentDoc}
${AiInsightSummaryFragmentDoc}
${AgentSessionFragmentDoc}`;
export const AiInsightFragmentDoc = gql`
    fragment AiInsight on AiInsight {
  id
  text
  summary
  sha
  freshness
  updatedAt
  insertedAt
  error {
    message
    source
  }
  ...AiInsightContext
}
    ${AiInsightContextFragmentDoc}`;
export const McpToolFragmentDoc = gql`
    fragment McpTool on McpTool {
  name
  description
  inputSchema
}
    `;
export const PolicyBindingFragmentDoc = gql`
    fragment PolicyBinding on PolicyBinding {
  id
  user {
    id
    name
    email
  }
  group {
    id
    name
  }
}
    `;
export const McpServerFragmentDoc = gql`
    fragment McpServer on McpServer {
  id
  name
  url
  confirm
  readBindings {
    ...PolicyBinding
  }
  writeBindings {
    ...PolicyBinding
  }
  authentication {
    headers {
      name
      value
    }
    plural
  }
}
    ${PolicyBindingFragmentDoc}`;
export const McpServerToolFragmentDoc = gql`
    fragment McpServerTool on McpServerTool {
  tool {
    ...McpTool
  }
  server {
    ...McpServer
  }
}
    ${McpToolFragmentDoc}
${McpServerFragmentDoc}`;
export const ChatThreadDetailsFragmentDoc = gql`
    fragment ChatThreadDetails on ChatThread {
  ...ChatThreadTiny
  insight {
    ...AiInsight
  }
  tools {
    ...McpServerTool
  }
}
    ${ChatThreadTinyFragmentDoc}
${AiInsightFragmentDoc}
${McpServerToolFragmentDoc}`;
export const PageInfoFragmentDoc = gql`
    fragment PageInfo on PageInfo {
  hasNextPage
  endCursor
  hasPreviousPage
  startCursor
}
    `;
export const ClusterTinyFragmentDoc = gql`
    fragment ClusterTiny on Cluster {
  ...ClusterMinimal
  self
  upgradePlan {
    compatibilities
    deprecations
    incompatibilities
  }
  virtual
}
    ${ClusterMinimalFragmentDoc}`;
export const ClusterBasicFragmentDoc = gql`
    fragment ClusterBasic on Cluster {
  ...ClusterTiny
  protect
  deletedAt
  version
  currentVersion
}
    ${ClusterTinyFragmentDoc}`;
export const PullRequestFragmentDoc = gql`
    fragment PullRequest on PullRequest {
  id
  service {
    id
    name
    protect
    deletedAt
  }
  cluster {
    ...ClusterBasic
  }
  title
  url
  labels
  creator
  status
  patch
  insertedAt
  updatedAt
}
    ${ClusterBasicFragmentDoc}`;
export const ScmConnectionFragmentDoc = gql`
    fragment ScmConnection on ScmConnection {
  id
  name
  insertedAt
  updatedAt
  type
  username
  baseUrl
  apiUrl
  azure {
    username
    organization
    project
  }
}
    `;
export const PrConfigurationFragmentDoc = gql`
    fragment PrConfiguration on PrConfiguration {
  condition {
    field
    operation
    value
  }
  values
  default
  documentation
  displayName
  longform
  name
  optional
  placeholder
  type
  page
}
    `;
export const PrConfirmationFragmentDoc = gql`
    fragment PrConfirmation on PrConfirmation {
  checklist {
    label
  }
  text
}
    `;
export const PrAutomationFragmentDoc = gql`
    fragment PrAutomation on PrAutomation {
  id
  name
  icon
  darkIcon
  documentation
  addon
  identifier
  cluster {
    ...ClusterBasic
  }
  service {
    id
    name
  }
  repository {
    url
    refs
  }
  role
  documentation
  connection {
    ...ScmConnection
  }
  createBindings {
    ...PolicyBinding
  }
  writeBindings {
    ...PolicyBinding
  }
  configuration {
    ...PrConfiguration
  }
  confirmation {
    ...PrConfirmation
  }
}
    ${ClusterBasicFragmentDoc}
${ScmConnectionFragmentDoc}
${PolicyBindingFragmentDoc}
${PrConfigurationFragmentDoc}
${PrConfirmationFragmentDoc}`;
export const ChatFragmentDoc = gql`
    fragment Chat on Chat {
  id
  content
  role
  seq
  type
  confirm
  confirmedAt
  attributes {
    file {
      name
    }
    tool {
      name
      arguments
    }
    prCall {
      context
      branch
    }
  }
  pullRequest {
    ...PullRequest
  }
  prAutomation {
    ...PrAutomation
  }
  server {
    id
    name
  }
  insertedAt
  updatedAt
}
    ${PullRequestFragmentDoc}
${PrAutomationFragmentDoc}`;
export const ChatThreadMessagesFragmentDoc = gql`
    fragment ChatThreadMessages on ChatThread {
  id
  chats(
    first: $first
    last: $last
    after: $after
    before: $before
    reverse: $reverse
  ) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...Chat
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${ChatFragmentDoc}`;
export const CloudConnectionTinyFragmentDoc = gql`
    fragment CloudConnectionTiny on CloudConnection {
  id
  name
  provider
}
    `;
export const ServiceDeploymentTinyFragmentDoc = gql`
    fragment ServiceDeploymentTiny on ServiceDeployment {
  id
  name
  cluster {
    ...ClusterMinimal
  }
  componentStatus
  status
  errors {
    message
    source
  }
}
    ${ClusterMinimalFragmentDoc}`;
export const ServiceDeploymentChatFragmentDoc = gql`
    fragment ServiceDeploymentChat on ServiceDeployment {
  ...ServiceDeploymentTiny
  protect
  insight {
    ...AiInsightSummary
  }
}
    ${ServiceDeploymentTinyFragmentDoc}
${AiInsightSummaryFragmentDoc}`;
export const StackTinyFragmentDoc = gql`
    fragment StackTiny on InfrastructureStack {
  id
  insertedAt
  updatedAt
  deletedAt
  name
  type
  repository {
    url
    pulledAt
  }
  paused
  status
  insight {
    ...AiInsightSummary
  }
}
    ${AiInsightSummaryFragmentDoc}`;
export const StackChatFragmentDoc = gql`
    fragment StackChat on InfrastructureStack {
  ...StackTiny
  insight {
    ...AiInsightSummary
  }
}
    ${StackTinyFragmentDoc}
${AiInsightSummaryFragmentDoc}`;
export const AiDeltaFragmentDoc = gql`
    fragment AiDelta on AiDelta {
  seq
  message
  role
  content
  tool {
    id
    name
  }
}
    `;
export const ClusterInsightComponentFragmentDoc = gql`
    fragment ClusterInsightComponent on ClusterInsightComponent {
  id
  kind
  name
  namespace
  group
  version
  priority
  insight {
    ...AiInsight
  }
}
    ${AiInsightFragmentDoc}`;
export const ClusterInsightComponentDetailFragmentDoc = gql`
    fragment ClusterInsightComponentDetail on ClusterInsightComponent {
  ...ClusterInsightComponent
  resource {
    raw
  }
}
    ${ClusterInsightComponentFragmentDoc}`;
export const PersonaConfigurationFragmentDoc = gql`
    fragment PersonaConfiguration on PersonaConfiguration {
  all
  deployments {
    addOns
    clusters
    pipelines
    providers
    repositories
    services
  }
  home {
    manager
    security
  }
  sidebar {
    audits
    kubernetes
    pullRequests
    settings
    backups
    stacks
  }
  services {
    configuration
    secrets
  }
  ai {
    pr
  }
}
    `;
export const PersonaFragmentDoc = gql`
    fragment Persona on Persona {
  id
  name
  description
  bindings {
    ...PolicyBinding
  }
  configuration {
    ...PersonaConfiguration
  }
}
    ${PolicyBindingFragmentDoc}
${PersonaConfigurationFragmentDoc}`;
export const UserFragmentDoc = gql`
    fragment User on User {
  id
  pluralId
  name
  email
  emailSettings {
    digest
  }
  profile
  backgroundColor
  readTimestamp
  roles {
    admin
  }
  personas {
    ...Persona
  }
}
    ${PersonaFragmentDoc}`;
export const McpServerAuditFragmentDoc = gql`
    fragment McpServerAudit on McpServerAudit {
  id
  actor {
    ...User
  }
  arguments
  tool
  insertedAt
  updatedAt
}
    ${UserFragmentDoc}`;
export const McpServerConnectionFragmentDoc = gql`
    fragment McpServerConnection on McpServerConnection {
  pageInfo {
    ...PageInfo
  }
  edges {
    node {
      ...McpServer
    }
  }
}
    ${PageInfoFragmentDoc}
${McpServerFragmentDoc}`;
export const AlertResolutionFragmentDoc = gql`
    fragment AlertResolution on AlertResolution {
  resolution
}
    `;
export const AlertFragmentDoc = gql`
    fragment Alert on Alert {
  id
  title
  message
  type
  severity
  state
  fingerprint
  url
  annotations
  tags {
    id
    name
    value
  }
  insight {
    ...AiInsight
  }
  resolution {
    ...AlertResolution
  }
  updatedAt
}
    ${AiInsightFragmentDoc}
${AlertResolutionFragmentDoc}`;
export const AlertConnectionFragmentDoc = gql`
    fragment AlertConnection on AlertConnection {
  edges {
    node {
      ...Alert
    }
  }
  pageInfo {
    ...PageInfo
  }
}
    ${AlertFragmentDoc}
${PageInfoFragmentDoc}`;
export const AuditFragmentDoc = gql`
    fragment Audit on Audit {
  id
  type
  action
  repository
  ip
  city
  country
  latitude
  longitude
  actor {
    ...User
  }
  insertedAt
}
    ${UserFragmentDoc}`;
export const ScmWebhookFragmentDoc = gql`
    fragment ScmWebhook on ScmWebhook {
  id
  name
  owner
  type
  url
  insertedAt
  updatedAt
}
    `;
export const ObjectStoreFragmentDoc = gql`
    fragment ObjectStore on ObjectStore {
  id
  name
  s3 {
    bucket
    region
    endpoint
    accessKeyId
  }
  azure {
    container
    storageAccount
    resourceGroup
    subscriptionId
    clientId
    tenantId
  }
  gcs {
    bucket
  }
  insertedAt
  updatedAt
}
    `;
export const ClustersObjectStoresFragmentDoc = gql`
    fragment ClustersObjectStores on Cluster {
  ...ClusterBasic
  objectStore {
    ...ObjectStore
  }
}
    ${ClusterBasicFragmentDoc}
${ObjectStoreFragmentDoc}`;
export const ClusterBackupFragmentDoc = gql`
    fragment ClusterBackup on ClusterBackup {
  id
  cluster {
    ...ClusterBasic
  }
  garbageCollected
  insertedAt
  updatedAt
}
    ${ClusterBasicFragmentDoc}`;
export const ClusterRestoreFragmentDoc = gql`
    fragment ClusterRestore on ClusterRestore {
  id
  status
  backup {
    ...ClusterBackup
  }
  insertedAt
  updatedAt
}
    ${ClusterBackupFragmentDoc}`;
export const CatalogFragmentDoc = gql`
    fragment Catalog on Catalog {
  id
  name
  author
  description
  category
  icon
  darkIcon
  createBindings {
    ...PolicyBinding
  }
  readBindings {
    ...PolicyBinding
  }
  writeBindings {
    ...PolicyBinding
  }
}
    ${PolicyBindingFragmentDoc}`;
export const ClusterConditionFragmentDoc = gql`
    fragment ClusterCondition on ClusterCondition {
  lastTransitionTime
  message
  reason
  severity
  status
  type
}
    `;
export const AddonVersionFragmentDoc = gql`
    fragment AddonVersion on AddonVersion {
  version
  kube
  chartVersion
  incompatibilities {
    version
    name
  }
  requirements {
    version
    name
  }
}
    `;
export const AddonVersionBlockingFragmentDoc = gql`
    fragment AddonVersionBlocking on AddonVersion {
  blocking(kubeVersion: $kubeVersion)
}
    `;
export const RuntimeServiceDetailsFragmentDoc = gql`
    fragment RuntimeServiceDetails on RuntimeService {
  id
  name
  version
  addon {
    icon
    versions {
      ...AddonVersion
    }
    releaseUrl(version: $version)
    readme
  }
  addonVersion {
    ...AddonVersionBlocking @include(if: $hasKubeVersion)
    ...AddonVersion
  }
}
    ${AddonVersionFragmentDoc}
${AddonVersionBlockingFragmentDoc}`;
export const MetricResponseFragmentDoc = gql`
    fragment MetricResponse on MetricResponse {
  metric
  values {
    timestamp
    value
  }
}
    `;
export const ClusterNodeMetricsFragmentDoc = gql`
    fragment ClusterNodeMetrics on Cluster {
  id
  clusterNodeMetrics(node: $node, start: $start, stop: $stop, step: $step) {
    cpu {
      ...MetricResponse
    }
    cpuUsage {
      ...MetricResponse
    }
    memory {
      ...MetricResponse
    }
    memoryUsage {
      ...MetricResponse
    }
  }
}
    ${MetricResponseFragmentDoc}`;
export const ClusterUpgradePlanFragmentDoc = gql`
    fragment ClusterUpgradePlan on ClusterUpgradePlan {
  compatibilities
  deprecations
  incompatibilities
  kubeletSkew
}
    `;
export const ClustersRowFragmentDoc = gql`
    fragment ClustersRow on Cluster {
  currentVersion
  id
  self
  healthy
  healthScore
  protect
  name
  handle
  distro
  cpuTotal
  memoryTotal
  cpuUtil
  nodeCount
  namespaceCount
  availabilityZones
  podCount
  memoryUtil
  installed
  pingedAt
  deletedAt
  provider {
    id
    cloud
    name
    namespace
    supportedVersions
  }
  self
  service {
    id
    repository {
      url
    }
  }
  version
  kubeletVersion
  tags {
    name
    value
  }
  distro
  upgradePlan {
    ...ClusterUpgradePlan
  }
  virtual
  insight {
    ...AiInsightSummary
  }
}
    ${ClusterUpgradePlanFragmentDoc}
${AiInsightSummaryFragmentDoc}`;
export const ApiDeprecationFragmentDoc = gql`
    fragment ApiDeprecation on ApiDeprecation {
  availableIn
  blocking
  component {
    group
    version
    kind
    name
    namespace
    service {
      git {
        ref
        folder
      }
      repository {
        httpsPath
        urlFormat
      }
    }
  }
  deprecatedIn
  removedIn
  replacement
}
    `;
export const TaintFragmentDoc = gql`
    fragment Taint on Taint {
  effect
  key
  value
}
    `;
export const NodePoolFragmentDoc = gql`
    fragment NodePool on NodePool {
  id
  name
  minSize
  maxSize
  instanceType
  spot
  labels
  taints {
    ...Taint
  }
}
    ${TaintFragmentDoc}`;
export const ClusterFragmentDoc = gql`
    fragment Cluster on Cluster {
  ...ClustersRow
  apiDeprecations {
    ...ApiDeprecation
  }
  currentVersion
  id
  name
  handle
  metadata
  nodePools {
    ...NodePool
  }
  pingedAt
  provider {
    id
    cloud
    name
    namespace
    supportedVersions
  }
  self
  service {
    id
    name
    repository {
      url
    }
  }
  version
  tags {
    name
    value
  }
  parentCluster {
    ...ClustersRow
  }
  operationalLayout {
    serviceMesh
  }
  alerts(first: 500) {
    edges {
      node {
        id
      }
    }
  }
}
    ${ClustersRowFragmentDoc}
${ApiDeprecationFragmentDoc}
${NodePoolFragmentDoc}`;
export const MetadataFragmentDoc = gql`
    fragment Metadata on Metadata {
  uid
  name
  namespace
  labels {
    name
    value
  }
  annotations {
    name
    value
  }
  creationTimestamp
}
    `;
export const ClusterNodeFragmentDoc = gql`
    fragment ClusterNode on Node {
  metadata {
    ...Metadata
  }
  status {
    phase
    allocatable
    capacity
    conditions {
      type
      status
      message
    }
  }
  spec {
    podCidr
    providerId
  }
}
    ${MetadataFragmentDoc}`;
export const NodeMetricFragmentDoc = gql`
    fragment NodeMetric on NodeMetric {
  metadata {
    ...Metadata
  }
  usage {
    cpu
    memory
  }
  timestamp
  window
}
    ${MetadataFragmentDoc}`;
export const ClusterWithNodesFragmentDoc = gql`
    fragment ClusterWithNodes on Cluster {
  ...ClusterBasic
  nodes {
    ...ClusterNode
  }
  nodeMetrics {
    ...NodeMetric
  }
}
    ${ClusterBasicFragmentDoc}
${ClusterNodeFragmentDoc}
${NodeMetricFragmentDoc}`;
export const ClusterWithMetricsFragmentDoc = gql`
    fragment ClusterWithMetrics on Cluster {
  ...ClusterWithNodes
  clusterMetrics(start: $start, stop: $stop, step: $step) {
    cpu {
      ...MetricResponse
    }
    cpuUsage {
      ...MetricResponse
    }
    cpuRequests {
      ...MetricResponse
    }
    cpuLimits {
      ...MetricResponse
    }
    memory {
      ...MetricResponse
    }
    memoryUsage {
      ...MetricResponse
    }
    memoryRequests {
      ...MetricResponse
    }
    memoryLimits {
      ...MetricResponse
    }
    pods {
      ...MetricResponse
    }
  }
}
    ${ClusterWithNodesFragmentDoc}
${MetricResponseFragmentDoc}`;
export const ClusterBindingsFragmentDoc = gql`
    fragment ClusterBindings on Cluster {
  id
  readBindings {
    ...PolicyBinding
  }
  writeBindings {
    ...PolicyBinding
  }
}
    ${PolicyBindingFragmentDoc}`;
export const ClusterStatusInfoFragmentDoc = gql`
    fragment ClusterStatusInfo on ClusterStatusInfo {
  count
  healthy
}
    `;
export const NetworkMeshWorkloadFragmentDoc = gql`
    fragment NetworkMeshWorkload on NetworkMeshWorkload {
  id
  name
  namespace
  service
}
    `;
export const NetworkMeshStatisticsFragmentDoc = gql`
    fragment NetworkMeshStatistics on NetworkMeshStatistics {
  bytes
  packets
  connections
  http200
  http400
  http500
  httpClientLatency
}
    `;
export const NetworkMeshEdgeFragmentDoc = gql`
    fragment NetworkMeshEdge on NetworkMeshEdge {
  id
  from {
    ...NetworkMeshWorkload
  }
  to {
    ...NetworkMeshWorkload
  }
  statistics {
    ...NetworkMeshStatistics
  }
}
    ${NetworkMeshWorkloadFragmentDoc}
${NetworkMeshStatisticsFragmentDoc}`;
export const ComponentMetricsFragmentFragmentDoc = gql`
    fragment ComponentMetricsFragment on ServiceDeployment {
  componentMetrics(
    componentId: $componentId
    start: $start
    stop: $stop
    step: $step
  ) {
    cpu {
      ...MetricResponse
    }
    mem {
      ...MetricResponse
    }
    podCpu {
      ...MetricResponse
    }
    podMem {
      ...MetricResponse
    }
  }
}
    ${MetricResponseFragmentDoc}`;
export const HelmRepositoryFragmentDoc = gql`
    fragment HelmRepository on HelmRepository {
  id
  url
  health
  provider
  insertedAt
  pulledAt
  updatedAt
}
    `;
export const FluxHelmRepositoryFragmentDoc = gql`
    fragment FluxHelmRepository on FluxHelmRepository {
  metadata {
    namespace
    name
  }
  spec {
    url
    type
    provider
  }
  status {
    ready
    message
  }
}
    `;
export const HelmChartVersionFragmentDoc = gql`
    fragment HelmChartVersion on HelmChartVersion {
  name
  appVersion
  version
  digest
}
    `;
export const ProjectTinyFragmentDoc = gql`
    fragment ProjectTiny on Project {
  id
  name
  default
  description
}
    `;
export const ServiceDeploymentsRowFragmentDoc = gql`
    fragment ServiceDeploymentsRow on ServiceDeployment {
  id
  name
  protect
  promotion
  message
  git {
    ref
    folder
  }
  helm {
    chart
    version
    url
    repository {
      namespace
      name
    }
  }
  cluster {
    ...ClusterMinimal
  }
  helmRepository {
    spec {
      url
    }
    status {
      ready
      message
    }
  }
  repository {
    id
    url
  }
  insertedAt
  updatedAt
  deletedAt
  componentStatus
  status
  errors {
    message
    source
    warning
  }
  globalService {
    id
    name
  }
  dryRun
  insight {
    ...AiInsightSummary
  }
}
    ${ClusterMinimalFragmentDoc}
${AiInsightSummaryFragmentDoc}`;
export const GitRepositoryFragmentDoc = gql`
    fragment GitRepository on GitRepository {
  id
  url
  health
  authMethod
  editable
  error
  insertedAt
  pulledAt
  updatedAt
  urlFormat
  httpsPath
}
    `;
export const ServiceTemplateWithoutConfigurationFragmentDoc = gql`
    fragment ServiceTemplateWithoutConfiguration on ServiceTemplate {
  contexts
  dependencies {
    id
    name
    status
  }
  git {
    folder
    ref
  }
  helm {
    chart
    git {
      folder
      ref
    }
    ignoreCrds
    ignoreHooks
    release
    repository {
      name
      namespace
    }
    set {
      name
      value
    }
    url
    values
    valuesFiles
    version
  }
  kustomize {
    path
    enableHelm
  }
  name
  namespace
  repository {
    ...GitRepository
  }
  repositoryId
  syncConfig {
    createNamespace
    enforceNamespace
    namespaceMetadata {
      annotations
      labels
    }
  }
  templated
}
    ${GitRepositoryFragmentDoc}`;
export const GlobalServiceFragmentDoc = gql`
    fragment GlobalService on GlobalService {
  id
  distro
  name
  project {
    ...ProjectTiny
  }
  cascade {
    delete
    detach
  }
  provider {
    id
    name
    cloud
    namespace
  }
  reparent
  service {
    ...ServiceDeploymentsRow
  }
  tags {
    name
    value
  }
  template {
    ...ServiceTemplateWithoutConfiguration
  }
  parent {
    id
    name
  }
  insertedAt
  updatedAt
  mgmt
}
    ${ProjectTinyFragmentDoc}
${ServiceDeploymentsRowFragmentDoc}
${ServiceTemplateWithoutConfigurationFragmentDoc}`;
export const HttpConnectionFragmentDoc = gql`
    fragment HttpConnection on HttpConnection {
  host
  user
}
    `;
export const SmtpSettingsFragmentDoc = gql`
    fragment SmtpSettings on SmtpSettings {
  server
  port
  sender
  user
  ssl
}
    `;
export const AiSettingsFragmentDoc = gql`
    fragment AiSettings on AiSettings {
  anthropic {
    model
  }
  openai {
    model
    embeddingModel
  }
  azure {
    apiVersion
    endpoint
    model
    embeddingModel
  }
  ollama {
    model
    url
  }
  bedrock {
    region
    modelId
    embeddingModel
  }
  vertex {
    model
    embeddingModel
    project
    location
  }
  enabled
  toolsEnabled
  provider
}
    `;
export const DeploymentSettingsFragmentDoc = gql`
    fragment DeploymentSettings on DeploymentSettings {
  id
  name
  enabled
  selfManaged
  insertedAt
  updatedAt
  onboarded
  agentHelmValues
  logging {
    enabled
    driver
  }
  lokiConnection {
    ...HttpConnection
  }
  prometheusConnection {
    ...HttpConnection
  }
  artifactRepository {
    ...GitRepository
  }
  deployerRepository {
    ...GitRepository
  }
  createBindings {
    ...PolicyBinding
  }
  smtp {
    ...SmtpSettings
  }
  ai {
    ...AiSettings
  }
  readBindings {
    ...PolicyBinding
  }
  writeBindings {
    ...PolicyBinding
  }
  gitBindings {
    ...PolicyBinding
  }
}
    ${HttpConnectionFragmentDoc}
${GitRepositoryFragmentDoc}
${PolicyBindingFragmentDoc}
${SmtpSettingsFragmentDoc}
${AiSettingsFragmentDoc}`;
export const ObservabilityProviderFragmentDoc = gql`
    fragment ObservabilityProvider on ObservabilityProvider {
  id
  name
  type
  insertedAt
  updatedAt
}
    `;
export const ObservabilityWebhookFragmentDoc = gql`
    fragment ObservabilityWebhook on ObservabilityWebhook {
  id
  name
  type
  url
  insertedAt
  updatedAt
}
    `;
export const ManagedNamespaceFragmentDoc = gql`
    fragment ManagedNamespace on ManagedNamespace {
  id
  name
  insertedAt
  updatedAt
  deletedAt
  description
  labels
  annotations
  pullSecrets
  cascade {
    delete
    detach
  }
  target {
    distro
    tags
  }
  project {
    ...ProjectTiny
  }
  service {
    ...ServiceTemplateWithoutConfiguration
  }
}
    ${ProjectTinyFragmentDoc}
${ServiceTemplateWithoutConfigurationFragmentDoc}`;
export const ServiceTemplateFragmentDoc = gql`
    fragment ServiceTemplate on ServiceTemplate {
  configuration {
    name
    value
  }
  contexts
  git {
    folder
    ref
  }
  helm {
    chart
    repository {
      name
      namespace
    }
    set {
      name
      value
    }
    valuesFiles
    version
  }
  kustomize {
    path
  }
  name
  namespace
  repository {
    ...GitRepository
  }
  repositoryId
  syncConfig {
    createNamespace
    namespaceMetadata {
      annotations
      labels
    }
  }
  templated
}
    ${GitRepositoryFragmentDoc}`;
export const ObserverTargetFragmentDoc = gql`
    fragment ObserverTarget on ObserverTarget {
  target
  format
  order
  git {
    type
    repositoryId
  }
  helm {
    url
    provider
    chart
  }
  oci {
    provider
    url
  }
}
    `;
export const ServiceErrorFragmentDoc = gql`
    fragment ServiceError on ServiceError {
  source
  message
  warning
}
    `;
export const ObserverFragmentDoc = gql`
    fragment Observer on Observer {
  id
  insertedAt
  updatedAt
  name
  crontab
  status
  lastRunAt
  nextRunAt
  lastValue
  project {
    ...ProjectTiny
  }
  target {
    ...ObserverTarget
  }
  errors {
    ...ServiceError
  }
}
    ${ProjectTinyFragmentDoc}
${ObserverTargetFragmentDoc}
${ServiceErrorFragmentDoc}`;
export const ContainerSpecFragmentDoc = gql`
    fragment ContainerSpec on ContainerSpec {
  args
  env {
    name
    value
  }
  envFrom {
    configMap
    secret
  }
  image
}
    `;
export const JobGateSpecFragmentDoc = gql`
    fragment JobGateSpec on JobGateSpec {
  annotations
  containers {
    ...ContainerSpec
  }
  labels
  namespace
  raw
  serviceAccount
}
    ${ContainerSpecFragmentDoc}`;
export const PipelineGateFragmentDoc = gql`
    fragment PipelineGate on PipelineGate {
  id
  name
  state
  type
  cluster {
    id
  }
  approver {
    ...User
  }
  edge {
    pipeline {
      id
      name
    }
  }
  spec {
    job {
      ...JobGateSpec
    }
  }
  insertedAt
  updatedAt
}
    ${UserFragmentDoc}
${JobGateSpecFragmentDoc}`;
export const RevisionFragmentDoc = gql`
    fragment Revision on Revision {
  id
  git {
    ref
    folder
  }
  insertedAt
  updatedAt
  message
  sha
  version
}
    `;
export const PipelineServiceDeploymentFragmentDoc = gql`
    fragment PipelineServiceDeployment on ServiceDeployment {
  id
  name
  namespace
  cluster {
    id
    name
  }
  status
  componentStatus
  revision {
    id
  }
}
    `;
export const PromotionServiceFragmentDoc = gql`
    fragment PromotionService on PromotionService {
  id
  revision {
    ...Revision
  }
  service {
    ...PipelineServiceDeployment
  }
  insertedAt
  updatedAt
}
    ${RevisionFragmentDoc}
${PipelineServiceDeploymentFragmentDoc}`;
export const PipelinePromotionFragmentDoc = gql`
    fragment PipelinePromotion on PipelinePromotion {
  id
  services {
    ...PromotionService
  }
  insertedAt
  updatedAt
  promotedAt
  revisedAt
}
    ${PromotionServiceFragmentDoc}`;
export const PromotionCriteriaFragmentDoc = gql`
    fragment PromotionCriteria on PromotionCriteria {
  id
  secrets
  source {
    ...PipelineServiceDeployment
  }
  insertedAt
  updatedAt
}
    ${PipelineServiceDeploymentFragmentDoc}`;
export const StageServiceFragmentDoc = gql`
    fragment StageService on StageService {
  id
  criteria {
    ...PromotionCriteria
  }
  insertedAt
  updatedAt
  service {
    ...PipelineServiceDeployment
  }
}
    ${PromotionCriteriaFragmentDoc}
${PipelineServiceDeploymentFragmentDoc}`;
export const PipelinePullRequestFragmentDoc = gql`
    fragment PipelinePullRequest on PipelinePullRequest {
  id
  service {
    id
    name
    protect
    deletedAt
  }
  stage {
    id
  }
  pullRequest {
    ...PullRequest
  }
}
    ${PullRequestFragmentDoc}`;
export const PipelineContextFragmentDoc = gql`
    fragment PipelineContext on PipelineContext {
  id
  context
  insertedAt
  updatedAt
  pullRequests {
    ...PullRequest
  }
  pipelinePullRequests {
    ...PipelinePullRequest
  }
}
    ${PullRequestFragmentDoc}
${PipelinePullRequestFragmentDoc}`;
export const PipelineStageFragmentDoc = gql`
    fragment PipelineStage on PipelineStage {
  id
  name
  insertedAt
  updatedAt
  promotion {
    ...PipelinePromotion
  }
  services {
    ...StageService
  }
  context {
    ...PipelineContext
  }
  errors {
    message
    source
  }
}
    ${PipelinePromotionFragmentDoc}
${StageServiceFragmentDoc}
${PipelineContextFragmentDoc}`;
export const PipelineStageEdgeFragmentDoc = gql`
    fragment PipelineStageEdge on PipelineStageEdge {
  id
  insertedAt
  promotedAt
  updatedAt
  gates {
    ...PipelineGate
  }
  from {
    ...PipelineStage
  }
  to {
    ...PipelineStage
  }
}
    ${PipelineGateFragmentDoc}
${PipelineStageFragmentDoc}`;
export const PipelineStatusFragmentDoc = gql`
    fragment PipelineStatus on PipelineStatus {
  closed
  pending
  running
}
    `;
export const PipelineFragmentDoc = gql`
    fragment Pipeline on Pipeline {
  id
  name
  insertedAt
  updatedAt
  edges {
    ...PipelineStageEdge
  }
  stages {
    ...PipelineStage
  }
  status {
    ...PipelineStatus
  }
}
    ${PipelineStageEdgeFragmentDoc}
${PipelineStageFragmentDoc}
${PipelineStatusFragmentDoc}`;
export const PipelineConnectionFragmentDoc = gql`
    fragment PipelineConnection on PipelineConnection {
  edges {
    node {
      ...Pipeline
    }
  }
  pageInfo {
    ...PageInfo
  }
}
    ${PipelineFragmentDoc}
${PageInfoFragmentDoc}`;
export const PipelineBindingsFragmentDoc = gql`
    fragment PipelineBindings on Pipeline {
  readBindings {
    ...PolicyBinding
  }
  writeBindings {
    ...PolicyBinding
  }
}
    ${PolicyBindingFragmentDoc}`;
export const ContainerStatusFragmentDoc = gql`
    fragment ContainerStatus on ContainerStatus {
  restartCount
  ready
  name
  state {
    running {
      startedAt
    }
    terminated {
      exitCode
      message
      reason
    }
    waiting {
      message
      reason
    }
  }
}
    `;
export const ResourceSpecFragmentDoc = gql`
    fragment ResourceSpec on ResourceSpec {
  cpu
  memory
}
    `;
export const ResourcesFragmentDoc = gql`
    fragment Resources on Resources {
  limits {
    ...ResourceSpec
  }
  requests {
    ...ResourceSpec
  }
}
    ${ResourceSpecFragmentDoc}`;
export const ContainerFragmentDoc = gql`
    fragment Container on Container {
  name
  image
  ports {
    containerPort
    protocol
  }
  resources {
    ...Resources
  }
}
    ${ResourcesFragmentDoc}`;
export const PodFragmentDoc = gql`
    fragment Pod on Pod {
  metadata {
    ...Metadata
  }
  status {
    phase
    podIp
    reason
    containerStatuses {
      ...ContainerStatus
    }
    initContainerStatuses {
      ...ContainerStatus
    }
    conditions {
      lastProbeTime
      lastTransitionTime
      message
      reason
      status
      type
    }
  }
  spec {
    nodeName
    serviceAccountName
    containers {
      ...Container
    }
    initContainers {
      ...Container
    }
  }
  raw
}
    ${MetadataFragmentDoc}
${ContainerStatusFragmentDoc}
${ContainerFragmentDoc}`;
export const PipelineGateJobFragmentDoc = gql`
    fragment PipelineGateJob on Job {
  events {
    action
    count
    eventTime
    lastTimestamp
    message
    reason
    type
  }
  metadata {
    ...Metadata
  }
  pods {
    ...Pod
  }
  raw
  spec {
    activeDeadlineSeconds
    backoffLimit
    parallelism
  }
  status {
    active
    completionTime
    failed
    startTime
    succeeded
  }
}
    ${MetadataFragmentDoc}
${PodFragmentDoc}`;
export const ProviderCredentialFragmentDoc = gql`
    fragment ProviderCredential on ProviderCredential {
  id
  insertedAt
  kind
  name
  namespace
  updatedAt
}
    `;
export const ClusterProviderFragmentDoc = gql`
    fragment ClusterProvider on ClusterProvider {
  id
  name
  namespace
  cloud
  editable
  git {
    folder
    ref
  }
  repository {
    id
    url
  }
  service {
    id
    name
    namespace
  }
  credentials {
    ...ProviderCredential
  }
  supportedVersions
  deletedAt
  insertedAt
  updatedAt
}
    ${ProviderCredentialFragmentDoc}`;
export const PullRequestConnectionFragmentDoc = gql`
    fragment PullRequestConnection on PullRequestConnection {
  pageInfo {
    ...PageInfo
  }
  edges {
    node {
      ...PullRequest
    }
  }
}
    ${PageInfoFragmentDoc}
${PullRequestFragmentDoc}`;
export const ServiceDeploymentComponentFragmentDoc = gql`
    fragment ServiceDeploymentComponent on ServiceComponent {
  id
  uid
  name
  group
  kind
  namespace
  state
  synced
  version
  apiDeprecations {
    ...ApiDeprecation
  }
  content {
    desired
    live
  }
  insight {
    ...AiInsight
  }
}
    ${ApiDeprecationFragmentDoc}
${AiInsightFragmentDoc}`;
export const ServiceComponentChildFragmentDoc = gql`
    fragment ServiceComponentChild on ServiceComponentChild {
  id
  group
  kind
  version
  name
  namespace
  parentUid
  uid
  state
  insertedAt
  updatedAt
  insight {
    ...AiInsight
  }
}
    ${AiInsightFragmentDoc}`;
export const ServiceDeploymentComponentWithChildrenFragmentDoc = gql`
    fragment ServiceDeploymentComponentWithChildren on ServiceComponent {
  ...ServiceDeploymentComponent
  children {
    ...ServiceComponentChild
  }
}
    ${ServiceDeploymentComponentFragmentDoc}
${ServiceComponentChildFragmentDoc}`;
export const ServiceDeploymentRevisionFragmentDoc = gql`
    fragment ServiceDeploymentRevision on Revision {
  id
  sha
  version
  message
  updatedAt
  insertedAt
  helm {
    chart
    version
  }
  git {
    folder
    ref
  }
}
    `;
export const ServiceDeploymentRevisionsFragmentDoc = gql`
    fragment ServiceDeploymentRevisions on ServiceDeployment {
  revision {
    ...ServiceDeploymentRevision
  }
  revisions(first: 500) {
    edges {
      node {
        ...ServiceDeploymentRevision
      }
    }
  }
}
    ${ServiceDeploymentRevisionFragmentDoc}`;
export const ServiceTreeNodeFragmentDoc = gql`
    fragment ServiceTreeNode on ServiceDeployment {
  id
  name
  namespace
  updatedAt
  status
  componentStatus
  components {
    ...ServiceDeploymentComponent
  }
  cluster {
    id
    name
  }
  repository {
    url
    pulledAt
  }
  git {
    ref
    folder
  }
  helmRepository {
    spec {
      url
    }
  }
  parent {
    id
    name
  }
  owner {
    id
    name
  }
  errors {
    source
    message
  }
}
    ${ServiceDeploymentComponentFragmentDoc}`;
export const ServiceDeploymentsConnectionFragmentDoc = gql`
    fragment ServiceDeploymentsConnection on ServiceDeploymentConnection {
  pageInfo {
    ...PageInfo
  }
  edges {
    node {
      ...ServiceDeploymentsRow
    }
  }
}
    ${PageInfoFragmentDoc}
${ServiceDeploymentsRowFragmentDoc}`;
export const ServiceDeploymentBindingsFragmentDoc = gql`
    fragment ServiceDeploymentBindings on ServiceDeployment {
  readBindings {
    ...PolicyBinding
  }
  writeBindings {
    ...PolicyBinding
  }
}
    ${PolicyBindingFragmentDoc}`;
export const ServiceStatusCountFragmentDoc = gql`
    fragment ServiceStatusCount on ServiceStatusCount {
  count
  status
}
    `;
export const ComponentTreeFragmentDoc = gql`
    fragment ComponentTree on ComponentTree {
  root {
    metadata {
      ...Metadata
    }
    raw
  }
  edges {
    from
    to
  }
  certificates {
    metadata {
      ...Metadata
    }
    raw
  }
  configmaps {
    metadata {
      ...Metadata
    }
    raw
  }
  cronjobs {
    metadata {
      ...Metadata
    }
    raw
  }
  daemonsets {
    metadata {
      ...Metadata
    }
    raw
  }
  deployments {
    metadata {
      ...Metadata
    }
    raw
  }
  ingresses {
    metadata {
      ...Metadata
    }
    raw
  }
  secrets {
    metadata {
      ...Metadata
    }
  }
  services {
    metadata {
      ...Metadata
    }
    raw
  }
  statefulsets {
    metadata {
      ...Metadata
    }
    raw
  }
}
    ${MetadataFragmentDoc}`;
export const ClusterUsageTinyFragmentDoc = gql`
    fragment ClusterUsageTiny on ClusterUsage {
  id
  cpu
  memory
  gpu
  storage
  cpuUtil
  memUtil
  cpuCost
  memoryCost
  storageCost
  nodeCost
  controlPlaneCost
  ingressCost
  loadBalancerCost
  egressCost
  cluster {
    ...ClusterTiny
    project {
      id
      name
    }
  }
}
    ${ClusterTinyFragmentDoc}`;
export const ClusterUsageHistoryFragmentDoc = gql`
    fragment ClusterUsageHistory on ClusterUsageHistory {
  id
  timestamp
  cpuCost
  memoryCost
  storageCost
}
    `;
export const ProjectUsageHistoryFragmentDoc = gql`
    fragment ProjectUsageHistory on ProjectUsageHistory {
  timestamp
  cpu
  memory
  gpu
  storageCost
  projectId
}
    `;
export const ClusterNamespaceUsageFragmentDoc = gql`
    fragment ClusterNamespaceUsage on ClusterNamespaceUsage {
  id
  namespace
  storage
  cpuCost
  cpuUtil
  cpu
  memoryCost
  memUtil
  memory
  ingressCost
  loadBalancerCost
  egressCost
  storageCost
}
    `;
export const TagFragmentDoc = gql`
    fragment Tag on Tag {
  name
  value
}
    `;
export const UserTinyFragmentDoc = gql`
    fragment UserTiny on User {
  name
  email
  profile
}
    `;
export const ClusterRegistrationFragmentDoc = gql`
    fragment ClusterRegistration on ClusterRegistration {
  id
  insertedAt
  updatedAt
  machineId
  name
  handle
  metadata
  tags {
    ...Tag
  }
  creator {
    ...UserTiny
  }
  project {
    ...ProjectTiny
  }
}
    ${TagFragmentDoc}
${UserTinyFragmentDoc}
${ProjectTinyFragmentDoc}`;
export const IsoImageFragmentDoc = gql`
    fragment IsoImage on ClusterIsoImage {
  id
  user
  password
  registry
  image
  insertedAt
  project {
    name
  }
}
    `;
export const FlowBasicFragmentDoc = gql`
    fragment FlowBasic on Flow {
  id
  name
  description
  icon
  alerts(first: 500) {
    edges {
      node {
        id
      }
    }
  }
}
    `;
export const FlowBasicWithBindingsFragmentDoc = gql`
    fragment FlowBasicWithBindings on Flow {
  ...FlowBasic
  readBindings {
    ...PolicyBinding
  }
  writeBindings {
    ...PolicyBinding
  }
}
    ${FlowBasicFragmentDoc}
${PolicyBindingFragmentDoc}`;
export const PreviewEnvironmentInstanceFragmentDoc = gql`
    fragment PreviewEnvironmentInstance on PreviewEnvironmentInstance {
  id
  pullRequest {
    url
  }
  service {
    ...ServiceDeploymentTiny
    protect
    deletedAt
  }
  template {
    id
    name
  }
  updatedAt
  insertedAt
}
    ${ServiceDeploymentTinyFragmentDoc}`;
export const PreviewEnvironmentInstanceConnectionFragmentDoc = gql`
    fragment PreviewEnvironmentInstanceConnection on PreviewEnvironmentInstanceConnection {
  pageInfo {
    ...PageInfo
  }
  edges {
    node {
      ...PreviewEnvironmentInstance
    }
  }
}
    ${PageInfoFragmentDoc}
${PreviewEnvironmentInstanceFragmentDoc}`;
export const PreviewEnvironmentTemplateFragmentDoc = gql`
    fragment PreviewEnvironmentTemplate on PreviewEnvironmentTemplate {
  id
  name
  commentTemplate
  referenceService {
    id
    name
    cluster {
      id
    }
  }
  template {
    ...ServiceTemplateWithoutConfiguration
  }
}
    ${ServiceTemplateWithoutConfigurationFragmentDoc}`;
export const PreviewEnvironmentTemplateConnectionFragmentDoc = gql`
    fragment PreviewEnvironmentTemplateConnection on PreviewEnvironmentTemplateConnection {
  pageInfo {
    ...PageInfo
  }
  edges {
    node {
      ...PreviewEnvironmentTemplate
    }
  }
}
    ${PageInfoFragmentDoc}
${PreviewEnvironmentTemplateFragmentDoc}`;
export const GroupFragmentDoc = gql`
    fragment Group on Group {
  id
  name
  description
  global
  insertedAt
  updatedAt
}
    `;
export const GroupMemberFragmentDoc = gql`
    fragment GroupMember on GroupMember {
  user {
    ...User
  }
  group {
    ...Group
  }
}
    ${UserFragmentDoc}
${GroupFragmentDoc}`;
export const UpgradeStatisticsFragmentDoc = gql`
    fragment UpgradeStatistics on UpgradeStatistics {
  upgradeable
  count
  latest
  compliant
}
    `;
export const RuntimeServiceFragmentDoc = gql`
    fragment RuntimeService on RuntimeService {
  id
  name
  version
  addon {
    icon
    versions {
      ...AddonVersion
    }
  }
  service {
    git {
      ref
      folder
    }
    repository {
      httpsPath
      urlFormat
    }
    helm {
      version
    }
  }
  addonVersion {
    ...AddonVersionBlocking @include(if: $hasKubeVersion)
    ...AddonVersion
  }
}
    ${AddonVersionFragmentDoc}
${AddonVersionBlockingFragmentDoc}`;
export const InsightClientInfoFragmentDoc = gql`
    fragment InsightClientInfo on InsightClientInfo {
  userAgent
  count
  lastRequestAt
}
    `;
export const UpgradeInsightDetailFragmentDoc = gql`
    fragment UpgradeInsightDetail on UpgradeInsightDetail {
  id
  removedIn
  replacedIn
  replacement
  status
  used
  clientInfo {
    ...InsightClientInfo
  }
}
    ${InsightClientInfoFragmentDoc}`;
export const UpgradeInsightFragmentDoc = gql`
    fragment UpgradeInsight on UpgradeInsight {
  id
  name
  description
  details {
    ...UpgradeInsightDetail
  }
  refreshedAt
  transitionedAt
  version
  status
}
    ${UpgradeInsightDetailFragmentDoc}`;
export const CloudAddonVersionInformationFragmentDoc = gql`
    fragment CloudAddonVersionInformation on CloudAddonVersionInformation {
  blocking(kubeVersion: $kubeVersion)
}
    `;
export const CloudAddonFragmentDoc = gql`
    fragment CloudAddon on CloudAddon {
  id
  insertedAt
  updatedAt
  name
  distro
  info {
    name
    publisher
    versions {
      version
      compatibilities
      ...CloudAddonVersionInformation @include(if: $hasKubeVersion)
    }
  }
  version
  versionInfo {
    version
    compatibilities
    ...CloudAddonVersionInformation @include(if: $hasKubeVersion)
  }
}
    ${CloudAddonVersionInformationFragmentDoc}`;
export const ClusterRuntimeServicesFragmentDoc = gql`
    fragment ClusterRuntimeServices on Cluster {
  id
  name
  currentVersion
  version
  runtimeServices {
    ...RuntimeService
  }
  apiDeprecations {
    ...ApiDeprecation
  }
  upgradeInsights {
    ...UpgradeInsight
  }
  cloudAddons {
    ...CloudAddon
  }
}
    ${RuntimeServiceFragmentDoc}
${ApiDeprecationFragmentDoc}
${UpgradeInsightFragmentDoc}
${CloudAddonFragmentDoc}`;
export const ClusterUpgradeDeprecatedCustomResourceFragmentDoc = gql`
    fragment ClusterUpgradeDeprecatedCustomResource on DeprecatedCustomResource {
  name
  group
  kind
  namespace
  version
  nextVersion
}
    `;
export const ClusterUpgradeFragmentDoc = gql`
    fragment ClusterUpgrade on Cluster {
  ...ClusterRuntimeServices
  prAutomations {
    id
  }
  deprecatedCustomResources {
    ...ClusterUpgradeDeprecatedCustomResource
  }
}
    ${ClusterRuntimeServicesFragmentDoc}
${ClusterUpgradeDeprecatedCustomResourceFragmentDoc}`;
export const ClusterInsightFragmentDoc = gql`
    fragment ClusterInsight on Cluster {
  id
  insight {
    ...AiInsight
  }
  insightComponents {
    ...ClusterInsightComponent
  }
}
    ${AiInsightFragmentDoc}
${ClusterInsightComponentFragmentDoc}`;
export const NodeStatisticFragmentDoc = gql`
    fragment NodeStatistic on NodeStatistic {
  id
  name
  pendingPods
  health
  cluster {
    id
  }
  insertedAt
  updatedAt
}
    `;
export const ClusterOverviewDetailsFragmentDoc = gql`
    fragment ClusterOverviewDetails on Cluster {
  ...ClustersRow
  ...ClusterUpgrade
  ...ClusterInsight
  nodeStatistics {
    ...NodeStatistic
  }
}
    ${ClustersRowFragmentDoc}
${ClusterUpgradeFragmentDoc}
${ClusterInsightFragmentDoc}
${NodeStatisticFragmentDoc}`;
export const ClusterHealthScoreFragmentDoc = gql`
    fragment ClusterHealthScore on Cluster {
  id
  name
  healthScore
}
    `;
export const PinnedCustomResourceFragmentDoc = gql`
    fragment PinnedCustomResource on PinnedCustomResource {
  id
  name
  kind
  version
  group
  cluster {
    ...ClusterTiny
  }
  displayName
  namespaced
}
    ${ClusterTinyFragmentDoc}`;
export const KubernetesClusterFragmentDoc = gql`
    fragment KubernetesCluster on Cluster {
  ...ClusterTiny
  project {
    ...ProjectTiny
  }
  pinnedCustomResources {
    ...PinnedCustomResource
  }
}
    ${ClusterTinyFragmentDoc}
${ProjectTinyFragmentDoc}
${PinnedCustomResourceFragmentDoc}`;
export const ArgoRolloutStatusFragmentDoc = gql`
    fragment ArgoRolloutStatus on ArgoRolloutStatus {
  abort
  phase
  replicas
  readyReplicas
  pauseConditions {
    reason
    startTime
  }
  conditions {
    message
    reason
    status
    type
  }
}
    `;
export const ArgoRolloutSpecFragmentDoc = gql`
    fragment ArgoRolloutSpec on ArgoRolloutSpec {
  replicas
  strategy {
    blueGreen {
      activeService
      autoPromotionEnabled
      autoPromotionSeconds
    }
    canary {
      steps {
        analysis {
          templates {
            templateName
          }
        }
        experiment {
          templates {
            name
          }
        }
        pause {
          duration
        }
        setWeight
      }
    }
  }
}
    `;
export const EventFragmentDoc = gql`
    fragment Event on Event {
  action
  lastTimestamp
  count
  message
  reason
  type
}
    `;
export const ArgoRolloutFragmentDoc = gql`
    fragment ArgoRollout on ArgoRollout {
  metadata {
    ...Metadata
  }
  status {
    ...ArgoRolloutStatus
  }
  spec {
    ...ArgoRolloutSpec
  }
  raw
  events {
    ...Event
  }
  pods {
    ...Pod
  }
}
    ${MetadataFragmentDoc}
${ArgoRolloutStatusFragmentDoc}
${ArgoRolloutSpecFragmentDoc}
${EventFragmentDoc}
${PodFragmentDoc}`;
export const StatusConditionFragmentDoc = gql`
    fragment StatusCondition on StatusCondition {
  message
  reason
  status
  type
}
    `;
export const CanaryStatusFragmentDoc = gql`
    fragment CanaryStatus on CanaryStatus {
  failedChecks
  canaryWeight
  iterations
  phase
  conditions {
    ...StatusCondition
  }
}
    ${StatusConditionFragmentDoc}`;
export const CanarySpecFragmentDoc = gql`
    fragment CanarySpec on CanarySpec {
  provider
  analysis {
    interval
    maxWeight
    stepWeight
    stepWeights
    threshold
  }
}
    `;
export const DeploymentFragmentDoc = gql`
    fragment Deployment on Deployment {
  metadata {
    ...Metadata
  }
  status {
    availableReplicas
    replicas
    unavailableReplicas
    conditions {
      ...StatusCondition
    }
  }
  spec {
    replicas
    strategy {
      type
    }
  }
  raw
  pods {
    ...Pod
  }
  events {
    ...Event
  }
}
    ${MetadataFragmentDoc}
${StatusConditionFragmentDoc}
${PodFragmentDoc}
${EventFragmentDoc}`;
export const CertificateStatusFragmentDoc = gql`
    fragment CertificateStatus on CertificateStatus {
  renewalTime
  notBefore
  notAfter
  conditions {
    ...StatusCondition
  }
}
    ${StatusConditionFragmentDoc}`;
export const CertificateSpecFragmentDoc = gql`
    fragment CertificateSpec on CertificateSpec {
  dnsNames
  secretName
  issuerRef {
    group
    kind
    name
  }
}
    `;
export const CertificateFragmentDoc = gql`
    fragment Certificate on Certificate {
  metadata {
    ...Metadata
  }
  status {
    ...CertificateStatus
  }
  spec {
    ...CertificateSpec
  }
  raw
  events {
    ...Event
  }
}
    ${MetadataFragmentDoc}
${CertificateStatusFragmentDoc}
${CertificateSpecFragmentDoc}
${EventFragmentDoc}`;
export const IngressFragmentDoc = gql`
    fragment Ingress on Ingress {
  metadata {
    ...Metadata
  }
  status {
    loadBalancer {
      ingress {
        ip
        hostname
      }
    }
  }
  spec {
    ingressClassName
    tls {
      hosts
    }
    rules {
      host
      http {
        paths {
          path
          backend {
            serviceName
            servicePort
          }
        }
      }
    }
  }
  certificates {
    ...Certificate
  }
  raw
  events {
    ...Event
  }
}
    ${MetadataFragmentDoc}
${CertificateFragmentDoc}
${EventFragmentDoc}`;
export const CanaryFragmentDoc = gql`
    fragment Canary on Canary {
  metadata {
    ...Metadata
  }
  status {
    ...CanaryStatus
  }
  spec {
    ...CanarySpec
  }
  raw
  canaryDeployment {
    ...Deployment
  }
  primaryDeployment {
    ...Deployment
  }
  ingress {
    ...Ingress
  }
  ingressCanary {
    ...Ingress
  }
  events {
    ...Event
  }
}
    ${MetadataFragmentDoc}
${CanaryStatusFragmentDoc}
${CanarySpecFragmentDoc}
${DeploymentFragmentDoc}
${IngressFragmentDoc}
${EventFragmentDoc}`;
export const JobStatusFragmentDoc = gql`
    fragment JobStatus on JobStatus {
  active
  completionTime
  succeeded
  failed
  startTime
}
    `;
export const CronJobJobFragmentDoc = gql`
    fragment CronJobJob on Job {
  metadata {
    name
    namespace
  }
  status {
    ...JobStatus
  }
}
    ${JobStatusFragmentDoc}`;
export const CronJobFragmentDoc = gql`
    fragment CronJob on CronJob {
  metadata {
    ...Metadata
  }
  status {
    lastScheduleTime
  }
  spec {
    schedule
    suspend
    concurrencyPolicy
  }
  raw
  events {
    ...Event
  }
  jobs {
    ...CronJobJob
  }
}
    ${MetadataFragmentDoc}
${EventFragmentDoc}
${CronJobJobFragmentDoc}`;
export const DaemonSetStatusFragmentDoc = gql`
    fragment DaemonSetStatus on DaemonSetStatus {
  currentNumberScheduled
  desiredNumberScheduled
  numberReady
}
    `;
export const DaemonSetSpecFragmentDoc = gql`
    fragment DaemonSetSpec on DaemonSetSpec {
  strategy {
    type
  }
}
    `;
export const DaemonSetFragmentDoc = gql`
    fragment DaemonSet on DaemonSet {
  metadata {
    ...Metadata
  }
  status {
    ...DaemonSetStatus
  }
  spec {
    ...DaemonSetSpec
  }
  pods {
    ...Pod
  }
  raw
  events {
    ...Event
  }
}
    ${MetadataFragmentDoc}
${DaemonSetStatusFragmentDoc}
${DaemonSetSpecFragmentDoc}
${PodFragmentDoc}
${EventFragmentDoc}`;
export const JobFragmentDoc = gql`
    fragment Job on Job {
  metadata {
    ...Metadata
  }
  status {
    ...JobStatus
  }
  spec {
    backoffLimit
    parallelism
    activeDeadlineSeconds
  }
  pods {
    ...Pod
  }
  raw
  events {
    ...Event
  }
}
    ${MetadataFragmentDoc}
${JobStatusFragmentDoc}
${PodFragmentDoc}
${EventFragmentDoc}`;
export const NodeFragmentDoc = gql`
    fragment Node on Node {
  metadata {
    ...Metadata
  }
  status {
    phase
    allocatable
    capacity
    conditions {
      type
      status
      message
    }
  }
  spec {
    podCidr
    providerId
  }
  raw
  pods {
    ...Pod
  }
  events {
    ...Event
  }
}
    ${MetadataFragmentDoc}
${PodFragmentDoc}
${EventFragmentDoc}`;
export const ServiceContextFragmentDoc = gql`
    fragment ServiceContext on ServiceContext {
  id
  configuration
  name
  project {
    id
    name
  }
  secrets {
    name
    value
  }
  insertedAt
  updatedAt
}
    `;
export const ServiceDependencyFragmentDoc = gql`
    fragment ServiceDependency on ServiceDependency {
  id
  name
  status
  updatedAt
}
    `;
export const StackMinimalFragmentDoc = gql`
    fragment StackMinimal on InfrastructureStack {
  id
  name
  type
  status
  insertedAt
  updatedAt
  deletedAt
}
    `;
export const ClusterScalingRecommendationFragmentDoc = gql`
    fragment ClusterScalingRecommendation on ClusterScalingRecommendation {
  id
  namespace
  name
  type
  container
  cpuCost
  cpuRequest
  cpuRecommendation
  memoryCost
  memoryRequest
  memoryRecommendation
  service {
    ...ServiceDeploymentTiny
    cluster {
      distro
      provider {
        id
        cloud
        name
        namespace
        supportedVersions
      }
    }
  }
}
    ${ServiceDeploymentTinyFragmentDoc}`;
export const ServiceDeploymentDetailsFragmentDoc = gql`
    fragment ServiceDeploymentDetails on ServiceDeployment {
  ...ServiceDeploymentsRow
  cluster {
    ...ClusterMinimal
    operationalLayout {
      serviceMesh
    }
  }
  namespace
  message
  version
  helm {
    values
    valuesFiles
  }
  components {
    ...ServiceDeploymentComponent
  }
  contexts {
    ...ServiceContext
  }
  dependencies {
    ...ServiceDependency
  }
  repository {
    pulledAt
  }
  insight {
    ...AiInsight
  }
  imports {
    stack {
      ...StackMinimal
    }
  }
  parent {
    id
    name
    cluster {
      id
      name
    }
  }
  alerts(first: 500) {
    edges {
      node {
        id
      }
    }
  }
  scalingRecommendations {
    ...ClusterScalingRecommendation
  }
}
    ${ServiceDeploymentsRowFragmentDoc}
${ClusterMinimalFragmentDoc}
${ServiceDeploymentComponentFragmentDoc}
${ServiceContextFragmentDoc}
${ServiceDependencyFragmentDoc}
${AiInsightFragmentDoc}
${StackMinimalFragmentDoc}
${ClusterScalingRecommendationFragmentDoc}`;
export const PluralObjectStatusFragmentDoc = gql`
    fragment PluralObjectStatus on PluralObjectStatus {
  id
  conditions {
    ...StatusCondition
  }
}
    ${StatusConditionFragmentDoc}`;
export const PluralServiceDeploymentFragmentDoc = gql`
    fragment PluralServiceDeployment on PluralServiceDeployment {
  events {
    ...Event
  }
  metadata {
    ...Metadata
  }
  reference {
    ...ServiceDeploymentDetails
  }
  status {
    ...PluralObjectStatus
  }
  raw
}
    ${EventFragmentDoc}
${MetadataFragmentDoc}
${ServiceDeploymentDetailsFragmentDoc}
${PluralObjectStatusFragmentDoc}`;
export const PodWithEventsFragmentDoc = gql`
    fragment PodWithEvents on Pod {
  ...Pod
  events {
    ...Event
  }
}
    ${PodFragmentDoc}
${EventFragmentDoc}`;
export const ServiceFragmentDoc = gql`
    fragment Service on Service {
  metadata {
    ...Metadata
  }
  status {
    loadBalancer {
      ingress {
        ip
      }
    }
  }
  spec {
    type
    clusterIp
    ports {
      name
      protocol
      port
      targetPort
    }
  }
  raw
  pods {
    ...Pod
  }
  events {
    ...Event
  }
}
    ${MetadataFragmentDoc}
${PodFragmentDoc}
${EventFragmentDoc}`;
export const StatefulSetFragmentDoc = gql`
    fragment StatefulSet on StatefulSet {
  metadata {
    ...Metadata
  }
  status {
    replicas
    currentReplicas
    readyReplicas
    updatedReplicas
    conditions {
      ...StatusCondition
    }
  }
  spec {
    replicas
    serviceName
  }
  raw
  pods {
    ...Pod
  }
  events {
    ...Event
  }
}
    ${MetadataFragmentDoc}
${StatusConditionFragmentDoc}
${PodFragmentDoc}
${EventFragmentDoc}`;
export const UnstructuredResourceFragmentDoc = gql`
    fragment UnstructuredResource on KubernetesUnstructured {
  raw
  metadata {
    ...Metadata
  }
  events {
    ...Event
  }
}
    ${MetadataFragmentDoc}
${EventFragmentDoc}`;
export const RefreshTokenFragmentDoc = gql`
    fragment RefreshToken on RefreshToken {
  id
  token
  insertedAt
  updatedAt
}
    `;
export const AccountFragmentDoc = gql`
    fragment Account on Account {
  grandfatheredUntil
  delinquentAt
  availableFeatures {
    audits
    userManagement
    databaseManagement
  }
  subscription {
    id
    plan {
      id
      name
      period
    }
  }
}
    `;
export const MetricPointResponseFragmentDoc = gql`
    fragment MetricPointResponse on MetricPointResponse {
  metric
  value {
    timestamp
    value
  }
}
    `;
export const UtilizationHeatMapFragmentDoc = gql`
    fragment UtilizationHeatMap on UtilizationHeatMap {
  cpu {
    ...MetricPointResponse
  }
  memory {
    ...MetricPointResponse
  }
}
    ${MetricPointResponseFragmentDoc}`;
export const UrlSinkConfigurationFragmentDoc = gql`
    fragment UrlSinkConfiguration on UrlSinkConfiguration {
  url
}
    `;
export const SinkConfigurationFragmentDoc = gql`
    fragment SinkConfiguration on SinkConfiguration {
  id
  slack {
    ...UrlSinkConfiguration
  }
  teams {
    ...UrlSinkConfiguration
  }
}
    ${UrlSinkConfigurationFragmentDoc}`;
export const NotificationSinkFragmentDoc = gql`
    fragment NotificationSink on NotificationSink {
  id
  name
  type
  insertedAt
  updatedAt
  configuration {
    ...SinkConfiguration
  }
}
    ${SinkConfigurationFragmentDoc}`;
export const NotificationFilterFragmentDoc = gql`
    fragment NotificationFilter on NotificationFilter {
  id
  cluster {
    id
    name
  }
  pipeline {
    id
    name
  }
  regex
  service {
    id
    name
  }
}
    `;
export const NotificationRouterFragmentDoc = gql`
    fragment NotificationRouter on NotificationRouter {
  id
  name
  sinks {
    ...NotificationSink
  }
  events
  filters {
    ...NotificationFilter
  }
  insertedAt
  updatedAt
}
    ${NotificationSinkFragmentDoc}
${NotificationFilterFragmentDoc}`;
export const AppNotificationFragmentDoc = gql`
    fragment AppNotification on AppNotification {
  id
  insertedAt
  updatedAt
  readAt
  priority
  text
}
    `;
export const OidcProviderFragmentDoc = gql`
    fragment OidcProvider on OidcProvider {
  id
  name
  description
  authMethod
  redirectUris
  clientId
  clientSecret
  bindings {
    ...PolicyBinding
  }
  writeBindings {
    ...PolicyBinding
  }
}
    ${PolicyBindingFragmentDoc}`;
export const PolicyConstraintFragmentDoc = gql`
    fragment PolicyConstraint on PolicyConstraint {
  cluster {
    ...ClusterBasic
  }
  description
  id
  insertedAt
  name
  recommendation
  ref {
    kind
    name
  }
  updatedAt
  violationCount
}
    ${ClusterBasicFragmentDoc}`;
export const ComplianceReportGeneratorFragmentDoc = gql`
    fragment ComplianceReportGenerator on ComplianceReportGenerator {
  id
  name
  format
  readBindings {
    ...PolicyBinding
  }
}
    ${PolicyBindingFragmentDoc}`;
export const ComplianceReportFragmentDoc = gql`
    fragment ComplianceReport on ComplianceReports {
  insertedAt
  id
  name
  sha256
}
    `;
export const ProjectFragmentDoc = gql`
    fragment Project on Project {
  id
  insertedAt
  updatedAt
  name
  default
  description
}
    `;
export const ProjectBindingsFragmentDoc = gql`
    fragment ProjectBindings on Project {
  readBindings {
    ...PolicyBinding
  }
  writeBindings {
    ...PolicyBinding
  }
}
    ${PolicyBindingFragmentDoc}`;
export const StackRunFragmentDoc = gql`
    fragment StackRun on StackRun {
  id
  insertedAt
  git {
    ref
  }
  message
  status
  approval
  approvedAt
  approver {
    name
    email
  }
  insight {
    ...AiInsight
  }
}
    ${AiInsightFragmentDoc}`;
export const StackFragmentDoc = gql`
    fragment Stack on InfrastructureStack {
  id
  insertedAt
  deletedAt
  name
  type
  deleteRun {
    ...StackRun
  }
  configuration {
    image
    version
    terraform {
      parallelism
      refresh
    }
  }
  repository {
    id
    url
    pulledAt
  }
  git {
    ref
    folder
  }
  cluster {
    ...ClusterTiny
  }
  paused
  status
  approval
  variables
  environment {
    name
    value
    secret
  }
  jobSpec {
    namespace
    raw
    annotations
    labels
    serviceAccount
    containers {
      image
      args
      env {
        value
        name
      }
      envFrom {
        secret
        configMap
      }
    }
  }
  tags {
    name
    value
  }
  insight {
    ...AiInsight
  }
  policyEngine {
    type
    maxSeverity
  }
}
    ${StackRunFragmentDoc}
${ClusterTinyFragmentDoc}
${AiInsightFragmentDoc}`;
export const ObservableMetricFragmentDoc = gql`
    fragment ObservableMetric on ObservableMetric {
  provider {
    name
    type
  }
  identifier
}
    `;
export const StackConfigurationFragmentDoc = gql`
    fragment StackConfiguration on StackConfiguration {
  version
  image
  terraform {
    parallelism
    refresh
  }
}
    `;
export const StackStateResourceFragmentDoc = gql`
    fragment StackStateResource on StackStateResource {
  name
  resource
  identifier
  links
  configuration
}
    `;
export const StackStateFragmentDoc = gql`
    fragment StackState on StackState {
  id
  plan
  state {
    ...StackStateResource
  }
}
    ${StackStateResourceFragmentDoc}`;
export const StackOutputFragmentDoc = gql`
    fragment StackOutput on StackOutput {
  name
  value
  secret
}
    `;
export const StackEnvironmentFragmentDoc = gql`
    fragment StackEnvironment on StackEnvironment {
  name
  value
  secret
}
    `;
export const ServiceErrorsFragmentDoc = gql`
    fragment ServiceErrors on ServiceError {
  source
  message
  warning
}
    `;
export const StackFileFragmentDoc = gql`
    fragment StackFile on StackFile {
  path
  content
}
    `;
export const RunStepFragmentDoc = gql`
    fragment RunStep on RunStep {
  id
  name
  insertedAt
  updatedAt
  status
  stage
  args
  cmd
  index
  logs {
    id
    updatedAt
    insertedAt
    logs
  }
}
    `;
export const StackPolicyViolationFragmentDoc = gql`
    fragment StackPolicyViolation on StackPolicyViolation {
  id
  insertedAt
  resolution
  severity
  policyUrl
  policyModule
  policyId
  description
  title
  causes {
    filename
    resource
    start
    end
    lines {
      line
      content
      first
      last
    }
  }
}
    `;
export const StackRunDetailsFragmentDoc = gql`
    fragment StackRunDetails on StackRun {
  id
  status
  updatedAt
  insertedAt
  type
  message
  approval
  approvedAt
  approver {
    ...User
  }
  cancellationReason
  stack {
    name
    deleteRun {
      id
    }
    observableMetrics {
      ...ObservableMetric
    }
  }
  configuration {
    ...StackConfiguration
  }
  state {
    ...StackState
  }
  repository {
    ...GitRepository
  }
  git {
    files
    ref
    folder
  }
  pullRequest {
    ...PullRequest
  }
  output {
    ...StackOutput
  }
  cluster {
    ...ClusterTiny
  }
  environment {
    ...StackEnvironment
  }
  errors {
    ...ServiceErrors
  }
  files {
    ...StackFile
  }
  jobSpec {
    ...JobGateSpec
  }
  steps {
    ...RunStep
  }
  insight {
    ...AiInsight
  }
  violations {
    ...StackPolicyViolation
  }
  policyEngine {
    type
    maxSeverity
  }
}
    ${UserFragmentDoc}
${ObservableMetricFragmentDoc}
${StackConfigurationFragmentDoc}
${StackStateFragmentDoc}
${GitRepositoryFragmentDoc}
${PullRequestFragmentDoc}
${StackOutputFragmentDoc}
${ClusterTinyFragmentDoc}
${StackEnvironmentFragmentDoc}
${ServiceErrorsFragmentDoc}
${StackFileFragmentDoc}
${JobGateSpecFragmentDoc}
${RunStepFragmentDoc}
${AiInsightFragmentDoc}
${StackPolicyViolationFragmentDoc}`;
export const CustomStackRunFragmentDoc = gql`
    fragment CustomStackRun on CustomStackRun {
  id
  name
  documentation
  commands {
    args
    cmd
  }
  configuration {
    ...PrConfiguration
  }
}
    ${PrConfigurationFragmentDoc}`;
export const AccessTokenFragmentDoc = gql`
    fragment AccessToken on AccessToken {
  id
  insertedAt
  updatedAt
  scopes {
    api
    apis
    identifier
    ids
  }
}
    `;
export const AccessTokenAuditFragmentDoc = gql`
    fragment AccessTokenAudit on AccessTokenAudit {
  id
  city
  count
  country
  insertedAt
  ip
  latitude
  longitude
  timestamp
  updatedAt
}
    `;
export const SharedSecretFragmentDoc = gql`
    fragment SharedSecret on SharedSecret {
  secret
  handle
  name
  insertedAt
  updatedAt
}
    `;
export const InviteFragmentDoc = gql`
    fragment Invite on Invite {
  secureId
}
    `;
export const RoleBindingFragmentDoc = gql`
    fragment RoleBinding on RoleBinding {
  id
  user {
    ...User
  }
  group {
    ...Group
  }
}
    ${UserFragmentDoc}
${GroupFragmentDoc}`;
export const RoleFragmentDoc = gql`
    fragment Role on Role {
  id
  name
  description
  repositories
  permissions
  roleBindings {
    ...RoleBinding
  }
}
    ${RoleBindingFragmentDoc}`;
export const AvailableFeaturesFragmentDoc = gql`
    fragment AvailableFeatures on AvailableFeatures {
  audits
  cd
  databaseManagement
  userManagement
}
    `;
export const ManifestFragmentDoc = gql`
    fragment Manifest on PluralManifest {
  network {
    pluralDns
    subdomain
  }
  cluster
  bucketPrefix
}
    `;
export const VulnerabilityReportTinyFragmentDoc = gql`
    fragment VulnerabilityReportTiny on VulnerabilityReport {
  id
  artifactUrl
  services {
    service {
      name
    }
  }
  namespaces {
    namespace
  }
  summary {
    criticalCount
    highCount
    mediumCount
    lowCount
    unknownCount
    noneCount
  }
}
    `;
export const CvssBundleFragmentDoc = gql`
    fragment CvssBundle on CvssBundle {
  attackComplexity
  attackVector
  availability
  confidentiality
  integrity
  privilegesRequired
  userInteraction
  nvidia {
    v2Score
    v2Vector
    v3Score
    v3Vector
    v40Score
    v40Vector
  }
  redhat {
    v2Score
    v2Vector
    v3Score
    v3Vector
    v40Score
    v40Vector
  }
}
    `;
export const VulnerabilityFragmentDoc = gql`
    fragment Vulnerability on Vulnerability {
  id
  title
  description
  severity
  score
  primaryLink
  links
  target
  class
  packageType
  pkgPath
  publishedDate
  installedVersion
  fixedVersion
  lastModifiedDate
  cvss {
    ...CvssBundle
  }
  cvssSource
  resource
  insertedAt
  updatedAt
}
    ${CvssBundleFragmentDoc}`;
export const VulnerabilityReportFragmentDoc = gql`
    fragment VulnerabilityReport on VulnerabilityReport {
  ...VulnerabilityReportTiny
  vulnerabilities {
    ...Vulnerability
  }
}
    ${VulnerabilityReportTinyFragmentDoc}
${VulnerabilityFragmentDoc}`;
export const VulnerabilityStatisticFragmentDoc = gql`
    fragment VulnerabilityStatistic on VulnerabilityStatistic {
  count
  grade
}
    `;
export const ClusterVulnAggregateFragmentDoc = gql`
    fragment ClusterVulnAggregate on ClusterVulnAggregate {
  cluster {
    id
    name
    handle
    project {
      name
    }
  }
  count
}
    `;
export const VulnerabilityReportConnectionFragmentDoc = gql`
    fragment VulnerabilityReportConnection on VulnerabilityReportConnection {
  pageInfo {
    ...PageInfo
  }
  edges {
    node {
      ...VulnerabilityReportTiny
    }
  }
}
    ${PageInfoFragmentDoc}
${VulnerabilityReportTinyFragmentDoc}`;
export const ChatThreadsDocument = gql`
    query ChatThreads($first: Int = 100, $last: Int, $after: String, $before: String, $q: String) {
  chatThreads(first: $first, last: $last, after: $after, before: $before, q: $q) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...ChatThreadTiny
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${ChatThreadTinyFragmentDoc}`;

/**
 * __useChatThreadsQuery__
 *
 * To run a query within a React component, call `useChatThreadsQuery` and pass it any options that fit your needs.
 * When your component renders, `useChatThreadsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChatThreadsQuery({
 *   variables: {
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      q: // value for 'q'
 *   },
 * });
 */
export function useChatThreadsQuery(baseOptions?: Apollo.QueryHookOptions<ChatThreadsQuery, ChatThreadsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChatThreadsQuery, ChatThreadsQueryVariables>(ChatThreadsDocument, options);
      }
export function useChatThreadsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChatThreadsQuery, ChatThreadsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChatThreadsQuery, ChatThreadsQueryVariables>(ChatThreadsDocument, options);
        }
export function useChatThreadsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ChatThreadsQuery, ChatThreadsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ChatThreadsQuery, ChatThreadsQueryVariables>(ChatThreadsDocument, options);
        }
export type ChatThreadsQueryHookResult = ReturnType<typeof useChatThreadsQuery>;
export type ChatThreadsLazyQueryHookResult = ReturnType<typeof useChatThreadsLazyQuery>;
export type ChatThreadsSuspenseQueryHookResult = ReturnType<typeof useChatThreadsSuspenseQuery>;
export type ChatThreadsQueryResult = Apollo.QueryResult<ChatThreadsQuery, ChatThreadsQueryVariables>;
export const ChatAgentSessionDocument = gql`
    query ChatAgentSession($id: ID!) {
  chatThread(id: $id) {
    id
    session {
      id
      done
      pullRequest {
        ...PullRequest
      }
      service {
        ...ServiceDeploymentChat
      }
      stack {
        ...StackChat
      }
      pullRequests(first: 100) {
        edges {
          node {
            ...PullRequest
          }
        }
      }
      serviceDeployments(first: 100) {
        edges {
          node {
            ...ServiceDeploymentTiny
          }
        }
      }
      stacks(first: 100) {
        edges {
          node {
            ...StackTiny
          }
        }
      }
    }
  }
}
    ${PullRequestFragmentDoc}
${ServiceDeploymentChatFragmentDoc}
${StackChatFragmentDoc}
${ServiceDeploymentTinyFragmentDoc}
${StackTinyFragmentDoc}`;

/**
 * __useChatAgentSessionQuery__
 *
 * To run a query within a React component, call `useChatAgentSessionQuery` and pass it any options that fit your needs.
 * When your component renders, `useChatAgentSessionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChatAgentSessionQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useChatAgentSessionQuery(baseOptions: Apollo.QueryHookOptions<ChatAgentSessionQuery, ChatAgentSessionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChatAgentSessionQuery, ChatAgentSessionQueryVariables>(ChatAgentSessionDocument, options);
      }
export function useChatAgentSessionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChatAgentSessionQuery, ChatAgentSessionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChatAgentSessionQuery, ChatAgentSessionQueryVariables>(ChatAgentSessionDocument, options);
        }
export function useChatAgentSessionSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ChatAgentSessionQuery, ChatAgentSessionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ChatAgentSessionQuery, ChatAgentSessionQueryVariables>(ChatAgentSessionDocument, options);
        }
export type ChatAgentSessionQueryHookResult = ReturnType<typeof useChatAgentSessionQuery>;
export type ChatAgentSessionLazyQueryHookResult = ReturnType<typeof useChatAgentSessionLazyQuery>;
export type ChatAgentSessionSuspenseQueryHookResult = ReturnType<typeof useChatAgentSessionSuspenseQuery>;
export type ChatAgentSessionQueryResult = Apollo.QueryResult<ChatAgentSessionQuery, ChatAgentSessionQueryVariables>;
export const ChatThreadDetailsDocument = gql`
    query ChatThreadDetails($id: ID!) {
  chatThread(id: $id) {
    ...ChatThreadDetails
  }
}
    ${ChatThreadDetailsFragmentDoc}`;

/**
 * __useChatThreadDetailsQuery__
 *
 * To run a query within a React component, call `useChatThreadDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useChatThreadDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChatThreadDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useChatThreadDetailsQuery(baseOptions: Apollo.QueryHookOptions<ChatThreadDetailsQuery, ChatThreadDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChatThreadDetailsQuery, ChatThreadDetailsQueryVariables>(ChatThreadDetailsDocument, options);
      }
export function useChatThreadDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChatThreadDetailsQuery, ChatThreadDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChatThreadDetailsQuery, ChatThreadDetailsQueryVariables>(ChatThreadDetailsDocument, options);
        }
export function useChatThreadDetailsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ChatThreadDetailsQuery, ChatThreadDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ChatThreadDetailsQuery, ChatThreadDetailsQueryVariables>(ChatThreadDetailsDocument, options);
        }
export type ChatThreadDetailsQueryHookResult = ReturnType<typeof useChatThreadDetailsQuery>;
export type ChatThreadDetailsLazyQueryHookResult = ReturnType<typeof useChatThreadDetailsLazyQuery>;
export type ChatThreadDetailsSuspenseQueryHookResult = ReturnType<typeof useChatThreadDetailsSuspenseQuery>;
export type ChatThreadDetailsQueryResult = Apollo.QueryResult<ChatThreadDetailsQuery, ChatThreadDetailsQueryVariables>;
export const ChatThreadMessagesDocument = gql`
    query ChatThreadMessages($id: ID!, $first: Int = 25, $last: Int, $after: String, $before: String, $reverse: Boolean = true) {
  chatThread(id: $id) {
    ...ChatThreadMessages
  }
}
    ${ChatThreadMessagesFragmentDoc}`;

/**
 * __useChatThreadMessagesQuery__
 *
 * To run a query within a React component, call `useChatThreadMessagesQuery` and pass it any options that fit your needs.
 * When your component renders, `useChatThreadMessagesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChatThreadMessagesQuery({
 *   variables: {
 *      id: // value for 'id'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      reverse: // value for 'reverse'
 *   },
 * });
 */
export function useChatThreadMessagesQuery(baseOptions: Apollo.QueryHookOptions<ChatThreadMessagesQuery, ChatThreadMessagesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChatThreadMessagesQuery, ChatThreadMessagesQueryVariables>(ChatThreadMessagesDocument, options);
      }
export function useChatThreadMessagesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChatThreadMessagesQuery, ChatThreadMessagesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChatThreadMessagesQuery, ChatThreadMessagesQueryVariables>(ChatThreadMessagesDocument, options);
        }
export function useChatThreadMessagesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ChatThreadMessagesQuery, ChatThreadMessagesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ChatThreadMessagesQuery, ChatThreadMessagesQueryVariables>(ChatThreadMessagesDocument, options);
        }
export type ChatThreadMessagesQueryHookResult = ReturnType<typeof useChatThreadMessagesQuery>;
export type ChatThreadMessagesLazyQueryHookResult = ReturnType<typeof useChatThreadMessagesLazyQuery>;
export type ChatThreadMessagesSuspenseQueryHookResult = ReturnType<typeof useChatThreadMessagesSuspenseQuery>;
export type ChatThreadMessagesQueryResult = Apollo.QueryResult<ChatThreadMessagesQuery, ChatThreadMessagesQueryVariables>;
export const AgentSessionsDocument = gql`
    query AgentSessions($first: Int = 100, $last: Int, $after: String, $before: String) {
  agentSessions(first: $first, last: $last, after: $after, before: $before) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...AgentSession
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${AgentSessionFragmentDoc}`;

/**
 * __useAgentSessionsQuery__
 *
 * To run a query within a React component, call `useAgentSessionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAgentSessionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAgentSessionsQuery({
 *   variables: {
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *   },
 * });
 */
export function useAgentSessionsQuery(baseOptions?: Apollo.QueryHookOptions<AgentSessionsQuery, AgentSessionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AgentSessionsQuery, AgentSessionsQueryVariables>(AgentSessionsDocument, options);
      }
export function useAgentSessionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AgentSessionsQuery, AgentSessionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AgentSessionsQuery, AgentSessionsQueryVariables>(AgentSessionsDocument, options);
        }
export function useAgentSessionsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AgentSessionsQuery, AgentSessionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AgentSessionsQuery, AgentSessionsQueryVariables>(AgentSessionsDocument, options);
        }
export type AgentSessionsQueryHookResult = ReturnType<typeof useAgentSessionsQuery>;
export type AgentSessionsLazyQueryHookResult = ReturnType<typeof useAgentSessionsLazyQuery>;
export type AgentSessionsSuspenseQueryHookResult = ReturnType<typeof useAgentSessionsSuspenseQuery>;
export type AgentSessionsQueryResult = Apollo.QueryResult<AgentSessionsQuery, AgentSessionsQueryVariables>;
export const CloudConnectionsDocument = gql`
    query CloudConnections($first: Int = 100, $last: Int, $after: String, $before: String, $q: String) {
  cloudConnections(
    first: $first
    last: $last
    after: $after
    before: $before
    q: $q
  ) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...CloudConnectionTiny
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${CloudConnectionTinyFragmentDoc}`;

/**
 * __useCloudConnectionsQuery__
 *
 * To run a query within a React component, call `useCloudConnectionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCloudConnectionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCloudConnectionsQuery({
 *   variables: {
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      q: // value for 'q'
 *   },
 * });
 */
export function useCloudConnectionsQuery(baseOptions?: Apollo.QueryHookOptions<CloudConnectionsQuery, CloudConnectionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CloudConnectionsQuery, CloudConnectionsQueryVariables>(CloudConnectionsDocument, options);
      }
export function useCloudConnectionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CloudConnectionsQuery, CloudConnectionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CloudConnectionsQuery, CloudConnectionsQueryVariables>(CloudConnectionsDocument, options);
        }
export function useCloudConnectionsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<CloudConnectionsQuery, CloudConnectionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CloudConnectionsQuery, CloudConnectionsQueryVariables>(CloudConnectionsDocument, options);
        }
export type CloudConnectionsQueryHookResult = ReturnType<typeof useCloudConnectionsQuery>;
export type CloudConnectionsLazyQueryHookResult = ReturnType<typeof useCloudConnectionsLazyQuery>;
export type CloudConnectionsSuspenseQueryHookResult = ReturnType<typeof useCloudConnectionsSuspenseQuery>;
export type CloudConnectionsQueryResult = Apollo.QueryResult<CloudConnectionsQuery, CloudConnectionsQueryVariables>;
export const HybridChatDocument = gql`
    mutation HybridChat($messages: [ChatMessage], $threadId: ID) {
  hybridChat(messages: $messages, threadId: $threadId) {
    ...Chat
  }
}
    ${ChatFragmentDoc}`;
export type HybridChatMutationFn = Apollo.MutationFunction<HybridChatMutation, HybridChatMutationVariables>;

/**
 * __useHybridChatMutation__
 *
 * To run a mutation, you first call `useHybridChatMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useHybridChatMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [hybridChatMutation, { data, loading, error }] = useHybridChatMutation({
 *   variables: {
 *      messages: // value for 'messages'
 *      threadId: // value for 'threadId'
 *   },
 * });
 */
export function useHybridChatMutation(baseOptions?: Apollo.MutationHookOptions<HybridChatMutation, HybridChatMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<HybridChatMutation, HybridChatMutationVariables>(HybridChatDocument, options);
      }
export type HybridChatMutationHookResult = ReturnType<typeof useHybridChatMutation>;
export type HybridChatMutationResult = Apollo.MutationResult<HybridChatMutation>;
export type HybridChatMutationOptions = Apollo.BaseMutationOptions<HybridChatMutation, HybridChatMutationVariables>;
export const ConfirmChatDocument = gql`
    mutation ConfirmChat($id: ID!) {
  confirmChat(id: $id) {
    ...Chat
  }
}
    ${ChatFragmentDoc}`;
export type ConfirmChatMutationFn = Apollo.MutationFunction<ConfirmChatMutation, ConfirmChatMutationVariables>;

/**
 * __useConfirmChatMutation__
 *
 * To run a mutation, you first call `useConfirmChatMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useConfirmChatMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [confirmChatMutation, { data, loading, error }] = useConfirmChatMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useConfirmChatMutation(baseOptions?: Apollo.MutationHookOptions<ConfirmChatMutation, ConfirmChatMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ConfirmChatMutation, ConfirmChatMutationVariables>(ConfirmChatDocument, options);
      }
export type ConfirmChatMutationHookResult = ReturnType<typeof useConfirmChatMutation>;
export type ConfirmChatMutationResult = Apollo.MutationResult<ConfirmChatMutation>;
export type ConfirmChatMutationOptions = Apollo.BaseMutationOptions<ConfirmChatMutation, ConfirmChatMutationVariables>;
export const ConfirmChatPlanDocument = gql`
    mutation ConfirmChatPlan($threadId: ID!) {
  confirmPlan(threadId: $threadId) {
    ...Chat
  }
}
    ${ChatFragmentDoc}`;
export type ConfirmChatPlanMutationFn = Apollo.MutationFunction<ConfirmChatPlanMutation, ConfirmChatPlanMutationVariables>;

/**
 * __useConfirmChatPlanMutation__
 *
 * To run a mutation, you first call `useConfirmChatPlanMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useConfirmChatPlanMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [confirmChatPlanMutation, { data, loading, error }] = useConfirmChatPlanMutation({
 *   variables: {
 *      threadId: // value for 'threadId'
 *   },
 * });
 */
export function useConfirmChatPlanMutation(baseOptions?: Apollo.MutationHookOptions<ConfirmChatPlanMutation, ConfirmChatPlanMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ConfirmChatPlanMutation, ConfirmChatPlanMutationVariables>(ConfirmChatPlanDocument, options);
      }
export type ConfirmChatPlanMutationHookResult = ReturnType<typeof useConfirmChatPlanMutation>;
export type ConfirmChatPlanMutationResult = Apollo.MutationResult<ConfirmChatPlanMutation>;
export type ConfirmChatPlanMutationOptions = Apollo.BaseMutationOptions<ConfirmChatPlanMutation, ConfirmChatPlanMutationVariables>;
export const DeleteChatDocument = gql`
    mutation DeleteChat($id: ID!) {
  deleteChat(id: $id) {
    ...Chat
  }
}
    ${ChatFragmentDoc}`;
export type DeleteChatMutationFn = Apollo.MutationFunction<DeleteChatMutation, DeleteChatMutationVariables>;

/**
 * __useDeleteChatMutation__
 *
 * To run a mutation, you first call `useDeleteChatMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteChatMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteChatMutation, { data, loading, error }] = useDeleteChatMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteChatMutation(baseOptions?: Apollo.MutationHookOptions<DeleteChatMutation, DeleteChatMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteChatMutation, DeleteChatMutationVariables>(DeleteChatDocument, options);
      }
export type DeleteChatMutationHookResult = ReturnType<typeof useDeleteChatMutation>;
export type DeleteChatMutationResult = Apollo.MutationResult<DeleteChatMutation>;
export type DeleteChatMutationOptions = Apollo.BaseMutationOptions<DeleteChatMutation, DeleteChatMutationVariables>;
export const CreateChatThreadDocument = gql`
    mutation CreateChatThread($attributes: ChatThreadAttributes!) {
  createThread(attributes: $attributes) {
    ...ChatThreadDetails
  }
}
    ${ChatThreadDetailsFragmentDoc}`;
export type CreateChatThreadMutationFn = Apollo.MutationFunction<CreateChatThreadMutation, CreateChatThreadMutationVariables>;

/**
 * __useCreateChatThreadMutation__
 *
 * To run a mutation, you first call `useCreateChatThreadMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateChatThreadMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createChatThreadMutation, { data, loading, error }] = useCreateChatThreadMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useCreateChatThreadMutation(baseOptions?: Apollo.MutationHookOptions<CreateChatThreadMutation, CreateChatThreadMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateChatThreadMutation, CreateChatThreadMutationVariables>(CreateChatThreadDocument, options);
      }
export type CreateChatThreadMutationHookResult = ReturnType<typeof useCreateChatThreadMutation>;
export type CreateChatThreadMutationResult = Apollo.MutationResult<CreateChatThreadMutation>;
export type CreateChatThreadMutationOptions = Apollo.BaseMutationOptions<CreateChatThreadMutation, CreateChatThreadMutationVariables>;
export const UpdateChatThreadDocument = gql`
    mutation UpdateChatThread($id: ID!, $attributes: ChatThreadAttributes!) {
  updateThread(id: $id, attributes: $attributes) {
    ...ChatThreadDetails
  }
}
    ${ChatThreadDetailsFragmentDoc}`;
export type UpdateChatThreadMutationFn = Apollo.MutationFunction<UpdateChatThreadMutation, UpdateChatThreadMutationVariables>;

/**
 * __useUpdateChatThreadMutation__
 *
 * To run a mutation, you first call `useUpdateChatThreadMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateChatThreadMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateChatThreadMutation, { data, loading, error }] = useUpdateChatThreadMutation({
 *   variables: {
 *      id: // value for 'id'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpdateChatThreadMutation(baseOptions?: Apollo.MutationHookOptions<UpdateChatThreadMutation, UpdateChatThreadMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateChatThreadMutation, UpdateChatThreadMutationVariables>(UpdateChatThreadDocument, options);
      }
export type UpdateChatThreadMutationHookResult = ReturnType<typeof useUpdateChatThreadMutation>;
export type UpdateChatThreadMutationResult = Apollo.MutationResult<UpdateChatThreadMutation>;
export type UpdateChatThreadMutationOptions = Apollo.BaseMutationOptions<UpdateChatThreadMutation, UpdateChatThreadMutationVariables>;
export const DeleteChatThreadDocument = gql`
    mutation DeleteChatThread($id: ID!) {
  deleteThread(id: $id) {
    ...ChatThreadTiny
  }
}
    ${ChatThreadTinyFragmentDoc}`;
export type DeleteChatThreadMutationFn = Apollo.MutationFunction<DeleteChatThreadMutation, DeleteChatThreadMutationVariables>;

/**
 * __useDeleteChatThreadMutation__
 *
 * To run a mutation, you first call `useDeleteChatThreadMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteChatThreadMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteChatThreadMutation, { data, loading, error }] = useDeleteChatThreadMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteChatThreadMutation(baseOptions?: Apollo.MutationHookOptions<DeleteChatThreadMutation, DeleteChatThreadMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteChatThreadMutation, DeleteChatThreadMutationVariables>(DeleteChatThreadDocument, options);
      }
export type DeleteChatThreadMutationHookResult = ReturnType<typeof useDeleteChatThreadMutation>;
export type DeleteChatThreadMutationResult = Apollo.MutationResult<DeleteChatThreadMutation>;
export type DeleteChatThreadMutationOptions = Apollo.BaseMutationOptions<DeleteChatThreadMutation, DeleteChatThreadMutationVariables>;
export const CloneChatThreadDocument = gql`
    mutation CloneChatThread($id: ID!, $seq: Int) {
  cloneThread(id: $id, seq: $seq) {
    ...ChatThreadDetails
  }
}
    ${ChatThreadDetailsFragmentDoc}`;
export type CloneChatThreadMutationFn = Apollo.MutationFunction<CloneChatThreadMutation, CloneChatThreadMutationVariables>;

/**
 * __useCloneChatThreadMutation__
 *
 * To run a mutation, you first call `useCloneChatThreadMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCloneChatThreadMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [cloneChatThreadMutation, { data, loading, error }] = useCloneChatThreadMutation({
 *   variables: {
 *      id: // value for 'id'
 *      seq: // value for 'seq'
 *   },
 * });
 */
export function useCloneChatThreadMutation(baseOptions?: Apollo.MutationHookOptions<CloneChatThreadMutation, CloneChatThreadMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CloneChatThreadMutation, CloneChatThreadMutationVariables>(CloneChatThreadDocument, options);
      }
export type CloneChatThreadMutationHookResult = ReturnType<typeof useCloneChatThreadMutation>;
export type CloneChatThreadMutationResult = Apollo.MutationResult<CloneChatThreadMutation>;
export type CloneChatThreadMutationOptions = Apollo.BaseMutationOptions<CloneChatThreadMutation, CloneChatThreadMutationVariables>;
export const AddChatContextDocument = gql`
    mutation AddChatContext($source: ContextSource!, $sourceId: ID, $threadId: ID!) {
  addChatContext(source: $source, sourceId: $sourceId, threadId: $threadId) {
    ...Chat
  }
}
    ${ChatFragmentDoc}`;
export type AddChatContextMutationFn = Apollo.MutationFunction<AddChatContextMutation, AddChatContextMutationVariables>;

/**
 * __useAddChatContextMutation__
 *
 * To run a mutation, you first call `useAddChatContextMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddChatContextMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addChatContextMutation, { data, loading, error }] = useAddChatContextMutation({
 *   variables: {
 *      source: // value for 'source'
 *      sourceId: // value for 'sourceId'
 *      threadId: // value for 'threadId'
 *   },
 * });
 */
export function useAddChatContextMutation(baseOptions?: Apollo.MutationHookOptions<AddChatContextMutation, AddChatContextMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddChatContextMutation, AddChatContextMutationVariables>(AddChatContextDocument, options);
      }
export type AddChatContextMutationHookResult = ReturnType<typeof useAddChatContextMutation>;
export type AddChatContextMutationResult = Apollo.MutationResult<AddChatContextMutation>;
export type AddChatContextMutationOptions = Apollo.BaseMutationOptions<AddChatContextMutation, AddChatContextMutationVariables>;
export const CreateAgentSessionDocument = gql`
    mutation CreateAgentSession($attributes: AgentSessionAttributes!) {
  createAgentSession(attributes: $attributes) {
    ...ChatThreadTiny
  }
}
    ${ChatThreadTinyFragmentDoc}`;
export type CreateAgentSessionMutationFn = Apollo.MutationFunction<CreateAgentSessionMutation, CreateAgentSessionMutationVariables>;

/**
 * __useCreateAgentSessionMutation__
 *
 * To run a mutation, you first call `useCreateAgentSessionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateAgentSessionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createAgentSessionMutation, { data, loading, error }] = useCreateAgentSessionMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useCreateAgentSessionMutation(baseOptions?: Apollo.MutationHookOptions<CreateAgentSessionMutation, CreateAgentSessionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateAgentSessionMutation, CreateAgentSessionMutationVariables>(CreateAgentSessionDocument, options);
      }
export type CreateAgentSessionMutationHookResult = ReturnType<typeof useCreateAgentSessionMutation>;
export type CreateAgentSessionMutationResult = Apollo.MutationResult<CreateAgentSessionMutation>;
export type CreateAgentSessionMutationOptions = Apollo.BaseMutationOptions<CreateAgentSessionMutation, CreateAgentSessionMutationVariables>;
export const AiChatStreamDocument = gql`
    subscription AIChatStream($threadId: ID, $insightId: ID, $scopeId: String, $recommendationId: ID) {
  aiStream(
    threadId: $threadId
    insightId: $insightId
    scopeId: $scopeId
    recommendationId: $recommendationId
  ) {
    ...AiDelta
  }
}
    ${AiDeltaFragmentDoc}`;

/**
 * __useAiChatStreamSubscription__
 *
 * To run a query within a React component, call `useAiChatStreamSubscription` and pass it any options that fit your needs.
 * When your component renders, `useAiChatStreamSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAiChatStreamSubscription({
 *   variables: {
 *      threadId: // value for 'threadId'
 *      insightId: // value for 'insightId'
 *      scopeId: // value for 'scopeId'
 *      recommendationId: // value for 'recommendationId'
 *   },
 * });
 */
export function useAiChatStreamSubscription(baseOptions?: Apollo.SubscriptionHookOptions<AiChatStreamSubscription, AiChatStreamSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<AiChatStreamSubscription, AiChatStreamSubscriptionVariables>(AiChatStreamDocument, options);
      }
export type AiChatStreamSubscriptionHookResult = ReturnType<typeof useAiChatStreamSubscription>;
export type AiChatStreamSubscriptionResult = Apollo.SubscriptionResult<AiChatStreamSubscription>;
export const AiInsightDocument = gql`
    query AiInsight($id: ID!) {
  aiInsight(id: $id) {
    ...AiInsight
  }
}
    ${AiInsightFragmentDoc}`;

/**
 * __useAiInsightQuery__
 *
 * To run a query within a React component, call `useAiInsightQuery` and pass it any options that fit your needs.
 * When your component renders, `useAiInsightQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAiInsightQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useAiInsightQuery(baseOptions: Apollo.QueryHookOptions<AiInsightQuery, AiInsightQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AiInsightQuery, AiInsightQueryVariables>(AiInsightDocument, options);
      }
export function useAiInsightLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AiInsightQuery, AiInsightQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AiInsightQuery, AiInsightQueryVariables>(AiInsightDocument, options);
        }
export function useAiInsightSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AiInsightQuery, AiInsightQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AiInsightQuery, AiInsightQueryVariables>(AiInsightDocument, options);
        }
export type AiInsightQueryHookResult = ReturnType<typeof useAiInsightQuery>;
export type AiInsightLazyQueryHookResult = ReturnType<typeof useAiInsightLazyQuery>;
export type AiInsightSuspenseQueryHookResult = ReturnType<typeof useAiInsightSuspenseQuery>;
export type AiInsightQueryResult = Apollo.QueryResult<AiInsightQuery, AiInsightQueryVariables>;
export const AiCompletionDocument = gql`
    query AICompletion($system: String!, $input: String, $chat: [ChatMessage], $scopeId: String) {
  aiCompletion(system: $system, input: $input, chat: $chat, scopeId: $scopeId)
}
    `;

/**
 * __useAiCompletionQuery__
 *
 * To run a query within a React component, call `useAiCompletionQuery` and pass it any options that fit your needs.
 * When your component renders, `useAiCompletionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAiCompletionQuery({
 *   variables: {
 *      system: // value for 'system'
 *      input: // value for 'input'
 *      chat: // value for 'chat'
 *      scopeId: // value for 'scopeId'
 *   },
 * });
 */
export function useAiCompletionQuery(baseOptions: Apollo.QueryHookOptions<AiCompletionQuery, AiCompletionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AiCompletionQuery, AiCompletionQueryVariables>(AiCompletionDocument, options);
      }
export function useAiCompletionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AiCompletionQuery, AiCompletionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AiCompletionQuery, AiCompletionQueryVariables>(AiCompletionDocument, options);
        }
export function useAiCompletionSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AiCompletionQuery, AiCompletionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AiCompletionQuery, AiCompletionQueryVariables>(AiCompletionDocument, options);
        }
export type AiCompletionQueryHookResult = ReturnType<typeof useAiCompletionQuery>;
export type AiCompletionLazyQueryHookResult = ReturnType<typeof useAiCompletionLazyQuery>;
export type AiCompletionSuspenseQueryHookResult = ReturnType<typeof useAiCompletionSuspenseQuery>;
export type AiCompletionQueryResult = Apollo.QueryResult<AiCompletionQuery, AiCompletionQueryVariables>;
export const AiSuggestedFixDocument = gql`
    query AISuggestedFix($insightID: ID!) {
  aiSuggestedFix(insightId: $insightID)
}
    `;

/**
 * __useAiSuggestedFixQuery__
 *
 * To run a query within a React component, call `useAiSuggestedFixQuery` and pass it any options that fit your needs.
 * When your component renders, `useAiSuggestedFixQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAiSuggestedFixQuery({
 *   variables: {
 *      insightID: // value for 'insightID'
 *   },
 * });
 */
export function useAiSuggestedFixQuery(baseOptions: Apollo.QueryHookOptions<AiSuggestedFixQuery, AiSuggestedFixQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AiSuggestedFixQuery, AiSuggestedFixQueryVariables>(AiSuggestedFixDocument, options);
      }
export function useAiSuggestedFixLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AiSuggestedFixQuery, AiSuggestedFixQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AiSuggestedFixQuery, AiSuggestedFixQueryVariables>(AiSuggestedFixDocument, options);
        }
export function useAiSuggestedFixSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AiSuggestedFixQuery, AiSuggestedFixQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AiSuggestedFixQuery, AiSuggestedFixQueryVariables>(AiSuggestedFixDocument, options);
        }
export type AiSuggestedFixQueryHookResult = ReturnType<typeof useAiSuggestedFixQuery>;
export type AiSuggestedFixLazyQueryHookResult = ReturnType<typeof useAiSuggestedFixLazyQuery>;
export type AiSuggestedFixSuspenseQueryHookResult = ReturnType<typeof useAiSuggestedFixSuspenseQuery>;
export type AiSuggestedFixQueryResult = Apollo.QueryResult<AiSuggestedFixQuery, AiSuggestedFixQueryVariables>;
export const ClusterInsightComponentDocument = gql`
    query ClusterInsightComponent($id: ID!) {
  clusterInsightComponent(id: $id) {
    ...ClusterInsightComponentDetail
  }
}
    ${ClusterInsightComponentDetailFragmentDoc}`;

/**
 * __useClusterInsightComponentQuery__
 *
 * To run a query within a React component, call `useClusterInsightComponentQuery` and pass it any options that fit your needs.
 * When your component renders, `useClusterInsightComponentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClusterInsightComponentQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useClusterInsightComponentQuery(baseOptions: Apollo.QueryHookOptions<ClusterInsightComponentQuery, ClusterInsightComponentQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClusterInsightComponentQuery, ClusterInsightComponentQueryVariables>(ClusterInsightComponentDocument, options);
      }
export function useClusterInsightComponentLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClusterInsightComponentQuery, ClusterInsightComponentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClusterInsightComponentQuery, ClusterInsightComponentQueryVariables>(ClusterInsightComponentDocument, options);
        }
export function useClusterInsightComponentSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClusterInsightComponentQuery, ClusterInsightComponentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClusterInsightComponentQuery, ClusterInsightComponentQueryVariables>(ClusterInsightComponentDocument, options);
        }
export type ClusterInsightComponentQueryHookResult = ReturnType<typeof useClusterInsightComponentQuery>;
export type ClusterInsightComponentLazyQueryHookResult = ReturnType<typeof useClusterInsightComponentLazyQuery>;
export type ClusterInsightComponentSuspenseQueryHookResult = ReturnType<typeof useClusterInsightComponentSuspenseQuery>;
export type ClusterInsightComponentQueryResult = Apollo.QueryResult<ClusterInsightComponentQuery, ClusterInsightComponentQueryVariables>;
export const AiFixPrDocument = gql`
    mutation AiFixPr($insightId: ID!, $messages: [ChatMessage]) {
  aiFixPr(insightId: $insightId, messages: $messages) {
    ...PullRequest
  }
}
    ${PullRequestFragmentDoc}`;
export type AiFixPrMutationFn = Apollo.MutationFunction<AiFixPrMutation, AiFixPrMutationVariables>;

/**
 * __useAiFixPrMutation__
 *
 * To run a mutation, you first call `useAiFixPrMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAiFixPrMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [aiFixPrMutation, { data, loading, error }] = useAiFixPrMutation({
 *   variables: {
 *      insightId: // value for 'insightId'
 *      messages: // value for 'messages'
 *   },
 * });
 */
export function useAiFixPrMutation(baseOptions?: Apollo.MutationHookOptions<AiFixPrMutation, AiFixPrMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AiFixPrMutation, AiFixPrMutationVariables>(AiFixPrDocument, options);
      }
export type AiFixPrMutationHookResult = ReturnType<typeof useAiFixPrMutation>;
export type AiFixPrMutationResult = Apollo.MutationResult<AiFixPrMutation>;
export type AiFixPrMutationOptions = Apollo.BaseMutationOptions<AiFixPrMutation, AiFixPrMutationVariables>;
export const RefreshInsightDocument = gql`
    mutation RefreshInsight($id: ID!) {
  refreshInsight(insightId: $id) {
    ...AiInsight
  }
}
    ${AiInsightFragmentDoc}`;
export type RefreshInsightMutationFn = Apollo.MutationFunction<RefreshInsightMutation, RefreshInsightMutationVariables>;

/**
 * __useRefreshInsightMutation__
 *
 * To run a mutation, you first call `useRefreshInsightMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRefreshInsightMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [refreshInsightMutation, { data, loading, error }] = useRefreshInsightMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRefreshInsightMutation(baseOptions?: Apollo.MutationHookOptions<RefreshInsightMutation, RefreshInsightMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RefreshInsightMutation, RefreshInsightMutationVariables>(RefreshInsightDocument, options);
      }
export type RefreshInsightMutationHookResult = ReturnType<typeof useRefreshInsightMutation>;
export type RefreshInsightMutationResult = Apollo.MutationResult<RefreshInsightMutation>;
export type RefreshInsightMutationOptions = Apollo.BaseMutationOptions<RefreshInsightMutation, RefreshInsightMutationVariables>;
export const McpServersDocument = gql`
    query McpServers($first: Int = 100, $after: String, $q: String) {
  mcpServers(first: $first, after: $after, q: $q) {
    ...McpServerConnection
  }
}
    ${McpServerConnectionFragmentDoc}`;

/**
 * __useMcpServersQuery__
 *
 * To run a query within a React component, call `useMcpServersQuery` and pass it any options that fit your needs.
 * When your component renders, `useMcpServersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMcpServersQuery({
 *   variables: {
 *      first: // value for 'first'
 *      after: // value for 'after'
 *      q: // value for 'q'
 *   },
 * });
 */
export function useMcpServersQuery(baseOptions?: Apollo.QueryHookOptions<McpServersQuery, McpServersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<McpServersQuery, McpServersQueryVariables>(McpServersDocument, options);
      }
export function useMcpServersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<McpServersQuery, McpServersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<McpServersQuery, McpServersQueryVariables>(McpServersDocument, options);
        }
export function useMcpServersSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<McpServersQuery, McpServersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<McpServersQuery, McpServersQueryVariables>(McpServersDocument, options);
        }
export type McpServersQueryHookResult = ReturnType<typeof useMcpServersQuery>;
export type McpServersLazyQueryHookResult = ReturnType<typeof useMcpServersLazyQuery>;
export type McpServersSuspenseQueryHookResult = ReturnType<typeof useMcpServersSuspenseQuery>;
export type McpServersQueryResult = Apollo.QueryResult<McpServersQuery, McpServersQueryVariables>;
export const McpServerDocument = gql`
    query McpServer($id: ID!) {
  mcpServer(id: $id) {
    ...McpServer
  }
}
    ${McpServerFragmentDoc}`;

/**
 * __useMcpServerQuery__
 *
 * To run a query within a React component, call `useMcpServerQuery` and pass it any options that fit your needs.
 * When your component renders, `useMcpServerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMcpServerQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useMcpServerQuery(baseOptions: Apollo.QueryHookOptions<McpServerQuery, McpServerQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<McpServerQuery, McpServerQueryVariables>(McpServerDocument, options);
      }
export function useMcpServerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<McpServerQuery, McpServerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<McpServerQuery, McpServerQueryVariables>(McpServerDocument, options);
        }
export function useMcpServerSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<McpServerQuery, McpServerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<McpServerQuery, McpServerQueryVariables>(McpServerDocument, options);
        }
export type McpServerQueryHookResult = ReturnType<typeof useMcpServerQuery>;
export type McpServerLazyQueryHookResult = ReturnType<typeof useMcpServerLazyQuery>;
export type McpServerSuspenseQueryHookResult = ReturnType<typeof useMcpServerSuspenseQuery>;
export type McpServerQueryResult = Apollo.QueryResult<McpServerQuery, McpServerQueryVariables>;
export const McpServerAuditsDocument = gql`
    query McpServerAudits($id: ID!, $first: Int = 100, $after: String) {
  mcpServer(id: $id) {
    id
    audits(first: $first, after: $after) {
      pageInfo {
        ...PageInfo
      }
      edges {
        node {
          ...McpServerAudit
        }
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${McpServerAuditFragmentDoc}`;

/**
 * __useMcpServerAuditsQuery__
 *
 * To run a query within a React component, call `useMcpServerAuditsQuery` and pass it any options that fit your needs.
 * When your component renders, `useMcpServerAuditsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMcpServerAuditsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      first: // value for 'first'
 *      after: // value for 'after'
 *   },
 * });
 */
export function useMcpServerAuditsQuery(baseOptions: Apollo.QueryHookOptions<McpServerAuditsQuery, McpServerAuditsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<McpServerAuditsQuery, McpServerAuditsQueryVariables>(McpServerAuditsDocument, options);
      }
export function useMcpServerAuditsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<McpServerAuditsQuery, McpServerAuditsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<McpServerAuditsQuery, McpServerAuditsQueryVariables>(McpServerAuditsDocument, options);
        }
export function useMcpServerAuditsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<McpServerAuditsQuery, McpServerAuditsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<McpServerAuditsQuery, McpServerAuditsQueryVariables>(McpServerAuditsDocument, options);
        }
export type McpServerAuditsQueryHookResult = ReturnType<typeof useMcpServerAuditsQuery>;
export type McpServerAuditsLazyQueryHookResult = ReturnType<typeof useMcpServerAuditsLazyQuery>;
export type McpServerAuditsSuspenseQueryHookResult = ReturnType<typeof useMcpServerAuditsSuspenseQuery>;
export type McpServerAuditsQueryResult = Apollo.QueryResult<McpServerAuditsQuery, McpServerAuditsQueryVariables>;
export const GenerateMcpTokenDocument = gql`
    query GenerateMcpToken {
  mcpToken
}
    `;

/**
 * __useGenerateMcpTokenQuery__
 *
 * To run a query within a React component, call `useGenerateMcpTokenQuery` and pass it any options that fit your needs.
 * When your component renders, `useGenerateMcpTokenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGenerateMcpTokenQuery({
 *   variables: {
 *   },
 * });
 */
export function useGenerateMcpTokenQuery(baseOptions?: Apollo.QueryHookOptions<GenerateMcpTokenQuery, GenerateMcpTokenQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GenerateMcpTokenQuery, GenerateMcpTokenQueryVariables>(GenerateMcpTokenDocument, options);
      }
export function useGenerateMcpTokenLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GenerateMcpTokenQuery, GenerateMcpTokenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GenerateMcpTokenQuery, GenerateMcpTokenQueryVariables>(GenerateMcpTokenDocument, options);
        }
export function useGenerateMcpTokenSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GenerateMcpTokenQuery, GenerateMcpTokenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GenerateMcpTokenQuery, GenerateMcpTokenQueryVariables>(GenerateMcpTokenDocument, options);
        }
export type GenerateMcpTokenQueryHookResult = ReturnType<typeof useGenerateMcpTokenQuery>;
export type GenerateMcpTokenLazyQueryHookResult = ReturnType<typeof useGenerateMcpTokenLazyQuery>;
export type GenerateMcpTokenSuspenseQueryHookResult = ReturnType<typeof useGenerateMcpTokenSuspenseQuery>;
export type GenerateMcpTokenQueryResult = Apollo.QueryResult<GenerateMcpTokenQuery, GenerateMcpTokenQueryVariables>;
export const UpsertMcpServerDocument = gql`
    mutation UpsertMcpServer($attributes: McpServerAttributes!) {
  upsertMcpServer(attributes: $attributes) {
    ...McpServer
  }
}
    ${McpServerFragmentDoc}`;
export type UpsertMcpServerMutationFn = Apollo.MutationFunction<UpsertMcpServerMutation, UpsertMcpServerMutationVariables>;

/**
 * __useUpsertMcpServerMutation__
 *
 * To run a mutation, you first call `useUpsertMcpServerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpsertMcpServerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upsertMcpServerMutation, { data, loading, error }] = useUpsertMcpServerMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpsertMcpServerMutation(baseOptions?: Apollo.MutationHookOptions<UpsertMcpServerMutation, UpsertMcpServerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpsertMcpServerMutation, UpsertMcpServerMutationVariables>(UpsertMcpServerDocument, options);
      }
export type UpsertMcpServerMutationHookResult = ReturnType<typeof useUpsertMcpServerMutation>;
export type UpsertMcpServerMutationResult = Apollo.MutationResult<UpsertMcpServerMutation>;
export type UpsertMcpServerMutationOptions = Apollo.BaseMutationOptions<UpsertMcpServerMutation, UpsertMcpServerMutationVariables>;
export const DeleteMcpServerDocument = gql`
    mutation DeleteMcpServer($id: ID!) {
  deleteMcpServer(id: $id) {
    id
  }
}
    `;
export type DeleteMcpServerMutationFn = Apollo.MutationFunction<DeleteMcpServerMutation, DeleteMcpServerMutationVariables>;

/**
 * __useDeleteMcpServerMutation__
 *
 * To run a mutation, you first call `useDeleteMcpServerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteMcpServerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteMcpServerMutation, { data, loading, error }] = useDeleteMcpServerMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteMcpServerMutation(baseOptions?: Apollo.MutationHookOptions<DeleteMcpServerMutation, DeleteMcpServerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteMcpServerMutation, DeleteMcpServerMutationVariables>(DeleteMcpServerDocument, options);
      }
export type DeleteMcpServerMutationHookResult = ReturnType<typeof useDeleteMcpServerMutation>;
export type DeleteMcpServerMutationResult = Apollo.MutationResult<DeleteMcpServerMutation>;
export type DeleteMcpServerMutationOptions = Apollo.BaseMutationOptions<DeleteMcpServerMutation, DeleteMcpServerMutationVariables>;
export const ClusterAlertsDocument = gql`
    query ClusterAlerts($clusterId: ID!, $after: String, $first: Int, $before: String, $last: Int) {
  cluster(id: $clusterId) {
    id
    alerts(after: $after, first: $first, before: $before, last: $last) {
      ...AlertConnection
    }
  }
}
    ${AlertConnectionFragmentDoc}`;

/**
 * __useClusterAlertsQuery__
 *
 * To run a query within a React component, call `useClusterAlertsQuery` and pass it any options that fit your needs.
 * When your component renders, `useClusterAlertsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClusterAlertsQuery({
 *   variables: {
 *      clusterId: // value for 'clusterId'
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      before: // value for 'before'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useClusterAlertsQuery(baseOptions: Apollo.QueryHookOptions<ClusterAlertsQuery, ClusterAlertsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClusterAlertsQuery, ClusterAlertsQueryVariables>(ClusterAlertsDocument, options);
      }
export function useClusterAlertsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClusterAlertsQuery, ClusterAlertsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClusterAlertsQuery, ClusterAlertsQueryVariables>(ClusterAlertsDocument, options);
        }
export function useClusterAlertsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClusterAlertsQuery, ClusterAlertsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClusterAlertsQuery, ClusterAlertsQueryVariables>(ClusterAlertsDocument, options);
        }
export type ClusterAlertsQueryHookResult = ReturnType<typeof useClusterAlertsQuery>;
export type ClusterAlertsLazyQueryHookResult = ReturnType<typeof useClusterAlertsLazyQuery>;
export type ClusterAlertsSuspenseQueryHookResult = ReturnType<typeof useClusterAlertsSuspenseQuery>;
export type ClusterAlertsQueryResult = Apollo.QueryResult<ClusterAlertsQuery, ClusterAlertsQueryVariables>;
export const ServiceAlertsDocument = gql`
    query ServiceAlerts($serviceId: ID!, $after: String, $first: Int, $before: String, $last: Int) {
  serviceDeployment(id: $serviceId) {
    id
    alerts(after: $after, first: $first, before: $before, last: $last) {
      ...AlertConnection
    }
  }
}
    ${AlertConnectionFragmentDoc}`;

/**
 * __useServiceAlertsQuery__
 *
 * To run a query within a React component, call `useServiceAlertsQuery` and pass it any options that fit your needs.
 * When your component renders, `useServiceAlertsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useServiceAlertsQuery({
 *   variables: {
 *      serviceId: // value for 'serviceId'
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      before: // value for 'before'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useServiceAlertsQuery(baseOptions: Apollo.QueryHookOptions<ServiceAlertsQuery, ServiceAlertsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ServiceAlertsQuery, ServiceAlertsQueryVariables>(ServiceAlertsDocument, options);
      }
export function useServiceAlertsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ServiceAlertsQuery, ServiceAlertsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ServiceAlertsQuery, ServiceAlertsQueryVariables>(ServiceAlertsDocument, options);
        }
export function useServiceAlertsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ServiceAlertsQuery, ServiceAlertsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ServiceAlertsQuery, ServiceAlertsQueryVariables>(ServiceAlertsDocument, options);
        }
export type ServiceAlertsQueryHookResult = ReturnType<typeof useServiceAlertsQuery>;
export type ServiceAlertsLazyQueryHookResult = ReturnType<typeof useServiceAlertsLazyQuery>;
export type ServiceAlertsSuspenseQueryHookResult = ReturnType<typeof useServiceAlertsSuspenseQuery>;
export type ServiceAlertsQueryResult = Apollo.QueryResult<ServiceAlertsQuery, ServiceAlertsQueryVariables>;
export const UpsertAlertResolutionDocument = gql`
    mutation UpsertAlertResolution($id: ID!, $attributes: AlertResolutionAttributes!) {
  createAlertResolution(id: $id, attributes: $attributes) {
    ...AlertResolution
  }
}
    ${AlertResolutionFragmentDoc}`;
export type UpsertAlertResolutionMutationFn = Apollo.MutationFunction<UpsertAlertResolutionMutation, UpsertAlertResolutionMutationVariables>;

/**
 * __useUpsertAlertResolutionMutation__
 *
 * To run a mutation, you first call `useUpsertAlertResolutionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpsertAlertResolutionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upsertAlertResolutionMutation, { data, loading, error }] = useUpsertAlertResolutionMutation({
 *   variables: {
 *      id: // value for 'id'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpsertAlertResolutionMutation(baseOptions?: Apollo.MutationHookOptions<UpsertAlertResolutionMutation, UpsertAlertResolutionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpsertAlertResolutionMutation, UpsertAlertResolutionMutationVariables>(UpsertAlertResolutionDocument, options);
      }
export type UpsertAlertResolutionMutationHookResult = ReturnType<typeof useUpsertAlertResolutionMutation>;
export type UpsertAlertResolutionMutationResult = Apollo.MutationResult<UpsertAlertResolutionMutation>;
export type UpsertAlertResolutionMutationOptions = Apollo.BaseMutationOptions<UpsertAlertResolutionMutation, UpsertAlertResolutionMutationVariables>;
export const AuditsDocument = gql`
    query Audits($repo: String, $cursor: String) {
  audits(repo: $repo, after: $cursor, first: 50) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...Audit
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${AuditFragmentDoc}`;

/**
 * __useAuditsQuery__
 *
 * To run a query within a React component, call `useAuditsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAuditsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAuditsQuery({
 *   variables: {
 *      repo: // value for 'repo'
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useAuditsQuery(baseOptions?: Apollo.QueryHookOptions<AuditsQuery, AuditsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AuditsQuery, AuditsQueryVariables>(AuditsDocument, options);
      }
export function useAuditsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AuditsQuery, AuditsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AuditsQuery, AuditsQueryVariables>(AuditsDocument, options);
        }
export function useAuditsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AuditsQuery, AuditsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AuditsQuery, AuditsQueryVariables>(AuditsDocument, options);
        }
export type AuditsQueryHookResult = ReturnType<typeof useAuditsQuery>;
export type AuditsLazyQueryHookResult = ReturnType<typeof useAuditsLazyQuery>;
export type AuditsSuspenseQueryHookResult = ReturnType<typeof useAuditsSuspenseQuery>;
export type AuditsQueryResult = Apollo.QueryResult<AuditsQuery, AuditsQueryVariables>;
export const AuditMetricsDocument = gql`
    query AuditMetrics {
  auditMetrics {
    country
    count
  }
}
    `;

/**
 * __useAuditMetricsQuery__
 *
 * To run a query within a React component, call `useAuditMetricsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAuditMetricsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAuditMetricsQuery({
 *   variables: {
 *   },
 * });
 */
export function useAuditMetricsQuery(baseOptions?: Apollo.QueryHookOptions<AuditMetricsQuery, AuditMetricsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AuditMetricsQuery, AuditMetricsQueryVariables>(AuditMetricsDocument, options);
      }
export function useAuditMetricsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AuditMetricsQuery, AuditMetricsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AuditMetricsQuery, AuditMetricsQueryVariables>(AuditMetricsDocument, options);
        }
export function useAuditMetricsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AuditMetricsQuery, AuditMetricsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AuditMetricsQuery, AuditMetricsQueryVariables>(AuditMetricsDocument, options);
        }
export type AuditMetricsQueryHookResult = ReturnType<typeof useAuditMetricsQuery>;
export type AuditMetricsLazyQueryHookResult = ReturnType<typeof useAuditMetricsLazyQuery>;
export type AuditMetricsSuspenseQueryHookResult = ReturnType<typeof useAuditMetricsSuspenseQuery>;
export type AuditMetricsQueryResult = Apollo.QueryResult<AuditMetricsQuery, AuditMetricsQueryVariables>;
export const PrAutomationsDocument = gql`
    query PrAutomations($first: Int = 100, $after: String, $catalogId: ID, $role: PrRole, $q: String) {
  prAutomations(
    first: $first
    after: $after
    catalogId: $catalogId
    role: $role
    q: $q
  ) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...PrAutomation
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${PrAutomationFragmentDoc}`;

/**
 * __usePrAutomationsQuery__
 *
 * To run a query within a React component, call `usePrAutomationsQuery` and pass it any options that fit your needs.
 * When your component renders, `usePrAutomationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePrAutomationsQuery({
 *   variables: {
 *      first: // value for 'first'
 *      after: // value for 'after'
 *      catalogId: // value for 'catalogId'
 *      role: // value for 'role'
 *      q: // value for 'q'
 *   },
 * });
 */
export function usePrAutomationsQuery(baseOptions?: Apollo.QueryHookOptions<PrAutomationsQuery, PrAutomationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PrAutomationsQuery, PrAutomationsQueryVariables>(PrAutomationsDocument, options);
      }
export function usePrAutomationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PrAutomationsQuery, PrAutomationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PrAutomationsQuery, PrAutomationsQueryVariables>(PrAutomationsDocument, options);
        }
export function usePrAutomationsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<PrAutomationsQuery, PrAutomationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PrAutomationsQuery, PrAutomationsQueryVariables>(PrAutomationsDocument, options);
        }
export type PrAutomationsQueryHookResult = ReturnType<typeof usePrAutomationsQuery>;
export type PrAutomationsLazyQueryHookResult = ReturnType<typeof usePrAutomationsLazyQuery>;
export type PrAutomationsSuspenseQueryHookResult = ReturnType<typeof usePrAutomationsSuspenseQuery>;
export type PrAutomationsQueryResult = Apollo.QueryResult<PrAutomationsQuery, PrAutomationsQueryVariables>;
export const CreatePrAutomationDocument = gql`
    mutation CreatePrAutomation($attributes: PrAutomationAttributes!) {
  createPrAutomation(attributes: $attributes) {
    ...PrAutomation
  }
}
    ${PrAutomationFragmentDoc}`;
export type CreatePrAutomationMutationFn = Apollo.MutationFunction<CreatePrAutomationMutation, CreatePrAutomationMutationVariables>;

/**
 * __useCreatePrAutomationMutation__
 *
 * To run a mutation, you first call `useCreatePrAutomationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePrAutomationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPrAutomationMutation, { data, loading, error }] = useCreatePrAutomationMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useCreatePrAutomationMutation(baseOptions?: Apollo.MutationHookOptions<CreatePrAutomationMutation, CreatePrAutomationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreatePrAutomationMutation, CreatePrAutomationMutationVariables>(CreatePrAutomationDocument, options);
      }
export type CreatePrAutomationMutationHookResult = ReturnType<typeof useCreatePrAutomationMutation>;
export type CreatePrAutomationMutationResult = Apollo.MutationResult<CreatePrAutomationMutation>;
export type CreatePrAutomationMutationOptions = Apollo.BaseMutationOptions<CreatePrAutomationMutation, CreatePrAutomationMutationVariables>;
export const UpdatePrAutomationDocument = gql`
    mutation UpdatePrAutomation($id: ID!, $attributes: PrAutomationAttributes!) {
  updatePrAutomation(id: $id, attributes: $attributes) {
    ...PrAutomation
  }
}
    ${PrAutomationFragmentDoc}`;
export type UpdatePrAutomationMutationFn = Apollo.MutationFunction<UpdatePrAutomationMutation, UpdatePrAutomationMutationVariables>;

/**
 * __useUpdatePrAutomationMutation__
 *
 * To run a mutation, you first call `useUpdatePrAutomationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdatePrAutomationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updatePrAutomationMutation, { data, loading, error }] = useUpdatePrAutomationMutation({
 *   variables: {
 *      id: // value for 'id'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpdatePrAutomationMutation(baseOptions?: Apollo.MutationHookOptions<UpdatePrAutomationMutation, UpdatePrAutomationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdatePrAutomationMutation, UpdatePrAutomationMutationVariables>(UpdatePrAutomationDocument, options);
      }
export type UpdatePrAutomationMutationHookResult = ReturnType<typeof useUpdatePrAutomationMutation>;
export type UpdatePrAutomationMutationResult = Apollo.MutationResult<UpdatePrAutomationMutation>;
export type UpdatePrAutomationMutationOptions = Apollo.BaseMutationOptions<UpdatePrAutomationMutation, UpdatePrAutomationMutationVariables>;
export const DeletePrAutomationDocument = gql`
    mutation DeletePrAutomation($id: ID!) {
  deletePrAutomation(id: $id) {
    ...PrAutomation
  }
}
    ${PrAutomationFragmentDoc}`;
export type DeletePrAutomationMutationFn = Apollo.MutationFunction<DeletePrAutomationMutation, DeletePrAutomationMutationVariables>;

/**
 * __useDeletePrAutomationMutation__
 *
 * To run a mutation, you first call `useDeletePrAutomationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeletePrAutomationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deletePrAutomationMutation, { data, loading, error }] = useDeletePrAutomationMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeletePrAutomationMutation(baseOptions?: Apollo.MutationHookOptions<DeletePrAutomationMutation, DeletePrAutomationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeletePrAutomationMutation, DeletePrAutomationMutationVariables>(DeletePrAutomationDocument, options);
      }
export type DeletePrAutomationMutationHookResult = ReturnType<typeof useDeletePrAutomationMutation>;
export type DeletePrAutomationMutationResult = Apollo.MutationResult<DeletePrAutomationMutation>;
export type DeletePrAutomationMutationOptions = Apollo.BaseMutationOptions<DeletePrAutomationMutation, DeletePrAutomationMutationVariables>;
export const ScmConnectionsDocument = gql`
    query ScmConnections($first: Int = 100, $after: String) {
  scmConnections(first: $first, after: $after) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...ScmConnection
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${ScmConnectionFragmentDoc}`;

/**
 * __useScmConnectionsQuery__
 *
 * To run a query within a React component, call `useScmConnectionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useScmConnectionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useScmConnectionsQuery({
 *   variables: {
 *      first: // value for 'first'
 *      after: // value for 'after'
 *   },
 * });
 */
export function useScmConnectionsQuery(baseOptions?: Apollo.QueryHookOptions<ScmConnectionsQuery, ScmConnectionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ScmConnectionsQuery, ScmConnectionsQueryVariables>(ScmConnectionsDocument, options);
      }
export function useScmConnectionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ScmConnectionsQuery, ScmConnectionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ScmConnectionsQuery, ScmConnectionsQueryVariables>(ScmConnectionsDocument, options);
        }
export function useScmConnectionsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ScmConnectionsQuery, ScmConnectionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ScmConnectionsQuery, ScmConnectionsQueryVariables>(ScmConnectionsDocument, options);
        }
export type ScmConnectionsQueryHookResult = ReturnType<typeof useScmConnectionsQuery>;
export type ScmConnectionsLazyQueryHookResult = ReturnType<typeof useScmConnectionsLazyQuery>;
export type ScmConnectionsSuspenseQueryHookResult = ReturnType<typeof useScmConnectionsSuspenseQuery>;
export type ScmConnectionsQueryResult = Apollo.QueryResult<ScmConnectionsQuery, ScmConnectionsQueryVariables>;
export const ScmConnectionDocument = gql`
    query ScmConnection($id: ID, $name: String) {
  scmConnection(id: $id, name: $name) {
    ...ScmConnection
  }
}
    ${ScmConnectionFragmentDoc}`;

/**
 * __useScmConnectionQuery__
 *
 * To run a query within a React component, call `useScmConnectionQuery` and pass it any options that fit your needs.
 * When your component renders, `useScmConnectionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useScmConnectionQuery({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *   },
 * });
 */
export function useScmConnectionQuery(baseOptions?: Apollo.QueryHookOptions<ScmConnectionQuery, ScmConnectionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ScmConnectionQuery, ScmConnectionQueryVariables>(ScmConnectionDocument, options);
      }
export function useScmConnectionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ScmConnectionQuery, ScmConnectionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ScmConnectionQuery, ScmConnectionQueryVariables>(ScmConnectionDocument, options);
        }
export function useScmConnectionSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ScmConnectionQuery, ScmConnectionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ScmConnectionQuery, ScmConnectionQueryVariables>(ScmConnectionDocument, options);
        }
export type ScmConnectionQueryHookResult = ReturnType<typeof useScmConnectionQuery>;
export type ScmConnectionLazyQueryHookResult = ReturnType<typeof useScmConnectionLazyQuery>;
export type ScmConnectionSuspenseQueryHookResult = ReturnType<typeof useScmConnectionSuspenseQuery>;
export type ScmConnectionQueryResult = Apollo.QueryResult<ScmConnectionQuery, ScmConnectionQueryVariables>;
export const CreateScmConnectionDocument = gql`
    mutation CreateScmConnection($attributes: ScmConnectionAttributes!) {
  createScmConnection(attributes: $attributes) {
    ...ScmConnection
  }
}
    ${ScmConnectionFragmentDoc}`;
export type CreateScmConnectionMutationFn = Apollo.MutationFunction<CreateScmConnectionMutation, CreateScmConnectionMutationVariables>;

/**
 * __useCreateScmConnectionMutation__
 *
 * To run a mutation, you first call `useCreateScmConnectionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateScmConnectionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createScmConnectionMutation, { data, loading, error }] = useCreateScmConnectionMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useCreateScmConnectionMutation(baseOptions?: Apollo.MutationHookOptions<CreateScmConnectionMutation, CreateScmConnectionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateScmConnectionMutation, CreateScmConnectionMutationVariables>(CreateScmConnectionDocument, options);
      }
export type CreateScmConnectionMutationHookResult = ReturnType<typeof useCreateScmConnectionMutation>;
export type CreateScmConnectionMutationResult = Apollo.MutationResult<CreateScmConnectionMutation>;
export type CreateScmConnectionMutationOptions = Apollo.BaseMutationOptions<CreateScmConnectionMutation, CreateScmConnectionMutationVariables>;
export const UpdateScmConnectionDocument = gql`
    mutation UpdateScmConnection($id: ID!, $attributes: ScmConnectionAttributes!) {
  updateScmConnection(id: $id, attributes: $attributes) {
    ...ScmConnection
  }
}
    ${ScmConnectionFragmentDoc}`;
export type UpdateScmConnectionMutationFn = Apollo.MutationFunction<UpdateScmConnectionMutation, UpdateScmConnectionMutationVariables>;

/**
 * __useUpdateScmConnectionMutation__
 *
 * To run a mutation, you first call `useUpdateScmConnectionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateScmConnectionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateScmConnectionMutation, { data, loading, error }] = useUpdateScmConnectionMutation({
 *   variables: {
 *      id: // value for 'id'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpdateScmConnectionMutation(baseOptions?: Apollo.MutationHookOptions<UpdateScmConnectionMutation, UpdateScmConnectionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateScmConnectionMutation, UpdateScmConnectionMutationVariables>(UpdateScmConnectionDocument, options);
      }
export type UpdateScmConnectionMutationHookResult = ReturnType<typeof useUpdateScmConnectionMutation>;
export type UpdateScmConnectionMutationResult = Apollo.MutationResult<UpdateScmConnectionMutation>;
export type UpdateScmConnectionMutationOptions = Apollo.BaseMutationOptions<UpdateScmConnectionMutation, UpdateScmConnectionMutationVariables>;
export const DeleteScmConnectionDocument = gql`
    mutation DeleteScmConnection($id: ID!) {
  deleteScmConnection(id: $id) {
    ...ScmConnection
  }
}
    ${ScmConnectionFragmentDoc}`;
export type DeleteScmConnectionMutationFn = Apollo.MutationFunction<DeleteScmConnectionMutation, DeleteScmConnectionMutationVariables>;

/**
 * __useDeleteScmConnectionMutation__
 *
 * To run a mutation, you first call `useDeleteScmConnectionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteScmConnectionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteScmConnectionMutation, { data, loading, error }] = useDeleteScmConnectionMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteScmConnectionMutation(baseOptions?: Apollo.MutationHookOptions<DeleteScmConnectionMutation, DeleteScmConnectionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteScmConnectionMutation, DeleteScmConnectionMutationVariables>(DeleteScmConnectionDocument, options);
      }
export type DeleteScmConnectionMutationHookResult = ReturnType<typeof useDeleteScmConnectionMutation>;
export type DeleteScmConnectionMutationResult = Apollo.MutationResult<DeleteScmConnectionMutation>;
export type DeleteScmConnectionMutationOptions = Apollo.BaseMutationOptions<DeleteScmConnectionMutation, DeleteScmConnectionMutationVariables>;
export const SetupRenovateDocument = gql`
    mutation SetupRenovate($connectionId: ID!, $repos: [String]!, $name: String, $namespace: String) {
  setupRenovate(
    connectionId: $connectionId
    repos: $repos
    name: $name
    namespace: $namespace
  ) {
    id
  }
}
    `;
export type SetupRenovateMutationFn = Apollo.MutationFunction<SetupRenovateMutation, SetupRenovateMutationVariables>;

/**
 * __useSetupRenovateMutation__
 *
 * To run a mutation, you first call `useSetupRenovateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetupRenovateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setupRenovateMutation, { data, loading, error }] = useSetupRenovateMutation({
 *   variables: {
 *      connectionId: // value for 'connectionId'
 *      repos: // value for 'repos'
 *      name: // value for 'name'
 *      namespace: // value for 'namespace'
 *   },
 * });
 */
export function useSetupRenovateMutation(baseOptions?: Apollo.MutationHookOptions<SetupRenovateMutation, SetupRenovateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SetupRenovateMutation, SetupRenovateMutationVariables>(SetupRenovateDocument, options);
      }
export type SetupRenovateMutationHookResult = ReturnType<typeof useSetupRenovateMutation>;
export type SetupRenovateMutationResult = Apollo.MutationResult<SetupRenovateMutation>;
export type SetupRenovateMutationOptions = Apollo.BaseMutationOptions<SetupRenovateMutation, SetupRenovateMutationVariables>;
export const ScmWebhooksDocument = gql`
    query ScmWebhooks($after: String, $before: String, $first: Int, $last: Int) {
  scmWebhooks(after: $after, before: $before, first: $first, last: $last) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...ScmWebhook
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${ScmWebhookFragmentDoc}`;

/**
 * __useScmWebhooksQuery__
 *
 * To run a query within a React component, call `useScmWebhooksQuery` and pass it any options that fit your needs.
 * When your component renders, `useScmWebhooksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useScmWebhooksQuery({
 *   variables: {
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useScmWebhooksQuery(baseOptions?: Apollo.QueryHookOptions<ScmWebhooksQuery, ScmWebhooksQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ScmWebhooksQuery, ScmWebhooksQueryVariables>(ScmWebhooksDocument, options);
      }
export function useScmWebhooksLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ScmWebhooksQuery, ScmWebhooksQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ScmWebhooksQuery, ScmWebhooksQueryVariables>(ScmWebhooksDocument, options);
        }
export function useScmWebhooksSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ScmWebhooksQuery, ScmWebhooksQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ScmWebhooksQuery, ScmWebhooksQueryVariables>(ScmWebhooksDocument, options);
        }
export type ScmWebhooksQueryHookResult = ReturnType<typeof useScmWebhooksQuery>;
export type ScmWebhooksLazyQueryHookResult = ReturnType<typeof useScmWebhooksLazyQuery>;
export type ScmWebhooksSuspenseQueryHookResult = ReturnType<typeof useScmWebhooksSuspenseQuery>;
export type ScmWebhooksQueryResult = Apollo.QueryResult<ScmWebhooksQuery, ScmWebhooksQueryVariables>;
export const CreateScmWebhookDocument = gql`
    mutation CreateScmWebhook($connectionId: ID!, $owner: String!) {
  createScmWebhook(connectionId: $connectionId, owner: $owner) {
    ...ScmWebhook
  }
}
    ${ScmWebhookFragmentDoc}`;
export type CreateScmWebhookMutationFn = Apollo.MutationFunction<CreateScmWebhookMutation, CreateScmWebhookMutationVariables>;

/**
 * __useCreateScmWebhookMutation__
 *
 * To run a mutation, you first call `useCreateScmWebhookMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateScmWebhookMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createScmWebhookMutation, { data, loading, error }] = useCreateScmWebhookMutation({
 *   variables: {
 *      connectionId: // value for 'connectionId'
 *      owner: // value for 'owner'
 *   },
 * });
 */
export function useCreateScmWebhookMutation(baseOptions?: Apollo.MutationHookOptions<CreateScmWebhookMutation, CreateScmWebhookMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateScmWebhookMutation, CreateScmWebhookMutationVariables>(CreateScmWebhookDocument, options);
      }
export type CreateScmWebhookMutationHookResult = ReturnType<typeof useCreateScmWebhookMutation>;
export type CreateScmWebhookMutationResult = Apollo.MutationResult<CreateScmWebhookMutation>;
export type CreateScmWebhookMutationOptions = Apollo.BaseMutationOptions<CreateScmWebhookMutation, CreateScmWebhookMutationVariables>;
export const DeleteScmWebhookDocument = gql`
    mutation DeleteScmWebhook($id: ID!) {
  deleteScmWebhook(id: $id) {
    ...ScmWebhook
  }
}
    ${ScmWebhookFragmentDoc}`;
export type DeleteScmWebhookMutationFn = Apollo.MutationFunction<DeleteScmWebhookMutation, DeleteScmWebhookMutationVariables>;

/**
 * __useDeleteScmWebhookMutation__
 *
 * To run a mutation, you first call `useDeleteScmWebhookMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteScmWebhookMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteScmWebhookMutation, { data, loading, error }] = useDeleteScmWebhookMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteScmWebhookMutation(baseOptions?: Apollo.MutationHookOptions<DeleteScmWebhookMutation, DeleteScmWebhookMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteScmWebhookMutation, DeleteScmWebhookMutationVariables>(DeleteScmWebhookDocument, options);
      }
export type DeleteScmWebhookMutationHookResult = ReturnType<typeof useDeleteScmWebhookMutation>;
export type DeleteScmWebhookMutationResult = Apollo.MutationResult<DeleteScmWebhookMutation>;
export type DeleteScmWebhookMutationOptions = Apollo.BaseMutationOptions<DeleteScmWebhookMutation, DeleteScmWebhookMutationVariables>;
export const CreateScmWebhookPointerDocument = gql`
    mutation CreateScmWebhookPointer($attributes: ScmWebhookAttributes!) {
  createScmWebhookPointer(attributes: $attributes) {
    ...ScmWebhook
  }
}
    ${ScmWebhookFragmentDoc}`;
export type CreateScmWebhookPointerMutationFn = Apollo.MutationFunction<CreateScmWebhookPointerMutation, CreateScmWebhookPointerMutationVariables>;

/**
 * __useCreateScmWebhookPointerMutation__
 *
 * To run a mutation, you first call `useCreateScmWebhookPointerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateScmWebhookPointerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createScmWebhookPointerMutation, { data, loading, error }] = useCreateScmWebhookPointerMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useCreateScmWebhookPointerMutation(baseOptions?: Apollo.MutationHookOptions<CreateScmWebhookPointerMutation, CreateScmWebhookPointerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateScmWebhookPointerMutation, CreateScmWebhookPointerMutationVariables>(CreateScmWebhookPointerDocument, options);
      }
export type CreateScmWebhookPointerMutationHookResult = ReturnType<typeof useCreateScmWebhookPointerMutation>;
export type CreateScmWebhookPointerMutationResult = Apollo.MutationResult<CreateScmWebhookPointerMutation>;
export type CreateScmWebhookPointerMutationOptions = Apollo.BaseMutationOptions<CreateScmWebhookPointerMutation, CreateScmWebhookPointerMutationVariables>;
export const RegisterGitHubAppDocument = gql`
    mutation RegisterGitHubApp($installationId: String!, $name: String!) {
  registerGithubApp(installationId: $installationId, name: $name) {
    id
  }
}
    `;
export type RegisterGitHubAppMutationFn = Apollo.MutationFunction<RegisterGitHubAppMutation, RegisterGitHubAppMutationVariables>;

/**
 * __useRegisterGitHubAppMutation__
 *
 * To run a mutation, you first call `useRegisterGitHubAppMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRegisterGitHubAppMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [registerGitHubAppMutation, { data, loading, error }] = useRegisterGitHubAppMutation({
 *   variables: {
 *      installationId: // value for 'installationId'
 *      name: // value for 'name'
 *   },
 * });
 */
export function useRegisterGitHubAppMutation(baseOptions?: Apollo.MutationHookOptions<RegisterGitHubAppMutation, RegisterGitHubAppMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RegisterGitHubAppMutation, RegisterGitHubAppMutationVariables>(RegisterGitHubAppDocument, options);
      }
export type RegisterGitHubAppMutationHookResult = ReturnType<typeof useRegisterGitHubAppMutation>;
export type RegisterGitHubAppMutationResult = Apollo.MutationResult<RegisterGitHubAppMutation>;
export type RegisterGitHubAppMutationOptions = Apollo.BaseMutationOptions<RegisterGitHubAppMutation, RegisterGitHubAppMutationVariables>;
export const ObjectStoresDocument = gql`
    query ObjectStores($after: String, $first: Int = 100, $before: String, $last: Int) {
  objectStores(after: $after, first: $first, before: $before, last: $last) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...ObjectStore
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${ObjectStoreFragmentDoc}`;

/**
 * __useObjectStoresQuery__
 *
 * To run a query within a React component, call `useObjectStoresQuery` and pass it any options that fit your needs.
 * When your component renders, `useObjectStoresQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useObjectStoresQuery({
 *   variables: {
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      before: // value for 'before'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useObjectStoresQuery(baseOptions?: Apollo.QueryHookOptions<ObjectStoresQuery, ObjectStoresQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ObjectStoresQuery, ObjectStoresQueryVariables>(ObjectStoresDocument, options);
      }
export function useObjectStoresLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ObjectStoresQuery, ObjectStoresQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ObjectStoresQuery, ObjectStoresQueryVariables>(ObjectStoresDocument, options);
        }
export function useObjectStoresSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ObjectStoresQuery, ObjectStoresQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ObjectStoresQuery, ObjectStoresQueryVariables>(ObjectStoresDocument, options);
        }
export type ObjectStoresQueryHookResult = ReturnType<typeof useObjectStoresQuery>;
export type ObjectStoresLazyQueryHookResult = ReturnType<typeof useObjectStoresLazyQuery>;
export type ObjectStoresSuspenseQueryHookResult = ReturnType<typeof useObjectStoresSuspenseQuery>;
export type ObjectStoresQueryResult = Apollo.QueryResult<ObjectStoresQuery, ObjectStoresQueryVariables>;
export const ClustersObjectStoresDocument = gql`
    query ClustersObjectStores($after: String, $first: Int = 100, $before: String, $last: Int, $backups: Boolean) {
  clusters(
    after: $after
    first: $first
    before: $before
    last: $last
    backups: $backups
  ) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...ClustersObjectStores
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${ClustersObjectStoresFragmentDoc}`;

/**
 * __useClustersObjectStoresQuery__
 *
 * To run a query within a React component, call `useClustersObjectStoresQuery` and pass it any options that fit your needs.
 * When your component renders, `useClustersObjectStoresQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClustersObjectStoresQuery({
 *   variables: {
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      before: // value for 'before'
 *      last: // value for 'last'
 *      backups: // value for 'backups'
 *   },
 * });
 */
export function useClustersObjectStoresQuery(baseOptions?: Apollo.QueryHookOptions<ClustersObjectStoresQuery, ClustersObjectStoresQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClustersObjectStoresQuery, ClustersObjectStoresQueryVariables>(ClustersObjectStoresDocument, options);
      }
export function useClustersObjectStoresLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClustersObjectStoresQuery, ClustersObjectStoresQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClustersObjectStoresQuery, ClustersObjectStoresQueryVariables>(ClustersObjectStoresDocument, options);
        }
export function useClustersObjectStoresSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClustersObjectStoresQuery, ClustersObjectStoresQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClustersObjectStoresQuery, ClustersObjectStoresQueryVariables>(ClustersObjectStoresDocument, options);
        }
export type ClustersObjectStoresQueryHookResult = ReturnType<typeof useClustersObjectStoresQuery>;
export type ClustersObjectStoresLazyQueryHookResult = ReturnType<typeof useClustersObjectStoresLazyQuery>;
export type ClustersObjectStoresSuspenseQueryHookResult = ReturnType<typeof useClustersObjectStoresSuspenseQuery>;
export type ClustersObjectStoresQueryResult = Apollo.QueryResult<ClustersObjectStoresQuery, ClustersObjectStoresQueryVariables>;
export const ClusterBackupDocument = gql`
    query ClusterBackup($id: ID, $clusterId: ID, $namespace: String, $name: String) {
  clusterBackup(
    id: $id
    clusterId: $clusterId
    namespace: $namespace
    name: $name
  ) {
    ...ClusterBackup
  }
}
    ${ClusterBackupFragmentDoc}`;

/**
 * __useClusterBackupQuery__
 *
 * To run a query within a React component, call `useClusterBackupQuery` and pass it any options that fit your needs.
 * When your component renders, `useClusterBackupQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClusterBackupQuery({
 *   variables: {
 *      id: // value for 'id'
 *      clusterId: // value for 'clusterId'
 *      namespace: // value for 'namespace'
 *      name: // value for 'name'
 *   },
 * });
 */
export function useClusterBackupQuery(baseOptions?: Apollo.QueryHookOptions<ClusterBackupQuery, ClusterBackupQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClusterBackupQuery, ClusterBackupQueryVariables>(ClusterBackupDocument, options);
      }
export function useClusterBackupLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClusterBackupQuery, ClusterBackupQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClusterBackupQuery, ClusterBackupQueryVariables>(ClusterBackupDocument, options);
        }
export function useClusterBackupSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClusterBackupQuery, ClusterBackupQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClusterBackupQuery, ClusterBackupQueryVariables>(ClusterBackupDocument, options);
        }
export type ClusterBackupQueryHookResult = ReturnType<typeof useClusterBackupQuery>;
export type ClusterBackupLazyQueryHookResult = ReturnType<typeof useClusterBackupLazyQuery>;
export type ClusterBackupSuspenseQueryHookResult = ReturnType<typeof useClusterBackupSuspenseQuery>;
export type ClusterBackupQueryResult = Apollo.QueryResult<ClusterBackupQuery, ClusterBackupQueryVariables>;
export const ClusterBackupsDocument = gql`
    query ClusterBackups($after: String, $first: Int = 100, $before: String, $last: Int, $clusterId: ID!) {
  clusterBackups(
    last: $last
    first: $first
    before: $before
    after: $after
    clusterId: $clusterId
  ) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...ClusterBackup
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${ClusterBackupFragmentDoc}`;

/**
 * __useClusterBackupsQuery__
 *
 * To run a query within a React component, call `useClusterBackupsQuery` and pass it any options that fit your needs.
 * When your component renders, `useClusterBackupsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClusterBackupsQuery({
 *   variables: {
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      before: // value for 'before'
 *      last: // value for 'last'
 *      clusterId: // value for 'clusterId'
 *   },
 * });
 */
export function useClusterBackupsQuery(baseOptions: Apollo.QueryHookOptions<ClusterBackupsQuery, ClusterBackupsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClusterBackupsQuery, ClusterBackupsQueryVariables>(ClusterBackupsDocument, options);
      }
export function useClusterBackupsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClusterBackupsQuery, ClusterBackupsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClusterBackupsQuery, ClusterBackupsQueryVariables>(ClusterBackupsDocument, options);
        }
export function useClusterBackupsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClusterBackupsQuery, ClusterBackupsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClusterBackupsQuery, ClusterBackupsQueryVariables>(ClusterBackupsDocument, options);
        }
export type ClusterBackupsQueryHookResult = ReturnType<typeof useClusterBackupsQuery>;
export type ClusterBackupsLazyQueryHookResult = ReturnType<typeof useClusterBackupsLazyQuery>;
export type ClusterBackupsSuspenseQueryHookResult = ReturnType<typeof useClusterBackupsSuspenseQuery>;
export type ClusterBackupsQueryResult = Apollo.QueryResult<ClusterBackupsQuery, ClusterBackupsQueryVariables>;
export const ClusterRestoresDocument = gql`
    query ClusterRestores($after: String, $first: Int = 100, $before: String, $last: Int, $clusterId: ID!) {
  clusterRestores(
    last: $last
    first: $first
    before: $before
    after: $after
    clusterId: $clusterId
  ) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...ClusterRestore
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${ClusterRestoreFragmentDoc}`;

/**
 * __useClusterRestoresQuery__
 *
 * To run a query within a React component, call `useClusterRestoresQuery` and pass it any options that fit your needs.
 * When your component renders, `useClusterRestoresQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClusterRestoresQuery({
 *   variables: {
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      before: // value for 'before'
 *      last: // value for 'last'
 *      clusterId: // value for 'clusterId'
 *   },
 * });
 */
export function useClusterRestoresQuery(baseOptions: Apollo.QueryHookOptions<ClusterRestoresQuery, ClusterRestoresQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClusterRestoresQuery, ClusterRestoresQueryVariables>(ClusterRestoresDocument, options);
      }
export function useClusterRestoresLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClusterRestoresQuery, ClusterRestoresQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClusterRestoresQuery, ClusterRestoresQueryVariables>(ClusterRestoresDocument, options);
        }
export function useClusterRestoresSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClusterRestoresQuery, ClusterRestoresQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClusterRestoresQuery, ClusterRestoresQueryVariables>(ClusterRestoresDocument, options);
        }
export type ClusterRestoresQueryHookResult = ReturnType<typeof useClusterRestoresQuery>;
export type ClusterRestoresLazyQueryHookResult = ReturnType<typeof useClusterRestoresLazyQuery>;
export type ClusterRestoresSuspenseQueryHookResult = ReturnType<typeof useClusterRestoresSuspenseQuery>;
export type ClusterRestoresQueryResult = Apollo.QueryResult<ClusterRestoresQuery, ClusterRestoresQueryVariables>;
export const CreateObjectStoreDocument = gql`
    mutation CreateObjectStore($attributes: ObjectStoreAttributes!) {
  createObjectStore(attributes: $attributes) {
    ...ObjectStore
  }
}
    ${ObjectStoreFragmentDoc}`;
export type CreateObjectStoreMutationFn = Apollo.MutationFunction<CreateObjectStoreMutation, CreateObjectStoreMutationVariables>;

/**
 * __useCreateObjectStoreMutation__
 *
 * To run a mutation, you first call `useCreateObjectStoreMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateObjectStoreMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createObjectStoreMutation, { data, loading, error }] = useCreateObjectStoreMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useCreateObjectStoreMutation(baseOptions?: Apollo.MutationHookOptions<CreateObjectStoreMutation, CreateObjectStoreMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateObjectStoreMutation, CreateObjectStoreMutationVariables>(CreateObjectStoreDocument, options);
      }
export type CreateObjectStoreMutationHookResult = ReturnType<typeof useCreateObjectStoreMutation>;
export type CreateObjectStoreMutationResult = Apollo.MutationResult<CreateObjectStoreMutation>;
export type CreateObjectStoreMutationOptions = Apollo.BaseMutationOptions<CreateObjectStoreMutation, CreateObjectStoreMutationVariables>;
export const UpdateObjectStoreDocument = gql`
    mutation UpdateObjectStore($id: ID!, $attributes: ObjectStoreAttributes!) {
  updateObjectStore(id: $id, attributes: $attributes) {
    ...ObjectStore
  }
}
    ${ObjectStoreFragmentDoc}`;
export type UpdateObjectStoreMutationFn = Apollo.MutationFunction<UpdateObjectStoreMutation, UpdateObjectStoreMutationVariables>;

/**
 * __useUpdateObjectStoreMutation__
 *
 * To run a mutation, you first call `useUpdateObjectStoreMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateObjectStoreMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateObjectStoreMutation, { data, loading, error }] = useUpdateObjectStoreMutation({
 *   variables: {
 *      id: // value for 'id'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpdateObjectStoreMutation(baseOptions?: Apollo.MutationHookOptions<UpdateObjectStoreMutation, UpdateObjectStoreMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateObjectStoreMutation, UpdateObjectStoreMutationVariables>(UpdateObjectStoreDocument, options);
      }
export type UpdateObjectStoreMutationHookResult = ReturnType<typeof useUpdateObjectStoreMutation>;
export type UpdateObjectStoreMutationResult = Apollo.MutationResult<UpdateObjectStoreMutation>;
export type UpdateObjectStoreMutationOptions = Apollo.BaseMutationOptions<UpdateObjectStoreMutation, UpdateObjectStoreMutationVariables>;
export const DeleteObjectStoreDocument = gql`
    mutation DeleteObjectStore($id: ID!) {
  deleteObjectStore(id: $id) {
    ...ObjectStore
  }
}
    ${ObjectStoreFragmentDoc}`;
export type DeleteObjectStoreMutationFn = Apollo.MutationFunction<DeleteObjectStoreMutation, DeleteObjectStoreMutationVariables>;

/**
 * __useDeleteObjectStoreMutation__
 *
 * To run a mutation, you first call `useDeleteObjectStoreMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteObjectStoreMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteObjectStoreMutation, { data, loading, error }] = useDeleteObjectStoreMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteObjectStoreMutation(baseOptions?: Apollo.MutationHookOptions<DeleteObjectStoreMutation, DeleteObjectStoreMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteObjectStoreMutation, DeleteObjectStoreMutationVariables>(DeleteObjectStoreDocument, options);
      }
export type DeleteObjectStoreMutationHookResult = ReturnType<typeof useDeleteObjectStoreMutation>;
export type DeleteObjectStoreMutationResult = Apollo.MutationResult<DeleteObjectStoreMutation>;
export type DeleteObjectStoreMutationOptions = Apollo.BaseMutationOptions<DeleteObjectStoreMutation, DeleteObjectStoreMutationVariables>;
export const ConfigureBackupsDocument = gql`
    mutation ConfigureBackups($clusterId: ID!, $storeId: ID!) {
  configureBackups(clusterId: $clusterId, storeId: $storeId) {
    ...ClusterTiny
  }
}
    ${ClusterTinyFragmentDoc}`;
export type ConfigureBackupsMutationFn = Apollo.MutationFunction<ConfigureBackupsMutation, ConfigureBackupsMutationVariables>;

/**
 * __useConfigureBackupsMutation__
 *
 * To run a mutation, you first call `useConfigureBackupsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useConfigureBackupsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [configureBackupsMutation, { data, loading, error }] = useConfigureBackupsMutation({
 *   variables: {
 *      clusterId: // value for 'clusterId'
 *      storeId: // value for 'storeId'
 *   },
 * });
 */
export function useConfigureBackupsMutation(baseOptions?: Apollo.MutationHookOptions<ConfigureBackupsMutation, ConfigureBackupsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ConfigureBackupsMutation, ConfigureBackupsMutationVariables>(ConfigureBackupsDocument, options);
      }
export type ConfigureBackupsMutationHookResult = ReturnType<typeof useConfigureBackupsMutation>;
export type ConfigureBackupsMutationResult = Apollo.MutationResult<ConfigureBackupsMutation>;
export type ConfigureBackupsMutationOptions = Apollo.BaseMutationOptions<ConfigureBackupsMutation, ConfigureBackupsMutationVariables>;
export const DelinkBackupsDocument = gql`
    mutation DelinkBackups($clusterId: ID!) {
  delinkBackups(clusterId: $clusterId) {
    ...ClusterTiny
  }
}
    ${ClusterTinyFragmentDoc}`;
export type DelinkBackupsMutationFn = Apollo.MutationFunction<DelinkBackupsMutation, DelinkBackupsMutationVariables>;

/**
 * __useDelinkBackupsMutation__
 *
 * To run a mutation, you first call `useDelinkBackupsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDelinkBackupsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [delinkBackupsMutation, { data, loading, error }] = useDelinkBackupsMutation({
 *   variables: {
 *      clusterId: // value for 'clusterId'
 *   },
 * });
 */
export function useDelinkBackupsMutation(baseOptions?: Apollo.MutationHookOptions<DelinkBackupsMutation, DelinkBackupsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DelinkBackupsMutation, DelinkBackupsMutationVariables>(DelinkBackupsDocument, options);
      }
export type DelinkBackupsMutationHookResult = ReturnType<typeof useDelinkBackupsMutation>;
export type DelinkBackupsMutationResult = Apollo.MutationResult<DelinkBackupsMutation>;
export type DelinkBackupsMutationOptions = Apollo.BaseMutationOptions<DelinkBackupsMutation, DelinkBackupsMutationVariables>;
export const CreateClusterRestoreDocument = gql`
    mutation CreateClusterRestore($backupId: ID!) {
  createClusterRestore(backupId: $backupId) {
    ...ClusterRestore
  }
}
    ${ClusterRestoreFragmentDoc}`;
export type CreateClusterRestoreMutationFn = Apollo.MutationFunction<CreateClusterRestoreMutation, CreateClusterRestoreMutationVariables>;

/**
 * __useCreateClusterRestoreMutation__
 *
 * To run a mutation, you first call `useCreateClusterRestoreMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateClusterRestoreMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createClusterRestoreMutation, { data, loading, error }] = useCreateClusterRestoreMutation({
 *   variables: {
 *      backupId: // value for 'backupId'
 *   },
 * });
 */
export function useCreateClusterRestoreMutation(baseOptions?: Apollo.MutationHookOptions<CreateClusterRestoreMutation, CreateClusterRestoreMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateClusterRestoreMutation, CreateClusterRestoreMutationVariables>(CreateClusterRestoreDocument, options);
      }
export type CreateClusterRestoreMutationHookResult = ReturnType<typeof useCreateClusterRestoreMutation>;
export type CreateClusterRestoreMutationResult = Apollo.MutationResult<CreateClusterRestoreMutation>;
export type CreateClusterRestoreMutationOptions = Apollo.BaseMutationOptions<CreateClusterRestoreMutation, CreateClusterRestoreMutationVariables>;
export const CatalogsDocument = gql`
    query Catalogs($after: String, $before: String, $first: Int, $last: Int) {
  catalogs(after: $after, before: $before, first: $first, last: $last) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...Catalog
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${CatalogFragmentDoc}`;

/**
 * __useCatalogsQuery__
 *
 * To run a query within a React component, call `useCatalogsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCatalogsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCatalogsQuery({
 *   variables: {
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useCatalogsQuery(baseOptions?: Apollo.QueryHookOptions<CatalogsQuery, CatalogsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CatalogsQuery, CatalogsQueryVariables>(CatalogsDocument, options);
      }
export function useCatalogsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CatalogsQuery, CatalogsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CatalogsQuery, CatalogsQueryVariables>(CatalogsDocument, options);
        }
export function useCatalogsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<CatalogsQuery, CatalogsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CatalogsQuery, CatalogsQueryVariables>(CatalogsDocument, options);
        }
export type CatalogsQueryHookResult = ReturnType<typeof useCatalogsQuery>;
export type CatalogsLazyQueryHookResult = ReturnType<typeof useCatalogsLazyQuery>;
export type CatalogsSuspenseQueryHookResult = ReturnType<typeof useCatalogsSuspenseQuery>;
export type CatalogsQueryResult = Apollo.QueryResult<CatalogsQuery, CatalogsQueryVariables>;
export const CatalogDocument = gql`
    query Catalog($id: ID, $name: String) {
  catalog(id: $id, name: $name) {
    ...Catalog
  }
}
    ${CatalogFragmentDoc}`;

/**
 * __useCatalogQuery__
 *
 * To run a query within a React component, call `useCatalogQuery` and pass it any options that fit your needs.
 * When your component renders, `useCatalogQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCatalogQuery({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *   },
 * });
 */
export function useCatalogQuery(baseOptions?: Apollo.QueryHookOptions<CatalogQuery, CatalogQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CatalogQuery, CatalogQueryVariables>(CatalogDocument, options);
      }
export function useCatalogLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CatalogQuery, CatalogQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CatalogQuery, CatalogQueryVariables>(CatalogDocument, options);
        }
export function useCatalogSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<CatalogQuery, CatalogQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CatalogQuery, CatalogQueryVariables>(CatalogDocument, options);
        }
export type CatalogQueryHookResult = ReturnType<typeof useCatalogQuery>;
export type CatalogLazyQueryHookResult = ReturnType<typeof useCatalogLazyQuery>;
export type CatalogSuspenseQueryHookResult = ReturnType<typeof useCatalogSuspenseQuery>;
export type CatalogQueryResult = Apollo.QueryResult<CatalogQuery, CatalogQueryVariables>;
export const UpsertCatalogDocument = gql`
    mutation UpsertCatalog($attributes: CatalogAttributes) {
  upsertCatalog(attributes: $attributes) {
    ...Catalog
  }
}
    ${CatalogFragmentDoc}`;
export type UpsertCatalogMutationFn = Apollo.MutationFunction<UpsertCatalogMutation, UpsertCatalogMutationVariables>;

/**
 * __useUpsertCatalogMutation__
 *
 * To run a mutation, you first call `useUpsertCatalogMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpsertCatalogMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upsertCatalogMutation, { data, loading, error }] = useUpsertCatalogMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpsertCatalogMutation(baseOptions?: Apollo.MutationHookOptions<UpsertCatalogMutation, UpsertCatalogMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpsertCatalogMutation, UpsertCatalogMutationVariables>(UpsertCatalogDocument, options);
      }
export type UpsertCatalogMutationHookResult = ReturnType<typeof useUpsertCatalogMutation>;
export type UpsertCatalogMutationResult = Apollo.MutationResult<UpsertCatalogMutation>;
export type UpsertCatalogMutationOptions = Apollo.BaseMutationOptions<UpsertCatalogMutation, UpsertCatalogMutationVariables>;
export const DeleteCatalogDocument = gql`
    mutation DeleteCatalog($id: ID!) {
  deleteCatalog(id: $id) {
    ...Catalog
  }
}
    ${CatalogFragmentDoc}`;
export type DeleteCatalogMutationFn = Apollo.MutationFunction<DeleteCatalogMutation, DeleteCatalogMutationVariables>;

/**
 * __useDeleteCatalogMutation__
 *
 * To run a mutation, you first call `useDeleteCatalogMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCatalogMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCatalogMutation, { data, loading, error }] = useDeleteCatalogMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteCatalogMutation(baseOptions?: Apollo.MutationHookOptions<DeleteCatalogMutation, DeleteCatalogMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteCatalogMutation, DeleteCatalogMutationVariables>(DeleteCatalogDocument, options);
      }
export type DeleteCatalogMutationHookResult = ReturnType<typeof useDeleteCatalogMutation>;
export type DeleteCatalogMutationResult = Apollo.MutationResult<DeleteCatalogMutation>;
export type DeleteCatalogMutationOptions = Apollo.BaseMutationOptions<DeleteCatalogMutation, DeleteCatalogMutationVariables>;
export const ClustersDocument = gql`
    query Clusters($first: Int, $after: String, $q: String, $healthy: Boolean, $tagQuery: TagQuery, $projectId: ID, $upgradeable: Boolean, $compliance: VersionCompliance, $healthRange: HealthRange) {
  clusters(
    first: $first
    after: $after
    q: $q
    healthy: $healthy
    tagQuery: $tagQuery
    projectId: $projectId
    upgradeable: $upgradeable
    compliance: $compliance
    healthRange: $healthRange
  ) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...ClustersRow
      }
    }
  }
  clusterStatuses(q: $q, projectId: $projectId) {
    ...ClusterStatusInfo
  }
  upgradeStatistics(q: $q, projectId: $projectId) {
    upgradeable
    count
  }
  tags
}
    ${PageInfoFragmentDoc}
${ClustersRowFragmentDoc}
${ClusterStatusInfoFragmentDoc}`;

/**
 * __useClustersQuery__
 *
 * To run a query within a React component, call `useClustersQuery` and pass it any options that fit your needs.
 * When your component renders, `useClustersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClustersQuery({
 *   variables: {
 *      first: // value for 'first'
 *      after: // value for 'after'
 *      q: // value for 'q'
 *      healthy: // value for 'healthy'
 *      tagQuery: // value for 'tagQuery'
 *      projectId: // value for 'projectId'
 *      upgradeable: // value for 'upgradeable'
 *      compliance: // value for 'compliance'
 *      healthRange: // value for 'healthRange'
 *   },
 * });
 */
export function useClustersQuery(baseOptions?: Apollo.QueryHookOptions<ClustersQuery, ClustersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClustersQuery, ClustersQueryVariables>(ClustersDocument, options);
      }
export function useClustersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClustersQuery, ClustersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClustersQuery, ClustersQueryVariables>(ClustersDocument, options);
        }
export function useClustersSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClustersQuery, ClustersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClustersQuery, ClustersQueryVariables>(ClustersDocument, options);
        }
export type ClustersQueryHookResult = ReturnType<typeof useClustersQuery>;
export type ClustersLazyQueryHookResult = ReturnType<typeof useClustersLazyQuery>;
export type ClustersSuspenseQueryHookResult = ReturnType<typeof useClustersSuspenseQuery>;
export type ClustersQueryResult = Apollo.QueryResult<ClustersQuery, ClustersQueryVariables>;
export const ClustersTinyDocument = gql`
    query ClustersTiny($projectId: ID, $first: Int) {
  clusters(first: $first, projectId: $projectId) {
    edges {
      node {
        ...ClusterTiny
      }
    }
  }
}
    ${ClusterTinyFragmentDoc}`;

/**
 * __useClustersTinyQuery__
 *
 * To run a query within a React component, call `useClustersTinyQuery` and pass it any options that fit your needs.
 * When your component renders, `useClustersTinyQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClustersTinyQuery({
 *   variables: {
 *      projectId: // value for 'projectId'
 *      first: // value for 'first'
 *   },
 * });
 */
export function useClustersTinyQuery(baseOptions?: Apollo.QueryHookOptions<ClustersTinyQuery, ClustersTinyQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClustersTinyQuery, ClustersTinyQueryVariables>(ClustersTinyDocument, options);
      }
export function useClustersTinyLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClustersTinyQuery, ClustersTinyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClustersTinyQuery, ClustersTinyQueryVariables>(ClustersTinyDocument, options);
        }
export function useClustersTinySuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClustersTinyQuery, ClustersTinyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClustersTinyQuery, ClustersTinyQueryVariables>(ClustersTinyDocument, options);
        }
export type ClustersTinyQueryHookResult = ReturnType<typeof useClustersTinyQuery>;
export type ClustersTinyLazyQueryHookResult = ReturnType<typeof useClustersTinyLazyQuery>;
export type ClustersTinySuspenseQueryHookResult = ReturnType<typeof useClustersTinySuspenseQuery>;
export type ClustersTinyQueryResult = Apollo.QueryResult<ClustersTinyQuery, ClustersTinyQueryVariables>;
export const VClustersDocument = gql`
    query VClusters($parentId: ID!, $first: Int, $after: String, $q: String, $healthy: Boolean, $projectId: ID) {
  clusters(
    first: $first
    after: $after
    q: $q
    healthy: $healthy
    projectId: $projectId
    parentId: $parentId
  ) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...ClustersRow
      }
    }
  }
  tags
}
    ${PageInfoFragmentDoc}
${ClustersRowFragmentDoc}`;

/**
 * __useVClustersQuery__
 *
 * To run a query within a React component, call `useVClustersQuery` and pass it any options that fit your needs.
 * When your component renders, `useVClustersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useVClustersQuery({
 *   variables: {
 *      parentId: // value for 'parentId'
 *      first: // value for 'first'
 *      after: // value for 'after'
 *      q: // value for 'q'
 *      healthy: // value for 'healthy'
 *      projectId: // value for 'projectId'
 *   },
 * });
 */
export function useVClustersQuery(baseOptions: Apollo.QueryHookOptions<VClustersQuery, VClustersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<VClustersQuery, VClustersQueryVariables>(VClustersDocument, options);
      }
export function useVClustersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<VClustersQuery, VClustersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<VClustersQuery, VClustersQueryVariables>(VClustersDocument, options);
        }
export function useVClustersSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<VClustersQuery, VClustersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<VClustersQuery, VClustersQueryVariables>(VClustersDocument, options);
        }
export type VClustersQueryHookResult = ReturnType<typeof useVClustersQuery>;
export type VClustersLazyQueryHookResult = ReturnType<typeof useVClustersLazyQuery>;
export type VClustersSuspenseQueryHookResult = ReturnType<typeof useVClustersSuspenseQuery>;
export type VClustersQueryResult = Apollo.QueryResult<VClustersQuery, VClustersQueryVariables>;
export const ClusterSelectorDocument = gql`
    query ClusterSelector($first: Int, $after: String, $q: String, $currentClusterId: ID, $projectId: ID) {
  clusters(first: $first, after: $after, q: $q, projectId: $projectId) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...ClusterTiny
      }
    }
  }
  cluster(id: $currentClusterId) {
    ...ClusterTiny
  }
}
    ${PageInfoFragmentDoc}
${ClusterTinyFragmentDoc}`;

/**
 * __useClusterSelectorQuery__
 *
 * To run a query within a React component, call `useClusterSelectorQuery` and pass it any options that fit your needs.
 * When your component renders, `useClusterSelectorQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClusterSelectorQuery({
 *   variables: {
 *      first: // value for 'first'
 *      after: // value for 'after'
 *      q: // value for 'q'
 *      currentClusterId: // value for 'currentClusterId'
 *      projectId: // value for 'projectId'
 *   },
 * });
 */
export function useClusterSelectorQuery(baseOptions?: Apollo.QueryHookOptions<ClusterSelectorQuery, ClusterSelectorQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClusterSelectorQuery, ClusterSelectorQueryVariables>(ClusterSelectorDocument, options);
      }
export function useClusterSelectorLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClusterSelectorQuery, ClusterSelectorQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClusterSelectorQuery, ClusterSelectorQueryVariables>(ClusterSelectorDocument, options);
        }
export function useClusterSelectorSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClusterSelectorQuery, ClusterSelectorQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClusterSelectorQuery, ClusterSelectorQueryVariables>(ClusterSelectorDocument, options);
        }
export type ClusterSelectorQueryHookResult = ReturnType<typeof useClusterSelectorQuery>;
export type ClusterSelectorLazyQueryHookResult = ReturnType<typeof useClusterSelectorLazyQuery>;
export type ClusterSelectorSuspenseQueryHookResult = ReturnType<typeof useClusterSelectorSuspenseQuery>;
export type ClusterSelectorQueryResult = Apollo.QueryResult<ClusterSelectorQuery, ClusterSelectorQueryVariables>;
export const ClusterDocument = gql`
    query Cluster($id: ID, $handle: String) {
  cluster(id: $id, handle: $handle) {
    ...Cluster
  }
}
    ${ClusterFragmentDoc}`;

/**
 * __useClusterQuery__
 *
 * To run a query within a React component, call `useClusterQuery` and pass it any options that fit your needs.
 * When your component renders, `useClusterQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClusterQuery({
 *   variables: {
 *      id: // value for 'id'
 *      handle: // value for 'handle'
 *   },
 * });
 */
export function useClusterQuery(baseOptions?: Apollo.QueryHookOptions<ClusterQuery, ClusterQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClusterQuery, ClusterQueryVariables>(ClusterDocument, options);
      }
export function useClusterLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClusterQuery, ClusterQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClusterQuery, ClusterQueryVariables>(ClusterDocument, options);
        }
export function useClusterSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClusterQuery, ClusterQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClusterQuery, ClusterQueryVariables>(ClusterDocument, options);
        }
export type ClusterQueryHookResult = ReturnType<typeof useClusterQuery>;
export type ClusterLazyQueryHookResult = ReturnType<typeof useClusterLazyQuery>;
export type ClusterSuspenseQueryHookResult = ReturnType<typeof useClusterSuspenseQuery>;
export type ClusterQueryResult = Apollo.QueryResult<ClusterQuery, ClusterQueryVariables>;
export const ClusterBasicDocument = gql`
    query ClusterBasic($id: ID!) {
  cluster(id: $id) {
    ...ClusterBasic
  }
}
    ${ClusterBasicFragmentDoc}`;

/**
 * __useClusterBasicQuery__
 *
 * To run a query within a React component, call `useClusterBasicQuery` and pass it any options that fit your needs.
 * When your component renders, `useClusterBasicQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClusterBasicQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useClusterBasicQuery(baseOptions: Apollo.QueryHookOptions<ClusterBasicQuery, ClusterBasicQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClusterBasicQuery, ClusterBasicQueryVariables>(ClusterBasicDocument, options);
      }
export function useClusterBasicLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClusterBasicQuery, ClusterBasicQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClusterBasicQuery, ClusterBasicQueryVariables>(ClusterBasicDocument, options);
        }
export function useClusterBasicSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClusterBasicQuery, ClusterBasicQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClusterBasicQuery, ClusterBasicQueryVariables>(ClusterBasicDocument, options);
        }
export type ClusterBasicQueryHookResult = ReturnType<typeof useClusterBasicQuery>;
export type ClusterBasicLazyQueryHookResult = ReturnType<typeof useClusterBasicLazyQuery>;
export type ClusterBasicSuspenseQueryHookResult = ReturnType<typeof useClusterBasicSuspenseQuery>;
export type ClusterBasicQueryResult = Apollo.QueryResult<ClusterBasicQuery, ClusterBasicQueryVariables>;
export const ClusterInsightDocument = gql`
    query ClusterInsight($id: ID!) {
  cluster(id: $id) {
    ...ClusterInsight
  }
}
    ${ClusterInsightFragmentDoc}`;

/**
 * __useClusterInsightQuery__
 *
 * To run a query within a React component, call `useClusterInsightQuery` and pass it any options that fit your needs.
 * When your component renders, `useClusterInsightQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClusterInsightQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useClusterInsightQuery(baseOptions: Apollo.QueryHookOptions<ClusterInsightQuery, ClusterInsightQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClusterInsightQuery, ClusterInsightQueryVariables>(ClusterInsightDocument, options);
      }
export function useClusterInsightLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClusterInsightQuery, ClusterInsightQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClusterInsightQuery, ClusterInsightQueryVariables>(ClusterInsightDocument, options);
        }
export function useClusterInsightSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClusterInsightQuery, ClusterInsightQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClusterInsightQuery, ClusterInsightQueryVariables>(ClusterInsightDocument, options);
        }
export type ClusterInsightQueryHookResult = ReturnType<typeof useClusterInsightQuery>;
export type ClusterInsightLazyQueryHookResult = ReturnType<typeof useClusterInsightLazyQuery>;
export type ClusterInsightSuspenseQueryHookResult = ReturnType<typeof useClusterInsightSuspenseQuery>;
export type ClusterInsightQueryResult = Apollo.QueryResult<ClusterInsightQuery, ClusterInsightQueryVariables>;
export const ClusterNodesDocument = gql`
    query ClusterNodes($id: ID!) {
  cluster(id: $id) {
    ...ClusterWithNodes
  }
}
    ${ClusterWithNodesFragmentDoc}`;

/**
 * __useClusterNodesQuery__
 *
 * To run a query within a React component, call `useClusterNodesQuery` and pass it any options that fit your needs.
 * When your component renders, `useClusterNodesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClusterNodesQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useClusterNodesQuery(baseOptions: Apollo.QueryHookOptions<ClusterNodesQuery, ClusterNodesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClusterNodesQuery, ClusterNodesQueryVariables>(ClusterNodesDocument, options);
      }
export function useClusterNodesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClusterNodesQuery, ClusterNodesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClusterNodesQuery, ClusterNodesQueryVariables>(ClusterNodesDocument, options);
        }
export function useClusterNodesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClusterNodesQuery, ClusterNodesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClusterNodesQuery, ClusterNodesQueryVariables>(ClusterNodesDocument, options);
        }
export type ClusterNodesQueryHookResult = ReturnType<typeof useClusterNodesQuery>;
export type ClusterNodesLazyQueryHookResult = ReturnType<typeof useClusterNodesLazyQuery>;
export type ClusterNodesSuspenseQueryHookResult = ReturnType<typeof useClusterNodesSuspenseQuery>;
export type ClusterNodesQueryResult = Apollo.QueryResult<ClusterNodesQuery, ClusterNodesQueryVariables>;
export const ClusterPodsDocument = gql`
    query ClusterPods($clusterId: ID, $namespace: String, $first: Int, $after: String, $before: String, $last: Int) {
  pods(
    first: $first
    after: $after
    before: $before
    last: $last
    clusterId: $clusterId
    namespace: $namespace
  ) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...Pod
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${PodFragmentDoc}`;

/**
 * __useClusterPodsQuery__
 *
 * To run a query within a React component, call `useClusterPodsQuery` and pass it any options that fit your needs.
 * When your component renders, `useClusterPodsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClusterPodsQuery({
 *   variables: {
 *      clusterId: // value for 'clusterId'
 *      namespace: // value for 'namespace'
 *      first: // value for 'first'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useClusterPodsQuery(baseOptions?: Apollo.QueryHookOptions<ClusterPodsQuery, ClusterPodsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClusterPodsQuery, ClusterPodsQueryVariables>(ClusterPodsDocument, options);
      }
export function useClusterPodsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClusterPodsQuery, ClusterPodsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClusterPodsQuery, ClusterPodsQueryVariables>(ClusterPodsDocument, options);
        }
export function useClusterPodsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClusterPodsQuery, ClusterPodsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClusterPodsQuery, ClusterPodsQueryVariables>(ClusterPodsDocument, options);
        }
export type ClusterPodsQueryHookResult = ReturnType<typeof useClusterPodsQuery>;
export type ClusterPodsLazyQueryHookResult = ReturnType<typeof useClusterPodsLazyQuery>;
export type ClusterPodsSuspenseQueryHookResult = ReturnType<typeof useClusterPodsSuspenseQuery>;
export type ClusterPodsQueryResult = Apollo.QueryResult<ClusterPodsQuery, ClusterPodsQueryVariables>;
export const ClusterNamespacesDocument = gql`
    query ClusterNamespaces($clusterId: ID) {
  namespaces(clusterId: $clusterId) {
    metadata {
      ...Metadata
    }
  }
}
    ${MetadataFragmentDoc}`;

/**
 * __useClusterNamespacesQuery__
 *
 * To run a query within a React component, call `useClusterNamespacesQuery` and pass it any options that fit your needs.
 * When your component renders, `useClusterNamespacesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClusterNamespacesQuery({
 *   variables: {
 *      clusterId: // value for 'clusterId'
 *   },
 * });
 */
export function useClusterNamespacesQuery(baseOptions?: Apollo.QueryHookOptions<ClusterNamespacesQuery, ClusterNamespacesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClusterNamespacesQuery, ClusterNamespacesQueryVariables>(ClusterNamespacesDocument, options);
      }
export function useClusterNamespacesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClusterNamespacesQuery, ClusterNamespacesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClusterNamespacesQuery, ClusterNamespacesQueryVariables>(ClusterNamespacesDocument, options);
        }
export function useClusterNamespacesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClusterNamespacesQuery, ClusterNamespacesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClusterNamespacesQuery, ClusterNamespacesQueryVariables>(ClusterNamespacesDocument, options);
        }
export type ClusterNamespacesQueryHookResult = ReturnType<typeof useClusterNamespacesQuery>;
export type ClusterNamespacesLazyQueryHookResult = ReturnType<typeof useClusterNamespacesLazyQuery>;
export type ClusterNamespacesSuspenseQueryHookResult = ReturnType<typeof useClusterNamespacesSuspenseQuery>;
export type ClusterNamespacesQueryResult = Apollo.QueryResult<ClusterNamespacesQuery, ClusterNamespacesQueryVariables>;
export const ClusterBindingsDocument = gql`
    query ClusterBindings($id: ID!) {
  cluster(id: $id) {
    ...ClusterBindings
  }
}
    ${ClusterBindingsFragmentDoc}`;

/**
 * __useClusterBindingsQuery__
 *
 * To run a query within a React component, call `useClusterBindingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useClusterBindingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClusterBindingsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useClusterBindingsQuery(baseOptions: Apollo.QueryHookOptions<ClusterBindingsQuery, ClusterBindingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClusterBindingsQuery, ClusterBindingsQueryVariables>(ClusterBindingsDocument, options);
      }
export function useClusterBindingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClusterBindingsQuery, ClusterBindingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClusterBindingsQuery, ClusterBindingsQueryVariables>(ClusterBindingsDocument, options);
        }
export function useClusterBindingsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClusterBindingsQuery, ClusterBindingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClusterBindingsQuery, ClusterBindingsQueryVariables>(ClusterBindingsDocument, options);
        }
export type ClusterBindingsQueryHookResult = ReturnType<typeof useClusterBindingsQuery>;
export type ClusterBindingsLazyQueryHookResult = ReturnType<typeof useClusterBindingsLazyQuery>;
export type ClusterBindingsSuspenseQueryHookResult = ReturnType<typeof useClusterBindingsSuspenseQuery>;
export type ClusterBindingsQueryResult = Apollo.QueryResult<ClusterBindingsQuery, ClusterBindingsQueryVariables>;
export const RuntimeServicesDocument = gql`
    query RuntimeServices($id: ID!, $kubeVersion: String!, $hasKubeVersion: Boolean!) {
  cluster(id: $id) {
    ...ClusterRuntimeServices
  }
}
    ${ClusterRuntimeServicesFragmentDoc}`;

/**
 * __useRuntimeServicesQuery__
 *
 * To run a query within a React component, call `useRuntimeServicesQuery` and pass it any options that fit your needs.
 * When your component renders, `useRuntimeServicesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRuntimeServicesQuery({
 *   variables: {
 *      id: // value for 'id'
 *      kubeVersion: // value for 'kubeVersion'
 *      hasKubeVersion: // value for 'hasKubeVersion'
 *   },
 * });
 */
export function useRuntimeServicesQuery(baseOptions: Apollo.QueryHookOptions<RuntimeServicesQuery, RuntimeServicesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RuntimeServicesQuery, RuntimeServicesQueryVariables>(RuntimeServicesDocument, options);
      }
export function useRuntimeServicesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RuntimeServicesQuery, RuntimeServicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RuntimeServicesQuery, RuntimeServicesQueryVariables>(RuntimeServicesDocument, options);
        }
export function useRuntimeServicesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<RuntimeServicesQuery, RuntimeServicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<RuntimeServicesQuery, RuntimeServicesQueryVariables>(RuntimeServicesDocument, options);
        }
export type RuntimeServicesQueryHookResult = ReturnType<typeof useRuntimeServicesQuery>;
export type RuntimeServicesLazyQueryHookResult = ReturnType<typeof useRuntimeServicesLazyQuery>;
export type RuntimeServicesSuspenseQueryHookResult = ReturnType<typeof useRuntimeServicesSuspenseQuery>;
export type RuntimeServicesQueryResult = Apollo.QueryResult<RuntimeServicesQuery, RuntimeServicesQueryVariables>;
export const RuntimeServiceDocument = gql`
    query RuntimeService($id: ID!, $version: String!, $kubeVersion: String!, $hasKubeVersion: Boolean!) {
  runtimeService(id: $id) {
    ...RuntimeServiceDetails
  }
}
    ${RuntimeServiceDetailsFragmentDoc}`;

/**
 * __useRuntimeServiceQuery__
 *
 * To run a query within a React component, call `useRuntimeServiceQuery` and pass it any options that fit your needs.
 * When your component renders, `useRuntimeServiceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRuntimeServiceQuery({
 *   variables: {
 *      id: // value for 'id'
 *      version: // value for 'version'
 *      kubeVersion: // value for 'kubeVersion'
 *      hasKubeVersion: // value for 'hasKubeVersion'
 *   },
 * });
 */
export function useRuntimeServiceQuery(baseOptions: Apollo.QueryHookOptions<RuntimeServiceQuery, RuntimeServiceQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RuntimeServiceQuery, RuntimeServiceQueryVariables>(RuntimeServiceDocument, options);
      }
export function useRuntimeServiceLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RuntimeServiceQuery, RuntimeServiceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RuntimeServiceQuery, RuntimeServiceQueryVariables>(RuntimeServiceDocument, options);
        }
export function useRuntimeServiceSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<RuntimeServiceQuery, RuntimeServiceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<RuntimeServiceQuery, RuntimeServiceQueryVariables>(RuntimeServiceDocument, options);
        }
export type RuntimeServiceQueryHookResult = ReturnType<typeof useRuntimeServiceQuery>;
export type RuntimeServiceLazyQueryHookResult = ReturnType<typeof useRuntimeServiceLazyQuery>;
export type RuntimeServiceSuspenseQueryHookResult = ReturnType<typeof useRuntimeServiceSuspenseQuery>;
export type RuntimeServiceQueryResult = Apollo.QueryResult<RuntimeServiceQuery, RuntimeServiceQueryVariables>;
export const UpdateClusterBindingsDocument = gql`
    mutation UpdateClusterBindings($id: ID!, $rbac: RbacAttributes!) {
  updateRbac(clusterId: $id, rbac: $rbac)
}
    `;
export type UpdateClusterBindingsMutationFn = Apollo.MutationFunction<UpdateClusterBindingsMutation, UpdateClusterBindingsMutationVariables>;

/**
 * __useUpdateClusterBindingsMutation__
 *
 * To run a mutation, you first call `useUpdateClusterBindingsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateClusterBindingsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateClusterBindingsMutation, { data, loading, error }] = useUpdateClusterBindingsMutation({
 *   variables: {
 *      id: // value for 'id'
 *      rbac: // value for 'rbac'
 *   },
 * });
 */
export function useUpdateClusterBindingsMutation(baseOptions?: Apollo.MutationHookOptions<UpdateClusterBindingsMutation, UpdateClusterBindingsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateClusterBindingsMutation, UpdateClusterBindingsMutationVariables>(UpdateClusterBindingsDocument, options);
      }
export type UpdateClusterBindingsMutationHookResult = ReturnType<typeof useUpdateClusterBindingsMutation>;
export type UpdateClusterBindingsMutationResult = Apollo.MutationResult<UpdateClusterBindingsMutation>;
export type UpdateClusterBindingsMutationOptions = Apollo.BaseMutationOptions<UpdateClusterBindingsMutation, UpdateClusterBindingsMutationVariables>;
export const UpdateClusterDocument = gql`
    mutation UpdateCluster($id: ID!, $attributes: ClusterUpdateAttributes!) {
  updateCluster(id: $id, attributes: $attributes) {
    ...Cluster
  }
}
    ${ClusterFragmentDoc}`;
export type UpdateClusterMutationFn = Apollo.MutationFunction<UpdateClusterMutation, UpdateClusterMutationVariables>;

/**
 * __useUpdateClusterMutation__
 *
 * To run a mutation, you first call `useUpdateClusterMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateClusterMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateClusterMutation, { data, loading, error }] = useUpdateClusterMutation({
 *   variables: {
 *      id: // value for 'id'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpdateClusterMutation(baseOptions?: Apollo.MutationHookOptions<UpdateClusterMutation, UpdateClusterMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateClusterMutation, UpdateClusterMutationVariables>(UpdateClusterDocument, options);
      }
export type UpdateClusterMutationHookResult = ReturnType<typeof useUpdateClusterMutation>;
export type UpdateClusterMutationResult = Apollo.MutationResult<UpdateClusterMutation>;
export type UpdateClusterMutationOptions = Apollo.BaseMutationOptions<UpdateClusterMutation, UpdateClusterMutationVariables>;
export const CreateClusterDocument = gql`
    mutation CreateCluster($attributes: ClusterAttributes!) {
  createCluster(attributes: $attributes) {
    ...Cluster
    deployToken
  }
}
    ${ClusterFragmentDoc}`;
export type CreateClusterMutationFn = Apollo.MutationFunction<CreateClusterMutation, CreateClusterMutationVariables>;

/**
 * __useCreateClusterMutation__
 *
 * To run a mutation, you first call `useCreateClusterMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateClusterMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createClusterMutation, { data, loading, error }] = useCreateClusterMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useCreateClusterMutation(baseOptions?: Apollo.MutationHookOptions<CreateClusterMutation, CreateClusterMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateClusterMutation, CreateClusterMutationVariables>(CreateClusterDocument, options);
      }
export type CreateClusterMutationHookResult = ReturnType<typeof useCreateClusterMutation>;
export type CreateClusterMutationResult = Apollo.MutationResult<CreateClusterMutation>;
export type CreateClusterMutationOptions = Apollo.BaseMutationOptions<CreateClusterMutation, CreateClusterMutationVariables>;
export const DeleteClusterDocument = gql`
    mutation DeleteCluster($id: ID!) {
  deleteCluster(id: $id) {
    ...Cluster
  }
}
    ${ClusterFragmentDoc}`;
export type DeleteClusterMutationFn = Apollo.MutationFunction<DeleteClusterMutation, DeleteClusterMutationVariables>;

/**
 * __useDeleteClusterMutation__
 *
 * To run a mutation, you first call `useDeleteClusterMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteClusterMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteClusterMutation, { data, loading, error }] = useDeleteClusterMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteClusterMutation(baseOptions?: Apollo.MutationHookOptions<DeleteClusterMutation, DeleteClusterMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteClusterMutation, DeleteClusterMutationVariables>(DeleteClusterDocument, options);
      }
export type DeleteClusterMutationHookResult = ReturnType<typeof useDeleteClusterMutation>;
export type DeleteClusterMutationResult = Apollo.MutationResult<DeleteClusterMutation>;
export type DeleteClusterMutationOptions = Apollo.BaseMutationOptions<DeleteClusterMutation, DeleteClusterMutationVariables>;
export const DetachClusterDocument = gql`
    mutation DetachCluster($id: ID!) {
  detachCluster(id: $id) {
    ...Cluster
  }
}
    ${ClusterFragmentDoc}`;
export type DetachClusterMutationFn = Apollo.MutationFunction<DetachClusterMutation, DetachClusterMutationVariables>;

/**
 * __useDetachClusterMutation__
 *
 * To run a mutation, you first call `useDetachClusterMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDetachClusterMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [detachClusterMutation, { data, loading, error }] = useDetachClusterMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDetachClusterMutation(baseOptions?: Apollo.MutationHookOptions<DetachClusterMutation, DetachClusterMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DetachClusterMutation, DetachClusterMutationVariables>(DetachClusterDocument, options);
      }
export type DetachClusterMutationHookResult = ReturnType<typeof useDetachClusterMutation>;
export type DetachClusterMutationResult = Apollo.MutationResult<DetachClusterMutation>;
export type DetachClusterMutationOptions = Apollo.BaseMutationOptions<DetachClusterMutation, DetachClusterMutationVariables>;
export const ClusterStatusesDocument = gql`
    query ClusterStatuses {
  clusterStatuses {
    ...ClusterStatusInfo
  }
}
    ${ClusterStatusInfoFragmentDoc}`;

/**
 * __useClusterStatusesQuery__
 *
 * To run a query within a React component, call `useClusterStatusesQuery` and pass it any options that fit your needs.
 * When your component renders, `useClusterStatusesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClusterStatusesQuery({
 *   variables: {
 *   },
 * });
 */
export function useClusterStatusesQuery(baseOptions?: Apollo.QueryHookOptions<ClusterStatusesQuery, ClusterStatusesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClusterStatusesQuery, ClusterStatusesQueryVariables>(ClusterStatusesDocument, options);
      }
export function useClusterStatusesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClusterStatusesQuery, ClusterStatusesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClusterStatusesQuery, ClusterStatusesQueryVariables>(ClusterStatusesDocument, options);
        }
export function useClusterStatusesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClusterStatusesQuery, ClusterStatusesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClusterStatusesQuery, ClusterStatusesQueryVariables>(ClusterStatusesDocument, options);
        }
export type ClusterStatusesQueryHookResult = ReturnType<typeof useClusterStatusesQuery>;
export type ClusterStatusesLazyQueryHookResult = ReturnType<typeof useClusterStatusesLazyQuery>;
export type ClusterStatusesSuspenseQueryHookResult = ReturnType<typeof useClusterStatusesSuspenseQuery>;
export type ClusterStatusesQueryResult = Apollo.QueryResult<ClusterStatusesQuery, ClusterStatusesQueryVariables>;
export const TagPairsDocument = gql`
    query TagPairs($first: Int = 30, $q: String, $tag: String, $type: TagType) {
  tagPairs(first: $first, q: $q, tag: $tag, type: $type) {
    edges {
      node {
        name
        value
        id
      }
    }
  }
}
    `;

/**
 * __useTagPairsQuery__
 *
 * To run a query within a React component, call `useTagPairsQuery` and pass it any options that fit your needs.
 * When your component renders, `useTagPairsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTagPairsQuery({
 *   variables: {
 *      first: // value for 'first'
 *      q: // value for 'q'
 *      tag: // value for 'tag'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useTagPairsQuery(baseOptions?: Apollo.QueryHookOptions<TagPairsQuery, TagPairsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TagPairsQuery, TagPairsQueryVariables>(TagPairsDocument, options);
      }
export function useTagPairsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TagPairsQuery, TagPairsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TagPairsQuery, TagPairsQueryVariables>(TagPairsDocument, options);
        }
export function useTagPairsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<TagPairsQuery, TagPairsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<TagPairsQuery, TagPairsQueryVariables>(TagPairsDocument, options);
        }
export type TagPairsQueryHookResult = ReturnType<typeof useTagPairsQuery>;
export type TagPairsLazyQueryHookResult = ReturnType<typeof useTagPairsLazyQuery>;
export type TagPairsSuspenseQueryHookResult = ReturnType<typeof useTagPairsSuspenseQuery>;
export type TagPairsQueryResult = Apollo.QueryResult<TagPairsQuery, TagPairsQueryVariables>;
export const ClusterMetricsDocument = gql`
    query ClusterMetrics($clusterId: ID!, $start: DateTime, $stop: DateTime, $step: String) {
  cluster(id: $clusterId) {
    ...ClusterWithMetrics
  }
}
    ${ClusterWithMetricsFragmentDoc}`;

/**
 * __useClusterMetricsQuery__
 *
 * To run a query within a React component, call `useClusterMetricsQuery` and pass it any options that fit your needs.
 * When your component renders, `useClusterMetricsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClusterMetricsQuery({
 *   variables: {
 *      clusterId: // value for 'clusterId'
 *      start: // value for 'start'
 *      stop: // value for 'stop'
 *      step: // value for 'step'
 *   },
 * });
 */
export function useClusterMetricsQuery(baseOptions: Apollo.QueryHookOptions<ClusterMetricsQuery, ClusterMetricsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClusterMetricsQuery, ClusterMetricsQueryVariables>(ClusterMetricsDocument, options);
      }
export function useClusterMetricsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClusterMetricsQuery, ClusterMetricsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClusterMetricsQuery, ClusterMetricsQueryVariables>(ClusterMetricsDocument, options);
        }
export function useClusterMetricsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClusterMetricsQuery, ClusterMetricsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClusterMetricsQuery, ClusterMetricsQueryVariables>(ClusterMetricsDocument, options);
        }
export type ClusterMetricsQueryHookResult = ReturnType<typeof useClusterMetricsQuery>;
export type ClusterMetricsLazyQueryHookResult = ReturnType<typeof useClusterMetricsLazyQuery>;
export type ClusterMetricsSuspenseQueryHookResult = ReturnType<typeof useClusterMetricsSuspenseQuery>;
export type ClusterMetricsQueryResult = Apollo.QueryResult<ClusterMetricsQuery, ClusterMetricsQueryVariables>;
export const ClusterNodeMetricsDocument = gql`
    query ClusterNodeMetrics($clusterId: ID!, $node: String!, $start: DateTime, $stop: DateTime, $step: String) {
  cluster(id: $clusterId) {
    ...ClusterNodeMetrics
  }
}
    ${ClusterNodeMetricsFragmentDoc}`;

/**
 * __useClusterNodeMetricsQuery__
 *
 * To run a query within a React component, call `useClusterNodeMetricsQuery` and pass it any options that fit your needs.
 * When your component renders, `useClusterNodeMetricsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClusterNodeMetricsQuery({
 *   variables: {
 *      clusterId: // value for 'clusterId'
 *      node: // value for 'node'
 *      start: // value for 'start'
 *      stop: // value for 'stop'
 *      step: // value for 'step'
 *   },
 * });
 */
export function useClusterNodeMetricsQuery(baseOptions: Apollo.QueryHookOptions<ClusterNodeMetricsQuery, ClusterNodeMetricsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClusterNodeMetricsQuery, ClusterNodeMetricsQueryVariables>(ClusterNodeMetricsDocument, options);
      }
export function useClusterNodeMetricsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClusterNodeMetricsQuery, ClusterNodeMetricsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClusterNodeMetricsQuery, ClusterNodeMetricsQueryVariables>(ClusterNodeMetricsDocument, options);
        }
export function useClusterNodeMetricsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClusterNodeMetricsQuery, ClusterNodeMetricsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClusterNodeMetricsQuery, ClusterNodeMetricsQueryVariables>(ClusterNodeMetricsDocument, options);
        }
export type ClusterNodeMetricsQueryHookResult = ReturnType<typeof useClusterNodeMetricsQuery>;
export type ClusterNodeMetricsLazyQueryHookResult = ReturnType<typeof useClusterNodeMetricsLazyQuery>;
export type ClusterNodeMetricsSuspenseQueryHookResult = ReturnType<typeof useClusterNodeMetricsSuspenseQuery>;
export type ClusterNodeMetricsQueryResult = Apollo.QueryResult<ClusterNodeMetricsQuery, ClusterNodeMetricsQueryVariables>;
export const ClusterNetworkGraphDocument = gql`
    query ClusterNetworkGraph($clusterId: ID!, $time: DateTime) {
  cluster(id: $clusterId) {
    id
    networkGraph(time: $time) {
      ...NetworkMeshEdge
    }
  }
}
    ${NetworkMeshEdgeFragmentDoc}`;

/**
 * __useClusterNetworkGraphQuery__
 *
 * To run a query within a React component, call `useClusterNetworkGraphQuery` and pass it any options that fit your needs.
 * When your component renders, `useClusterNetworkGraphQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClusterNetworkGraphQuery({
 *   variables: {
 *      clusterId: // value for 'clusterId'
 *      time: // value for 'time'
 *   },
 * });
 */
export function useClusterNetworkGraphQuery(baseOptions: Apollo.QueryHookOptions<ClusterNetworkGraphQuery, ClusterNetworkGraphQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClusterNetworkGraphQuery, ClusterNetworkGraphQueryVariables>(ClusterNetworkGraphDocument, options);
      }
export function useClusterNetworkGraphLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClusterNetworkGraphQuery, ClusterNetworkGraphQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClusterNetworkGraphQuery, ClusterNetworkGraphQueryVariables>(ClusterNetworkGraphDocument, options);
        }
export function useClusterNetworkGraphSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClusterNetworkGraphQuery, ClusterNetworkGraphQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClusterNetworkGraphQuery, ClusterNetworkGraphQueryVariables>(ClusterNetworkGraphDocument, options);
        }
export type ClusterNetworkGraphQueryHookResult = ReturnType<typeof useClusterNetworkGraphQuery>;
export type ClusterNetworkGraphLazyQueryHookResult = ReturnType<typeof useClusterNetworkGraphLazyQuery>;
export type ClusterNetworkGraphSuspenseQueryHookResult = ReturnType<typeof useClusterNetworkGraphSuspenseQuery>;
export type ClusterNetworkGraphQueryResult = Apollo.QueryResult<ClusterNetworkGraphQuery, ClusterNetworkGraphQueryVariables>;
export const ServiceDeploymentComponentMetricsDocument = gql`
    query ServiceDeploymentComponentMetrics($id: ID, $name: String, $cluster: String, $componentId: ID!, $start: DateTime, $stop: DateTime, $step: String) {
  serviceDeployment(id: $id, name: $name, cluster: $cluster) {
    ...ComponentMetricsFragment
  }
}
    ${ComponentMetricsFragmentFragmentDoc}`;

/**
 * __useServiceDeploymentComponentMetricsQuery__
 *
 * To run a query within a React component, call `useServiceDeploymentComponentMetricsQuery` and pass it any options that fit your needs.
 * When your component renders, `useServiceDeploymentComponentMetricsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useServiceDeploymentComponentMetricsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      cluster: // value for 'cluster'
 *      componentId: // value for 'componentId'
 *      start: // value for 'start'
 *      stop: // value for 'stop'
 *      step: // value for 'step'
 *   },
 * });
 */
export function useServiceDeploymentComponentMetricsQuery(baseOptions: Apollo.QueryHookOptions<ServiceDeploymentComponentMetricsQuery, ServiceDeploymentComponentMetricsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ServiceDeploymentComponentMetricsQuery, ServiceDeploymentComponentMetricsQueryVariables>(ServiceDeploymentComponentMetricsDocument, options);
      }
export function useServiceDeploymentComponentMetricsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ServiceDeploymentComponentMetricsQuery, ServiceDeploymentComponentMetricsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ServiceDeploymentComponentMetricsQuery, ServiceDeploymentComponentMetricsQueryVariables>(ServiceDeploymentComponentMetricsDocument, options);
        }
export function useServiceDeploymentComponentMetricsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ServiceDeploymentComponentMetricsQuery, ServiceDeploymentComponentMetricsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ServiceDeploymentComponentMetricsQuery, ServiceDeploymentComponentMetricsQueryVariables>(ServiceDeploymentComponentMetricsDocument, options);
        }
export type ServiceDeploymentComponentMetricsQueryHookResult = ReturnType<typeof useServiceDeploymentComponentMetricsQuery>;
export type ServiceDeploymentComponentMetricsLazyQueryHookResult = ReturnType<typeof useServiceDeploymentComponentMetricsLazyQuery>;
export type ServiceDeploymentComponentMetricsSuspenseQueryHookResult = ReturnType<typeof useServiceDeploymentComponentMetricsSuspenseQuery>;
export type ServiceDeploymentComponentMetricsQueryResult = Apollo.QueryResult<ServiceDeploymentComponentMetricsQuery, ServiceDeploymentComponentMetricsQueryVariables>;
export const UsageDocument = gql`
    query Usage($cpu: String!, $mem: String!, $podCpu: String!, $podMem: String!, $step: String!, $offset: Int!, $clusterId: ID) {
  cpu: metric(clusterId: $clusterId, query: $cpu, offset: $offset, step: $step) {
    ...MetricResponse
  }
  mem: metric(clusterId: $clusterId, query: $mem, offset: $offset, step: $step) {
    ...MetricResponse
  }
  podCpu: metric(
    clusterId: $clusterId
    query: $podCpu
    offset: $offset
    step: $step
  ) {
    ...MetricResponse
  }
  podMem: metric(
    clusterId: $clusterId
    query: $podMem
    offset: $offset
    step: $step
  ) {
    ...MetricResponse
  }
}
    ${MetricResponseFragmentDoc}`;

/**
 * __useUsageQuery__
 *
 * To run a query within a React component, call `useUsageQuery` and pass it any options that fit your needs.
 * When your component renders, `useUsageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUsageQuery({
 *   variables: {
 *      cpu: // value for 'cpu'
 *      mem: // value for 'mem'
 *      podCpu: // value for 'podCpu'
 *      podMem: // value for 'podMem'
 *      step: // value for 'step'
 *      offset: // value for 'offset'
 *      clusterId: // value for 'clusterId'
 *   },
 * });
 */
export function useUsageQuery(baseOptions: Apollo.QueryHookOptions<UsageQuery, UsageQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UsageQuery, UsageQueryVariables>(UsageDocument, options);
      }
export function useUsageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UsageQuery, UsageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UsageQuery, UsageQueryVariables>(UsageDocument, options);
        }
export function useUsageSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<UsageQuery, UsageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<UsageQuery, UsageQueryVariables>(UsageDocument, options);
        }
export type UsageQueryHookResult = ReturnType<typeof useUsageQuery>;
export type UsageLazyQueryHookResult = ReturnType<typeof useUsageLazyQuery>;
export type UsageSuspenseQueryHookResult = ReturnType<typeof useUsageSuspenseQuery>;
export type UsageQueryResult = Apollo.QueryResult<UsageQuery, UsageQueryVariables>;
export const GitRepositoriesDocument = gql`
    query GitRepositories {
  gitRepositories(first: 100) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...GitRepository
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${GitRepositoryFragmentDoc}`;

/**
 * __useGitRepositoriesQuery__
 *
 * To run a query within a React component, call `useGitRepositoriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGitRepositoriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGitRepositoriesQuery({
 *   variables: {
 *   },
 * });
 */
export function useGitRepositoriesQuery(baseOptions?: Apollo.QueryHookOptions<GitRepositoriesQuery, GitRepositoriesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GitRepositoriesQuery, GitRepositoriesQueryVariables>(GitRepositoriesDocument, options);
      }
export function useGitRepositoriesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GitRepositoriesQuery, GitRepositoriesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GitRepositoriesQuery, GitRepositoriesQueryVariables>(GitRepositoriesDocument, options);
        }
export function useGitRepositoriesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GitRepositoriesQuery, GitRepositoriesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GitRepositoriesQuery, GitRepositoriesQueryVariables>(GitRepositoriesDocument, options);
        }
export type GitRepositoriesQueryHookResult = ReturnType<typeof useGitRepositoriesQuery>;
export type GitRepositoriesLazyQueryHookResult = ReturnType<typeof useGitRepositoriesLazyQuery>;
export type GitRepositoriesSuspenseQueryHookResult = ReturnType<typeof useGitRepositoriesSuspenseQuery>;
export type GitRepositoriesQueryResult = Apollo.QueryResult<GitRepositoriesQuery, GitRepositoriesQueryVariables>;
export const HelmRepositoriesDocument = gql`
    query HelmRepositories {
  helmRepositories(first: 100) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...HelmRepository
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${HelmRepositoryFragmentDoc}`;

/**
 * __useHelmRepositoriesQuery__
 *
 * To run a query within a React component, call `useHelmRepositoriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useHelmRepositoriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useHelmRepositoriesQuery({
 *   variables: {
 *   },
 * });
 */
export function useHelmRepositoriesQuery(baseOptions?: Apollo.QueryHookOptions<HelmRepositoriesQuery, HelmRepositoriesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<HelmRepositoriesQuery, HelmRepositoriesQueryVariables>(HelmRepositoriesDocument, options);
      }
export function useHelmRepositoriesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<HelmRepositoriesQuery, HelmRepositoriesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<HelmRepositoriesQuery, HelmRepositoriesQueryVariables>(HelmRepositoriesDocument, options);
        }
export function useHelmRepositoriesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<HelmRepositoriesQuery, HelmRepositoriesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<HelmRepositoriesQuery, HelmRepositoriesQueryVariables>(HelmRepositoriesDocument, options);
        }
export type HelmRepositoriesQueryHookResult = ReturnType<typeof useHelmRepositoriesQuery>;
export type HelmRepositoriesLazyQueryHookResult = ReturnType<typeof useHelmRepositoriesLazyQuery>;
export type HelmRepositoriesSuspenseQueryHookResult = ReturnType<typeof useHelmRepositoriesSuspenseQuery>;
export type HelmRepositoriesQueryResult = Apollo.QueryResult<HelmRepositoriesQuery, HelmRepositoriesQueryVariables>;
export const FluxHelmRepositoriesDocument = gql`
    query FluxHelmRepositories {
  fluxHelmRepositories {
    ...FluxHelmRepository
  }
}
    ${FluxHelmRepositoryFragmentDoc}`;

/**
 * __useFluxHelmRepositoriesQuery__
 *
 * To run a query within a React component, call `useFluxHelmRepositoriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useFluxHelmRepositoriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFluxHelmRepositoriesQuery({
 *   variables: {
 *   },
 * });
 */
export function useFluxHelmRepositoriesQuery(baseOptions?: Apollo.QueryHookOptions<FluxHelmRepositoriesQuery, FluxHelmRepositoriesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FluxHelmRepositoriesQuery, FluxHelmRepositoriesQueryVariables>(FluxHelmRepositoriesDocument, options);
      }
export function useFluxHelmRepositoriesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FluxHelmRepositoriesQuery, FluxHelmRepositoriesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FluxHelmRepositoriesQuery, FluxHelmRepositoriesQueryVariables>(FluxHelmRepositoriesDocument, options);
        }
export function useFluxHelmRepositoriesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<FluxHelmRepositoriesQuery, FluxHelmRepositoriesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<FluxHelmRepositoriesQuery, FluxHelmRepositoriesQueryVariables>(FluxHelmRepositoriesDocument, options);
        }
export type FluxHelmRepositoriesQueryHookResult = ReturnType<typeof useFluxHelmRepositoriesQuery>;
export type FluxHelmRepositoriesLazyQueryHookResult = ReturnType<typeof useFluxHelmRepositoriesLazyQuery>;
export type FluxHelmRepositoriesSuspenseQueryHookResult = ReturnType<typeof useFluxHelmRepositoriesSuspenseQuery>;
export type FluxHelmRepositoriesQueryResult = Apollo.QueryResult<FluxHelmRepositoriesQuery, FluxHelmRepositoriesQueryVariables>;
export const FluxHelmRepositoryDocument = gql`
    query FluxHelmRepository($namespace: String!, $name: String!) {
  fluxHelmRepository(namespace: $namespace, name: $name) {
    ...FluxHelmRepository
    charts {
      name
      versions {
        ...HelmChartVersion
      }
    }
  }
}
    ${FluxHelmRepositoryFragmentDoc}
${HelmChartVersionFragmentDoc}`;

/**
 * __useFluxHelmRepositoryQuery__
 *
 * To run a query within a React component, call `useFluxHelmRepositoryQuery` and pass it any options that fit your needs.
 * When your component renders, `useFluxHelmRepositoryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFluxHelmRepositoryQuery({
 *   variables: {
 *      namespace: // value for 'namespace'
 *      name: // value for 'name'
 *   },
 * });
 */
export function useFluxHelmRepositoryQuery(baseOptions: Apollo.QueryHookOptions<FluxHelmRepositoryQuery, FluxHelmRepositoryQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FluxHelmRepositoryQuery, FluxHelmRepositoryQueryVariables>(FluxHelmRepositoryDocument, options);
      }
export function useFluxHelmRepositoryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FluxHelmRepositoryQuery, FluxHelmRepositoryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FluxHelmRepositoryQuery, FluxHelmRepositoryQueryVariables>(FluxHelmRepositoryDocument, options);
        }
export function useFluxHelmRepositorySuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<FluxHelmRepositoryQuery, FluxHelmRepositoryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<FluxHelmRepositoryQuery, FluxHelmRepositoryQueryVariables>(FluxHelmRepositoryDocument, options);
        }
export type FluxHelmRepositoryQueryHookResult = ReturnType<typeof useFluxHelmRepositoryQuery>;
export type FluxHelmRepositoryLazyQueryHookResult = ReturnType<typeof useFluxHelmRepositoryLazyQuery>;
export type FluxHelmRepositorySuspenseQueryHookResult = ReturnType<typeof useFluxHelmRepositorySuspenseQuery>;
export type FluxHelmRepositoryQueryResult = Apollo.QueryResult<FluxHelmRepositoryQuery, FluxHelmRepositoryQueryVariables>;
export const GitRepositoryDocument = gql`
    query GitRepository($id: ID!) {
  gitRepository(id: $id) {
    refs
  }
}
    `;

/**
 * __useGitRepositoryQuery__
 *
 * To run a query within a React component, call `useGitRepositoryQuery` and pass it any options that fit your needs.
 * When your component renders, `useGitRepositoryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGitRepositoryQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGitRepositoryQuery(baseOptions: Apollo.QueryHookOptions<GitRepositoryQuery, GitRepositoryQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GitRepositoryQuery, GitRepositoryQueryVariables>(GitRepositoryDocument, options);
      }
export function useGitRepositoryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GitRepositoryQuery, GitRepositoryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GitRepositoryQuery, GitRepositoryQueryVariables>(GitRepositoryDocument, options);
        }
export function useGitRepositorySuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GitRepositoryQuery, GitRepositoryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GitRepositoryQuery, GitRepositoryQueryVariables>(GitRepositoryDocument, options);
        }
export type GitRepositoryQueryHookResult = ReturnType<typeof useGitRepositoryQuery>;
export type GitRepositoryLazyQueryHookResult = ReturnType<typeof useGitRepositoryLazyQuery>;
export type GitRepositorySuspenseQueryHookResult = ReturnType<typeof useGitRepositorySuspenseQuery>;
export type GitRepositoryQueryResult = Apollo.QueryResult<GitRepositoryQuery, GitRepositoryQueryVariables>;
export const CreateGitRepositoryDocument = gql`
    mutation CreateGitRepository($attributes: GitAttributes!) {
  createGitRepository(attributes: $attributes) {
    ...GitRepository
  }
}
    ${GitRepositoryFragmentDoc}`;
export type CreateGitRepositoryMutationFn = Apollo.MutationFunction<CreateGitRepositoryMutation, CreateGitRepositoryMutationVariables>;

/**
 * __useCreateGitRepositoryMutation__
 *
 * To run a mutation, you first call `useCreateGitRepositoryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateGitRepositoryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createGitRepositoryMutation, { data, loading, error }] = useCreateGitRepositoryMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useCreateGitRepositoryMutation(baseOptions?: Apollo.MutationHookOptions<CreateGitRepositoryMutation, CreateGitRepositoryMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateGitRepositoryMutation, CreateGitRepositoryMutationVariables>(CreateGitRepositoryDocument, options);
      }
export type CreateGitRepositoryMutationHookResult = ReturnType<typeof useCreateGitRepositoryMutation>;
export type CreateGitRepositoryMutationResult = Apollo.MutationResult<CreateGitRepositoryMutation>;
export type CreateGitRepositoryMutationOptions = Apollo.BaseMutationOptions<CreateGitRepositoryMutation, CreateGitRepositoryMutationVariables>;
export const DeleteGitRepositoryDocument = gql`
    mutation DeleteGitRepository($id: ID!) {
  deleteGitRepository(id: $id) {
    id
  }
}
    `;
export type DeleteGitRepositoryMutationFn = Apollo.MutationFunction<DeleteGitRepositoryMutation, DeleteGitRepositoryMutationVariables>;

/**
 * __useDeleteGitRepositoryMutation__
 *
 * To run a mutation, you first call `useDeleteGitRepositoryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteGitRepositoryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteGitRepositoryMutation, { data, loading, error }] = useDeleteGitRepositoryMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteGitRepositoryMutation(baseOptions?: Apollo.MutationHookOptions<DeleteGitRepositoryMutation, DeleteGitRepositoryMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteGitRepositoryMutation, DeleteGitRepositoryMutationVariables>(DeleteGitRepositoryDocument, options);
      }
export type DeleteGitRepositoryMutationHookResult = ReturnType<typeof useDeleteGitRepositoryMutation>;
export type DeleteGitRepositoryMutationResult = Apollo.MutationResult<DeleteGitRepositoryMutation>;
export type DeleteGitRepositoryMutationOptions = Apollo.BaseMutationOptions<DeleteGitRepositoryMutation, DeleteGitRepositoryMutationVariables>;
export const UpdateGitRepositoryDocument = gql`
    mutation UpdateGitRepository($id: ID!, $attributes: GitAttributes!) {
  updateGitRepository(id: $id, attributes: $attributes) {
    ...GitRepository
  }
}
    ${GitRepositoryFragmentDoc}`;
export type UpdateGitRepositoryMutationFn = Apollo.MutationFunction<UpdateGitRepositoryMutation, UpdateGitRepositoryMutationVariables>;

/**
 * __useUpdateGitRepositoryMutation__
 *
 * To run a mutation, you first call `useUpdateGitRepositoryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateGitRepositoryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateGitRepositoryMutation, { data, loading, error }] = useUpdateGitRepositoryMutation({
 *   variables: {
 *      id: // value for 'id'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpdateGitRepositoryMutation(baseOptions?: Apollo.MutationHookOptions<UpdateGitRepositoryMutation, UpdateGitRepositoryMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateGitRepositoryMutation, UpdateGitRepositoryMutationVariables>(UpdateGitRepositoryDocument, options);
      }
export type UpdateGitRepositoryMutationHookResult = ReturnType<typeof useUpdateGitRepositoryMutation>;
export type UpdateGitRepositoryMutationResult = Apollo.MutationResult<UpdateGitRepositoryMutation>;
export type UpdateGitRepositoryMutationOptions = Apollo.BaseMutationOptions<UpdateGitRepositoryMutation, UpdateGitRepositoryMutationVariables>;
export const CreateGlobalServiceDocument = gql`
    mutation CreateGlobalService($attributes: GlobalServiceAttributes!, $cluster: String, $name: String, $serviceId: ID) {
  createGlobalService(
    attributes: $attributes
    cluster: $cluster
    name: $name
    serviceId: $serviceId
  ) {
    ...GlobalService
  }
}
    ${GlobalServiceFragmentDoc}`;
export type CreateGlobalServiceMutationFn = Apollo.MutationFunction<CreateGlobalServiceMutation, CreateGlobalServiceMutationVariables>;

/**
 * __useCreateGlobalServiceMutation__
 *
 * To run a mutation, you first call `useCreateGlobalServiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateGlobalServiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createGlobalServiceMutation, { data, loading, error }] = useCreateGlobalServiceMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *      cluster: // value for 'cluster'
 *      name: // value for 'name'
 *      serviceId: // value for 'serviceId'
 *   },
 * });
 */
export function useCreateGlobalServiceMutation(baseOptions?: Apollo.MutationHookOptions<CreateGlobalServiceMutation, CreateGlobalServiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateGlobalServiceMutation, CreateGlobalServiceMutationVariables>(CreateGlobalServiceDocument, options);
      }
export type CreateGlobalServiceMutationHookResult = ReturnType<typeof useCreateGlobalServiceMutation>;
export type CreateGlobalServiceMutationResult = Apollo.MutationResult<CreateGlobalServiceMutation>;
export type CreateGlobalServiceMutationOptions = Apollo.BaseMutationOptions<CreateGlobalServiceMutation, CreateGlobalServiceMutationVariables>;
export const UpdateGlobalServiceDocument = gql`
    mutation UpdateGlobalService($id: ID!, $attributes: GlobalServiceAttributes!) {
  updateGlobalService(id: $id, attributes: $attributes) {
    id
  }
}
    `;
export type UpdateGlobalServiceMutationFn = Apollo.MutationFunction<UpdateGlobalServiceMutation, UpdateGlobalServiceMutationVariables>;

/**
 * __useUpdateGlobalServiceMutation__
 *
 * To run a mutation, you first call `useUpdateGlobalServiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateGlobalServiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateGlobalServiceMutation, { data, loading, error }] = useUpdateGlobalServiceMutation({
 *   variables: {
 *      id: // value for 'id'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpdateGlobalServiceMutation(baseOptions?: Apollo.MutationHookOptions<UpdateGlobalServiceMutation, UpdateGlobalServiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateGlobalServiceMutation, UpdateGlobalServiceMutationVariables>(UpdateGlobalServiceDocument, options);
      }
export type UpdateGlobalServiceMutationHookResult = ReturnType<typeof useUpdateGlobalServiceMutation>;
export type UpdateGlobalServiceMutationResult = Apollo.MutationResult<UpdateGlobalServiceMutation>;
export type UpdateGlobalServiceMutationOptions = Apollo.BaseMutationOptions<UpdateGlobalServiceMutation, UpdateGlobalServiceMutationVariables>;
export const DeleteGlobalServiceDocument = gql`
    mutation DeleteGlobalService($id: ID!) {
  deleteGlobalService(id: $id) {
    id
  }
}
    `;
export type DeleteGlobalServiceMutationFn = Apollo.MutationFunction<DeleteGlobalServiceMutation, DeleteGlobalServiceMutationVariables>;

/**
 * __useDeleteGlobalServiceMutation__
 *
 * To run a mutation, you first call `useDeleteGlobalServiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteGlobalServiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteGlobalServiceMutation, { data, loading, error }] = useDeleteGlobalServiceMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteGlobalServiceMutation(baseOptions?: Apollo.MutationHookOptions<DeleteGlobalServiceMutation, DeleteGlobalServiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteGlobalServiceMutation, DeleteGlobalServiceMutationVariables>(DeleteGlobalServiceDocument, options);
      }
export type DeleteGlobalServiceMutationHookResult = ReturnType<typeof useDeleteGlobalServiceMutation>;
export type DeleteGlobalServiceMutationResult = Apollo.MutationResult<DeleteGlobalServiceMutation>;
export type DeleteGlobalServiceMutationOptions = Apollo.BaseMutationOptions<DeleteGlobalServiceMutation, DeleteGlobalServiceMutationVariables>;
export const GlobalServicesDocument = gql`
    query GlobalServices($first: Int, $after: String, $projectId: ID, $q: String) {
  globalServices(first: $first, after: $after, projectId: $projectId, q: $q) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...GlobalService
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${GlobalServiceFragmentDoc}`;

/**
 * __useGlobalServicesQuery__
 *
 * To run a query within a React component, call `useGlobalServicesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGlobalServicesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGlobalServicesQuery({
 *   variables: {
 *      first: // value for 'first'
 *      after: // value for 'after'
 *      projectId: // value for 'projectId'
 *      q: // value for 'q'
 *   },
 * });
 */
export function useGlobalServicesQuery(baseOptions?: Apollo.QueryHookOptions<GlobalServicesQuery, GlobalServicesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GlobalServicesQuery, GlobalServicesQueryVariables>(GlobalServicesDocument, options);
      }
export function useGlobalServicesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GlobalServicesQuery, GlobalServicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GlobalServicesQuery, GlobalServicesQueryVariables>(GlobalServicesDocument, options);
        }
export function useGlobalServicesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GlobalServicesQuery, GlobalServicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GlobalServicesQuery, GlobalServicesQueryVariables>(GlobalServicesDocument, options);
        }
export type GlobalServicesQueryHookResult = ReturnType<typeof useGlobalServicesQuery>;
export type GlobalServicesLazyQueryHookResult = ReturnType<typeof useGlobalServicesLazyQuery>;
export type GlobalServicesSuspenseQueryHookResult = ReturnType<typeof useGlobalServicesSuspenseQuery>;
export type GlobalServicesQueryResult = Apollo.QueryResult<GlobalServicesQuery, GlobalServicesQueryVariables>;
export const GetGlobalServiceDocument = gql`
    query GetGlobalService($serviceId: ID!) {
  globalService(id: $serviceId) {
    ...GlobalService
  }
}
    ${GlobalServiceFragmentDoc}`;

/**
 * __useGetGlobalServiceQuery__
 *
 * To run a query within a React component, call `useGetGlobalServiceQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGlobalServiceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGlobalServiceQuery({
 *   variables: {
 *      serviceId: // value for 'serviceId'
 *   },
 * });
 */
export function useGetGlobalServiceQuery(baseOptions: Apollo.QueryHookOptions<GetGlobalServiceQuery, GetGlobalServiceQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetGlobalServiceQuery, GetGlobalServiceQueryVariables>(GetGlobalServiceDocument, options);
      }
export function useGetGlobalServiceLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGlobalServiceQuery, GetGlobalServiceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetGlobalServiceQuery, GetGlobalServiceQueryVariables>(GetGlobalServiceDocument, options);
        }
export function useGetGlobalServiceSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetGlobalServiceQuery, GetGlobalServiceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetGlobalServiceQuery, GetGlobalServiceQueryVariables>(GetGlobalServiceDocument, options);
        }
export type GetGlobalServiceQueryHookResult = ReturnType<typeof useGetGlobalServiceQuery>;
export type GetGlobalServiceLazyQueryHookResult = ReturnType<typeof useGetGlobalServiceLazyQuery>;
export type GetGlobalServiceSuspenseQueryHookResult = ReturnType<typeof useGetGlobalServiceSuspenseQuery>;
export type GetGlobalServiceQueryResult = Apollo.QueryResult<GetGlobalServiceQuery, GetGlobalServiceQueryVariables>;
export const GetGlobalServiceServicesDocument = gql`
    query GetGlobalServiceServices($serviceId: ID!, $first: Int, $after: String) {
  globalService(id: $serviceId) {
    services(first: $first, after: $after) {
      pageInfo {
        ...PageInfo
      }
      edges {
        node {
          ...ServiceDeploymentsRow
        }
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${ServiceDeploymentsRowFragmentDoc}`;

/**
 * __useGetGlobalServiceServicesQuery__
 *
 * To run a query within a React component, call `useGetGlobalServiceServicesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGlobalServiceServicesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGlobalServiceServicesQuery({
 *   variables: {
 *      serviceId: // value for 'serviceId'
 *      first: // value for 'first'
 *      after: // value for 'after'
 *   },
 * });
 */
export function useGetGlobalServiceServicesQuery(baseOptions: Apollo.QueryHookOptions<GetGlobalServiceServicesQuery, GetGlobalServiceServicesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetGlobalServiceServicesQuery, GetGlobalServiceServicesQueryVariables>(GetGlobalServiceServicesDocument, options);
      }
export function useGetGlobalServiceServicesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGlobalServiceServicesQuery, GetGlobalServiceServicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetGlobalServiceServicesQuery, GetGlobalServiceServicesQueryVariables>(GetGlobalServiceServicesDocument, options);
        }
export function useGetGlobalServiceServicesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetGlobalServiceServicesQuery, GetGlobalServiceServicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetGlobalServiceServicesQuery, GetGlobalServiceServicesQueryVariables>(GetGlobalServiceServicesDocument, options);
        }
export type GetGlobalServiceServicesQueryHookResult = ReturnType<typeof useGetGlobalServiceServicesQuery>;
export type GetGlobalServiceServicesLazyQueryHookResult = ReturnType<typeof useGetGlobalServiceServicesLazyQuery>;
export type GetGlobalServiceServicesSuspenseQueryHookResult = ReturnType<typeof useGetGlobalServiceServicesSuspenseQuery>;
export type GetGlobalServiceServicesQueryResult = Apollo.QueryResult<GetGlobalServiceServicesQuery, GetGlobalServiceServicesQueryVariables>;
export const SyncGlobalServiceDocument = gql`
    mutation SyncGlobalService($id: ID!) {
  syncGlobalService(id: $id) {
    ...GlobalService
  }
}
    ${GlobalServiceFragmentDoc}`;
export type SyncGlobalServiceMutationFn = Apollo.MutationFunction<SyncGlobalServiceMutation, SyncGlobalServiceMutationVariables>;

/**
 * __useSyncGlobalServiceMutation__
 *
 * To run a mutation, you first call `useSyncGlobalServiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSyncGlobalServiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [syncGlobalServiceMutation, { data, loading, error }] = useSyncGlobalServiceMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useSyncGlobalServiceMutation(baseOptions?: Apollo.MutationHookOptions<SyncGlobalServiceMutation, SyncGlobalServiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SyncGlobalServiceMutation, SyncGlobalServiceMutationVariables>(SyncGlobalServiceDocument, options);
      }
export type SyncGlobalServiceMutationHookResult = ReturnType<typeof useSyncGlobalServiceMutation>;
export type SyncGlobalServiceMutationResult = Apollo.MutationResult<SyncGlobalServiceMutation>;
export type SyncGlobalServiceMutationOptions = Apollo.BaseMutationOptions<SyncGlobalServiceMutation, SyncGlobalServiceMutationVariables>;
export const DeploymentSettingsDocument = gql`
    query DeploymentSettings {
  deploymentSettings {
    ...DeploymentSettings
  }
}
    ${DeploymentSettingsFragmentDoc}`;

/**
 * __useDeploymentSettingsQuery__
 *
 * To run a query within a React component, call `useDeploymentSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useDeploymentSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDeploymentSettingsQuery({
 *   variables: {
 *   },
 * });
 */
export function useDeploymentSettingsQuery(baseOptions?: Apollo.QueryHookOptions<DeploymentSettingsQuery, DeploymentSettingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DeploymentSettingsQuery, DeploymentSettingsQueryVariables>(DeploymentSettingsDocument, options);
      }
export function useDeploymentSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DeploymentSettingsQuery, DeploymentSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DeploymentSettingsQuery, DeploymentSettingsQueryVariables>(DeploymentSettingsDocument, options);
        }
export function useDeploymentSettingsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<DeploymentSettingsQuery, DeploymentSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<DeploymentSettingsQuery, DeploymentSettingsQueryVariables>(DeploymentSettingsDocument, options);
        }
export type DeploymentSettingsQueryHookResult = ReturnType<typeof useDeploymentSettingsQuery>;
export type DeploymentSettingsLazyQueryHookResult = ReturnType<typeof useDeploymentSettingsLazyQuery>;
export type DeploymentSettingsSuspenseQueryHookResult = ReturnType<typeof useDeploymentSettingsSuspenseQuery>;
export type DeploymentSettingsQueryResult = Apollo.QueryResult<DeploymentSettingsQuery, DeploymentSettingsQueryVariables>;
export const ObservabilityProvidersDocument = gql`
    query ObservabilityProviders($first: Int, $after: String) {
  observabilityProviders(first: $first, after: $after) {
    edges {
      node {
        ...ObservabilityProvider
      }
    }
    pageInfo {
      ...PageInfo
    }
  }
}
    ${ObservabilityProviderFragmentDoc}
${PageInfoFragmentDoc}`;

/**
 * __useObservabilityProvidersQuery__
 *
 * To run a query within a React component, call `useObservabilityProvidersQuery` and pass it any options that fit your needs.
 * When your component renders, `useObservabilityProvidersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useObservabilityProvidersQuery({
 *   variables: {
 *      first: // value for 'first'
 *      after: // value for 'after'
 *   },
 * });
 */
export function useObservabilityProvidersQuery(baseOptions?: Apollo.QueryHookOptions<ObservabilityProvidersQuery, ObservabilityProvidersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ObservabilityProvidersQuery, ObservabilityProvidersQueryVariables>(ObservabilityProvidersDocument, options);
      }
export function useObservabilityProvidersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ObservabilityProvidersQuery, ObservabilityProvidersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ObservabilityProvidersQuery, ObservabilityProvidersQueryVariables>(ObservabilityProvidersDocument, options);
        }
export function useObservabilityProvidersSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ObservabilityProvidersQuery, ObservabilityProvidersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ObservabilityProvidersQuery, ObservabilityProvidersQueryVariables>(ObservabilityProvidersDocument, options);
        }
export type ObservabilityProvidersQueryHookResult = ReturnType<typeof useObservabilityProvidersQuery>;
export type ObservabilityProvidersLazyQueryHookResult = ReturnType<typeof useObservabilityProvidersLazyQuery>;
export type ObservabilityProvidersSuspenseQueryHookResult = ReturnType<typeof useObservabilityProvidersSuspenseQuery>;
export type ObservabilityProvidersQueryResult = Apollo.QueryResult<ObservabilityProvidersQuery, ObservabilityProvidersQueryVariables>;
export const ObservabilityWebhooksDocument = gql`
    query ObservabilityWebhooks($first: Int, $after: String) {
  observabilityWebhooks(first: $first, after: $after) {
    edges {
      node {
        ...ObservabilityWebhook
      }
    }
    pageInfo {
      ...PageInfo
    }
  }
}
    ${ObservabilityWebhookFragmentDoc}
${PageInfoFragmentDoc}`;

/**
 * __useObservabilityWebhooksQuery__
 *
 * To run a query within a React component, call `useObservabilityWebhooksQuery` and pass it any options that fit your needs.
 * When your component renders, `useObservabilityWebhooksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useObservabilityWebhooksQuery({
 *   variables: {
 *      first: // value for 'first'
 *      after: // value for 'after'
 *   },
 * });
 */
export function useObservabilityWebhooksQuery(baseOptions?: Apollo.QueryHookOptions<ObservabilityWebhooksQuery, ObservabilityWebhooksQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ObservabilityWebhooksQuery, ObservabilityWebhooksQueryVariables>(ObservabilityWebhooksDocument, options);
      }
export function useObservabilityWebhooksLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ObservabilityWebhooksQuery, ObservabilityWebhooksQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ObservabilityWebhooksQuery, ObservabilityWebhooksQueryVariables>(ObservabilityWebhooksDocument, options);
        }
export function useObservabilityWebhooksSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ObservabilityWebhooksQuery, ObservabilityWebhooksQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ObservabilityWebhooksQuery, ObservabilityWebhooksQueryVariables>(ObservabilityWebhooksDocument, options);
        }
export type ObservabilityWebhooksQueryHookResult = ReturnType<typeof useObservabilityWebhooksQuery>;
export type ObservabilityWebhooksLazyQueryHookResult = ReturnType<typeof useObservabilityWebhooksLazyQuery>;
export type ObservabilityWebhooksSuspenseQueryHookResult = ReturnType<typeof useObservabilityWebhooksSuspenseQuery>;
export type ObservabilityWebhooksQueryResult = Apollo.QueryResult<ObservabilityWebhooksQuery, ObservabilityWebhooksQueryVariables>;
export const UpdateDeploymentSettingsDocument = gql`
    mutation UpdateDeploymentSettings($attributes: DeploymentSettingsAttributes!) {
  updateDeploymentSettings(attributes: $attributes) {
    ...DeploymentSettings
  }
}
    ${DeploymentSettingsFragmentDoc}`;
export type UpdateDeploymentSettingsMutationFn = Apollo.MutationFunction<UpdateDeploymentSettingsMutation, UpdateDeploymentSettingsMutationVariables>;

/**
 * __useUpdateDeploymentSettingsMutation__
 *
 * To run a mutation, you first call `useUpdateDeploymentSettingsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateDeploymentSettingsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateDeploymentSettingsMutation, { data, loading, error }] = useUpdateDeploymentSettingsMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpdateDeploymentSettingsMutation(baseOptions?: Apollo.MutationHookOptions<UpdateDeploymentSettingsMutation, UpdateDeploymentSettingsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateDeploymentSettingsMutation, UpdateDeploymentSettingsMutationVariables>(UpdateDeploymentSettingsDocument, options);
      }
export type UpdateDeploymentSettingsMutationHookResult = ReturnType<typeof useUpdateDeploymentSettingsMutation>;
export type UpdateDeploymentSettingsMutationResult = Apollo.MutationResult<UpdateDeploymentSettingsMutation>;
export type UpdateDeploymentSettingsMutationOptions = Apollo.BaseMutationOptions<UpdateDeploymentSettingsMutation, UpdateDeploymentSettingsMutationVariables>;
export const UpsertObservabilityProviderDocument = gql`
    mutation UpsertObservabilityProvider($attributes: ObservabilityProviderAttributes!) {
  upsertObservabilityProvider(attributes: $attributes) {
    ...ObservabilityProvider
  }
}
    ${ObservabilityProviderFragmentDoc}`;
export type UpsertObservabilityProviderMutationFn = Apollo.MutationFunction<UpsertObservabilityProviderMutation, UpsertObservabilityProviderMutationVariables>;

/**
 * __useUpsertObservabilityProviderMutation__
 *
 * To run a mutation, you first call `useUpsertObservabilityProviderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpsertObservabilityProviderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upsertObservabilityProviderMutation, { data, loading, error }] = useUpsertObservabilityProviderMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpsertObservabilityProviderMutation(baseOptions?: Apollo.MutationHookOptions<UpsertObservabilityProviderMutation, UpsertObservabilityProviderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpsertObservabilityProviderMutation, UpsertObservabilityProviderMutationVariables>(UpsertObservabilityProviderDocument, options);
      }
export type UpsertObservabilityProviderMutationHookResult = ReturnType<typeof useUpsertObservabilityProviderMutation>;
export type UpsertObservabilityProviderMutationResult = Apollo.MutationResult<UpsertObservabilityProviderMutation>;
export type UpsertObservabilityProviderMutationOptions = Apollo.BaseMutationOptions<UpsertObservabilityProviderMutation, UpsertObservabilityProviderMutationVariables>;
export const UpsertObservabilityWebhookDocument = gql`
    mutation UpsertObservabilityWebhook($attributes: ObservabilityWebhookAttributes!) {
  upsertObservabilityWebhook(attributes: $attributes) {
    ...ObservabilityWebhook
  }
}
    ${ObservabilityWebhookFragmentDoc}`;
export type UpsertObservabilityWebhookMutationFn = Apollo.MutationFunction<UpsertObservabilityWebhookMutation, UpsertObservabilityWebhookMutationVariables>;

/**
 * __useUpsertObservabilityWebhookMutation__
 *
 * To run a mutation, you first call `useUpsertObservabilityWebhookMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpsertObservabilityWebhookMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upsertObservabilityWebhookMutation, { data, loading, error }] = useUpsertObservabilityWebhookMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpsertObservabilityWebhookMutation(baseOptions?: Apollo.MutationHookOptions<UpsertObservabilityWebhookMutation, UpsertObservabilityWebhookMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpsertObservabilityWebhookMutation, UpsertObservabilityWebhookMutationVariables>(UpsertObservabilityWebhookDocument, options);
      }
export type UpsertObservabilityWebhookMutationHookResult = ReturnType<typeof useUpsertObservabilityWebhookMutation>;
export type UpsertObservabilityWebhookMutationResult = Apollo.MutationResult<UpsertObservabilityWebhookMutation>;
export type UpsertObservabilityWebhookMutationOptions = Apollo.BaseMutationOptions<UpsertObservabilityWebhookMutation, UpsertObservabilityWebhookMutationVariables>;
export const DeleteObservabilityProviderDocument = gql`
    mutation DeleteObservabilityProvider($id: ID!) {
  deleteObservabilityProvider(id: $id) {
    ...ObservabilityProvider
  }
}
    ${ObservabilityProviderFragmentDoc}`;
export type DeleteObservabilityProviderMutationFn = Apollo.MutationFunction<DeleteObservabilityProviderMutation, DeleteObservabilityProviderMutationVariables>;

/**
 * __useDeleteObservabilityProviderMutation__
 *
 * To run a mutation, you first call `useDeleteObservabilityProviderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteObservabilityProviderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteObservabilityProviderMutation, { data, loading, error }] = useDeleteObservabilityProviderMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteObservabilityProviderMutation(baseOptions?: Apollo.MutationHookOptions<DeleteObservabilityProviderMutation, DeleteObservabilityProviderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteObservabilityProviderMutation, DeleteObservabilityProviderMutationVariables>(DeleteObservabilityProviderDocument, options);
      }
export type DeleteObservabilityProviderMutationHookResult = ReturnType<typeof useDeleteObservabilityProviderMutation>;
export type DeleteObservabilityProviderMutationResult = Apollo.MutationResult<DeleteObservabilityProviderMutation>;
export type DeleteObservabilityProviderMutationOptions = Apollo.BaseMutationOptions<DeleteObservabilityProviderMutation, DeleteObservabilityProviderMutationVariables>;
export const DeleteObservabilityWebhookDocument = gql`
    mutation DeleteObservabilityWebhook($id: ID!) {
  deleteObservabilityWebhook(id: $id) {
    ...ObservabilityWebhook
  }
}
    ${ObservabilityWebhookFragmentDoc}`;
export type DeleteObservabilityWebhookMutationFn = Apollo.MutationFunction<DeleteObservabilityWebhookMutation, DeleteObservabilityWebhookMutationVariables>;

/**
 * __useDeleteObservabilityWebhookMutation__
 *
 * To run a mutation, you first call `useDeleteObservabilityWebhookMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteObservabilityWebhookMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteObservabilityWebhookMutation, { data, loading, error }] = useDeleteObservabilityWebhookMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteObservabilityWebhookMutation(baseOptions?: Apollo.MutationHookOptions<DeleteObservabilityWebhookMutation, DeleteObservabilityWebhookMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteObservabilityWebhookMutation, DeleteObservabilityWebhookMutationVariables>(DeleteObservabilityWebhookDocument, options);
      }
export type DeleteObservabilityWebhookMutationHookResult = ReturnType<typeof useDeleteObservabilityWebhookMutation>;
export type DeleteObservabilityWebhookMutationResult = Apollo.MutationResult<DeleteObservabilityWebhookMutation>;
export type DeleteObservabilityWebhookMutationOptions = Apollo.BaseMutationOptions<DeleteObservabilityWebhookMutation, DeleteObservabilityWebhookMutationVariables>;
export const DissmissOnboardingDocument = gql`
    mutation DissmissOnboarding {
  dismissOnboarding {
    onboarded
  }
}
    `;
export type DissmissOnboardingMutationFn = Apollo.MutationFunction<DissmissOnboardingMutation, DissmissOnboardingMutationVariables>;

/**
 * __useDissmissOnboardingMutation__
 *
 * To run a mutation, you first call `useDissmissOnboardingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDissmissOnboardingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [dissmissOnboardingMutation, { data, loading, error }] = useDissmissOnboardingMutation({
 *   variables: {
 *   },
 * });
 */
export function useDissmissOnboardingMutation(baseOptions?: Apollo.MutationHookOptions<DissmissOnboardingMutation, DissmissOnboardingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DissmissOnboardingMutation, DissmissOnboardingMutationVariables>(DissmissOnboardingDocument, options);
      }
export type DissmissOnboardingMutationHookResult = ReturnType<typeof useDissmissOnboardingMutation>;
export type DissmissOnboardingMutationResult = Apollo.MutationResult<DissmissOnboardingMutation>;
export type DissmissOnboardingMutationOptions = Apollo.BaseMutationOptions<DissmissOnboardingMutation, DissmissOnboardingMutationVariables>;
export const ManagedNamespacesDocument = gql`
    query ManagedNamespaces($first: Int, $after: String, $projectId: ID) {
  managedNamespaces(first: $first, after: $after, projectId: $projectId) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...ManagedNamespace
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${ManagedNamespaceFragmentDoc}`;

/**
 * __useManagedNamespacesQuery__
 *
 * To run a query within a React component, call `useManagedNamespacesQuery` and pass it any options that fit your needs.
 * When your component renders, `useManagedNamespacesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManagedNamespacesQuery({
 *   variables: {
 *      first: // value for 'first'
 *      after: // value for 'after'
 *      projectId: // value for 'projectId'
 *   },
 * });
 */
export function useManagedNamespacesQuery(baseOptions?: Apollo.QueryHookOptions<ManagedNamespacesQuery, ManagedNamespacesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManagedNamespacesQuery, ManagedNamespacesQueryVariables>(ManagedNamespacesDocument, options);
      }
export function useManagedNamespacesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManagedNamespacesQuery, ManagedNamespacesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManagedNamespacesQuery, ManagedNamespacesQueryVariables>(ManagedNamespacesDocument, options);
        }
export function useManagedNamespacesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ManagedNamespacesQuery, ManagedNamespacesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ManagedNamespacesQuery, ManagedNamespacesQueryVariables>(ManagedNamespacesDocument, options);
        }
export type ManagedNamespacesQueryHookResult = ReturnType<typeof useManagedNamespacesQuery>;
export type ManagedNamespacesLazyQueryHookResult = ReturnType<typeof useManagedNamespacesLazyQuery>;
export type ManagedNamespacesSuspenseQueryHookResult = ReturnType<typeof useManagedNamespacesSuspenseQuery>;
export type ManagedNamespacesQueryResult = Apollo.QueryResult<ManagedNamespacesQuery, ManagedNamespacesQueryVariables>;
export const GetManagedNamespaceNameDocument = gql`
    query GetManagedNamespaceName($namespaceId: ID!) {
  managedNamespace(id: $namespaceId) {
    name
  }
}
    `;

/**
 * __useGetManagedNamespaceNameQuery__
 *
 * To run a query within a React component, call `useGetManagedNamespaceNameQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetManagedNamespaceNameQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetManagedNamespaceNameQuery({
 *   variables: {
 *      namespaceId: // value for 'namespaceId'
 *   },
 * });
 */
export function useGetManagedNamespaceNameQuery(baseOptions: Apollo.QueryHookOptions<GetManagedNamespaceNameQuery, GetManagedNamespaceNameQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetManagedNamespaceNameQuery, GetManagedNamespaceNameQueryVariables>(GetManagedNamespaceNameDocument, options);
      }
export function useGetManagedNamespaceNameLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetManagedNamespaceNameQuery, GetManagedNamespaceNameQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetManagedNamespaceNameQuery, GetManagedNamespaceNameQueryVariables>(GetManagedNamespaceNameDocument, options);
        }
export function useGetManagedNamespaceNameSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetManagedNamespaceNameQuery, GetManagedNamespaceNameQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetManagedNamespaceNameQuery, GetManagedNamespaceNameQueryVariables>(GetManagedNamespaceNameDocument, options);
        }
export type GetManagedNamespaceNameQueryHookResult = ReturnType<typeof useGetManagedNamespaceNameQuery>;
export type GetManagedNamespaceNameLazyQueryHookResult = ReturnType<typeof useGetManagedNamespaceNameLazyQuery>;
export type GetManagedNamespaceNameSuspenseQueryHookResult = ReturnType<typeof useGetManagedNamespaceNameSuspenseQuery>;
export type GetManagedNamespaceNameQueryResult = Apollo.QueryResult<GetManagedNamespaceNameQuery, GetManagedNamespaceNameQueryVariables>;
export const GetManagedNamespaceDocument = gql`
    query GetManagedNamespace($namespaceId: ID!) {
  managedNamespace(id: $namespaceId) {
    ...ManagedNamespace
  }
}
    ${ManagedNamespaceFragmentDoc}`;

/**
 * __useGetManagedNamespaceQuery__
 *
 * To run a query within a React component, call `useGetManagedNamespaceQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetManagedNamespaceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetManagedNamespaceQuery({
 *   variables: {
 *      namespaceId: // value for 'namespaceId'
 *   },
 * });
 */
export function useGetManagedNamespaceQuery(baseOptions: Apollo.QueryHookOptions<GetManagedNamespaceQuery, GetManagedNamespaceQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetManagedNamespaceQuery, GetManagedNamespaceQueryVariables>(GetManagedNamespaceDocument, options);
      }
export function useGetManagedNamespaceLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetManagedNamespaceQuery, GetManagedNamespaceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetManagedNamespaceQuery, GetManagedNamespaceQueryVariables>(GetManagedNamespaceDocument, options);
        }
export function useGetManagedNamespaceSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetManagedNamespaceQuery, GetManagedNamespaceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetManagedNamespaceQuery, GetManagedNamespaceQueryVariables>(GetManagedNamespaceDocument, options);
        }
export type GetManagedNamespaceQueryHookResult = ReturnType<typeof useGetManagedNamespaceQuery>;
export type GetManagedNamespaceLazyQueryHookResult = ReturnType<typeof useGetManagedNamespaceLazyQuery>;
export type GetManagedNamespaceSuspenseQueryHookResult = ReturnType<typeof useGetManagedNamespaceSuspenseQuery>;
export type GetManagedNamespaceQueryResult = Apollo.QueryResult<GetManagedNamespaceQuery, GetManagedNamespaceQueryVariables>;
export const GetManagedNamespaceServicesDocument = gql`
    query GetManagedNamespaceServices($namespaceId: ID!, $first: Int, $after: String) {
  managedNamespace(id: $namespaceId) {
    services(first: $first, after: $after) {
      pageInfo {
        ...PageInfo
      }
      edges {
        node {
          ...ServiceDeploymentsRow
        }
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${ServiceDeploymentsRowFragmentDoc}`;

/**
 * __useGetManagedNamespaceServicesQuery__
 *
 * To run a query within a React component, call `useGetManagedNamespaceServicesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetManagedNamespaceServicesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetManagedNamespaceServicesQuery({
 *   variables: {
 *      namespaceId: // value for 'namespaceId'
 *      first: // value for 'first'
 *      after: // value for 'after'
 *   },
 * });
 */
export function useGetManagedNamespaceServicesQuery(baseOptions: Apollo.QueryHookOptions<GetManagedNamespaceServicesQuery, GetManagedNamespaceServicesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetManagedNamespaceServicesQuery, GetManagedNamespaceServicesQueryVariables>(GetManagedNamespaceServicesDocument, options);
      }
export function useGetManagedNamespaceServicesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetManagedNamespaceServicesQuery, GetManagedNamespaceServicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetManagedNamespaceServicesQuery, GetManagedNamespaceServicesQueryVariables>(GetManagedNamespaceServicesDocument, options);
        }
export function useGetManagedNamespaceServicesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetManagedNamespaceServicesQuery, GetManagedNamespaceServicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetManagedNamespaceServicesQuery, GetManagedNamespaceServicesQueryVariables>(GetManagedNamespaceServicesDocument, options);
        }
export type GetManagedNamespaceServicesQueryHookResult = ReturnType<typeof useGetManagedNamespaceServicesQuery>;
export type GetManagedNamespaceServicesLazyQueryHookResult = ReturnType<typeof useGetManagedNamespaceServicesLazyQuery>;
export type GetManagedNamespaceServicesSuspenseQueryHookResult = ReturnType<typeof useGetManagedNamespaceServicesSuspenseQuery>;
export type GetManagedNamespaceServicesQueryResult = Apollo.QueryResult<GetManagedNamespaceServicesQuery, GetManagedNamespaceServicesQueryVariables>;
export const ObserversDocument = gql`
    query Observers($first: Int, $last: Int, $before: String, $after: String, $projectId: ID) {
  observers(
    first: $first
    last: $last
    before: $before
    after: $after
    projectId: $projectId
  ) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...Observer
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${ObserverFragmentDoc}`;

/**
 * __useObserversQuery__
 *
 * To run a query within a React component, call `useObserversQuery` and pass it any options that fit your needs.
 * When your component renders, `useObserversQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useObserversQuery({
 *   variables: {
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      before: // value for 'before'
 *      after: // value for 'after'
 *      projectId: // value for 'projectId'
 *   },
 * });
 */
export function useObserversQuery(baseOptions?: Apollo.QueryHookOptions<ObserversQuery, ObserversQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ObserversQuery, ObserversQueryVariables>(ObserversDocument, options);
      }
export function useObserversLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ObserversQuery, ObserversQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ObserversQuery, ObserversQueryVariables>(ObserversDocument, options);
        }
export function useObserversSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ObserversQuery, ObserversQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ObserversQuery, ObserversQueryVariables>(ObserversDocument, options);
        }
export type ObserversQueryHookResult = ReturnType<typeof useObserversQuery>;
export type ObserversLazyQueryHookResult = ReturnType<typeof useObserversLazyQuery>;
export type ObserversSuspenseQueryHookResult = ReturnType<typeof useObserversSuspenseQuery>;
export type ObserversQueryResult = Apollo.QueryResult<ObserversQuery, ObserversQueryVariables>;
export const ObserverDocument = gql`
    query Observer($id: ID, $name: String) {
  observer(id: $id, name: $name) {
    ...Observer
  }
}
    ${ObserverFragmentDoc}`;

/**
 * __useObserverQuery__
 *
 * To run a query within a React component, call `useObserverQuery` and pass it any options that fit your needs.
 * When your component renders, `useObserverQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useObserverQuery({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *   },
 * });
 */
export function useObserverQuery(baseOptions?: Apollo.QueryHookOptions<ObserverQuery, ObserverQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ObserverQuery, ObserverQueryVariables>(ObserverDocument, options);
      }
export function useObserverLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ObserverQuery, ObserverQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ObserverQuery, ObserverQueryVariables>(ObserverDocument, options);
        }
export function useObserverSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ObserverQuery, ObserverQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ObserverQuery, ObserverQueryVariables>(ObserverDocument, options);
        }
export type ObserverQueryHookResult = ReturnType<typeof useObserverQuery>;
export type ObserverLazyQueryHookResult = ReturnType<typeof useObserverLazyQuery>;
export type ObserverSuspenseQueryHookResult = ReturnType<typeof useObserverSuspenseQuery>;
export type ObserverQueryResult = Apollo.QueryResult<ObserverQuery, ObserverQueryVariables>;
export const UpsertObserverDocument = gql`
    mutation UpsertObserver($attrs: ObserverAttributes) {
  upsertObserver(attributes: $attrs) {
    ...Observer
  }
}
    ${ObserverFragmentDoc}`;
export type UpsertObserverMutationFn = Apollo.MutationFunction<UpsertObserverMutation, UpsertObserverMutationVariables>;

/**
 * __useUpsertObserverMutation__
 *
 * To run a mutation, you first call `useUpsertObserverMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpsertObserverMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upsertObserverMutation, { data, loading, error }] = useUpsertObserverMutation({
 *   variables: {
 *      attrs: // value for 'attrs'
 *   },
 * });
 */
export function useUpsertObserverMutation(baseOptions?: Apollo.MutationHookOptions<UpsertObserverMutation, UpsertObserverMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpsertObserverMutation, UpsertObserverMutationVariables>(UpsertObserverDocument, options);
      }
export type UpsertObserverMutationHookResult = ReturnType<typeof useUpsertObserverMutation>;
export type UpsertObserverMutationResult = Apollo.MutationResult<UpsertObserverMutation>;
export type UpsertObserverMutationOptions = Apollo.BaseMutationOptions<UpsertObserverMutation, UpsertObserverMutationVariables>;
export const DeleteObserverDocument = gql`
    mutation DeleteObserver($id: ID!) {
  deleteObserver(id: $id) {
    ...Observer
  }
}
    ${ObserverFragmentDoc}`;
export type DeleteObserverMutationFn = Apollo.MutationFunction<DeleteObserverMutation, DeleteObserverMutationVariables>;

/**
 * __useDeleteObserverMutation__
 *
 * To run a mutation, you first call `useDeleteObserverMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteObserverMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteObserverMutation, { data, loading, error }] = useDeleteObserverMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteObserverMutation(baseOptions?: Apollo.MutationHookOptions<DeleteObserverMutation, DeleteObserverMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteObserverMutation, DeleteObserverMutationVariables>(DeleteObserverDocument, options);
      }
export type DeleteObserverMutationHookResult = ReturnType<typeof useDeleteObserverMutation>;
export type DeleteObserverMutationResult = Apollo.MutationResult<DeleteObserverMutation>;
export type DeleteObserverMutationOptions = Apollo.BaseMutationOptions<DeleteObserverMutation, DeleteObserverMutationVariables>;
export const KickObserverDocument = gql`
    mutation KickObserver($id: ID!) {
  kickObserver(id: $id) {
    ...Observer
  }
}
    ${ObserverFragmentDoc}`;
export type KickObserverMutationFn = Apollo.MutationFunction<KickObserverMutation, KickObserverMutationVariables>;

/**
 * __useKickObserverMutation__
 *
 * To run a mutation, you first call `useKickObserverMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useKickObserverMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [kickObserverMutation, { data, loading, error }] = useKickObserverMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useKickObserverMutation(baseOptions?: Apollo.MutationHookOptions<KickObserverMutation, KickObserverMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<KickObserverMutation, KickObserverMutationVariables>(KickObserverDocument, options);
      }
export type KickObserverMutationHookResult = ReturnType<typeof useKickObserverMutation>;
export type KickObserverMutationResult = Apollo.MutationResult<KickObserverMutation>;
export type KickObserverMutationOptions = Apollo.BaseMutationOptions<KickObserverMutation, KickObserverMutationVariables>;
export const PipelinesDocument = gql`
    query Pipelines($q: String, $first: Int = 50, $after: String, $projectId: ID) {
  pipelines(q: $q, first: $first, after: $after, projectId: $projectId) {
    ...PipelineConnection
  }
}
    ${PipelineConnectionFragmentDoc}`;

/**
 * __usePipelinesQuery__
 *
 * To run a query within a React component, call `usePipelinesQuery` and pass it any options that fit your needs.
 * When your component renders, `usePipelinesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePipelinesQuery({
 *   variables: {
 *      q: // value for 'q'
 *      first: // value for 'first'
 *      after: // value for 'after'
 *      projectId: // value for 'projectId'
 *   },
 * });
 */
export function usePipelinesQuery(baseOptions?: Apollo.QueryHookOptions<PipelinesQuery, PipelinesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PipelinesQuery, PipelinesQueryVariables>(PipelinesDocument, options);
      }
export function usePipelinesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PipelinesQuery, PipelinesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PipelinesQuery, PipelinesQueryVariables>(PipelinesDocument, options);
        }
export function usePipelinesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<PipelinesQuery, PipelinesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PipelinesQuery, PipelinesQueryVariables>(PipelinesDocument, options);
        }
export type PipelinesQueryHookResult = ReturnType<typeof usePipelinesQuery>;
export type PipelinesLazyQueryHookResult = ReturnType<typeof usePipelinesLazyQuery>;
export type PipelinesSuspenseQueryHookResult = ReturnType<typeof usePipelinesSuspenseQuery>;
export type PipelinesQueryResult = Apollo.QueryResult<PipelinesQuery, PipelinesQueryVariables>;
export const PipelineBindingsDocument = gql`
    query PipelineBindings($id: ID!) {
  pipeline(id: $id) {
    ...PipelineBindings
  }
}
    ${PipelineBindingsFragmentDoc}`;

/**
 * __usePipelineBindingsQuery__
 *
 * To run a query within a React component, call `usePipelineBindingsQuery` and pass it any options that fit your needs.
 * When your component renders, `usePipelineBindingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePipelineBindingsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePipelineBindingsQuery(baseOptions: Apollo.QueryHookOptions<PipelineBindingsQuery, PipelineBindingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PipelineBindingsQuery, PipelineBindingsQueryVariables>(PipelineBindingsDocument, options);
      }
export function usePipelineBindingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PipelineBindingsQuery, PipelineBindingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PipelineBindingsQuery, PipelineBindingsQueryVariables>(PipelineBindingsDocument, options);
        }
export function usePipelineBindingsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<PipelineBindingsQuery, PipelineBindingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PipelineBindingsQuery, PipelineBindingsQueryVariables>(PipelineBindingsDocument, options);
        }
export type PipelineBindingsQueryHookResult = ReturnType<typeof usePipelineBindingsQuery>;
export type PipelineBindingsLazyQueryHookResult = ReturnType<typeof usePipelineBindingsLazyQuery>;
export type PipelineBindingsSuspenseQueryHookResult = ReturnType<typeof usePipelineBindingsSuspenseQuery>;
export type PipelineBindingsQueryResult = Apollo.QueryResult<PipelineBindingsQuery, PipelineBindingsQueryVariables>;
export const JobGateDocument = gql`
    query JobGate($id: ID!) {
  pipelineGate(id: $id) {
    ...PipelineGate
    job {
      ...PipelineGateJob
    }
  }
}
    ${PipelineGateFragmentDoc}
${PipelineGateJobFragmentDoc}`;

/**
 * __useJobGateQuery__
 *
 * To run a query within a React component, call `useJobGateQuery` and pass it any options that fit your needs.
 * When your component renders, `useJobGateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useJobGateQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useJobGateQuery(baseOptions: Apollo.QueryHookOptions<JobGateQuery, JobGateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<JobGateQuery, JobGateQueryVariables>(JobGateDocument, options);
      }
export function useJobGateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<JobGateQuery, JobGateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<JobGateQuery, JobGateQueryVariables>(JobGateDocument, options);
        }
export function useJobGateSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<JobGateQuery, JobGateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<JobGateQuery, JobGateQueryVariables>(JobGateDocument, options);
        }
export type JobGateQueryHookResult = ReturnType<typeof useJobGateQuery>;
export type JobGateLazyQueryHookResult = ReturnType<typeof useJobGateLazyQuery>;
export type JobGateSuspenseQueryHookResult = ReturnType<typeof useJobGateSuspenseQuery>;
export type JobGateQueryResult = Apollo.QueryResult<JobGateQuery, JobGateQueryVariables>;
export const JobGateLogsDocument = gql`
    query JobGateLogs($id: ID!, $container: String!, $sinceSeconds: Int!) {
  pipelineGate(id: $id) {
    job {
      logs(container: $container, sinceSeconds: $sinceSeconds)
    }
  }
}
    `;

/**
 * __useJobGateLogsQuery__
 *
 * To run a query within a React component, call `useJobGateLogsQuery` and pass it any options that fit your needs.
 * When your component renders, `useJobGateLogsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useJobGateLogsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      container: // value for 'container'
 *      sinceSeconds: // value for 'sinceSeconds'
 *   },
 * });
 */
export function useJobGateLogsQuery(baseOptions: Apollo.QueryHookOptions<JobGateLogsQuery, JobGateLogsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<JobGateLogsQuery, JobGateLogsQueryVariables>(JobGateLogsDocument, options);
      }
export function useJobGateLogsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<JobGateLogsQuery, JobGateLogsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<JobGateLogsQuery, JobGateLogsQueryVariables>(JobGateLogsDocument, options);
        }
export function useJobGateLogsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<JobGateLogsQuery, JobGateLogsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<JobGateLogsQuery, JobGateLogsQueryVariables>(JobGateLogsDocument, options);
        }
export type JobGateLogsQueryHookResult = ReturnType<typeof useJobGateLogsQuery>;
export type JobGateLogsLazyQueryHookResult = ReturnType<typeof useJobGateLogsLazyQuery>;
export type JobGateLogsSuspenseQueryHookResult = ReturnType<typeof useJobGateLogsSuspenseQuery>;
export type JobGateLogsQueryResult = Apollo.QueryResult<JobGateLogsQuery, JobGateLogsQueryVariables>;
export const PipelineDocument = gql`
    query Pipeline($id: ID!) {
  pipeline(id: $id) {
    ...Pipeline
  }
}
    ${PipelineFragmentDoc}`;

/**
 * __usePipelineQuery__
 *
 * To run a query within a React component, call `usePipelineQuery` and pass it any options that fit your needs.
 * When your component renders, `usePipelineQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePipelineQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePipelineQuery(baseOptions: Apollo.QueryHookOptions<PipelineQuery, PipelineQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PipelineQuery, PipelineQueryVariables>(PipelineDocument, options);
      }
export function usePipelineLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PipelineQuery, PipelineQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PipelineQuery, PipelineQueryVariables>(PipelineDocument, options);
        }
export function usePipelineSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<PipelineQuery, PipelineQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PipelineQuery, PipelineQueryVariables>(PipelineDocument, options);
        }
export type PipelineQueryHookResult = ReturnType<typeof usePipelineQuery>;
export type PipelineLazyQueryHookResult = ReturnType<typeof usePipelineLazyQuery>;
export type PipelineSuspenseQueryHookResult = ReturnType<typeof usePipelineSuspenseQuery>;
export type PipelineQueryResult = Apollo.QueryResult<PipelineQuery, PipelineQueryVariables>;
export const PipelineContextsDocument = gql`
    query PipelineContexts($id: ID!, $before: String, $after: String, $first: Int!, $last: Int) {
  pipeline(id: $id) {
    id
    contexts(after: $after, before: $before, first: $first, last: $last) {
      edges {
        node {
          ...PipelineContext
        }
      }
    }
  }
}
    ${PipelineContextFragmentDoc}`;

/**
 * __usePipelineContextsQuery__
 *
 * To run a query within a React component, call `usePipelineContextsQuery` and pass it any options that fit your needs.
 * When your component renders, `usePipelineContextsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePipelineContextsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      before: // value for 'before'
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function usePipelineContextsQuery(baseOptions: Apollo.QueryHookOptions<PipelineContextsQuery, PipelineContextsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PipelineContextsQuery, PipelineContextsQueryVariables>(PipelineContextsDocument, options);
      }
export function usePipelineContextsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PipelineContextsQuery, PipelineContextsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PipelineContextsQuery, PipelineContextsQueryVariables>(PipelineContextsDocument, options);
        }
export function usePipelineContextsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<PipelineContextsQuery, PipelineContextsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PipelineContextsQuery, PipelineContextsQueryVariables>(PipelineContextsDocument, options);
        }
export type PipelineContextsQueryHookResult = ReturnType<typeof usePipelineContextsQuery>;
export type PipelineContextsLazyQueryHookResult = ReturnType<typeof usePipelineContextsLazyQuery>;
export type PipelineContextsSuspenseQueryHookResult = ReturnType<typeof usePipelineContextsSuspenseQuery>;
export type PipelineContextsQueryResult = Apollo.QueryResult<PipelineContextsQuery, PipelineContextsQueryVariables>;
export const PipelineContextDocument = gql`
    query PipelineContext($id: ID!) {
  pipelineContext(id: $id) {
    ...PipelineContext
    pipeline {
      ...Pipeline
    }
  }
}
    ${PipelineContextFragmentDoc}
${PipelineFragmentDoc}`;

/**
 * __usePipelineContextQuery__
 *
 * To run a query within a React component, call `usePipelineContextQuery` and pass it any options that fit your needs.
 * When your component renders, `usePipelineContextQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePipelineContextQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePipelineContextQuery(baseOptions: Apollo.QueryHookOptions<PipelineContextQuery, PipelineContextQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PipelineContextQuery, PipelineContextQueryVariables>(PipelineContextDocument, options);
      }
export function usePipelineContextLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PipelineContextQuery, PipelineContextQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PipelineContextQuery, PipelineContextQueryVariables>(PipelineContextDocument, options);
        }
export function usePipelineContextSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<PipelineContextQuery, PipelineContextQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PipelineContextQuery, PipelineContextQueryVariables>(PipelineContextDocument, options);
        }
export type PipelineContextQueryHookResult = ReturnType<typeof usePipelineContextQuery>;
export type PipelineContextLazyQueryHookResult = ReturnType<typeof usePipelineContextLazyQuery>;
export type PipelineContextSuspenseQueryHookResult = ReturnType<typeof usePipelineContextSuspenseQuery>;
export type PipelineContextQueryResult = Apollo.QueryResult<PipelineContextQuery, PipelineContextQueryVariables>;
export const DeletePipelineDocument = gql`
    mutation deletePipeline($id: ID!) {
  deletePipeline(id: $id) {
    ...Pipeline
  }
}
    ${PipelineFragmentDoc}`;
export type DeletePipelineMutationFn = Apollo.MutationFunction<DeletePipelineMutation, DeletePipelineMutationVariables>;

/**
 * __useDeletePipelineMutation__
 *
 * To run a mutation, you first call `useDeletePipelineMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeletePipelineMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deletePipelineMutation, { data, loading, error }] = useDeletePipelineMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeletePipelineMutation(baseOptions?: Apollo.MutationHookOptions<DeletePipelineMutation, DeletePipelineMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeletePipelineMutation, DeletePipelineMutationVariables>(DeletePipelineDocument, options);
      }
export type DeletePipelineMutationHookResult = ReturnType<typeof useDeletePipelineMutation>;
export type DeletePipelineMutationResult = Apollo.MutationResult<DeletePipelineMutation>;
export type DeletePipelineMutationOptions = Apollo.BaseMutationOptions<DeletePipelineMutation, DeletePipelineMutationVariables>;
export const ApproveGateDocument = gql`
    mutation ApproveGate($id: ID!) {
  approveGate(id: $id) {
    ...PipelineGate
  }
}
    ${PipelineGateFragmentDoc}`;
export type ApproveGateMutationFn = Apollo.MutationFunction<ApproveGateMutation, ApproveGateMutationVariables>;

/**
 * __useApproveGateMutation__
 *
 * To run a mutation, you first call `useApproveGateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useApproveGateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [approveGateMutation, { data, loading, error }] = useApproveGateMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useApproveGateMutation(baseOptions?: Apollo.MutationHookOptions<ApproveGateMutation, ApproveGateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ApproveGateMutation, ApproveGateMutationVariables>(ApproveGateDocument, options);
      }
export type ApproveGateMutationHookResult = ReturnType<typeof useApproveGateMutation>;
export type ApproveGateMutationResult = Apollo.MutationResult<ApproveGateMutation>;
export type ApproveGateMutationOptions = Apollo.BaseMutationOptions<ApproveGateMutation, ApproveGateMutationVariables>;
export const CreatePipelineContextDocument = gql`
    mutation CreatePipelineContext($pipelineId: ID!, $attributes: PipelineContextAttributes!) {
  createPipelineContext(pipelineId: $pipelineId, attributes: $attributes) {
    ...PipelineContext
    pipeline {
      id
    }
  }
}
    ${PipelineContextFragmentDoc}`;
export type CreatePipelineContextMutationFn = Apollo.MutationFunction<CreatePipelineContextMutation, CreatePipelineContextMutationVariables>;

/**
 * __useCreatePipelineContextMutation__
 *
 * To run a mutation, you first call `useCreatePipelineContextMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePipelineContextMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPipelineContextMutation, { data, loading, error }] = useCreatePipelineContextMutation({
 *   variables: {
 *      pipelineId: // value for 'pipelineId'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useCreatePipelineContextMutation(baseOptions?: Apollo.MutationHookOptions<CreatePipelineContextMutation, CreatePipelineContextMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreatePipelineContextMutation, CreatePipelineContextMutationVariables>(CreatePipelineContextDocument, options);
      }
export type CreatePipelineContextMutationHookResult = ReturnType<typeof useCreatePipelineContextMutation>;
export type CreatePipelineContextMutationResult = Apollo.MutationResult<CreatePipelineContextMutation>;
export type CreatePipelineContextMutationOptions = Apollo.BaseMutationOptions<CreatePipelineContextMutation, CreatePipelineContextMutationVariables>;
export const ForceGateDocument = gql`
    mutation ForceGate($id: ID!, $state: GateState) {
  forceGate(id: $id, state: $state) {
    ...PipelineGate
  }
}
    ${PipelineGateFragmentDoc}`;
export type ForceGateMutationFn = Apollo.MutationFunction<ForceGateMutation, ForceGateMutationVariables>;

/**
 * __useForceGateMutation__
 *
 * To run a mutation, you first call `useForceGateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useForceGateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [forceGateMutation, { data, loading, error }] = useForceGateMutation({
 *   variables: {
 *      id: // value for 'id'
 *      state: // value for 'state'
 *   },
 * });
 */
export function useForceGateMutation(baseOptions?: Apollo.MutationHookOptions<ForceGateMutation, ForceGateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ForceGateMutation, ForceGateMutationVariables>(ForceGateDocument, options);
      }
export type ForceGateMutationHookResult = ReturnType<typeof useForceGateMutation>;
export type ForceGateMutationResult = Apollo.MutationResult<ForceGateMutation>;
export type ForceGateMutationOptions = Apollo.BaseMutationOptions<ForceGateMutation, ForceGateMutationVariables>;
export const ClusterProvidersDocument = gql`
    query ClusterProviders {
  clusterProviders(first: 100) {
    edges {
      node {
        ...ClusterProvider
      }
    }
  }
}
    ${ClusterProviderFragmentDoc}`;

/**
 * __useClusterProvidersQuery__
 *
 * To run a query within a React component, call `useClusterProvidersQuery` and pass it any options that fit your needs.
 * When your component renders, `useClusterProvidersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClusterProvidersQuery({
 *   variables: {
 *   },
 * });
 */
export function useClusterProvidersQuery(baseOptions?: Apollo.QueryHookOptions<ClusterProvidersQuery, ClusterProvidersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClusterProvidersQuery, ClusterProvidersQueryVariables>(ClusterProvidersDocument, options);
      }
export function useClusterProvidersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClusterProvidersQuery, ClusterProvidersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClusterProvidersQuery, ClusterProvidersQueryVariables>(ClusterProvidersDocument, options);
        }
export function useClusterProvidersSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClusterProvidersQuery, ClusterProvidersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClusterProvidersQuery, ClusterProvidersQueryVariables>(ClusterProvidersDocument, options);
        }
export type ClusterProvidersQueryHookResult = ReturnType<typeof useClusterProvidersQuery>;
export type ClusterProvidersLazyQueryHookResult = ReturnType<typeof useClusterProvidersLazyQuery>;
export type ClusterProvidersSuspenseQueryHookResult = ReturnType<typeof useClusterProvidersSuspenseQuery>;
export type ClusterProvidersQueryResult = Apollo.QueryResult<ClusterProvidersQuery, ClusterProvidersQueryVariables>;
export const CreateClusterProviderDocument = gql`
    mutation CreateClusterProvider($attributes: ClusterProviderAttributes!) {
  createClusterProvider(attributes: $attributes) {
    ...ClusterProvider
  }
}
    ${ClusterProviderFragmentDoc}`;
export type CreateClusterProviderMutationFn = Apollo.MutationFunction<CreateClusterProviderMutation, CreateClusterProviderMutationVariables>;

/**
 * __useCreateClusterProviderMutation__
 *
 * To run a mutation, you first call `useCreateClusterProviderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateClusterProviderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createClusterProviderMutation, { data, loading, error }] = useCreateClusterProviderMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useCreateClusterProviderMutation(baseOptions?: Apollo.MutationHookOptions<CreateClusterProviderMutation, CreateClusterProviderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateClusterProviderMutation, CreateClusterProviderMutationVariables>(CreateClusterProviderDocument, options);
      }
export type CreateClusterProviderMutationHookResult = ReturnType<typeof useCreateClusterProviderMutation>;
export type CreateClusterProviderMutationResult = Apollo.MutationResult<CreateClusterProviderMutation>;
export type CreateClusterProviderMutationOptions = Apollo.BaseMutationOptions<CreateClusterProviderMutation, CreateClusterProviderMutationVariables>;
export const UpdateClusterProviderDocument = gql`
    mutation UpdateClusterProvider($id: ID!, $attributes: ClusterProviderUpdateAttributes!) {
  updateClusterProvider(id: $id, attributes: $attributes) {
    ...ClusterProvider
  }
}
    ${ClusterProviderFragmentDoc}`;
export type UpdateClusterProviderMutationFn = Apollo.MutationFunction<UpdateClusterProviderMutation, UpdateClusterProviderMutationVariables>;

/**
 * __useUpdateClusterProviderMutation__
 *
 * To run a mutation, you first call `useUpdateClusterProviderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateClusterProviderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateClusterProviderMutation, { data, loading, error }] = useUpdateClusterProviderMutation({
 *   variables: {
 *      id: // value for 'id'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpdateClusterProviderMutation(baseOptions?: Apollo.MutationHookOptions<UpdateClusterProviderMutation, UpdateClusterProviderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateClusterProviderMutation, UpdateClusterProviderMutationVariables>(UpdateClusterProviderDocument, options);
      }
export type UpdateClusterProviderMutationHookResult = ReturnType<typeof useUpdateClusterProviderMutation>;
export type UpdateClusterProviderMutationResult = Apollo.MutationResult<UpdateClusterProviderMutation>;
export type UpdateClusterProviderMutationOptions = Apollo.BaseMutationOptions<UpdateClusterProviderMutation, UpdateClusterProviderMutationVariables>;
export const DeleteClusterProviderDocument = gql`
    mutation DeleteClusterProvider($id: ID!) {
  deleteClusterProvider(id: $id) {
    ...ClusterProvider
  }
}
    ${ClusterProviderFragmentDoc}`;
export type DeleteClusterProviderMutationFn = Apollo.MutationFunction<DeleteClusterProviderMutation, DeleteClusterProviderMutationVariables>;

/**
 * __useDeleteClusterProviderMutation__
 *
 * To run a mutation, you first call `useDeleteClusterProviderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteClusterProviderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteClusterProviderMutation, { data, loading, error }] = useDeleteClusterProviderMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteClusterProviderMutation(baseOptions?: Apollo.MutationHookOptions<DeleteClusterProviderMutation, DeleteClusterProviderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteClusterProviderMutation, DeleteClusterProviderMutationVariables>(DeleteClusterProviderDocument, options);
      }
export type DeleteClusterProviderMutationHookResult = ReturnType<typeof useDeleteClusterProviderMutation>;
export type DeleteClusterProviderMutationResult = Apollo.MutationResult<DeleteClusterProviderMutation>;
export type DeleteClusterProviderMutationOptions = Apollo.BaseMutationOptions<DeleteClusterProviderMutation, DeleteClusterProviderMutationVariables>;
export const CreatePullRequestDocument = gql`
    mutation CreatePullRequest($id: ID!, $branch: String!, $identifier: String, $context: Json!, $threadId: ID) {
  createPullRequest(
    id: $id
    branch: $branch
    identifier: $identifier
    context: $context
    threadId: $threadId
  ) {
    ...PullRequest
  }
}
    ${PullRequestFragmentDoc}`;
export type CreatePullRequestMutationFn = Apollo.MutationFunction<CreatePullRequestMutation, CreatePullRequestMutationVariables>;

/**
 * __useCreatePullRequestMutation__
 *
 * To run a mutation, you first call `useCreatePullRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePullRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPullRequestMutation, { data, loading, error }] = useCreatePullRequestMutation({
 *   variables: {
 *      id: // value for 'id'
 *      branch: // value for 'branch'
 *      identifier: // value for 'identifier'
 *      context: // value for 'context'
 *      threadId: // value for 'threadId'
 *   },
 * });
 */
export function useCreatePullRequestMutation(baseOptions?: Apollo.MutationHookOptions<CreatePullRequestMutation, CreatePullRequestMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreatePullRequestMutation, CreatePullRequestMutationVariables>(CreatePullRequestDocument, options);
      }
export type CreatePullRequestMutationHookResult = ReturnType<typeof useCreatePullRequestMutation>;
export type CreatePullRequestMutationResult = Apollo.MutationResult<CreatePullRequestMutation>;
export type CreatePullRequestMutationOptions = Apollo.BaseMutationOptions<CreatePullRequestMutation, CreatePullRequestMutationVariables>;
export const UpdatePullRequestDocument = gql`
    mutation UpdatePullRequest($id: ID!, $attributes: PullRequestUpdateAttributes) {
  updatePullRequest(id: $id, attributes: $attributes) {
    ...PullRequest
  }
}
    ${PullRequestFragmentDoc}`;
export type UpdatePullRequestMutationFn = Apollo.MutationFunction<UpdatePullRequestMutation, UpdatePullRequestMutationVariables>;

/**
 * __useUpdatePullRequestMutation__
 *
 * To run a mutation, you first call `useUpdatePullRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdatePullRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updatePullRequestMutation, { data, loading, error }] = useUpdatePullRequestMutation({
 *   variables: {
 *      id: // value for 'id'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpdatePullRequestMutation(baseOptions?: Apollo.MutationHookOptions<UpdatePullRequestMutation, UpdatePullRequestMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdatePullRequestMutation, UpdatePullRequestMutationVariables>(UpdatePullRequestDocument, options);
      }
export type UpdatePullRequestMutationHookResult = ReturnType<typeof useUpdatePullRequestMutation>;
export type UpdatePullRequestMutationResult = Apollo.MutationResult<UpdatePullRequestMutation>;
export type UpdatePullRequestMutationOptions = Apollo.BaseMutationOptions<UpdatePullRequestMutation, UpdatePullRequestMutationVariables>;
export const DeletePullRequestDocument = gql`
    mutation DeletePullRequest($id: ID!) {
  deletePullRequest(id: $id) {
    ...PullRequest
  }
}
    ${PullRequestFragmentDoc}`;
export type DeletePullRequestMutationFn = Apollo.MutationFunction<DeletePullRequestMutation, DeletePullRequestMutationVariables>;

/**
 * __useDeletePullRequestMutation__
 *
 * To run a mutation, you first call `useDeletePullRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeletePullRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deletePullRequestMutation, { data, loading, error }] = useDeletePullRequestMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeletePullRequestMutation(baseOptions?: Apollo.MutationHookOptions<DeletePullRequestMutation, DeletePullRequestMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeletePullRequestMutation, DeletePullRequestMutationVariables>(DeletePullRequestDocument, options);
      }
export type DeletePullRequestMutationHookResult = ReturnType<typeof useDeletePullRequestMutation>;
export type DeletePullRequestMutationResult = Apollo.MutationResult<DeletePullRequestMutation>;
export type DeletePullRequestMutationOptions = Apollo.BaseMutationOptions<DeletePullRequestMutation, DeletePullRequestMutationVariables>;
export const PullRequestsDocument = gql`
    query PullRequests($q: String, $first: Int = 100, $after: String, $clusterId: ID, $serviceId: ID, $open: Boolean) {
  pullRequests(
    q: $q
    first: $first
    after: $after
    clusterId: $clusterId
    serviceId: $serviceId
    open: $open
  ) {
    ...PullRequestConnection
  }
}
    ${PullRequestConnectionFragmentDoc}`;

/**
 * __usePullRequestsQuery__
 *
 * To run a query within a React component, call `usePullRequestsQuery` and pass it any options that fit your needs.
 * When your component renders, `usePullRequestsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePullRequestsQuery({
 *   variables: {
 *      q: // value for 'q'
 *      first: // value for 'first'
 *      after: // value for 'after'
 *      clusterId: // value for 'clusterId'
 *      serviceId: // value for 'serviceId'
 *      open: // value for 'open'
 *   },
 * });
 */
export function usePullRequestsQuery(baseOptions?: Apollo.QueryHookOptions<PullRequestsQuery, PullRequestsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PullRequestsQuery, PullRequestsQueryVariables>(PullRequestsDocument, options);
      }
export function usePullRequestsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PullRequestsQuery, PullRequestsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PullRequestsQuery, PullRequestsQueryVariables>(PullRequestsDocument, options);
        }
export function usePullRequestsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<PullRequestsQuery, PullRequestsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PullRequestsQuery, PullRequestsQueryVariables>(PullRequestsDocument, options);
        }
export type PullRequestsQueryHookResult = ReturnType<typeof usePullRequestsQuery>;
export type PullRequestsLazyQueryHookResult = ReturnType<typeof usePullRequestsLazyQuery>;
export type PullRequestsSuspenseQueryHookResult = ReturnType<typeof usePullRequestsSuspenseQuery>;
export type PullRequestsQueryResult = Apollo.QueryResult<PullRequestsQuery, PullRequestsQueryVariables>;
export const ServiceDeploymentsDocument = gql`
    query ServiceDeployments($first: Int = 100, $after: String, $q: String, $cluster: String, $clusterId: ID, $status: ServiceDeploymentStatus, $projectId: ID) {
  serviceDeployments(
    first: $first
    after: $after
    q: $q
    cluster: $cluster
    clusterId: $clusterId
    status: $status
    projectId: $projectId
  ) {
    ...ServiceDeploymentsConnection
  }
  serviceStatuses(clusterId: $clusterId) {
    ...ServiceStatusCount
  }
}
    ${ServiceDeploymentsConnectionFragmentDoc}
${ServiceStatusCountFragmentDoc}`;

/**
 * __useServiceDeploymentsQuery__
 *
 * To run a query within a React component, call `useServiceDeploymentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useServiceDeploymentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useServiceDeploymentsQuery({
 *   variables: {
 *      first: // value for 'first'
 *      after: // value for 'after'
 *      q: // value for 'q'
 *      cluster: // value for 'cluster'
 *      clusterId: // value for 'clusterId'
 *      status: // value for 'status'
 *      projectId: // value for 'projectId'
 *   },
 * });
 */
export function useServiceDeploymentsQuery(baseOptions?: Apollo.QueryHookOptions<ServiceDeploymentsQuery, ServiceDeploymentsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ServiceDeploymentsQuery, ServiceDeploymentsQueryVariables>(ServiceDeploymentsDocument, options);
      }
export function useServiceDeploymentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ServiceDeploymentsQuery, ServiceDeploymentsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ServiceDeploymentsQuery, ServiceDeploymentsQueryVariables>(ServiceDeploymentsDocument, options);
        }
export function useServiceDeploymentsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ServiceDeploymentsQuery, ServiceDeploymentsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ServiceDeploymentsQuery, ServiceDeploymentsQueryVariables>(ServiceDeploymentsDocument, options);
        }
export type ServiceDeploymentsQueryHookResult = ReturnType<typeof useServiceDeploymentsQuery>;
export type ServiceDeploymentsLazyQueryHookResult = ReturnType<typeof useServiceDeploymentsLazyQuery>;
export type ServiceDeploymentsSuspenseQueryHookResult = ReturnType<typeof useServiceDeploymentsSuspenseQuery>;
export type ServiceDeploymentsQueryResult = Apollo.QueryResult<ServiceDeploymentsQuery, ServiceDeploymentsQueryVariables>;
export const ServiceDeploymentsTinyDocument = gql`
    query ServiceDeploymentsTiny($clusterId: ID, $projectId: ID) {
  serviceDeployments(first: 100, clusterId: $clusterId, projectId: $projectId) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...ServiceDeploymentTiny
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${ServiceDeploymentTinyFragmentDoc}`;

/**
 * __useServiceDeploymentsTinyQuery__
 *
 * To run a query within a React component, call `useServiceDeploymentsTinyQuery` and pass it any options that fit your needs.
 * When your component renders, `useServiceDeploymentsTinyQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useServiceDeploymentsTinyQuery({
 *   variables: {
 *      clusterId: // value for 'clusterId'
 *      projectId: // value for 'projectId'
 *   },
 * });
 */
export function useServiceDeploymentsTinyQuery(baseOptions?: Apollo.QueryHookOptions<ServiceDeploymentsTinyQuery, ServiceDeploymentsTinyQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ServiceDeploymentsTinyQuery, ServiceDeploymentsTinyQueryVariables>(ServiceDeploymentsTinyDocument, options);
      }
export function useServiceDeploymentsTinyLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ServiceDeploymentsTinyQuery, ServiceDeploymentsTinyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ServiceDeploymentsTinyQuery, ServiceDeploymentsTinyQueryVariables>(ServiceDeploymentsTinyDocument, options);
        }
export function useServiceDeploymentsTinySuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ServiceDeploymentsTinyQuery, ServiceDeploymentsTinyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ServiceDeploymentsTinyQuery, ServiceDeploymentsTinyQueryVariables>(ServiceDeploymentsTinyDocument, options);
        }
export type ServiceDeploymentsTinyQueryHookResult = ReturnType<typeof useServiceDeploymentsTinyQuery>;
export type ServiceDeploymentsTinyLazyQueryHookResult = ReturnType<typeof useServiceDeploymentsTinyLazyQuery>;
export type ServiceDeploymentsTinySuspenseQueryHookResult = ReturnType<typeof useServiceDeploymentsTinySuspenseQuery>;
export type ServiceDeploymentsTinyQueryResult = Apollo.QueryResult<ServiceDeploymentsTinyQuery, ServiceDeploymentsTinyQueryVariables>;
export const ServiceTreeDocument = gql`
    query ServiceTree($first: Int = 100, $status: ServiceDeploymentStatus, $clusterId: ID, $projectId: ID) {
  serviceTree(
    first: $first
    status: $status
    clusterId: $clusterId
    projectId: $projectId
  ) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...ServiceTreeNode
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${ServiceTreeNodeFragmentDoc}`;

/**
 * __useServiceTreeQuery__
 *
 * To run a query within a React component, call `useServiceTreeQuery` and pass it any options that fit your needs.
 * When your component renders, `useServiceTreeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useServiceTreeQuery({
 *   variables: {
 *      first: // value for 'first'
 *      status: // value for 'status'
 *      clusterId: // value for 'clusterId'
 *      projectId: // value for 'projectId'
 *   },
 * });
 */
export function useServiceTreeQuery(baseOptions?: Apollo.QueryHookOptions<ServiceTreeQuery, ServiceTreeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ServiceTreeQuery, ServiceTreeQueryVariables>(ServiceTreeDocument, options);
      }
export function useServiceTreeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ServiceTreeQuery, ServiceTreeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ServiceTreeQuery, ServiceTreeQueryVariables>(ServiceTreeDocument, options);
        }
export function useServiceTreeSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ServiceTreeQuery, ServiceTreeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ServiceTreeQuery, ServiceTreeQueryVariables>(ServiceTreeDocument, options);
        }
export type ServiceTreeQueryHookResult = ReturnType<typeof useServiceTreeQuery>;
export type ServiceTreeLazyQueryHookResult = ReturnType<typeof useServiceTreeLazyQuery>;
export type ServiceTreeSuspenseQueryHookResult = ReturnType<typeof useServiceTreeSuspenseQuery>;
export type ServiceTreeQueryResult = Apollo.QueryResult<ServiceTreeQuery, ServiceTreeQueryVariables>;
export const ServiceDeploymentDocument = gql`
    query ServiceDeployment($id: ID!) {
  serviceDeployment(id: $id) {
    ...ServiceDeploymentDetails
  }
}
    ${ServiceDeploymentDetailsFragmentDoc}`;

/**
 * __useServiceDeploymentQuery__
 *
 * To run a query within a React component, call `useServiceDeploymentQuery` and pass it any options that fit your needs.
 * When your component renders, `useServiceDeploymentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useServiceDeploymentQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useServiceDeploymentQuery(baseOptions: Apollo.QueryHookOptions<ServiceDeploymentQuery, ServiceDeploymentQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ServiceDeploymentQuery, ServiceDeploymentQueryVariables>(ServiceDeploymentDocument, options);
      }
export function useServiceDeploymentLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ServiceDeploymentQuery, ServiceDeploymentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ServiceDeploymentQuery, ServiceDeploymentQueryVariables>(ServiceDeploymentDocument, options);
        }
export function useServiceDeploymentSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ServiceDeploymentQuery, ServiceDeploymentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ServiceDeploymentQuery, ServiceDeploymentQueryVariables>(ServiceDeploymentDocument, options);
        }
export type ServiceDeploymentQueryHookResult = ReturnType<typeof useServiceDeploymentQuery>;
export type ServiceDeploymentLazyQueryHookResult = ReturnType<typeof useServiceDeploymentLazyQuery>;
export type ServiceDeploymentSuspenseQueryHookResult = ReturnType<typeof useServiceDeploymentSuspenseQuery>;
export type ServiceDeploymentQueryResult = Apollo.QueryResult<ServiceDeploymentQuery, ServiceDeploymentQueryVariables>;
export const ServiceDeploymentTinyDocument = gql`
    query ServiceDeploymentTiny($id: ID!) {
  serviceDeployment(id: $id) {
    ...ServiceDeploymentTiny
  }
}
    ${ServiceDeploymentTinyFragmentDoc}`;

/**
 * __useServiceDeploymentTinyQuery__
 *
 * To run a query within a React component, call `useServiceDeploymentTinyQuery` and pass it any options that fit your needs.
 * When your component renders, `useServiceDeploymentTinyQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useServiceDeploymentTinyQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useServiceDeploymentTinyQuery(baseOptions: Apollo.QueryHookOptions<ServiceDeploymentTinyQuery, ServiceDeploymentTinyQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ServiceDeploymentTinyQuery, ServiceDeploymentTinyQueryVariables>(ServiceDeploymentTinyDocument, options);
      }
export function useServiceDeploymentTinyLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ServiceDeploymentTinyQuery, ServiceDeploymentTinyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ServiceDeploymentTinyQuery, ServiceDeploymentTinyQueryVariables>(ServiceDeploymentTinyDocument, options);
        }
export function useServiceDeploymentTinySuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ServiceDeploymentTinyQuery, ServiceDeploymentTinyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ServiceDeploymentTinyQuery, ServiceDeploymentTinyQueryVariables>(ServiceDeploymentTinyDocument, options);
        }
export type ServiceDeploymentTinyQueryHookResult = ReturnType<typeof useServiceDeploymentTinyQuery>;
export type ServiceDeploymentTinyLazyQueryHookResult = ReturnType<typeof useServiceDeploymentTinyLazyQuery>;
export type ServiceDeploymentTinySuspenseQueryHookResult = ReturnType<typeof useServiceDeploymentTinySuspenseQuery>;
export type ServiceDeploymentTinyQueryResult = Apollo.QueryResult<ServiceDeploymentTinyQuery, ServiceDeploymentTinyQueryVariables>;
export const ServiceDeploymentComponentsDocument = gql`
    query ServiceDeploymentComponents($id: ID!) {
  serviceDeployment(id: $id) {
    id
    name
    cluster {
      id
      name
      handle
    }
    components {
      ...ServiceDeploymentComponent
    }
  }
}
    ${ServiceDeploymentComponentFragmentDoc}`;

/**
 * __useServiceDeploymentComponentsQuery__
 *
 * To run a query within a React component, call `useServiceDeploymentComponentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useServiceDeploymentComponentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useServiceDeploymentComponentsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useServiceDeploymentComponentsQuery(baseOptions: Apollo.QueryHookOptions<ServiceDeploymentComponentsQuery, ServiceDeploymentComponentsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ServiceDeploymentComponentsQuery, ServiceDeploymentComponentsQueryVariables>(ServiceDeploymentComponentsDocument, options);
      }
export function useServiceDeploymentComponentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ServiceDeploymentComponentsQuery, ServiceDeploymentComponentsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ServiceDeploymentComponentsQuery, ServiceDeploymentComponentsQueryVariables>(ServiceDeploymentComponentsDocument, options);
        }
export function useServiceDeploymentComponentsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ServiceDeploymentComponentsQuery, ServiceDeploymentComponentsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ServiceDeploymentComponentsQuery, ServiceDeploymentComponentsQueryVariables>(ServiceDeploymentComponentsDocument, options);
        }
export type ServiceDeploymentComponentsQueryHookResult = ReturnType<typeof useServiceDeploymentComponentsQuery>;
export type ServiceDeploymentComponentsLazyQueryHookResult = ReturnType<typeof useServiceDeploymentComponentsLazyQuery>;
export type ServiceDeploymentComponentsSuspenseQueryHookResult = ReturnType<typeof useServiceDeploymentComponentsSuspenseQuery>;
export type ServiceDeploymentComponentsQueryResult = Apollo.QueryResult<ServiceDeploymentComponentsQuery, ServiceDeploymentComponentsQueryVariables>;
export const ServiceDeploymentComponentsWithChildrenDocument = gql`
    query ServiceDeploymentComponentsWithChildren($id: ID!) {
  serviceDeployment(id: $id) {
    id
    name
    cluster {
      id
      name
      handle
    }
    components {
      ...ServiceDeploymentComponentWithChildren
    }
  }
}
    ${ServiceDeploymentComponentWithChildrenFragmentDoc}`;

/**
 * __useServiceDeploymentComponentsWithChildrenQuery__
 *
 * To run a query within a React component, call `useServiceDeploymentComponentsWithChildrenQuery` and pass it any options that fit your needs.
 * When your component renders, `useServiceDeploymentComponentsWithChildrenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useServiceDeploymentComponentsWithChildrenQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useServiceDeploymentComponentsWithChildrenQuery(baseOptions: Apollo.QueryHookOptions<ServiceDeploymentComponentsWithChildrenQuery, ServiceDeploymentComponentsWithChildrenQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ServiceDeploymentComponentsWithChildrenQuery, ServiceDeploymentComponentsWithChildrenQueryVariables>(ServiceDeploymentComponentsWithChildrenDocument, options);
      }
export function useServiceDeploymentComponentsWithChildrenLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ServiceDeploymentComponentsWithChildrenQuery, ServiceDeploymentComponentsWithChildrenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ServiceDeploymentComponentsWithChildrenQuery, ServiceDeploymentComponentsWithChildrenQueryVariables>(ServiceDeploymentComponentsWithChildrenDocument, options);
        }
export function useServiceDeploymentComponentsWithChildrenSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ServiceDeploymentComponentsWithChildrenQuery, ServiceDeploymentComponentsWithChildrenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ServiceDeploymentComponentsWithChildrenQuery, ServiceDeploymentComponentsWithChildrenQueryVariables>(ServiceDeploymentComponentsWithChildrenDocument, options);
        }
export type ServiceDeploymentComponentsWithChildrenQueryHookResult = ReturnType<typeof useServiceDeploymentComponentsWithChildrenQuery>;
export type ServiceDeploymentComponentsWithChildrenLazyQueryHookResult = ReturnType<typeof useServiceDeploymentComponentsWithChildrenLazyQuery>;
export type ServiceDeploymentComponentsWithChildrenSuspenseQueryHookResult = ReturnType<typeof useServiceDeploymentComponentsWithChildrenSuspenseQuery>;
export type ServiceDeploymentComponentsWithChildrenQueryResult = Apollo.QueryResult<ServiceDeploymentComponentsWithChildrenQuery, ServiceDeploymentComponentsWithChildrenQueryVariables>;
export const ServiceDeploymentSecretsDocument = gql`
    query ServiceDeploymentSecrets($id: ID!) {
  serviceDeployment(id: $id) {
    configuration {
      name
      value
    }
    helm {
      values
    }
  }
}
    `;

/**
 * __useServiceDeploymentSecretsQuery__
 *
 * To run a query within a React component, call `useServiceDeploymentSecretsQuery` and pass it any options that fit your needs.
 * When your component renders, `useServiceDeploymentSecretsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useServiceDeploymentSecretsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useServiceDeploymentSecretsQuery(baseOptions: Apollo.QueryHookOptions<ServiceDeploymentSecretsQuery, ServiceDeploymentSecretsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ServiceDeploymentSecretsQuery, ServiceDeploymentSecretsQueryVariables>(ServiceDeploymentSecretsDocument, options);
      }
export function useServiceDeploymentSecretsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ServiceDeploymentSecretsQuery, ServiceDeploymentSecretsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ServiceDeploymentSecretsQuery, ServiceDeploymentSecretsQueryVariables>(ServiceDeploymentSecretsDocument, options);
        }
export function useServiceDeploymentSecretsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ServiceDeploymentSecretsQuery, ServiceDeploymentSecretsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ServiceDeploymentSecretsQuery, ServiceDeploymentSecretsQueryVariables>(ServiceDeploymentSecretsDocument, options);
        }
export type ServiceDeploymentSecretsQueryHookResult = ReturnType<typeof useServiceDeploymentSecretsQuery>;
export type ServiceDeploymentSecretsLazyQueryHookResult = ReturnType<typeof useServiceDeploymentSecretsLazyQuery>;
export type ServiceDeploymentSecretsSuspenseQueryHookResult = ReturnType<typeof useServiceDeploymentSecretsSuspenseQuery>;
export type ServiceDeploymentSecretsQueryResult = Apollo.QueryResult<ServiceDeploymentSecretsQuery, ServiceDeploymentSecretsQueryVariables>;
export const ServiceDeploymentRevisionsDocument = gql`
    query ServiceDeploymentRevisions($id: ID!) {
  serviceDeployment(id: $id) {
    ...ServiceDeploymentRevisions
  }
}
    ${ServiceDeploymentRevisionsFragmentDoc}`;

/**
 * __useServiceDeploymentRevisionsQuery__
 *
 * To run a query within a React component, call `useServiceDeploymentRevisionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useServiceDeploymentRevisionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useServiceDeploymentRevisionsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useServiceDeploymentRevisionsQuery(baseOptions: Apollo.QueryHookOptions<ServiceDeploymentRevisionsQuery, ServiceDeploymentRevisionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ServiceDeploymentRevisionsQuery, ServiceDeploymentRevisionsQueryVariables>(ServiceDeploymentRevisionsDocument, options);
      }
export function useServiceDeploymentRevisionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ServiceDeploymentRevisionsQuery, ServiceDeploymentRevisionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ServiceDeploymentRevisionsQuery, ServiceDeploymentRevisionsQueryVariables>(ServiceDeploymentRevisionsDocument, options);
        }
export function useServiceDeploymentRevisionsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ServiceDeploymentRevisionsQuery, ServiceDeploymentRevisionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ServiceDeploymentRevisionsQuery, ServiceDeploymentRevisionsQueryVariables>(ServiceDeploymentRevisionsDocument, options);
        }
export type ServiceDeploymentRevisionsQueryHookResult = ReturnType<typeof useServiceDeploymentRevisionsQuery>;
export type ServiceDeploymentRevisionsLazyQueryHookResult = ReturnType<typeof useServiceDeploymentRevisionsLazyQuery>;
export type ServiceDeploymentRevisionsSuspenseQueryHookResult = ReturnType<typeof useServiceDeploymentRevisionsSuspenseQuery>;
export type ServiceDeploymentRevisionsQueryResult = Apollo.QueryResult<ServiceDeploymentRevisionsQuery, ServiceDeploymentRevisionsQueryVariables>;
export const CreateServiceDeploymentDocument = gql`
    mutation CreateServiceDeployment($attributes: ServiceDeploymentAttributes!, $cluster: String, $clusterId: ID) {
  createServiceDeployment(
    attributes: $attributes
    cluster: $cluster
    clusterId: $clusterId
  ) {
    ...ServiceDeploymentsRow
  }
}
    ${ServiceDeploymentsRowFragmentDoc}`;
export type CreateServiceDeploymentMutationFn = Apollo.MutationFunction<CreateServiceDeploymentMutation, CreateServiceDeploymentMutationVariables>;

/**
 * __useCreateServiceDeploymentMutation__
 *
 * To run a mutation, you first call `useCreateServiceDeploymentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateServiceDeploymentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createServiceDeploymentMutation, { data, loading, error }] = useCreateServiceDeploymentMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *      cluster: // value for 'cluster'
 *      clusterId: // value for 'clusterId'
 *   },
 * });
 */
export function useCreateServiceDeploymentMutation(baseOptions?: Apollo.MutationHookOptions<CreateServiceDeploymentMutation, CreateServiceDeploymentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateServiceDeploymentMutation, CreateServiceDeploymentMutationVariables>(CreateServiceDeploymentDocument, options);
      }
export type CreateServiceDeploymentMutationHookResult = ReturnType<typeof useCreateServiceDeploymentMutation>;
export type CreateServiceDeploymentMutationResult = Apollo.MutationResult<CreateServiceDeploymentMutation>;
export type CreateServiceDeploymentMutationOptions = Apollo.BaseMutationOptions<CreateServiceDeploymentMutation, CreateServiceDeploymentMutationVariables>;
export const UpdateServiceDeploymentDocument = gql`
    mutation UpdateServiceDeployment($id: ID!, $attributes: ServiceUpdateAttributes!) {
  updateServiceDeployment(id: $id, attributes: $attributes) {
    ...ServiceDeploymentDetails
  }
}
    ${ServiceDeploymentDetailsFragmentDoc}`;
export type UpdateServiceDeploymentMutationFn = Apollo.MutationFunction<UpdateServiceDeploymentMutation, UpdateServiceDeploymentMutationVariables>;

/**
 * __useUpdateServiceDeploymentMutation__
 *
 * To run a mutation, you first call `useUpdateServiceDeploymentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateServiceDeploymentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateServiceDeploymentMutation, { data, loading, error }] = useUpdateServiceDeploymentMutation({
 *   variables: {
 *      id: // value for 'id'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpdateServiceDeploymentMutation(baseOptions?: Apollo.MutationHookOptions<UpdateServiceDeploymentMutation, UpdateServiceDeploymentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateServiceDeploymentMutation, UpdateServiceDeploymentMutationVariables>(UpdateServiceDeploymentDocument, options);
      }
export type UpdateServiceDeploymentMutationHookResult = ReturnType<typeof useUpdateServiceDeploymentMutation>;
export type UpdateServiceDeploymentMutationResult = Apollo.MutationResult<UpdateServiceDeploymentMutation>;
export type UpdateServiceDeploymentMutationOptions = Apollo.BaseMutationOptions<UpdateServiceDeploymentMutation, UpdateServiceDeploymentMutationVariables>;
export const MergeServiceDocument = gql`
    mutation MergeService($id: ID!, $configuration: [ConfigAttributes]) {
  mergeService(id: $id, configuration: $configuration) {
    configuration {
      name
      value
    }
  }
}
    `;
export type MergeServiceMutationFn = Apollo.MutationFunction<MergeServiceMutation, MergeServiceMutationVariables>;

/**
 * __useMergeServiceMutation__
 *
 * To run a mutation, you first call `useMergeServiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useMergeServiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [mergeServiceMutation, { data, loading, error }] = useMergeServiceMutation({
 *   variables: {
 *      id: // value for 'id'
 *      configuration: // value for 'configuration'
 *   },
 * });
 */
export function useMergeServiceMutation(baseOptions?: Apollo.MutationHookOptions<MergeServiceMutation, MergeServiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<MergeServiceMutation, MergeServiceMutationVariables>(MergeServiceDocument, options);
      }
export type MergeServiceMutationHookResult = ReturnType<typeof useMergeServiceMutation>;
export type MergeServiceMutationResult = Apollo.MutationResult<MergeServiceMutation>;
export type MergeServiceMutationOptions = Apollo.BaseMutationOptions<MergeServiceMutation, MergeServiceMutationVariables>;
export const DeleteServiceDeploymentDocument = gql`
    mutation DeleteServiceDeployment($id: ID!) {
  deleteServiceDeployment(id: $id) {
    id
  }
}
    `;
export type DeleteServiceDeploymentMutationFn = Apollo.MutationFunction<DeleteServiceDeploymentMutation, DeleteServiceDeploymentMutationVariables>;

/**
 * __useDeleteServiceDeploymentMutation__
 *
 * To run a mutation, you first call `useDeleteServiceDeploymentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteServiceDeploymentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteServiceDeploymentMutation, { data, loading, error }] = useDeleteServiceDeploymentMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteServiceDeploymentMutation(baseOptions?: Apollo.MutationHookOptions<DeleteServiceDeploymentMutation, DeleteServiceDeploymentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteServiceDeploymentMutation, DeleteServiceDeploymentMutationVariables>(DeleteServiceDeploymentDocument, options);
      }
export type DeleteServiceDeploymentMutationHookResult = ReturnType<typeof useDeleteServiceDeploymentMutation>;
export type DeleteServiceDeploymentMutationResult = Apollo.MutationResult<DeleteServiceDeploymentMutation>;
export type DeleteServiceDeploymentMutationOptions = Apollo.BaseMutationOptions<DeleteServiceDeploymentMutation, DeleteServiceDeploymentMutationVariables>;
export const DetachServiceDeploymentDocument = gql`
    mutation DetachServiceDeployment($id: ID!) {
  detachServiceDeployment(id: $id) {
    id
  }
}
    `;
export type DetachServiceDeploymentMutationFn = Apollo.MutationFunction<DetachServiceDeploymentMutation, DetachServiceDeploymentMutationVariables>;

/**
 * __useDetachServiceDeploymentMutation__
 *
 * To run a mutation, you first call `useDetachServiceDeploymentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDetachServiceDeploymentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [detachServiceDeploymentMutation, { data, loading, error }] = useDetachServiceDeploymentMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDetachServiceDeploymentMutation(baseOptions?: Apollo.MutationHookOptions<DetachServiceDeploymentMutation, DetachServiceDeploymentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DetachServiceDeploymentMutation, DetachServiceDeploymentMutationVariables>(DetachServiceDeploymentDocument, options);
      }
export type DetachServiceDeploymentMutationHookResult = ReturnType<typeof useDetachServiceDeploymentMutation>;
export type DetachServiceDeploymentMutationResult = Apollo.MutationResult<DetachServiceDeploymentMutation>;
export type DetachServiceDeploymentMutationOptions = Apollo.BaseMutationOptions<DetachServiceDeploymentMutation, DetachServiceDeploymentMutationVariables>;
export const RollbackServiceDocument = gql`
    mutation RollbackService($id: ID, $revisionId: ID!) {
  rollbackService(id: $id, revisionId: $revisionId) {
    ...ServiceDeploymentsRow
  }
}
    ${ServiceDeploymentsRowFragmentDoc}`;
export type RollbackServiceMutationFn = Apollo.MutationFunction<RollbackServiceMutation, RollbackServiceMutationVariables>;

/**
 * __useRollbackServiceMutation__
 *
 * To run a mutation, you first call `useRollbackServiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRollbackServiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [rollbackServiceMutation, { data, loading, error }] = useRollbackServiceMutation({
 *   variables: {
 *      id: // value for 'id'
 *      revisionId: // value for 'revisionId'
 *   },
 * });
 */
export function useRollbackServiceMutation(baseOptions?: Apollo.MutationHookOptions<RollbackServiceMutation, RollbackServiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RollbackServiceMutation, RollbackServiceMutationVariables>(RollbackServiceDocument, options);
      }
export type RollbackServiceMutationHookResult = ReturnType<typeof useRollbackServiceMutation>;
export type RollbackServiceMutationResult = Apollo.MutationResult<RollbackServiceMutation>;
export type RollbackServiceMutationOptions = Apollo.BaseMutationOptions<RollbackServiceMutation, RollbackServiceMutationVariables>;
export const ProceedServiceDocument = gql`
    mutation ProceedService($id: ID!, $promotion: ServicePromotion) {
  proceed(id: $id, promotion: $promotion) {
    ...ServiceDeploymentDetails
  }
}
    ${ServiceDeploymentDetailsFragmentDoc}`;
export type ProceedServiceMutationFn = Apollo.MutationFunction<ProceedServiceMutation, ProceedServiceMutationVariables>;

/**
 * __useProceedServiceMutation__
 *
 * To run a mutation, you first call `useProceedServiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useProceedServiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [proceedServiceMutation, { data, loading, error }] = useProceedServiceMutation({
 *   variables: {
 *      id: // value for 'id'
 *      promotion: // value for 'promotion'
 *   },
 * });
 */
export function useProceedServiceMutation(baseOptions?: Apollo.MutationHookOptions<ProceedServiceMutation, ProceedServiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ProceedServiceMutation, ProceedServiceMutationVariables>(ProceedServiceDocument, options);
      }
export type ProceedServiceMutationHookResult = ReturnType<typeof useProceedServiceMutation>;
export type ProceedServiceMutationResult = Apollo.MutationResult<ProceedServiceMutation>;
export type ProceedServiceMutationOptions = Apollo.BaseMutationOptions<ProceedServiceMutation, ProceedServiceMutationVariables>;
export const SelfManageDocument = gql`
    mutation SelfManage($values: String!) {
  selfManage(values: $values) {
    ...ServiceDeploymentsRow
  }
}
    ${ServiceDeploymentsRowFragmentDoc}`;
export type SelfManageMutationFn = Apollo.MutationFunction<SelfManageMutation, SelfManageMutationVariables>;

/**
 * __useSelfManageMutation__
 *
 * To run a mutation, you first call `useSelfManageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSelfManageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [selfManageMutation, { data, loading, error }] = useSelfManageMutation({
 *   variables: {
 *      values: // value for 'values'
 *   },
 * });
 */
export function useSelfManageMutation(baseOptions?: Apollo.MutationHookOptions<SelfManageMutation, SelfManageMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SelfManageMutation, SelfManageMutationVariables>(SelfManageDocument, options);
      }
export type SelfManageMutationHookResult = ReturnType<typeof useSelfManageMutation>;
export type SelfManageMutationResult = Apollo.MutationResult<SelfManageMutation>;
export type SelfManageMutationOptions = Apollo.BaseMutationOptions<SelfManageMutation, SelfManageMutationVariables>;
export const KickServiceDocument = gql`
    mutation KickService($id: ID!) {
  kickService(serviceId: $id) {
    ...ServiceDeploymentsRow
  }
}
    ${ServiceDeploymentsRowFragmentDoc}`;
export type KickServiceMutationFn = Apollo.MutationFunction<KickServiceMutation, KickServiceMutationVariables>;

/**
 * __useKickServiceMutation__
 *
 * To run a mutation, you first call `useKickServiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useKickServiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [kickServiceMutation, { data, loading, error }] = useKickServiceMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useKickServiceMutation(baseOptions?: Apollo.MutationHookOptions<KickServiceMutation, KickServiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<KickServiceMutation, KickServiceMutationVariables>(KickServiceDocument, options);
      }
export type KickServiceMutationHookResult = ReturnType<typeof useKickServiceMutation>;
export type KickServiceMutationResult = Apollo.MutationResult<KickServiceMutation>;
export type KickServiceMutationOptions = Apollo.BaseMutationOptions<KickServiceMutation, KickServiceMutationVariables>;
export const ServiceDeploymentBindingsDocument = gql`
    query ServiceDeploymentBindings($id: ID!) {
  serviceDeployment(id: $id) {
    id
    ...ServiceDeploymentBindings
  }
}
    ${ServiceDeploymentBindingsFragmentDoc}`;

/**
 * __useServiceDeploymentBindingsQuery__
 *
 * To run a query within a React component, call `useServiceDeploymentBindingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useServiceDeploymentBindingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useServiceDeploymentBindingsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useServiceDeploymentBindingsQuery(baseOptions: Apollo.QueryHookOptions<ServiceDeploymentBindingsQuery, ServiceDeploymentBindingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ServiceDeploymentBindingsQuery, ServiceDeploymentBindingsQueryVariables>(ServiceDeploymentBindingsDocument, options);
      }
export function useServiceDeploymentBindingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ServiceDeploymentBindingsQuery, ServiceDeploymentBindingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ServiceDeploymentBindingsQuery, ServiceDeploymentBindingsQueryVariables>(ServiceDeploymentBindingsDocument, options);
        }
export function useServiceDeploymentBindingsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ServiceDeploymentBindingsQuery, ServiceDeploymentBindingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ServiceDeploymentBindingsQuery, ServiceDeploymentBindingsQueryVariables>(ServiceDeploymentBindingsDocument, options);
        }
export type ServiceDeploymentBindingsQueryHookResult = ReturnType<typeof useServiceDeploymentBindingsQuery>;
export type ServiceDeploymentBindingsLazyQueryHookResult = ReturnType<typeof useServiceDeploymentBindingsLazyQuery>;
export type ServiceDeploymentBindingsSuspenseQueryHookResult = ReturnType<typeof useServiceDeploymentBindingsSuspenseQuery>;
export type ServiceDeploymentBindingsQueryResult = Apollo.QueryResult<ServiceDeploymentBindingsQuery, ServiceDeploymentBindingsQueryVariables>;
export const ServiceStatusesDocument = gql`
    query ServiceStatuses($clusterId: ID) {
  serviceStatuses(clusterId: $clusterId) {
    ...ServiceStatusCount
  }
}
    ${ServiceStatusCountFragmentDoc}`;

/**
 * __useServiceStatusesQuery__
 *
 * To run a query within a React component, call `useServiceStatusesQuery` and pass it any options that fit your needs.
 * When your component renders, `useServiceStatusesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useServiceStatusesQuery({
 *   variables: {
 *      clusterId: // value for 'clusterId'
 *   },
 * });
 */
export function useServiceStatusesQuery(baseOptions?: Apollo.QueryHookOptions<ServiceStatusesQuery, ServiceStatusesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ServiceStatusesQuery, ServiceStatusesQueryVariables>(ServiceStatusesDocument, options);
      }
export function useServiceStatusesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ServiceStatusesQuery, ServiceStatusesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ServiceStatusesQuery, ServiceStatusesQueryVariables>(ServiceStatusesDocument, options);
        }
export function useServiceStatusesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ServiceStatusesQuery, ServiceStatusesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ServiceStatusesQuery, ServiceStatusesQueryVariables>(ServiceStatusesDocument, options);
        }
export type ServiceStatusesQueryHookResult = ReturnType<typeof useServiceStatusesQuery>;
export type ServiceStatusesLazyQueryHookResult = ReturnType<typeof useServiceStatusesLazyQuery>;
export type ServiceStatusesSuspenseQueryHookResult = ReturnType<typeof useServiceStatusesSuspenseQuery>;
export type ServiceStatusesQueryResult = Apollo.QueryResult<ServiceStatusesQuery, ServiceStatusesQueryVariables>;
export const ServiceNetworkGraphDocument = gql`
    query ServiceNetworkGraph($serviceId: ID!, $time: DateTime) {
  serviceDeployment(id: $serviceId) {
    id
    networkGraph(time: $time) {
      ...NetworkMeshEdge
    }
  }
}
    ${NetworkMeshEdgeFragmentDoc}`;

/**
 * __useServiceNetworkGraphQuery__
 *
 * To run a query within a React component, call `useServiceNetworkGraphQuery` and pass it any options that fit your needs.
 * When your component renders, `useServiceNetworkGraphQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useServiceNetworkGraphQuery({
 *   variables: {
 *      serviceId: // value for 'serviceId'
 *      time: // value for 'time'
 *   },
 * });
 */
export function useServiceNetworkGraphQuery(baseOptions: Apollo.QueryHookOptions<ServiceNetworkGraphQuery, ServiceNetworkGraphQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ServiceNetworkGraphQuery, ServiceNetworkGraphQueryVariables>(ServiceNetworkGraphDocument, options);
      }
export function useServiceNetworkGraphLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ServiceNetworkGraphQuery, ServiceNetworkGraphQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ServiceNetworkGraphQuery, ServiceNetworkGraphQueryVariables>(ServiceNetworkGraphDocument, options);
        }
export function useServiceNetworkGraphSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ServiceNetworkGraphQuery, ServiceNetworkGraphQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ServiceNetworkGraphQuery, ServiceNetworkGraphQueryVariables>(ServiceNetworkGraphDocument, options);
        }
export type ServiceNetworkGraphQueryHookResult = ReturnType<typeof useServiceNetworkGraphQuery>;
export type ServiceNetworkGraphLazyQueryHookResult = ReturnType<typeof useServiceNetworkGraphLazyQuery>;
export type ServiceNetworkGraphSuspenseQueryHookResult = ReturnType<typeof useServiceNetworkGraphSuspenseQuery>;
export type ServiceNetworkGraphQueryResult = Apollo.QueryResult<ServiceNetworkGraphQuery, ServiceNetworkGraphQueryVariables>;
export const ServiceComponentRawDocument = gql`
    query ServiceComponentRaw($serviceId: ID!, $componentId: ID, $childId: ID) {
  serviceDeployment(id: $serviceId) {
    id
    rawResource(childId: $childId, componentId: $componentId) {
      ...UnstructuredResource
    }
  }
}
    ${UnstructuredResourceFragmentDoc}`;

/**
 * __useServiceComponentRawQuery__
 *
 * To run a query within a React component, call `useServiceComponentRawQuery` and pass it any options that fit your needs.
 * When your component renders, `useServiceComponentRawQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useServiceComponentRawQuery({
 *   variables: {
 *      serviceId: // value for 'serviceId'
 *      componentId: // value for 'componentId'
 *      childId: // value for 'childId'
 *   },
 * });
 */
export function useServiceComponentRawQuery(baseOptions: Apollo.QueryHookOptions<ServiceComponentRawQuery, ServiceComponentRawQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ServiceComponentRawQuery, ServiceComponentRawQueryVariables>(ServiceComponentRawDocument, options);
      }
export function useServiceComponentRawLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ServiceComponentRawQuery, ServiceComponentRawQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ServiceComponentRawQuery, ServiceComponentRawQueryVariables>(ServiceComponentRawDocument, options);
        }
export function useServiceComponentRawSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ServiceComponentRawQuery, ServiceComponentRawQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ServiceComponentRawQuery, ServiceComponentRawQueryVariables>(ServiceComponentRawDocument, options);
        }
export type ServiceComponentRawQueryHookResult = ReturnType<typeof useServiceComponentRawQuery>;
export type ServiceComponentRawLazyQueryHookResult = ReturnType<typeof useServiceComponentRawLazyQuery>;
export type ServiceComponentRawSuspenseQueryHookResult = ReturnType<typeof useServiceComponentRawSuspenseQuery>;
export type ServiceComponentRawQueryResult = Apollo.QueryResult<ServiceComponentRawQuery, ServiceComponentRawQueryVariables>;
export const ComponentTreeDocument = gql`
    query ComponentTree($id: ID!) {
  componentTree(id: $id) {
    ...ComponentTree
  }
}
    ${ComponentTreeFragmentDoc}`;

/**
 * __useComponentTreeQuery__
 *
 * To run a query within a React component, call `useComponentTreeQuery` and pass it any options that fit your needs.
 * When your component renders, `useComponentTreeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useComponentTreeQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useComponentTreeQuery(baseOptions: Apollo.QueryHookOptions<ComponentTreeQuery, ComponentTreeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ComponentTreeQuery, ComponentTreeQueryVariables>(ComponentTreeDocument, options);
      }
export function useComponentTreeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ComponentTreeQuery, ComponentTreeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ComponentTreeQuery, ComponentTreeQueryVariables>(ComponentTreeDocument, options);
        }
export function useComponentTreeSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ComponentTreeQuery, ComponentTreeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ComponentTreeQuery, ComponentTreeQueryVariables>(ComponentTreeDocument, options);
        }
export type ComponentTreeQueryHookResult = ReturnType<typeof useComponentTreeQuery>;
export type ComponentTreeLazyQueryHookResult = ReturnType<typeof useComponentTreeLazyQuery>;
export type ComponentTreeSuspenseQueryHookResult = ReturnType<typeof useComponentTreeSuspenseQuery>;
export type ComponentTreeQueryResult = Apollo.QueryResult<ComponentTreeQuery, ComponentTreeQueryVariables>;
export const ClusterUsagesDocument = gql`
    query ClusterUsages($after: String, $first: Int = 500, $before: String, $last: Int, $q: String, $tagQuery: TagQuery, $projectId: ID) {
  clusterUsages(
    after: $after
    first: $first
    before: $before
    last: $last
    q: $q
    tagQuery: $tagQuery
    projectId: $projectId
  ) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...ClusterUsageTiny
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${ClusterUsageTinyFragmentDoc}`;

/**
 * __useClusterUsagesQuery__
 *
 * To run a query within a React component, call `useClusterUsagesQuery` and pass it any options that fit your needs.
 * When your component renders, `useClusterUsagesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClusterUsagesQuery({
 *   variables: {
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      before: // value for 'before'
 *      last: // value for 'last'
 *      q: // value for 'q'
 *      tagQuery: // value for 'tagQuery'
 *      projectId: // value for 'projectId'
 *   },
 * });
 */
export function useClusterUsagesQuery(baseOptions?: Apollo.QueryHookOptions<ClusterUsagesQuery, ClusterUsagesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClusterUsagesQuery, ClusterUsagesQueryVariables>(ClusterUsagesDocument, options);
      }
export function useClusterUsagesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClusterUsagesQuery, ClusterUsagesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClusterUsagesQuery, ClusterUsagesQueryVariables>(ClusterUsagesDocument, options);
        }
export function useClusterUsagesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClusterUsagesQuery, ClusterUsagesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClusterUsagesQuery, ClusterUsagesQueryVariables>(ClusterUsagesDocument, options);
        }
export type ClusterUsagesQueryHookResult = ReturnType<typeof useClusterUsagesQuery>;
export type ClusterUsagesLazyQueryHookResult = ReturnType<typeof useClusterUsagesLazyQuery>;
export type ClusterUsagesSuspenseQueryHookResult = ReturnType<typeof useClusterUsagesSuspenseQuery>;
export type ClusterUsagesQueryResult = Apollo.QueryResult<ClusterUsagesQuery, ClusterUsagesQueryVariables>;
export const ClusterUsageHistoryDocument = gql`
    query ClusterUsageHistory($id: ID!, $after: String, $first: Int, $before: String, $last: Int) {
  clusterUsage(id: $id) {
    id
    cpuCost
    memoryCost
    storageCost
    history(after: $after, first: $first, before: $before, last: $last) {
      pageInfo {
        ...PageInfo
      }
      edges {
        node {
          ...ClusterUsageHistory
        }
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${ClusterUsageHistoryFragmentDoc}`;

/**
 * __useClusterUsageHistoryQuery__
 *
 * To run a query within a React component, call `useClusterUsageHistoryQuery` and pass it any options that fit your needs.
 * When your component renders, `useClusterUsageHistoryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClusterUsageHistoryQuery({
 *   variables: {
 *      id: // value for 'id'
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      before: // value for 'before'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useClusterUsageHistoryQuery(baseOptions: Apollo.QueryHookOptions<ClusterUsageHistoryQuery, ClusterUsageHistoryQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClusterUsageHistoryQuery, ClusterUsageHistoryQueryVariables>(ClusterUsageHistoryDocument, options);
      }
export function useClusterUsageHistoryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClusterUsageHistoryQuery, ClusterUsageHistoryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClusterUsageHistoryQuery, ClusterUsageHistoryQueryVariables>(ClusterUsageHistoryDocument, options);
        }
export function useClusterUsageHistorySuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClusterUsageHistoryQuery, ClusterUsageHistoryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClusterUsageHistoryQuery, ClusterUsageHistoryQueryVariables>(ClusterUsageHistoryDocument, options);
        }
export type ClusterUsageHistoryQueryHookResult = ReturnType<typeof useClusterUsageHistoryQuery>;
export type ClusterUsageHistoryLazyQueryHookResult = ReturnType<typeof useClusterUsageHistoryLazyQuery>;
export type ClusterUsageHistorySuspenseQueryHookResult = ReturnType<typeof useClusterUsageHistorySuspenseQuery>;
export type ClusterUsageHistoryQueryResult = Apollo.QueryResult<ClusterUsageHistoryQuery, ClusterUsageHistoryQueryVariables>;
export const ClusterUsageNamespacesDocument = gql`
    query ClusterUsageNamespaces($id: ID!, $after: String, $first: Int, $before: String, $last: Int, $q: String) {
  clusterUsage(id: $id) {
    id
    cluster {
      id
      name
    }
    namespaces(after: $after, first: $first, before: $before, last: $last, q: $q) {
      pageInfo {
        ...PageInfo
      }
      edges {
        node {
          ...ClusterNamespaceUsage
        }
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${ClusterNamespaceUsageFragmentDoc}`;

/**
 * __useClusterUsageNamespacesQuery__
 *
 * To run a query within a React component, call `useClusterUsageNamespacesQuery` and pass it any options that fit your needs.
 * When your component renders, `useClusterUsageNamespacesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClusterUsageNamespacesQuery({
 *   variables: {
 *      id: // value for 'id'
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      before: // value for 'before'
 *      last: // value for 'last'
 *      q: // value for 'q'
 *   },
 * });
 */
export function useClusterUsageNamespacesQuery(baseOptions: Apollo.QueryHookOptions<ClusterUsageNamespacesQuery, ClusterUsageNamespacesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClusterUsageNamespacesQuery, ClusterUsageNamespacesQueryVariables>(ClusterUsageNamespacesDocument, options);
      }
export function useClusterUsageNamespacesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClusterUsageNamespacesQuery, ClusterUsageNamespacesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClusterUsageNamespacesQuery, ClusterUsageNamespacesQueryVariables>(ClusterUsageNamespacesDocument, options);
        }
export function useClusterUsageNamespacesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClusterUsageNamespacesQuery, ClusterUsageNamespacesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClusterUsageNamespacesQuery, ClusterUsageNamespacesQueryVariables>(ClusterUsageNamespacesDocument, options);
        }
export type ClusterUsageNamespacesQueryHookResult = ReturnType<typeof useClusterUsageNamespacesQuery>;
export type ClusterUsageNamespacesLazyQueryHookResult = ReturnType<typeof useClusterUsageNamespacesLazyQuery>;
export type ClusterUsageNamespacesSuspenseQueryHookResult = ReturnType<typeof useClusterUsageNamespacesSuspenseQuery>;
export type ClusterUsageNamespacesQueryResult = Apollo.QueryResult<ClusterUsageNamespacesQuery, ClusterUsageNamespacesQueryVariables>;
export const ClusterUsageScalingRecommendationsDocument = gql`
    query ClusterUsageScalingRecommendations($id: ID!, $after: String, $first: Int, $before: String, $last: Int, $q: String, $type: ScalingRecommendationType) {
  clusterUsage(id: $id) {
    id
    cluster {
      id
      name
    }
    recommendations(
      after: $after
      first: $first
      before: $before
      last: $last
      q: $q
      type: $type
    ) {
      pageInfo {
        ...PageInfo
      }
      edges {
        node {
          ...ClusterScalingRecommendation
        }
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${ClusterScalingRecommendationFragmentDoc}`;

/**
 * __useClusterUsageScalingRecommendationsQuery__
 *
 * To run a query within a React component, call `useClusterUsageScalingRecommendationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useClusterUsageScalingRecommendationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClusterUsageScalingRecommendationsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      before: // value for 'before'
 *      last: // value for 'last'
 *      q: // value for 'q'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useClusterUsageScalingRecommendationsQuery(baseOptions: Apollo.QueryHookOptions<ClusterUsageScalingRecommendationsQuery, ClusterUsageScalingRecommendationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClusterUsageScalingRecommendationsQuery, ClusterUsageScalingRecommendationsQueryVariables>(ClusterUsageScalingRecommendationsDocument, options);
      }
export function useClusterUsageScalingRecommendationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClusterUsageScalingRecommendationsQuery, ClusterUsageScalingRecommendationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClusterUsageScalingRecommendationsQuery, ClusterUsageScalingRecommendationsQueryVariables>(ClusterUsageScalingRecommendationsDocument, options);
        }
export function useClusterUsageScalingRecommendationsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClusterUsageScalingRecommendationsQuery, ClusterUsageScalingRecommendationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClusterUsageScalingRecommendationsQuery, ClusterUsageScalingRecommendationsQueryVariables>(ClusterUsageScalingRecommendationsDocument, options);
        }
export type ClusterUsageScalingRecommendationsQueryHookResult = ReturnType<typeof useClusterUsageScalingRecommendationsQuery>;
export type ClusterUsageScalingRecommendationsLazyQueryHookResult = ReturnType<typeof useClusterUsageScalingRecommendationsLazyQuery>;
export type ClusterUsageScalingRecommendationsSuspenseQueryHookResult = ReturnType<typeof useClusterUsageScalingRecommendationsSuspenseQuery>;
export type ClusterUsageScalingRecommendationsQueryResult = Apollo.QueryResult<ClusterUsageScalingRecommendationsQuery, ClusterUsageScalingRecommendationsQueryVariables>;
export const ProjectUsageHistoryDocument = gql`
    query ProjectUsageHistory($after: String, $first: Int = 365, $before: String, $last: Int) {
  projectUsageHistory(after: $after, first: $first, before: $before, last: $last) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...ProjectUsageHistory
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${ProjectUsageHistoryFragmentDoc}`;

/**
 * __useProjectUsageHistoryQuery__
 *
 * To run a query within a React component, call `useProjectUsageHistoryQuery` and pass it any options that fit your needs.
 * When your component renders, `useProjectUsageHistoryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProjectUsageHistoryQuery({
 *   variables: {
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      before: // value for 'before'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useProjectUsageHistoryQuery(baseOptions?: Apollo.QueryHookOptions<ProjectUsageHistoryQuery, ProjectUsageHistoryQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProjectUsageHistoryQuery, ProjectUsageHistoryQueryVariables>(ProjectUsageHistoryDocument, options);
      }
export function useProjectUsageHistoryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProjectUsageHistoryQuery, ProjectUsageHistoryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProjectUsageHistoryQuery, ProjectUsageHistoryQueryVariables>(ProjectUsageHistoryDocument, options);
        }
export function useProjectUsageHistorySuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ProjectUsageHistoryQuery, ProjectUsageHistoryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ProjectUsageHistoryQuery, ProjectUsageHistoryQueryVariables>(ProjectUsageHistoryDocument, options);
        }
export type ProjectUsageHistoryQueryHookResult = ReturnType<typeof useProjectUsageHistoryQuery>;
export type ProjectUsageHistoryLazyQueryHookResult = ReturnType<typeof useProjectUsageHistoryLazyQuery>;
export type ProjectUsageHistorySuspenseQueryHookResult = ReturnType<typeof useProjectUsageHistorySuspenseQuery>;
export type ProjectUsageHistoryQueryResult = Apollo.QueryResult<ProjectUsageHistoryQuery, ProjectUsageHistoryQueryVariables>;
export const SuggestScalingRecommendationDocument = gql`
    mutation SuggestScalingRecommendation($id: ID!) {
  suggestScalingRecommendation(id: $id)
}
    `;
export type SuggestScalingRecommendationMutationFn = Apollo.MutationFunction<SuggestScalingRecommendationMutation, SuggestScalingRecommendationMutationVariables>;

/**
 * __useSuggestScalingRecommendationMutation__
 *
 * To run a mutation, you first call `useSuggestScalingRecommendationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSuggestScalingRecommendationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [suggestScalingRecommendationMutation, { data, loading, error }] = useSuggestScalingRecommendationMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useSuggestScalingRecommendationMutation(baseOptions?: Apollo.MutationHookOptions<SuggestScalingRecommendationMutation, SuggestScalingRecommendationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SuggestScalingRecommendationMutation, SuggestScalingRecommendationMutationVariables>(SuggestScalingRecommendationDocument, options);
      }
export type SuggestScalingRecommendationMutationHookResult = ReturnType<typeof useSuggestScalingRecommendationMutation>;
export type SuggestScalingRecommendationMutationResult = Apollo.MutationResult<SuggestScalingRecommendationMutation>;
export type SuggestScalingRecommendationMutationOptions = Apollo.BaseMutationOptions<SuggestScalingRecommendationMutation, SuggestScalingRecommendationMutationVariables>;
export const ApplyScalingRecommendationDocument = gql`
    mutation ApplyScalingRecommendation($id: ID!) {
  applyScalingRecommendation(id: $id) {
    ...PullRequest
  }
}
    ${PullRequestFragmentDoc}`;
export type ApplyScalingRecommendationMutationFn = Apollo.MutationFunction<ApplyScalingRecommendationMutation, ApplyScalingRecommendationMutationVariables>;

/**
 * __useApplyScalingRecommendationMutation__
 *
 * To run a mutation, you first call `useApplyScalingRecommendationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useApplyScalingRecommendationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [applyScalingRecommendationMutation, { data, loading, error }] = useApplyScalingRecommendationMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useApplyScalingRecommendationMutation(baseOptions?: Apollo.MutationHookOptions<ApplyScalingRecommendationMutation, ApplyScalingRecommendationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ApplyScalingRecommendationMutation, ApplyScalingRecommendationMutationVariables>(ApplyScalingRecommendationDocument, options);
      }
export type ApplyScalingRecommendationMutationHookResult = ReturnType<typeof useApplyScalingRecommendationMutation>;
export type ApplyScalingRecommendationMutationResult = Apollo.MutationResult<ApplyScalingRecommendationMutation>;
export type ApplyScalingRecommendationMutationOptions = Apollo.BaseMutationOptions<ApplyScalingRecommendationMutation, ApplyScalingRecommendationMutationVariables>;
export const ClusterRegistrationDocument = gql`
    query ClusterRegistration($id: ID, $machineId: String) {
  clusterRegistration(id: $id, machineId: $machineId) {
    ...ClusterRegistration
  }
}
    ${ClusterRegistrationFragmentDoc}`;

/**
 * __useClusterRegistrationQuery__
 *
 * To run a query within a React component, call `useClusterRegistrationQuery` and pass it any options that fit your needs.
 * When your component renders, `useClusterRegistrationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClusterRegistrationQuery({
 *   variables: {
 *      id: // value for 'id'
 *      machineId: // value for 'machineId'
 *   },
 * });
 */
export function useClusterRegistrationQuery(baseOptions?: Apollo.QueryHookOptions<ClusterRegistrationQuery, ClusterRegistrationQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClusterRegistrationQuery, ClusterRegistrationQueryVariables>(ClusterRegistrationDocument, options);
      }
export function useClusterRegistrationLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClusterRegistrationQuery, ClusterRegistrationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClusterRegistrationQuery, ClusterRegistrationQueryVariables>(ClusterRegistrationDocument, options);
        }
export function useClusterRegistrationSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClusterRegistrationQuery, ClusterRegistrationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClusterRegistrationQuery, ClusterRegistrationQueryVariables>(ClusterRegistrationDocument, options);
        }
export type ClusterRegistrationQueryHookResult = ReturnType<typeof useClusterRegistrationQuery>;
export type ClusterRegistrationLazyQueryHookResult = ReturnType<typeof useClusterRegistrationLazyQuery>;
export type ClusterRegistrationSuspenseQueryHookResult = ReturnType<typeof useClusterRegistrationSuspenseQuery>;
export type ClusterRegistrationQueryResult = Apollo.QueryResult<ClusterRegistrationQuery, ClusterRegistrationQueryVariables>;
export const ClusterRegistrationsDocument = gql`
    query ClusterRegistrations($after: String, $first: Int, $before: String, $last: Int) {
  clusterRegistrations(after: $after, first: $first, before: $before, last: $last) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...ClusterRegistration
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${ClusterRegistrationFragmentDoc}`;

/**
 * __useClusterRegistrationsQuery__
 *
 * To run a query within a React component, call `useClusterRegistrationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useClusterRegistrationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClusterRegistrationsQuery({
 *   variables: {
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      before: // value for 'before'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useClusterRegistrationsQuery(baseOptions?: Apollo.QueryHookOptions<ClusterRegistrationsQuery, ClusterRegistrationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClusterRegistrationsQuery, ClusterRegistrationsQueryVariables>(ClusterRegistrationsDocument, options);
      }
export function useClusterRegistrationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClusterRegistrationsQuery, ClusterRegistrationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClusterRegistrationsQuery, ClusterRegistrationsQueryVariables>(ClusterRegistrationsDocument, options);
        }
export function useClusterRegistrationsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClusterRegistrationsQuery, ClusterRegistrationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClusterRegistrationsQuery, ClusterRegistrationsQueryVariables>(ClusterRegistrationsDocument, options);
        }
export type ClusterRegistrationsQueryHookResult = ReturnType<typeof useClusterRegistrationsQuery>;
export type ClusterRegistrationsLazyQueryHookResult = ReturnType<typeof useClusterRegistrationsLazyQuery>;
export type ClusterRegistrationsSuspenseQueryHookResult = ReturnType<typeof useClusterRegistrationsSuspenseQuery>;
export type ClusterRegistrationsQueryResult = Apollo.QueryResult<ClusterRegistrationsQuery, ClusterRegistrationsQueryVariables>;
export const CreateClusterRegistrationDocument = gql`
    mutation CreateClusterRegistration($attributes: ClusterRegistrationCreateAttributes!) {
  createClusterRegistration(attributes: $attributes) {
    ...ClusterRegistration
  }
}
    ${ClusterRegistrationFragmentDoc}`;
export type CreateClusterRegistrationMutationFn = Apollo.MutationFunction<CreateClusterRegistrationMutation, CreateClusterRegistrationMutationVariables>;

/**
 * __useCreateClusterRegistrationMutation__
 *
 * To run a mutation, you first call `useCreateClusterRegistrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateClusterRegistrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createClusterRegistrationMutation, { data, loading, error }] = useCreateClusterRegistrationMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useCreateClusterRegistrationMutation(baseOptions?: Apollo.MutationHookOptions<CreateClusterRegistrationMutation, CreateClusterRegistrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateClusterRegistrationMutation, CreateClusterRegistrationMutationVariables>(CreateClusterRegistrationDocument, options);
      }
export type CreateClusterRegistrationMutationHookResult = ReturnType<typeof useCreateClusterRegistrationMutation>;
export type CreateClusterRegistrationMutationResult = Apollo.MutationResult<CreateClusterRegistrationMutation>;
export type CreateClusterRegistrationMutationOptions = Apollo.BaseMutationOptions<CreateClusterRegistrationMutation, CreateClusterRegistrationMutationVariables>;
export const UpdateClusterRegistrationDocument = gql`
    mutation UpdateClusterRegistration($id: ID!, $attributes: ClusterRegistrationUpdateAttributes!) {
  updateClusterRegistration(id: $id, attributes: $attributes) {
    ...ClusterRegistration
  }
}
    ${ClusterRegistrationFragmentDoc}`;
export type UpdateClusterRegistrationMutationFn = Apollo.MutationFunction<UpdateClusterRegistrationMutation, UpdateClusterRegistrationMutationVariables>;

/**
 * __useUpdateClusterRegistrationMutation__
 *
 * To run a mutation, you first call `useUpdateClusterRegistrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateClusterRegistrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateClusterRegistrationMutation, { data, loading, error }] = useUpdateClusterRegistrationMutation({
 *   variables: {
 *      id: // value for 'id'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpdateClusterRegistrationMutation(baseOptions?: Apollo.MutationHookOptions<UpdateClusterRegistrationMutation, UpdateClusterRegistrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateClusterRegistrationMutation, UpdateClusterRegistrationMutationVariables>(UpdateClusterRegistrationDocument, options);
      }
export type UpdateClusterRegistrationMutationHookResult = ReturnType<typeof useUpdateClusterRegistrationMutation>;
export type UpdateClusterRegistrationMutationResult = Apollo.MutationResult<UpdateClusterRegistrationMutation>;
export type UpdateClusterRegistrationMutationOptions = Apollo.BaseMutationOptions<UpdateClusterRegistrationMutation, UpdateClusterRegistrationMutationVariables>;
export const DeleteClusterRegistrationDocument = gql`
    mutation DeleteClusterRegistration($id: ID!) {
  deleteClusterRegistration(id: $id) {
    ...ClusterRegistration
  }
}
    ${ClusterRegistrationFragmentDoc}`;
export type DeleteClusterRegistrationMutationFn = Apollo.MutationFunction<DeleteClusterRegistrationMutation, DeleteClusterRegistrationMutationVariables>;

/**
 * __useDeleteClusterRegistrationMutation__
 *
 * To run a mutation, you first call `useDeleteClusterRegistrationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteClusterRegistrationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteClusterRegistrationMutation, { data, loading, error }] = useDeleteClusterRegistrationMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteClusterRegistrationMutation(baseOptions?: Apollo.MutationHookOptions<DeleteClusterRegistrationMutation, DeleteClusterRegistrationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteClusterRegistrationMutation, DeleteClusterRegistrationMutationVariables>(DeleteClusterRegistrationDocument, options);
      }
export type DeleteClusterRegistrationMutationHookResult = ReturnType<typeof useDeleteClusterRegistrationMutation>;
export type DeleteClusterRegistrationMutationResult = Apollo.MutationResult<DeleteClusterRegistrationMutation>;
export type DeleteClusterRegistrationMutationOptions = Apollo.BaseMutationOptions<DeleteClusterRegistrationMutation, DeleteClusterRegistrationMutationVariables>;
export const ClusterIsoImagesDocument = gql`
    query ClusterISOImages($after: String, $first: Int, $before: String, $last: Int) {
  clusterIsoImages(after: $after, first: $first, before: $before, last: $last) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...IsoImage
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${IsoImageFragmentDoc}`;

/**
 * __useClusterIsoImagesQuery__
 *
 * To run a query within a React component, call `useClusterIsoImagesQuery` and pass it any options that fit your needs.
 * When your component renders, `useClusterIsoImagesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClusterIsoImagesQuery({
 *   variables: {
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      before: // value for 'before'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useClusterIsoImagesQuery(baseOptions?: Apollo.QueryHookOptions<ClusterIsoImagesQuery, ClusterIsoImagesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClusterIsoImagesQuery, ClusterIsoImagesQueryVariables>(ClusterIsoImagesDocument, options);
      }
export function useClusterIsoImagesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClusterIsoImagesQuery, ClusterIsoImagesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClusterIsoImagesQuery, ClusterIsoImagesQueryVariables>(ClusterIsoImagesDocument, options);
        }
export function useClusterIsoImagesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClusterIsoImagesQuery, ClusterIsoImagesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClusterIsoImagesQuery, ClusterIsoImagesQueryVariables>(ClusterIsoImagesDocument, options);
        }
export type ClusterIsoImagesQueryHookResult = ReturnType<typeof useClusterIsoImagesQuery>;
export type ClusterIsoImagesLazyQueryHookResult = ReturnType<typeof useClusterIsoImagesLazyQuery>;
export type ClusterIsoImagesSuspenseQueryHookResult = ReturnType<typeof useClusterIsoImagesSuspenseQuery>;
export type ClusterIsoImagesQueryResult = Apollo.QueryResult<ClusterIsoImagesQuery, ClusterIsoImagesQueryVariables>;
export const FlowsDocument = gql`
    query Flows($first: Int = 100, $after: String, $q: String) {
  flows(first: $first, after: $after, q: $q) {
    edges {
      node {
        ...FlowBasicWithBindings
      }
    }
    pageInfo {
      ...PageInfo
    }
  }
}
    ${FlowBasicWithBindingsFragmentDoc}
${PageInfoFragmentDoc}`;

/**
 * __useFlowsQuery__
 *
 * To run a query within a React component, call `useFlowsQuery` and pass it any options that fit your needs.
 * When your component renders, `useFlowsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFlowsQuery({
 *   variables: {
 *      first: // value for 'first'
 *      after: // value for 'after'
 *      q: // value for 'q'
 *   },
 * });
 */
export function useFlowsQuery(baseOptions?: Apollo.QueryHookOptions<FlowsQuery, FlowsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FlowsQuery, FlowsQueryVariables>(FlowsDocument, options);
      }
export function useFlowsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FlowsQuery, FlowsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FlowsQuery, FlowsQueryVariables>(FlowsDocument, options);
        }
export function useFlowsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<FlowsQuery, FlowsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<FlowsQuery, FlowsQueryVariables>(FlowsDocument, options);
        }
export type FlowsQueryHookResult = ReturnType<typeof useFlowsQuery>;
export type FlowsLazyQueryHookResult = ReturnType<typeof useFlowsLazyQuery>;
export type FlowsSuspenseQueryHookResult = ReturnType<typeof useFlowsSuspenseQuery>;
export type FlowsQueryResult = Apollo.QueryResult<FlowsQuery, FlowsQueryVariables>;
export const FlowDocument = gql`
    query Flow($id: ID!) {
  flow(id: $id) {
    ...FlowBasicWithBindings
  }
}
    ${FlowBasicWithBindingsFragmentDoc}`;

/**
 * __useFlowQuery__
 *
 * To run a query within a React component, call `useFlowQuery` and pass it any options that fit your needs.
 * When your component renders, `useFlowQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFlowQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useFlowQuery(baseOptions: Apollo.QueryHookOptions<FlowQuery, FlowQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FlowQuery, FlowQueryVariables>(FlowDocument, options);
      }
export function useFlowLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FlowQuery, FlowQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FlowQuery, FlowQueryVariables>(FlowDocument, options);
        }
export function useFlowSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<FlowQuery, FlowQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<FlowQuery, FlowQueryVariables>(FlowDocument, options);
        }
export type FlowQueryHookResult = ReturnType<typeof useFlowQuery>;
export type FlowLazyQueryHookResult = ReturnType<typeof useFlowLazyQuery>;
export type FlowSuspenseQueryHookResult = ReturnType<typeof useFlowSuspenseQuery>;
export type FlowQueryResult = Apollo.QueryResult<FlowQuery, FlowQueryVariables>;
export const FlowServicesDocument = gql`
    query FlowServices($id: ID!, $first: Int = 100, $after: String) {
  flow(id: $id) {
    id
    name
    services(first: $first, after: $after) {
      ...ServiceDeploymentsConnection
    }
  }
}
    ${ServiceDeploymentsConnectionFragmentDoc}`;

/**
 * __useFlowServicesQuery__
 *
 * To run a query within a React component, call `useFlowServicesQuery` and pass it any options that fit your needs.
 * When your component renders, `useFlowServicesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFlowServicesQuery({
 *   variables: {
 *      id: // value for 'id'
 *      first: // value for 'first'
 *      after: // value for 'after'
 *   },
 * });
 */
export function useFlowServicesQuery(baseOptions: Apollo.QueryHookOptions<FlowServicesQuery, FlowServicesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FlowServicesQuery, FlowServicesQueryVariables>(FlowServicesDocument, options);
      }
export function useFlowServicesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FlowServicesQuery, FlowServicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FlowServicesQuery, FlowServicesQueryVariables>(FlowServicesDocument, options);
        }
export function useFlowServicesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<FlowServicesQuery, FlowServicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<FlowServicesQuery, FlowServicesQueryVariables>(FlowServicesDocument, options);
        }
export type FlowServicesQueryHookResult = ReturnType<typeof useFlowServicesQuery>;
export type FlowServicesLazyQueryHookResult = ReturnType<typeof useFlowServicesLazyQuery>;
export type FlowServicesSuspenseQueryHookResult = ReturnType<typeof useFlowServicesSuspenseQuery>;
export type FlowServicesQueryResult = Apollo.QueryResult<FlowServicesQuery, FlowServicesQueryVariables>;
export const FlowPipelinesDocument = gql`
    query FlowPipelines($id: ID!, $first: Int = 100, $after: String) {
  flow(id: $id) {
    id
    pipelines(first: $first, after: $after) {
      ...PipelineConnection
    }
  }
}
    ${PipelineConnectionFragmentDoc}`;

/**
 * __useFlowPipelinesQuery__
 *
 * To run a query within a React component, call `useFlowPipelinesQuery` and pass it any options that fit your needs.
 * When your component renders, `useFlowPipelinesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFlowPipelinesQuery({
 *   variables: {
 *      id: // value for 'id'
 *      first: // value for 'first'
 *      after: // value for 'after'
 *   },
 * });
 */
export function useFlowPipelinesQuery(baseOptions: Apollo.QueryHookOptions<FlowPipelinesQuery, FlowPipelinesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FlowPipelinesQuery, FlowPipelinesQueryVariables>(FlowPipelinesDocument, options);
      }
export function useFlowPipelinesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FlowPipelinesQuery, FlowPipelinesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FlowPipelinesQuery, FlowPipelinesQueryVariables>(FlowPipelinesDocument, options);
        }
export function useFlowPipelinesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<FlowPipelinesQuery, FlowPipelinesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<FlowPipelinesQuery, FlowPipelinesQueryVariables>(FlowPipelinesDocument, options);
        }
export type FlowPipelinesQueryHookResult = ReturnType<typeof useFlowPipelinesQuery>;
export type FlowPipelinesLazyQueryHookResult = ReturnType<typeof useFlowPipelinesLazyQuery>;
export type FlowPipelinesSuspenseQueryHookResult = ReturnType<typeof useFlowPipelinesSuspenseQuery>;
export type FlowPipelinesQueryResult = Apollo.QueryResult<FlowPipelinesQuery, FlowPipelinesQueryVariables>;
export const FlowAlertsDocument = gql`
    query FlowAlerts($id: ID!, $first: Int = 100, $after: String) {
  flow(id: $id) {
    id
    alerts(first: $first, after: $after) {
      ...AlertConnection
    }
  }
}
    ${AlertConnectionFragmentDoc}`;

/**
 * __useFlowAlertsQuery__
 *
 * To run a query within a React component, call `useFlowAlertsQuery` and pass it any options that fit your needs.
 * When your component renders, `useFlowAlertsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFlowAlertsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      first: // value for 'first'
 *      after: // value for 'after'
 *   },
 * });
 */
export function useFlowAlertsQuery(baseOptions: Apollo.QueryHookOptions<FlowAlertsQuery, FlowAlertsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FlowAlertsQuery, FlowAlertsQueryVariables>(FlowAlertsDocument, options);
      }
export function useFlowAlertsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FlowAlertsQuery, FlowAlertsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FlowAlertsQuery, FlowAlertsQueryVariables>(FlowAlertsDocument, options);
        }
export function useFlowAlertsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<FlowAlertsQuery, FlowAlertsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<FlowAlertsQuery, FlowAlertsQueryVariables>(FlowAlertsDocument, options);
        }
export type FlowAlertsQueryHookResult = ReturnType<typeof useFlowAlertsQuery>;
export type FlowAlertsLazyQueryHookResult = ReturnType<typeof useFlowAlertsLazyQuery>;
export type FlowAlertsSuspenseQueryHookResult = ReturnType<typeof useFlowAlertsSuspenseQuery>;
export type FlowAlertsQueryResult = Apollo.QueryResult<FlowAlertsQuery, FlowAlertsQueryVariables>;
export const FlowPrsDocument = gql`
    query FlowPrs($id: ID!, $first: Int = 100, $after: String) {
  flow(id: $id) {
    id
    pullRequests(first: $first, after: $after) {
      ...PullRequestConnection
    }
  }
}
    ${PullRequestConnectionFragmentDoc}`;

/**
 * __useFlowPrsQuery__
 *
 * To run a query within a React component, call `useFlowPrsQuery` and pass it any options that fit your needs.
 * When your component renders, `useFlowPrsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFlowPrsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      first: // value for 'first'
 *      after: // value for 'after'
 *   },
 * });
 */
export function useFlowPrsQuery(baseOptions: Apollo.QueryHookOptions<FlowPrsQuery, FlowPrsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FlowPrsQuery, FlowPrsQueryVariables>(FlowPrsDocument, options);
      }
export function useFlowPrsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FlowPrsQuery, FlowPrsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FlowPrsQuery, FlowPrsQueryVariables>(FlowPrsDocument, options);
        }
export function useFlowPrsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<FlowPrsQuery, FlowPrsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<FlowPrsQuery, FlowPrsQueryVariables>(FlowPrsDocument, options);
        }
export type FlowPrsQueryHookResult = ReturnType<typeof useFlowPrsQuery>;
export type FlowPrsLazyQueryHookResult = ReturnType<typeof useFlowPrsLazyQuery>;
export type FlowPrsSuspenseQueryHookResult = ReturnType<typeof useFlowPrsSuspenseQuery>;
export type FlowPrsQueryResult = Apollo.QueryResult<FlowPrsQuery, FlowPrsQueryVariables>;
export const FlowPreviewEnvironmentInstancesDocument = gql`
    query FlowPreviewEnvironmentInstances($id: ID!, $first: Int = 100, $after: String) {
  flow(id: $id) {
    id
    previewEnvironmentInstances(first: $first, after: $after) {
      ...PreviewEnvironmentInstanceConnection
    }
  }
}
    ${PreviewEnvironmentInstanceConnectionFragmentDoc}`;

/**
 * __useFlowPreviewEnvironmentInstancesQuery__
 *
 * To run a query within a React component, call `useFlowPreviewEnvironmentInstancesQuery` and pass it any options that fit your needs.
 * When your component renders, `useFlowPreviewEnvironmentInstancesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFlowPreviewEnvironmentInstancesQuery({
 *   variables: {
 *      id: // value for 'id'
 *      first: // value for 'first'
 *      after: // value for 'after'
 *   },
 * });
 */
export function useFlowPreviewEnvironmentInstancesQuery(baseOptions: Apollo.QueryHookOptions<FlowPreviewEnvironmentInstancesQuery, FlowPreviewEnvironmentInstancesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FlowPreviewEnvironmentInstancesQuery, FlowPreviewEnvironmentInstancesQueryVariables>(FlowPreviewEnvironmentInstancesDocument, options);
      }
export function useFlowPreviewEnvironmentInstancesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FlowPreviewEnvironmentInstancesQuery, FlowPreviewEnvironmentInstancesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FlowPreviewEnvironmentInstancesQuery, FlowPreviewEnvironmentInstancesQueryVariables>(FlowPreviewEnvironmentInstancesDocument, options);
        }
export function useFlowPreviewEnvironmentInstancesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<FlowPreviewEnvironmentInstancesQuery, FlowPreviewEnvironmentInstancesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<FlowPreviewEnvironmentInstancesQuery, FlowPreviewEnvironmentInstancesQueryVariables>(FlowPreviewEnvironmentInstancesDocument, options);
        }
export type FlowPreviewEnvironmentInstancesQueryHookResult = ReturnType<typeof useFlowPreviewEnvironmentInstancesQuery>;
export type FlowPreviewEnvironmentInstancesLazyQueryHookResult = ReturnType<typeof useFlowPreviewEnvironmentInstancesLazyQuery>;
export type FlowPreviewEnvironmentInstancesSuspenseQueryHookResult = ReturnType<typeof useFlowPreviewEnvironmentInstancesSuspenseQuery>;
export type FlowPreviewEnvironmentInstancesQueryResult = Apollo.QueryResult<FlowPreviewEnvironmentInstancesQuery, FlowPreviewEnvironmentInstancesQueryVariables>;
export const FlowPreviewEnvironmentTemplatesDocument = gql`
    query FlowPreviewEnvironmentTemplates($id: ID!, $first: Int = 100, $after: String) {
  flow(id: $id) {
    id
    previewEnvironmentTemplates(first: $first, after: $after) {
      ...PreviewEnvironmentTemplateConnection
    }
  }
}
    ${PreviewEnvironmentTemplateConnectionFragmentDoc}`;

/**
 * __useFlowPreviewEnvironmentTemplatesQuery__
 *
 * To run a query within a React component, call `useFlowPreviewEnvironmentTemplatesQuery` and pass it any options that fit your needs.
 * When your component renders, `useFlowPreviewEnvironmentTemplatesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFlowPreviewEnvironmentTemplatesQuery({
 *   variables: {
 *      id: // value for 'id'
 *      first: // value for 'first'
 *      after: // value for 'after'
 *   },
 * });
 */
export function useFlowPreviewEnvironmentTemplatesQuery(baseOptions: Apollo.QueryHookOptions<FlowPreviewEnvironmentTemplatesQuery, FlowPreviewEnvironmentTemplatesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FlowPreviewEnvironmentTemplatesQuery, FlowPreviewEnvironmentTemplatesQueryVariables>(FlowPreviewEnvironmentTemplatesDocument, options);
      }
export function useFlowPreviewEnvironmentTemplatesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FlowPreviewEnvironmentTemplatesQuery, FlowPreviewEnvironmentTemplatesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FlowPreviewEnvironmentTemplatesQuery, FlowPreviewEnvironmentTemplatesQueryVariables>(FlowPreviewEnvironmentTemplatesDocument, options);
        }
export function useFlowPreviewEnvironmentTemplatesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<FlowPreviewEnvironmentTemplatesQuery, FlowPreviewEnvironmentTemplatesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<FlowPreviewEnvironmentTemplatesQuery, FlowPreviewEnvironmentTemplatesQueryVariables>(FlowPreviewEnvironmentTemplatesDocument, options);
        }
export type FlowPreviewEnvironmentTemplatesQueryHookResult = ReturnType<typeof useFlowPreviewEnvironmentTemplatesQuery>;
export type FlowPreviewEnvironmentTemplatesLazyQueryHookResult = ReturnType<typeof useFlowPreviewEnvironmentTemplatesLazyQuery>;
export type FlowPreviewEnvironmentTemplatesSuspenseQueryHookResult = ReturnType<typeof useFlowPreviewEnvironmentTemplatesSuspenseQuery>;
export type FlowPreviewEnvironmentTemplatesQueryResult = Apollo.QueryResult<FlowPreviewEnvironmentTemplatesQuery, FlowPreviewEnvironmentTemplatesQueryVariables>;
export const FlowMcpServersDocument = gql`
    query FlowMcpServers($id: ID!) {
  flow(id: $id) {
    id
    servers {
      ...McpServer
    }
  }
}
    ${McpServerFragmentDoc}`;

/**
 * __useFlowMcpServersQuery__
 *
 * To run a query within a React component, call `useFlowMcpServersQuery` and pass it any options that fit your needs.
 * When your component renders, `useFlowMcpServersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFlowMcpServersQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useFlowMcpServersQuery(baseOptions: Apollo.QueryHookOptions<FlowMcpServersQuery, FlowMcpServersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FlowMcpServersQuery, FlowMcpServersQueryVariables>(FlowMcpServersDocument, options);
      }
export function useFlowMcpServersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FlowMcpServersQuery, FlowMcpServersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FlowMcpServersQuery, FlowMcpServersQueryVariables>(FlowMcpServersDocument, options);
        }
export function useFlowMcpServersSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<FlowMcpServersQuery, FlowMcpServersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<FlowMcpServersQuery, FlowMcpServersQueryVariables>(FlowMcpServersDocument, options);
        }
export type FlowMcpServersQueryHookResult = ReturnType<typeof useFlowMcpServersQuery>;
export type FlowMcpServersLazyQueryHookResult = ReturnType<typeof useFlowMcpServersLazyQuery>;
export type FlowMcpServersSuspenseQueryHookResult = ReturnType<typeof useFlowMcpServersSuspenseQuery>;
export type FlowMcpServersQueryResult = Apollo.QueryResult<FlowMcpServersQuery, FlowMcpServersQueryVariables>;
export const FlowVulnerabilityReportsDocument = gql`
    query FlowVulnerabilityReports($id: ID!, $first: Int = 100, $after: String) {
  flow(id: $id) {
    id
    vulnerabilityReports(first: $first, after: $after) {
      ...VulnerabilityReportConnection
    }
  }
}
    ${VulnerabilityReportConnectionFragmentDoc}`;

/**
 * __useFlowVulnerabilityReportsQuery__
 *
 * To run a query within a React component, call `useFlowVulnerabilityReportsQuery` and pass it any options that fit your needs.
 * When your component renders, `useFlowVulnerabilityReportsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFlowVulnerabilityReportsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      first: // value for 'first'
 *      after: // value for 'after'
 *   },
 * });
 */
export function useFlowVulnerabilityReportsQuery(baseOptions: Apollo.QueryHookOptions<FlowVulnerabilityReportsQuery, FlowVulnerabilityReportsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FlowVulnerabilityReportsQuery, FlowVulnerabilityReportsQueryVariables>(FlowVulnerabilityReportsDocument, options);
      }
export function useFlowVulnerabilityReportsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FlowVulnerabilityReportsQuery, FlowVulnerabilityReportsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FlowVulnerabilityReportsQuery, FlowVulnerabilityReportsQueryVariables>(FlowVulnerabilityReportsDocument, options);
        }
export function useFlowVulnerabilityReportsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<FlowVulnerabilityReportsQuery, FlowVulnerabilityReportsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<FlowVulnerabilityReportsQuery, FlowVulnerabilityReportsQueryVariables>(FlowVulnerabilityReportsDocument, options);
        }
export type FlowVulnerabilityReportsQueryHookResult = ReturnType<typeof useFlowVulnerabilityReportsQuery>;
export type FlowVulnerabilityReportsLazyQueryHookResult = ReturnType<typeof useFlowVulnerabilityReportsLazyQuery>;
export type FlowVulnerabilityReportsSuspenseQueryHookResult = ReturnType<typeof useFlowVulnerabilityReportsSuspenseQuery>;
export type FlowVulnerabilityReportsQueryResult = Apollo.QueryResult<FlowVulnerabilityReportsQuery, FlowVulnerabilityReportsQueryVariables>;
export const UpsertFlowDocument = gql`
    mutation UpsertFlow($attributes: FlowAttributes!) {
  upsertFlow(attributes: $attributes) {
    ...FlowBasicWithBindings
  }
}
    ${FlowBasicWithBindingsFragmentDoc}`;
export type UpsertFlowMutationFn = Apollo.MutationFunction<UpsertFlowMutation, UpsertFlowMutationVariables>;

/**
 * __useUpsertFlowMutation__
 *
 * To run a mutation, you first call `useUpsertFlowMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpsertFlowMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upsertFlowMutation, { data, loading, error }] = useUpsertFlowMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpsertFlowMutation(baseOptions?: Apollo.MutationHookOptions<UpsertFlowMutation, UpsertFlowMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpsertFlowMutation, UpsertFlowMutationVariables>(UpsertFlowDocument, options);
      }
export type UpsertFlowMutationHookResult = ReturnType<typeof useUpsertFlowMutation>;
export type UpsertFlowMutationResult = Apollo.MutationResult<UpsertFlowMutation>;
export type UpsertFlowMutationOptions = Apollo.BaseMutationOptions<UpsertFlowMutation, UpsertFlowMutationVariables>;
export const GroupsDocument = gql`
    query Groups($q: String, $first: Int = 20, $after: String) {
  groups(q: $q, first: $first, after: $after) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...Group
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${GroupFragmentDoc}`;

/**
 * __useGroupsQuery__
 *
 * To run a query within a React component, call `useGroupsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGroupsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGroupsQuery({
 *   variables: {
 *      q: // value for 'q'
 *      first: // value for 'first'
 *      after: // value for 'after'
 *   },
 * });
 */
export function useGroupsQuery(baseOptions?: Apollo.QueryHookOptions<GroupsQuery, GroupsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GroupsQuery, GroupsQueryVariables>(GroupsDocument, options);
      }
export function useGroupsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GroupsQuery, GroupsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GroupsQuery, GroupsQueryVariables>(GroupsDocument, options);
        }
export function useGroupsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GroupsQuery, GroupsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GroupsQuery, GroupsQueryVariables>(GroupsDocument, options);
        }
export type GroupsQueryHookResult = ReturnType<typeof useGroupsQuery>;
export type GroupsLazyQueryHookResult = ReturnType<typeof useGroupsLazyQuery>;
export type GroupsSuspenseQueryHookResult = ReturnType<typeof useGroupsSuspenseQuery>;
export type GroupsQueryResult = Apollo.QueryResult<GroupsQuery, GroupsQueryVariables>;
export const SearchGroupsDocument = gql`
    query SearchGroups($q: String, $cursor: String) {
  groups(q: $q, after: $cursor, first: 5) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...Group
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${GroupFragmentDoc}`;

/**
 * __useSearchGroupsQuery__
 *
 * To run a query within a React component, call `useSearchGroupsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchGroupsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchGroupsQuery({
 *   variables: {
 *      q: // value for 'q'
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useSearchGroupsQuery(baseOptions?: Apollo.QueryHookOptions<SearchGroupsQuery, SearchGroupsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SearchGroupsQuery, SearchGroupsQueryVariables>(SearchGroupsDocument, options);
      }
export function useSearchGroupsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchGroupsQuery, SearchGroupsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SearchGroupsQuery, SearchGroupsQueryVariables>(SearchGroupsDocument, options);
        }
export function useSearchGroupsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<SearchGroupsQuery, SearchGroupsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SearchGroupsQuery, SearchGroupsQueryVariables>(SearchGroupsDocument, options);
        }
export type SearchGroupsQueryHookResult = ReturnType<typeof useSearchGroupsQuery>;
export type SearchGroupsLazyQueryHookResult = ReturnType<typeof useSearchGroupsLazyQuery>;
export type SearchGroupsSuspenseQueryHookResult = ReturnType<typeof useSearchGroupsSuspenseQuery>;
export type SearchGroupsQueryResult = Apollo.QueryResult<SearchGroupsQuery, SearchGroupsQueryVariables>;
export const GroupMembersDocument = gql`
    query GroupMembers($cursor: String, $id: ID!) {
  groupMembers(groupId: $id, after: $cursor, first: 20) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...GroupMember
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${GroupMemberFragmentDoc}`;

/**
 * __useGroupMembersQuery__
 *
 * To run a query within a React component, call `useGroupMembersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGroupMembersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGroupMembersQuery({
 *   variables: {
 *      cursor: // value for 'cursor'
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGroupMembersQuery(baseOptions: Apollo.QueryHookOptions<GroupMembersQuery, GroupMembersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GroupMembersQuery, GroupMembersQueryVariables>(GroupMembersDocument, options);
      }
export function useGroupMembersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GroupMembersQuery, GroupMembersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GroupMembersQuery, GroupMembersQueryVariables>(GroupMembersDocument, options);
        }
export function useGroupMembersSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GroupMembersQuery, GroupMembersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GroupMembersQuery, GroupMembersQueryVariables>(GroupMembersDocument, options);
        }
export type GroupMembersQueryHookResult = ReturnType<typeof useGroupMembersQuery>;
export type GroupMembersLazyQueryHookResult = ReturnType<typeof useGroupMembersLazyQuery>;
export type GroupMembersSuspenseQueryHookResult = ReturnType<typeof useGroupMembersSuspenseQuery>;
export type GroupMembersQueryResult = Apollo.QueryResult<GroupMembersQuery, GroupMembersQueryVariables>;
export const CreateGroupMemberDocument = gql`
    mutation CreateGroupMember($groupId: ID!, $userId: ID!) {
  createGroupMember(groupId: $groupId, userId: $userId) {
    ...GroupMember
  }
}
    ${GroupMemberFragmentDoc}`;
export type CreateGroupMemberMutationFn = Apollo.MutationFunction<CreateGroupMemberMutation, CreateGroupMemberMutationVariables>;

/**
 * __useCreateGroupMemberMutation__
 *
 * To run a mutation, you first call `useCreateGroupMemberMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateGroupMemberMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createGroupMemberMutation, { data, loading, error }] = useCreateGroupMemberMutation({
 *   variables: {
 *      groupId: // value for 'groupId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useCreateGroupMemberMutation(baseOptions?: Apollo.MutationHookOptions<CreateGroupMemberMutation, CreateGroupMemberMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateGroupMemberMutation, CreateGroupMemberMutationVariables>(CreateGroupMemberDocument, options);
      }
export type CreateGroupMemberMutationHookResult = ReturnType<typeof useCreateGroupMemberMutation>;
export type CreateGroupMemberMutationResult = Apollo.MutationResult<CreateGroupMemberMutation>;
export type CreateGroupMemberMutationOptions = Apollo.BaseMutationOptions<CreateGroupMemberMutation, CreateGroupMemberMutationVariables>;
export const DeleteGroupMemberDocument = gql`
    mutation DeleteGroupMember($groupId: ID!, $userId: ID!) {
  deleteGroupMember(groupId: $groupId, userId: $userId) {
    ...GroupMember
  }
}
    ${GroupMemberFragmentDoc}`;
export type DeleteGroupMemberMutationFn = Apollo.MutationFunction<DeleteGroupMemberMutation, DeleteGroupMemberMutationVariables>;

/**
 * __useDeleteGroupMemberMutation__
 *
 * To run a mutation, you first call `useDeleteGroupMemberMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteGroupMemberMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteGroupMemberMutation, { data, loading, error }] = useDeleteGroupMemberMutation({
 *   variables: {
 *      groupId: // value for 'groupId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useDeleteGroupMemberMutation(baseOptions?: Apollo.MutationHookOptions<DeleteGroupMemberMutation, DeleteGroupMemberMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteGroupMemberMutation, DeleteGroupMemberMutationVariables>(DeleteGroupMemberDocument, options);
      }
export type DeleteGroupMemberMutationHookResult = ReturnType<typeof useDeleteGroupMemberMutation>;
export type DeleteGroupMemberMutationResult = Apollo.MutationResult<DeleteGroupMemberMutation>;
export type DeleteGroupMemberMutationOptions = Apollo.BaseMutationOptions<DeleteGroupMemberMutation, DeleteGroupMemberMutationVariables>;
export const CreateGroupDocument = gql`
    mutation CreateGroup($attributes: GroupAttributes!) {
  createGroup(attributes: $attributes) {
    ...Group
  }
}
    ${GroupFragmentDoc}`;
export type CreateGroupMutationFn = Apollo.MutationFunction<CreateGroupMutation, CreateGroupMutationVariables>;

/**
 * __useCreateGroupMutation__
 *
 * To run a mutation, you first call `useCreateGroupMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateGroupMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createGroupMutation, { data, loading, error }] = useCreateGroupMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useCreateGroupMutation(baseOptions?: Apollo.MutationHookOptions<CreateGroupMutation, CreateGroupMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateGroupMutation, CreateGroupMutationVariables>(CreateGroupDocument, options);
      }
export type CreateGroupMutationHookResult = ReturnType<typeof useCreateGroupMutation>;
export type CreateGroupMutationResult = Apollo.MutationResult<CreateGroupMutation>;
export type CreateGroupMutationOptions = Apollo.BaseMutationOptions<CreateGroupMutation, CreateGroupMutationVariables>;
export const UpdateGroupDocument = gql`
    mutation UpdateGroup($id: ID!, $attributes: GroupAttributes!) {
  updateGroup(groupId: $id, attributes: $attributes) {
    ...Group
  }
}
    ${GroupFragmentDoc}`;
export type UpdateGroupMutationFn = Apollo.MutationFunction<UpdateGroupMutation, UpdateGroupMutationVariables>;

/**
 * __useUpdateGroupMutation__
 *
 * To run a mutation, you first call `useUpdateGroupMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateGroupMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateGroupMutation, { data, loading, error }] = useUpdateGroupMutation({
 *   variables: {
 *      id: // value for 'id'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpdateGroupMutation(baseOptions?: Apollo.MutationHookOptions<UpdateGroupMutation, UpdateGroupMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateGroupMutation, UpdateGroupMutationVariables>(UpdateGroupDocument, options);
      }
export type UpdateGroupMutationHookResult = ReturnType<typeof useUpdateGroupMutation>;
export type UpdateGroupMutationResult = Apollo.MutationResult<UpdateGroupMutation>;
export type UpdateGroupMutationOptions = Apollo.BaseMutationOptions<UpdateGroupMutation, UpdateGroupMutationVariables>;
export const DeleteGroupDocument = gql`
    mutation DeleteGroup($id: ID!) {
  deleteGroup(groupId: $id) {
    ...Group
  }
}
    ${GroupFragmentDoc}`;
export type DeleteGroupMutationFn = Apollo.MutationFunction<DeleteGroupMutation, DeleteGroupMutationVariables>;

/**
 * __useDeleteGroupMutation__
 *
 * To run a mutation, you first call `useDeleteGroupMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteGroupMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteGroupMutation, { data, loading, error }] = useDeleteGroupMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteGroupMutation(baseOptions?: Apollo.MutationHookOptions<DeleteGroupMutation, DeleteGroupMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteGroupMutation, DeleteGroupMutationVariables>(DeleteGroupDocument, options);
      }
export type DeleteGroupMutationHookResult = ReturnType<typeof useDeleteGroupMutation>;
export type DeleteGroupMutationResult = Apollo.MutationResult<DeleteGroupMutation>;
export type DeleteGroupMutationOptions = Apollo.BaseMutationOptions<DeleteGroupMutation, DeleteGroupMutationVariables>;
export const ClusterOverviewDetailsDocument = gql`
    query ClusterOverviewDetails($id: ID!, $kubeVersion: String!, $hasKubeVersion: Boolean!) {
  cluster(id: $id) {
    ...ClusterOverviewDetails
  }
}
    ${ClusterOverviewDetailsFragmentDoc}`;

/**
 * __useClusterOverviewDetailsQuery__
 *
 * To run a query within a React component, call `useClusterOverviewDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useClusterOverviewDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClusterOverviewDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      kubeVersion: // value for 'kubeVersion'
 *      hasKubeVersion: // value for 'hasKubeVersion'
 *   },
 * });
 */
export function useClusterOverviewDetailsQuery(baseOptions: Apollo.QueryHookOptions<ClusterOverviewDetailsQuery, ClusterOverviewDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClusterOverviewDetailsQuery, ClusterOverviewDetailsQueryVariables>(ClusterOverviewDetailsDocument, options);
      }
export function useClusterOverviewDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClusterOverviewDetailsQuery, ClusterOverviewDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClusterOverviewDetailsQuery, ClusterOverviewDetailsQueryVariables>(ClusterOverviewDetailsDocument, options);
        }
export function useClusterOverviewDetailsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClusterOverviewDetailsQuery, ClusterOverviewDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClusterOverviewDetailsQuery, ClusterOverviewDetailsQueryVariables>(ClusterOverviewDetailsDocument, options);
        }
export type ClusterOverviewDetailsQueryHookResult = ReturnType<typeof useClusterOverviewDetailsQuery>;
export type ClusterOverviewDetailsLazyQueryHookResult = ReturnType<typeof useClusterOverviewDetailsLazyQuery>;
export type ClusterOverviewDetailsSuspenseQueryHookResult = ReturnType<typeof useClusterOverviewDetailsSuspenseQuery>;
export type ClusterOverviewDetailsQueryResult = Apollo.QueryResult<ClusterOverviewDetailsQuery, ClusterOverviewDetailsQueryVariables>;
export const UpgradeStatisticsDocument = gql`
    query UpgradeStatistics($projectId: ID, $tag: TagInput) {
  upgradeStatistics(projectId: $projectId, tag: $tag) {
    ...UpgradeStatistics
  }
}
    ${UpgradeStatisticsFragmentDoc}`;

/**
 * __useUpgradeStatisticsQuery__
 *
 * To run a query within a React component, call `useUpgradeStatisticsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUpgradeStatisticsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUpgradeStatisticsQuery({
 *   variables: {
 *      projectId: // value for 'projectId'
 *      tag: // value for 'tag'
 *   },
 * });
 */
export function useUpgradeStatisticsQuery(baseOptions?: Apollo.QueryHookOptions<UpgradeStatisticsQuery, UpgradeStatisticsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UpgradeStatisticsQuery, UpgradeStatisticsQueryVariables>(UpgradeStatisticsDocument, options);
      }
export function useUpgradeStatisticsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UpgradeStatisticsQuery, UpgradeStatisticsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UpgradeStatisticsQuery, UpgradeStatisticsQueryVariables>(UpgradeStatisticsDocument, options);
        }
export function useUpgradeStatisticsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<UpgradeStatisticsQuery, UpgradeStatisticsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<UpgradeStatisticsQuery, UpgradeStatisticsQueryVariables>(UpgradeStatisticsDocument, options);
        }
export type UpgradeStatisticsQueryHookResult = ReturnType<typeof useUpgradeStatisticsQuery>;
export type UpgradeStatisticsLazyQueryHookResult = ReturnType<typeof useUpgradeStatisticsLazyQuery>;
export type UpgradeStatisticsSuspenseQueryHookResult = ReturnType<typeof useUpgradeStatisticsSuspenseQuery>;
export type UpgradeStatisticsQueryResult = Apollo.QueryResult<UpgradeStatisticsQuery, UpgradeStatisticsQueryVariables>;
export const ClusterHealthScoresDocument = gql`
    query ClusterHealthScores($projectId: ID) {
  clusters(projectId: $projectId, first: 1000) {
    edges {
      node {
        ...ClusterHealthScore
      }
    }
  }
}
    ${ClusterHealthScoreFragmentDoc}`;

/**
 * __useClusterHealthScoresQuery__
 *
 * To run a query within a React component, call `useClusterHealthScoresQuery` and pass it any options that fit your needs.
 * When your component renders, `useClusterHealthScoresQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClusterHealthScoresQuery({
 *   variables: {
 *      projectId: // value for 'projectId'
 *   },
 * });
 */
export function useClusterHealthScoresQuery(baseOptions?: Apollo.QueryHookOptions<ClusterHealthScoresQuery, ClusterHealthScoresQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClusterHealthScoresQuery, ClusterHealthScoresQueryVariables>(ClusterHealthScoresDocument, options);
      }
export function useClusterHealthScoresLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClusterHealthScoresQuery, ClusterHealthScoresQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClusterHealthScoresQuery, ClusterHealthScoresQueryVariables>(ClusterHealthScoresDocument, options);
        }
export function useClusterHealthScoresSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClusterHealthScoresQuery, ClusterHealthScoresQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClusterHealthScoresQuery, ClusterHealthScoresQueryVariables>(ClusterHealthScoresDocument, options);
        }
export type ClusterHealthScoresQueryHookResult = ReturnType<typeof useClusterHealthScoresQuery>;
export type ClusterHealthScoresLazyQueryHookResult = ReturnType<typeof useClusterHealthScoresLazyQuery>;
export type ClusterHealthScoresSuspenseQueryHookResult = ReturnType<typeof useClusterHealthScoresSuspenseQuery>;
export type ClusterHealthScoresQueryResult = Apollo.QueryResult<ClusterHealthScoresQuery, ClusterHealthScoresQueryVariables>;
export const KubernetesClustersDocument = gql`
    query KubernetesClusters($projectId: ID) {
  clusters(first: 200, projectId: $projectId) {
    edges {
      node {
        ...KubernetesCluster
      }
    }
  }
}
    ${KubernetesClusterFragmentDoc}`;

/**
 * __useKubernetesClustersQuery__
 *
 * To run a query within a React component, call `useKubernetesClustersQuery` and pass it any options that fit your needs.
 * When your component renders, `useKubernetesClustersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useKubernetesClustersQuery({
 *   variables: {
 *      projectId: // value for 'projectId'
 *   },
 * });
 */
export function useKubernetesClustersQuery(baseOptions?: Apollo.QueryHookOptions<KubernetesClustersQuery, KubernetesClustersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<KubernetesClustersQuery, KubernetesClustersQueryVariables>(KubernetesClustersDocument, options);
      }
export function useKubernetesClustersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<KubernetesClustersQuery, KubernetesClustersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<KubernetesClustersQuery, KubernetesClustersQueryVariables>(KubernetesClustersDocument, options);
        }
export function useKubernetesClustersSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<KubernetesClustersQuery, KubernetesClustersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<KubernetesClustersQuery, KubernetesClustersQueryVariables>(KubernetesClustersDocument, options);
        }
export type KubernetesClustersQueryHookResult = ReturnType<typeof useKubernetesClustersQuery>;
export type KubernetesClustersLazyQueryHookResult = ReturnType<typeof useKubernetesClustersLazyQuery>;
export type KubernetesClustersSuspenseQueryHookResult = ReturnType<typeof useKubernetesClustersSuspenseQuery>;
export type KubernetesClustersQueryResult = Apollo.QueryResult<KubernetesClustersQuery, KubernetesClustersQueryVariables>;
export const KubernetesClusterAuditLogsDocument = gql`
    query KubernetesClusterAuditLogs($clusterId: ID, $first: Int, $after: String, $before: String, $last: Int) {
  cluster(id: $clusterId) {
    auditLogs(first: $first, last: $last, after: $after, before: $before) {
      pageInfo {
        ...PageInfo
      }
      edges {
        node {
          id
          insertedAt
          method
          path
          actor {
            name
            email
          }
        }
      }
    }
  }
}
    ${PageInfoFragmentDoc}`;

/**
 * __useKubernetesClusterAuditLogsQuery__
 *
 * To run a query within a React component, call `useKubernetesClusterAuditLogsQuery` and pass it any options that fit your needs.
 * When your component renders, `useKubernetesClusterAuditLogsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useKubernetesClusterAuditLogsQuery({
 *   variables: {
 *      clusterId: // value for 'clusterId'
 *      first: // value for 'first'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useKubernetesClusterAuditLogsQuery(baseOptions?: Apollo.QueryHookOptions<KubernetesClusterAuditLogsQuery, KubernetesClusterAuditLogsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<KubernetesClusterAuditLogsQuery, KubernetesClusterAuditLogsQueryVariables>(KubernetesClusterAuditLogsDocument, options);
      }
export function useKubernetesClusterAuditLogsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<KubernetesClusterAuditLogsQuery, KubernetesClusterAuditLogsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<KubernetesClusterAuditLogsQuery, KubernetesClusterAuditLogsQueryVariables>(KubernetesClusterAuditLogsDocument, options);
        }
export function useKubernetesClusterAuditLogsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<KubernetesClusterAuditLogsQuery, KubernetesClusterAuditLogsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<KubernetesClusterAuditLogsQuery, KubernetesClusterAuditLogsQueryVariables>(KubernetesClusterAuditLogsDocument, options);
        }
export type KubernetesClusterAuditLogsQueryHookResult = ReturnType<typeof useKubernetesClusterAuditLogsQuery>;
export type KubernetesClusterAuditLogsLazyQueryHookResult = ReturnType<typeof useKubernetesClusterAuditLogsLazyQuery>;
export type KubernetesClusterAuditLogsSuspenseQueryHookResult = ReturnType<typeof useKubernetesClusterAuditLogsSuspenseQuery>;
export type KubernetesClusterAuditLogsQueryResult = Apollo.QueryResult<KubernetesClusterAuditLogsQuery, KubernetesClusterAuditLogsQueryVariables>;
export const PinCustomResourceDocument = gql`
    mutation PinCustomResource($attributes: PinnedCustomResourceAttributes!) {
  createPinnedCustomResource(attributes: $attributes) {
    ...PinnedCustomResource
  }
}
    ${PinnedCustomResourceFragmentDoc}`;
export type PinCustomResourceMutationFn = Apollo.MutationFunction<PinCustomResourceMutation, PinCustomResourceMutationVariables>;

/**
 * __usePinCustomResourceMutation__
 *
 * To run a mutation, you first call `usePinCustomResourceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePinCustomResourceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [pinCustomResourceMutation, { data, loading, error }] = usePinCustomResourceMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function usePinCustomResourceMutation(baseOptions?: Apollo.MutationHookOptions<PinCustomResourceMutation, PinCustomResourceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PinCustomResourceMutation, PinCustomResourceMutationVariables>(PinCustomResourceDocument, options);
      }
export type PinCustomResourceMutationHookResult = ReturnType<typeof usePinCustomResourceMutation>;
export type PinCustomResourceMutationResult = Apollo.MutationResult<PinCustomResourceMutation>;
export type PinCustomResourceMutationOptions = Apollo.BaseMutationOptions<PinCustomResourceMutation, PinCustomResourceMutationVariables>;
export const UnpinCustomResourceDocument = gql`
    mutation UnpinCustomResource($id: ID!) {
  deletePinnedCustomResource(id: $id) {
    ...PinnedCustomResource
  }
}
    ${PinnedCustomResourceFragmentDoc}`;
export type UnpinCustomResourceMutationFn = Apollo.MutationFunction<UnpinCustomResourceMutation, UnpinCustomResourceMutationVariables>;

/**
 * __useUnpinCustomResourceMutation__
 *
 * To run a mutation, you first call `useUnpinCustomResourceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUnpinCustomResourceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [unpinCustomResourceMutation, { data, loading, error }] = useUnpinCustomResourceMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useUnpinCustomResourceMutation(baseOptions?: Apollo.MutationHookOptions<UnpinCustomResourceMutation, UnpinCustomResourceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UnpinCustomResourceMutation, UnpinCustomResourceMutationVariables>(UnpinCustomResourceDocument, options);
      }
export type UnpinCustomResourceMutationHookResult = ReturnType<typeof useUnpinCustomResourceMutation>;
export type UnpinCustomResourceMutationResult = Apollo.MutationResult<UnpinCustomResourceMutation>;
export type UnpinCustomResourceMutationOptions = Apollo.BaseMutationOptions<UnpinCustomResourceMutation, UnpinCustomResourceMutationVariables>;
export const ArgoRolloutDocument = gql`
    query ArgoRollout($name: String!, $namespace: String!, $serviceId: ID) {
  argoRollout(name: $name, namespace: $namespace, serviceId: $serviceId) {
    ...ArgoRollout
  }
}
    ${ArgoRolloutFragmentDoc}`;

/**
 * __useArgoRolloutQuery__
 *
 * To run a query within a React component, call `useArgoRolloutQuery` and pass it any options that fit your needs.
 * When your component renders, `useArgoRolloutQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useArgoRolloutQuery({
 *   variables: {
 *      name: // value for 'name'
 *      namespace: // value for 'namespace'
 *      serviceId: // value for 'serviceId'
 *   },
 * });
 */
export function useArgoRolloutQuery(baseOptions: Apollo.QueryHookOptions<ArgoRolloutQuery, ArgoRolloutQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ArgoRolloutQuery, ArgoRolloutQueryVariables>(ArgoRolloutDocument, options);
      }
export function useArgoRolloutLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ArgoRolloutQuery, ArgoRolloutQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ArgoRolloutQuery, ArgoRolloutQueryVariables>(ArgoRolloutDocument, options);
        }
export function useArgoRolloutSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ArgoRolloutQuery, ArgoRolloutQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ArgoRolloutQuery, ArgoRolloutQueryVariables>(ArgoRolloutDocument, options);
        }
export type ArgoRolloutQueryHookResult = ReturnType<typeof useArgoRolloutQuery>;
export type ArgoRolloutLazyQueryHookResult = ReturnType<typeof useArgoRolloutLazyQuery>;
export type ArgoRolloutSuspenseQueryHookResult = ReturnType<typeof useArgoRolloutSuspenseQuery>;
export type ArgoRolloutQueryResult = Apollo.QueryResult<ArgoRolloutQuery, ArgoRolloutQueryVariables>;
export const CanaryDocument = gql`
    query Canary($name: String!, $namespace: String!, $serviceId: ID) {
  canary(name: $name, namespace: $namespace, serviceId: $serviceId) {
    ...Canary
  }
}
    ${CanaryFragmentDoc}`;

/**
 * __useCanaryQuery__
 *
 * To run a query within a React component, call `useCanaryQuery` and pass it any options that fit your needs.
 * When your component renders, `useCanaryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCanaryQuery({
 *   variables: {
 *      name: // value for 'name'
 *      namespace: // value for 'namespace'
 *      serviceId: // value for 'serviceId'
 *   },
 * });
 */
export function useCanaryQuery(baseOptions: Apollo.QueryHookOptions<CanaryQuery, CanaryQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CanaryQuery, CanaryQueryVariables>(CanaryDocument, options);
      }
export function useCanaryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CanaryQuery, CanaryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CanaryQuery, CanaryQueryVariables>(CanaryDocument, options);
        }
export function useCanarySuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<CanaryQuery, CanaryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CanaryQuery, CanaryQueryVariables>(CanaryDocument, options);
        }
export type CanaryQueryHookResult = ReturnType<typeof useCanaryQuery>;
export type CanaryLazyQueryHookResult = ReturnType<typeof useCanaryLazyQuery>;
export type CanarySuspenseQueryHookResult = ReturnType<typeof useCanarySuspenseQuery>;
export type CanaryQueryResult = Apollo.QueryResult<CanaryQuery, CanaryQueryVariables>;
export const CertificateDocument = gql`
    query Certificate($name: String!, $namespace: String!, $serviceId: ID) {
  certificate(name: $name, namespace: $namespace, serviceId: $serviceId) {
    ...Certificate
  }
}
    ${CertificateFragmentDoc}`;

/**
 * __useCertificateQuery__
 *
 * To run a query within a React component, call `useCertificateQuery` and pass it any options that fit your needs.
 * When your component renders, `useCertificateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCertificateQuery({
 *   variables: {
 *      name: // value for 'name'
 *      namespace: // value for 'namespace'
 *      serviceId: // value for 'serviceId'
 *   },
 * });
 */
export function useCertificateQuery(baseOptions: Apollo.QueryHookOptions<CertificateQuery, CertificateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CertificateQuery, CertificateQueryVariables>(CertificateDocument, options);
      }
export function useCertificateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CertificateQuery, CertificateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CertificateQuery, CertificateQueryVariables>(CertificateDocument, options);
        }
export function useCertificateSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<CertificateQuery, CertificateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CertificateQuery, CertificateQueryVariables>(CertificateDocument, options);
        }
export type CertificateQueryHookResult = ReturnType<typeof useCertificateQuery>;
export type CertificateLazyQueryHookResult = ReturnType<typeof useCertificateLazyQuery>;
export type CertificateSuspenseQueryHookResult = ReturnType<typeof useCertificateSuspenseQuery>;
export type CertificateQueryResult = Apollo.QueryResult<CertificateQuery, CertificateQueryVariables>;
export const CronJobDocument = gql`
    query CronJob($name: String!, $namespace: String!, $serviceId: ID) {
  cronJob(name: $name, namespace: $namespace, serviceId: $serviceId) {
    ...CronJob
  }
}
    ${CronJobFragmentDoc}`;

/**
 * __useCronJobQuery__
 *
 * To run a query within a React component, call `useCronJobQuery` and pass it any options that fit your needs.
 * When your component renders, `useCronJobQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCronJobQuery({
 *   variables: {
 *      name: // value for 'name'
 *      namespace: // value for 'namespace'
 *      serviceId: // value for 'serviceId'
 *   },
 * });
 */
export function useCronJobQuery(baseOptions: Apollo.QueryHookOptions<CronJobQuery, CronJobQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CronJobQuery, CronJobQueryVariables>(CronJobDocument, options);
      }
export function useCronJobLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CronJobQuery, CronJobQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CronJobQuery, CronJobQueryVariables>(CronJobDocument, options);
        }
export function useCronJobSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<CronJobQuery, CronJobQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CronJobQuery, CronJobQueryVariables>(CronJobDocument, options);
        }
export type CronJobQueryHookResult = ReturnType<typeof useCronJobQuery>;
export type CronJobLazyQueryHookResult = ReturnType<typeof useCronJobLazyQuery>;
export type CronJobSuspenseQueryHookResult = ReturnType<typeof useCronJobSuspenseQuery>;
export type CronJobQueryResult = Apollo.QueryResult<CronJobQuery, CronJobQueryVariables>;
export const DaemonSetDocument = gql`
    query DaemonSet($name: String!, $namespace: String!, $serviceId: ID) {
  daemonSet(name: $name, namespace: $namespace, serviceId: $serviceId) {
    ...DaemonSet
  }
}
    ${DaemonSetFragmentDoc}`;

/**
 * __useDaemonSetQuery__
 *
 * To run a query within a React component, call `useDaemonSetQuery` and pass it any options that fit your needs.
 * When your component renders, `useDaemonSetQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDaemonSetQuery({
 *   variables: {
 *      name: // value for 'name'
 *      namespace: // value for 'namespace'
 *      serviceId: // value for 'serviceId'
 *   },
 * });
 */
export function useDaemonSetQuery(baseOptions: Apollo.QueryHookOptions<DaemonSetQuery, DaemonSetQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DaemonSetQuery, DaemonSetQueryVariables>(DaemonSetDocument, options);
      }
export function useDaemonSetLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DaemonSetQuery, DaemonSetQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DaemonSetQuery, DaemonSetQueryVariables>(DaemonSetDocument, options);
        }
export function useDaemonSetSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<DaemonSetQuery, DaemonSetQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<DaemonSetQuery, DaemonSetQueryVariables>(DaemonSetDocument, options);
        }
export type DaemonSetQueryHookResult = ReturnType<typeof useDaemonSetQuery>;
export type DaemonSetLazyQueryHookResult = ReturnType<typeof useDaemonSetLazyQuery>;
export type DaemonSetSuspenseQueryHookResult = ReturnType<typeof useDaemonSetSuspenseQuery>;
export type DaemonSetQueryResult = Apollo.QueryResult<DaemonSetQuery, DaemonSetQueryVariables>;
export const DeploymentDocument = gql`
    query Deployment($name: String!, $namespace: String!, $serviceId: ID) {
  deployment(name: $name, namespace: $namespace, serviceId: $serviceId) {
    ...Deployment
  }
}
    ${DeploymentFragmentDoc}`;

/**
 * __useDeploymentQuery__
 *
 * To run a query within a React component, call `useDeploymentQuery` and pass it any options that fit your needs.
 * When your component renders, `useDeploymentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDeploymentQuery({
 *   variables: {
 *      name: // value for 'name'
 *      namespace: // value for 'namespace'
 *      serviceId: // value for 'serviceId'
 *   },
 * });
 */
export function useDeploymentQuery(baseOptions: Apollo.QueryHookOptions<DeploymentQuery, DeploymentQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DeploymentQuery, DeploymentQueryVariables>(DeploymentDocument, options);
      }
export function useDeploymentLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DeploymentQuery, DeploymentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DeploymentQuery, DeploymentQueryVariables>(DeploymentDocument, options);
        }
export function useDeploymentSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<DeploymentQuery, DeploymentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<DeploymentQuery, DeploymentQueryVariables>(DeploymentDocument, options);
        }
export type DeploymentQueryHookResult = ReturnType<typeof useDeploymentQuery>;
export type DeploymentLazyQueryHookResult = ReturnType<typeof useDeploymentLazyQuery>;
export type DeploymentSuspenseQueryHookResult = ReturnType<typeof useDeploymentSuspenseQuery>;
export type DeploymentQueryResult = Apollo.QueryResult<DeploymentQuery, DeploymentQueryVariables>;
export const IngressDocument = gql`
    query Ingress($name: String!, $namespace: String!, $serviceId: ID) {
  ingress(name: $name, namespace: $namespace, serviceId: $serviceId) {
    ...Ingress
  }
}
    ${IngressFragmentDoc}`;

/**
 * __useIngressQuery__
 *
 * To run a query within a React component, call `useIngressQuery` and pass it any options that fit your needs.
 * When your component renders, `useIngressQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useIngressQuery({
 *   variables: {
 *      name: // value for 'name'
 *      namespace: // value for 'namespace'
 *      serviceId: // value for 'serviceId'
 *   },
 * });
 */
export function useIngressQuery(baseOptions: Apollo.QueryHookOptions<IngressQuery, IngressQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<IngressQuery, IngressQueryVariables>(IngressDocument, options);
      }
export function useIngressLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<IngressQuery, IngressQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<IngressQuery, IngressQueryVariables>(IngressDocument, options);
        }
export function useIngressSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<IngressQuery, IngressQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<IngressQuery, IngressQueryVariables>(IngressDocument, options);
        }
export type IngressQueryHookResult = ReturnType<typeof useIngressQuery>;
export type IngressLazyQueryHookResult = ReturnType<typeof useIngressLazyQuery>;
export type IngressSuspenseQueryHookResult = ReturnType<typeof useIngressSuspenseQuery>;
export type IngressQueryResult = Apollo.QueryResult<IngressQuery, IngressQueryVariables>;
export const JobDocument = gql`
    query Job($name: String!, $namespace: String!, $serviceId: ID) {
  job(name: $name, namespace: $namespace, serviceId: $serviceId) {
    ...Job
  }
}
    ${JobFragmentDoc}`;

/**
 * __useJobQuery__
 *
 * To run a query within a React component, call `useJobQuery` and pass it any options that fit your needs.
 * When your component renders, `useJobQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useJobQuery({
 *   variables: {
 *      name: // value for 'name'
 *      namespace: // value for 'namespace'
 *      serviceId: // value for 'serviceId'
 *   },
 * });
 */
export function useJobQuery(baseOptions: Apollo.QueryHookOptions<JobQuery, JobQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<JobQuery, JobQueryVariables>(JobDocument, options);
      }
export function useJobLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<JobQuery, JobQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<JobQuery, JobQueryVariables>(JobDocument, options);
        }
export function useJobSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<JobQuery, JobQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<JobQuery, JobQueryVariables>(JobDocument, options);
        }
export type JobQueryHookResult = ReturnType<typeof useJobQuery>;
export type JobLazyQueryHookResult = ReturnType<typeof useJobLazyQuery>;
export type JobSuspenseQueryHookResult = ReturnType<typeof useJobSuspenseQuery>;
export type JobQueryResult = Apollo.QueryResult<JobQuery, JobQueryVariables>;
export const DeleteJobDocument = gql`
    mutation DeleteJob($name: String!, $namespace: String!) {
  deleteJob(name: $name, namespace: $namespace) {
    ...Job
  }
}
    ${JobFragmentDoc}`;
export type DeleteJobMutationFn = Apollo.MutationFunction<DeleteJobMutation, DeleteJobMutationVariables>;

/**
 * __useDeleteJobMutation__
 *
 * To run a mutation, you first call `useDeleteJobMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteJobMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteJobMutation, { data, loading, error }] = useDeleteJobMutation({
 *   variables: {
 *      name: // value for 'name'
 *      namespace: // value for 'namespace'
 *   },
 * });
 */
export function useDeleteJobMutation(baseOptions?: Apollo.MutationHookOptions<DeleteJobMutation, DeleteJobMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteJobMutation, DeleteJobMutationVariables>(DeleteJobDocument, options);
      }
export type DeleteJobMutationHookResult = ReturnType<typeof useDeleteJobMutation>;
export type DeleteJobMutationResult = Apollo.MutationResult<DeleteJobMutation>;
export type DeleteJobMutationOptions = Apollo.BaseMutationOptions<DeleteJobMutation, DeleteJobMutationVariables>;
export const NodeDocument = gql`
    query Node($name: String!, $clusterId: ID) {
  node(name: $name, clusterId: $clusterId) {
    ...Node
  }
}
    ${NodeFragmentDoc}`;

/**
 * __useNodeQuery__
 *
 * To run a query within a React component, call `useNodeQuery` and pass it any options that fit your needs.
 * When your component renders, `useNodeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNodeQuery({
 *   variables: {
 *      name: // value for 'name'
 *      clusterId: // value for 'clusterId'
 *   },
 * });
 */
export function useNodeQuery(baseOptions: Apollo.QueryHookOptions<NodeQuery, NodeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<NodeQuery, NodeQueryVariables>(NodeDocument, options);
      }
export function useNodeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<NodeQuery, NodeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<NodeQuery, NodeQueryVariables>(NodeDocument, options);
        }
export function useNodeSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<NodeQuery, NodeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<NodeQuery, NodeQueryVariables>(NodeDocument, options);
        }
export type NodeQueryHookResult = ReturnType<typeof useNodeQuery>;
export type NodeLazyQueryHookResult = ReturnType<typeof useNodeLazyQuery>;
export type NodeSuspenseQueryHookResult = ReturnType<typeof useNodeSuspenseQuery>;
export type NodeQueryResult = Apollo.QueryResult<NodeQuery, NodeQueryVariables>;
export const NodeMetricDocument = gql`
    query NodeMetric($name: String!, $clusterId: ID) {
  nodeMetric(name: $name, clusterId: $clusterId) {
    ...NodeMetric
  }
}
    ${NodeMetricFragmentDoc}`;

/**
 * __useNodeMetricQuery__
 *
 * To run a query within a React component, call `useNodeMetricQuery` and pass it any options that fit your needs.
 * When your component renders, `useNodeMetricQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNodeMetricQuery({
 *   variables: {
 *      name: // value for 'name'
 *      clusterId: // value for 'clusterId'
 *   },
 * });
 */
export function useNodeMetricQuery(baseOptions: Apollo.QueryHookOptions<NodeMetricQuery, NodeMetricQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<NodeMetricQuery, NodeMetricQueryVariables>(NodeMetricDocument, options);
      }
export function useNodeMetricLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<NodeMetricQuery, NodeMetricQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<NodeMetricQuery, NodeMetricQueryVariables>(NodeMetricDocument, options);
        }
export function useNodeMetricSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<NodeMetricQuery, NodeMetricQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<NodeMetricQuery, NodeMetricQueryVariables>(NodeMetricDocument, options);
        }
export type NodeMetricQueryHookResult = ReturnType<typeof useNodeMetricQuery>;
export type NodeMetricLazyQueryHookResult = ReturnType<typeof useNodeMetricLazyQuery>;
export type NodeMetricSuspenseQueryHookResult = ReturnType<typeof useNodeMetricSuspenseQuery>;
export type NodeMetricQueryResult = Apollo.QueryResult<NodeMetricQuery, NodeMetricQueryVariables>;
export const PluralServiceDeploymentDocument = gql`
    query PluralServiceDeployment($name: String!, $namespace: String!, $serviceId: ID) {
  pluralServiceDeployment(
    name: $name
    namespace: $namespace
    serviceId: $serviceId
  ) {
    ...PluralServiceDeployment
  }
}
    ${PluralServiceDeploymentFragmentDoc}`;

/**
 * __usePluralServiceDeploymentQuery__
 *
 * To run a query within a React component, call `usePluralServiceDeploymentQuery` and pass it any options that fit your needs.
 * When your component renders, `usePluralServiceDeploymentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePluralServiceDeploymentQuery({
 *   variables: {
 *      name: // value for 'name'
 *      namespace: // value for 'namespace'
 *      serviceId: // value for 'serviceId'
 *   },
 * });
 */
export function usePluralServiceDeploymentQuery(baseOptions: Apollo.QueryHookOptions<PluralServiceDeploymentQuery, PluralServiceDeploymentQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PluralServiceDeploymentQuery, PluralServiceDeploymentQueryVariables>(PluralServiceDeploymentDocument, options);
      }
export function usePluralServiceDeploymentLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PluralServiceDeploymentQuery, PluralServiceDeploymentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PluralServiceDeploymentQuery, PluralServiceDeploymentQueryVariables>(PluralServiceDeploymentDocument, options);
        }
export function usePluralServiceDeploymentSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<PluralServiceDeploymentQuery, PluralServiceDeploymentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PluralServiceDeploymentQuery, PluralServiceDeploymentQueryVariables>(PluralServiceDeploymentDocument, options);
        }
export type PluralServiceDeploymentQueryHookResult = ReturnType<typeof usePluralServiceDeploymentQuery>;
export type PluralServiceDeploymentLazyQueryHookResult = ReturnType<typeof usePluralServiceDeploymentLazyQuery>;
export type PluralServiceDeploymentSuspenseQueryHookResult = ReturnType<typeof usePluralServiceDeploymentSuspenseQuery>;
export type PluralServiceDeploymentQueryResult = Apollo.QueryResult<PluralServiceDeploymentQuery, PluralServiceDeploymentQueryVariables>;
export const PodDocument = gql`
    query Pod($name: String!, $namespace: String!, $clusterId: ID, $serviceId: ID) {
  pod(
    name: $name
    namespace: $namespace
    clusterId: $clusterId
    serviceId: $serviceId
  ) {
    ...PodWithEvents
  }
}
    ${PodWithEventsFragmentDoc}`;

/**
 * __usePodQuery__
 *
 * To run a query within a React component, call `usePodQuery` and pass it any options that fit your needs.
 * When your component renders, `usePodQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePodQuery({
 *   variables: {
 *      name: // value for 'name'
 *      namespace: // value for 'namespace'
 *      clusterId: // value for 'clusterId'
 *      serviceId: // value for 'serviceId'
 *   },
 * });
 */
export function usePodQuery(baseOptions: Apollo.QueryHookOptions<PodQuery, PodQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PodQuery, PodQueryVariables>(PodDocument, options);
      }
export function usePodLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PodQuery, PodQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PodQuery, PodQueryVariables>(PodDocument, options);
        }
export function usePodSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<PodQuery, PodQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PodQuery, PodQueryVariables>(PodDocument, options);
        }
export type PodQueryHookResult = ReturnType<typeof usePodQuery>;
export type PodLazyQueryHookResult = ReturnType<typeof usePodLazyQuery>;
export type PodSuspenseQueryHookResult = ReturnType<typeof usePodSuspenseQuery>;
export type PodQueryResult = Apollo.QueryResult<PodQuery, PodQueryVariables>;
export const PodLogsDocument = gql`
    query PodLogs($name: String!, $namespace: String!, $clusterId: ID, $serviceId: ID, $container: String!, $sinceSeconds: Int!) {
  pod(
    name: $name
    namespace: $namespace
    clusterId: $clusterId
    serviceId: $serviceId
  ) {
    logs(container: $container, sinceSeconds: $sinceSeconds)
  }
}
    `;

/**
 * __usePodLogsQuery__
 *
 * To run a query within a React component, call `usePodLogsQuery` and pass it any options that fit your needs.
 * When your component renders, `usePodLogsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePodLogsQuery({
 *   variables: {
 *      name: // value for 'name'
 *      namespace: // value for 'namespace'
 *      clusterId: // value for 'clusterId'
 *      serviceId: // value for 'serviceId'
 *      container: // value for 'container'
 *      sinceSeconds: // value for 'sinceSeconds'
 *   },
 * });
 */
export function usePodLogsQuery(baseOptions: Apollo.QueryHookOptions<PodLogsQuery, PodLogsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PodLogsQuery, PodLogsQueryVariables>(PodLogsDocument, options);
      }
export function usePodLogsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PodLogsQuery, PodLogsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PodLogsQuery, PodLogsQueryVariables>(PodLogsDocument, options);
        }
export function usePodLogsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<PodLogsQuery, PodLogsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PodLogsQuery, PodLogsQueryVariables>(PodLogsDocument, options);
        }
export type PodLogsQueryHookResult = ReturnType<typeof usePodLogsQuery>;
export type PodLogsLazyQueryHookResult = ReturnType<typeof usePodLogsLazyQuery>;
export type PodLogsSuspenseQueryHookResult = ReturnType<typeof usePodLogsSuspenseQuery>;
export type PodLogsQueryResult = Apollo.QueryResult<PodLogsQuery, PodLogsQueryVariables>;
export const DeletePodDocument = gql`
    mutation DeletePod($name: String!, $namespace: String!, $serviceId: ID) {
  deletePod(name: $name, namespace: $namespace, serviceId: $serviceId) {
    ...Pod
  }
}
    ${PodFragmentDoc}`;
export type DeletePodMutationFn = Apollo.MutationFunction<DeletePodMutation, DeletePodMutationVariables>;

/**
 * __useDeletePodMutation__
 *
 * To run a mutation, you first call `useDeletePodMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeletePodMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deletePodMutation, { data, loading, error }] = useDeletePodMutation({
 *   variables: {
 *      name: // value for 'name'
 *      namespace: // value for 'namespace'
 *      serviceId: // value for 'serviceId'
 *   },
 * });
 */
export function useDeletePodMutation(baseOptions?: Apollo.MutationHookOptions<DeletePodMutation, DeletePodMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeletePodMutation, DeletePodMutationVariables>(DeletePodDocument, options);
      }
export type DeletePodMutationHookResult = ReturnType<typeof useDeletePodMutation>;
export type DeletePodMutationResult = Apollo.MutationResult<DeletePodMutation>;
export type DeletePodMutationOptions = Apollo.BaseMutationOptions<DeletePodMutation, DeletePodMutationVariables>;
export const ServiceDocument = gql`
    query Service($name: String!, $namespace: String!, $serviceId: ID) {
  service(name: $name, namespace: $namespace, serviceId: $serviceId) {
    ...Service
  }
}
    ${ServiceFragmentDoc}`;

/**
 * __useServiceQuery__
 *
 * To run a query within a React component, call `useServiceQuery` and pass it any options that fit your needs.
 * When your component renders, `useServiceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useServiceQuery({
 *   variables: {
 *      name: // value for 'name'
 *      namespace: // value for 'namespace'
 *      serviceId: // value for 'serviceId'
 *   },
 * });
 */
export function useServiceQuery(baseOptions: Apollo.QueryHookOptions<ServiceQuery, ServiceQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ServiceQuery, ServiceQueryVariables>(ServiceDocument, options);
      }
export function useServiceLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ServiceQuery, ServiceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ServiceQuery, ServiceQueryVariables>(ServiceDocument, options);
        }
export function useServiceSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ServiceQuery, ServiceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ServiceQuery, ServiceQueryVariables>(ServiceDocument, options);
        }
export type ServiceQueryHookResult = ReturnType<typeof useServiceQuery>;
export type ServiceLazyQueryHookResult = ReturnType<typeof useServiceLazyQuery>;
export type ServiceSuspenseQueryHookResult = ReturnType<typeof useServiceSuspenseQuery>;
export type ServiceQueryResult = Apollo.QueryResult<ServiceQuery, ServiceQueryVariables>;
export const StatefulSetDocument = gql`
    query StatefulSet($name: String!, $namespace: String!, $serviceId: ID) {
  statefulSet(name: $name, namespace: $namespace, serviceId: $serviceId) {
    ...StatefulSet
  }
}
    ${StatefulSetFragmentDoc}`;

/**
 * __useStatefulSetQuery__
 *
 * To run a query within a React component, call `useStatefulSetQuery` and pass it any options that fit your needs.
 * When your component renders, `useStatefulSetQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStatefulSetQuery({
 *   variables: {
 *      name: // value for 'name'
 *      namespace: // value for 'namespace'
 *      serviceId: // value for 'serviceId'
 *   },
 * });
 */
export function useStatefulSetQuery(baseOptions: Apollo.QueryHookOptions<StatefulSetQuery, StatefulSetQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StatefulSetQuery, StatefulSetQueryVariables>(StatefulSetDocument, options);
      }
export function useStatefulSetLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StatefulSetQuery, StatefulSetQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StatefulSetQuery, StatefulSetQueryVariables>(StatefulSetDocument, options);
        }
export function useStatefulSetSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<StatefulSetQuery, StatefulSetQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<StatefulSetQuery, StatefulSetQueryVariables>(StatefulSetDocument, options);
        }
export type StatefulSetQueryHookResult = ReturnType<typeof useStatefulSetQuery>;
export type StatefulSetLazyQueryHookResult = ReturnType<typeof useStatefulSetLazyQuery>;
export type StatefulSetSuspenseQueryHookResult = ReturnType<typeof useStatefulSetSuspenseQuery>;
export type StatefulSetQueryResult = Apollo.QueryResult<StatefulSetQuery, StatefulSetQueryVariables>;
export const UnstructuredResourceDocument = gql`
    query UnstructuredResource($group: String, $kind: String!, $name: String!, $namespace: String, $serviceId: ID!, $version: String!) {
  unstructuredResource(
    group: $group
    kind: $kind
    name: $name
    namespace: $namespace
    serviceId: $serviceId
    version: $version
  ) {
    ...UnstructuredResource
  }
}
    ${UnstructuredResourceFragmentDoc}`;

/**
 * __useUnstructuredResourceQuery__
 *
 * To run a query within a React component, call `useUnstructuredResourceQuery` and pass it any options that fit your needs.
 * When your component renders, `useUnstructuredResourceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUnstructuredResourceQuery({
 *   variables: {
 *      group: // value for 'group'
 *      kind: // value for 'kind'
 *      name: // value for 'name'
 *      namespace: // value for 'namespace'
 *      serviceId: // value for 'serviceId'
 *      version: // value for 'version'
 *   },
 * });
 */
export function useUnstructuredResourceQuery(baseOptions: Apollo.QueryHookOptions<UnstructuredResourceQuery, UnstructuredResourceQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UnstructuredResourceQuery, UnstructuredResourceQueryVariables>(UnstructuredResourceDocument, options);
      }
export function useUnstructuredResourceLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UnstructuredResourceQuery, UnstructuredResourceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UnstructuredResourceQuery, UnstructuredResourceQueryVariables>(UnstructuredResourceDocument, options);
        }
export function useUnstructuredResourceSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<UnstructuredResourceQuery, UnstructuredResourceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<UnstructuredResourceQuery, UnstructuredResourceQueryVariables>(UnstructuredResourceDocument, options);
        }
export type UnstructuredResourceQueryHookResult = ReturnType<typeof useUnstructuredResourceQuery>;
export type UnstructuredResourceLazyQueryHookResult = ReturnType<typeof useUnstructuredResourceLazyQuery>;
export type UnstructuredResourceSuspenseQueryHookResult = ReturnType<typeof useUnstructuredResourceSuspenseQuery>;
export type UnstructuredResourceQueryResult = Apollo.QueryResult<UnstructuredResourceQuery, UnstructuredResourceQueryVariables>;
export const SubscriptionDocument = gql`
    query Subscription {
  account {
    ...Account
  }
}
    ${AccountFragmentDoc}`;

/**
 * __useSubscriptionQuery__
 *
 * To run a query within a React component, call `useSubscriptionQuery` and pass it any options that fit your needs.
 * When your component renders, `useSubscriptionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSubscriptionQuery({
 *   variables: {
 *   },
 * });
 */
export function useSubscriptionQuery(baseOptions?: Apollo.QueryHookOptions<SubscriptionQuery, SubscriptionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SubscriptionQuery, SubscriptionQueryVariables>(SubscriptionDocument, options);
      }
export function useSubscriptionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SubscriptionQuery, SubscriptionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SubscriptionQuery, SubscriptionQueryVariables>(SubscriptionDocument, options);
        }
export function useSubscriptionSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<SubscriptionQuery, SubscriptionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SubscriptionQuery, SubscriptionQueryVariables>(SubscriptionDocument, options);
        }
export type SubscriptionQueryHookResult = ReturnType<typeof useSubscriptionQuery>;
export type SubscriptionLazyQueryHookResult = ReturnType<typeof useSubscriptionLazyQuery>;
export type SubscriptionSuspenseQueryHookResult = ReturnType<typeof useSubscriptionSuspenseQuery>;
export type SubscriptionQueryResult = Apollo.QueryResult<SubscriptionQuery, SubscriptionQueryVariables>;
export const MeGroupsDocument = gql`
    query MeGroups {
  me {
    id
    groups {
      ...Group
    }
  }
}
    ${GroupFragmentDoc}`;

/**
 * __useMeGroupsQuery__
 *
 * To run a query within a React component, call `useMeGroupsQuery` and pass it any options that fit your needs.
 * When your component renders, `useMeGroupsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMeGroupsQuery({
 *   variables: {
 *   },
 * });
 */
export function useMeGroupsQuery(baseOptions?: Apollo.QueryHookOptions<MeGroupsQuery, MeGroupsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MeGroupsQuery, MeGroupsQueryVariables>(MeGroupsDocument, options);
      }
export function useMeGroupsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MeGroupsQuery, MeGroupsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MeGroupsQuery, MeGroupsQueryVariables>(MeGroupsDocument, options);
        }
export function useMeGroupsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<MeGroupsQuery, MeGroupsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<MeGroupsQuery, MeGroupsQueryVariables>(MeGroupsDocument, options);
        }
export type MeGroupsQueryHookResult = ReturnType<typeof useMeGroupsQuery>;
export type MeGroupsLazyQueryHookResult = ReturnType<typeof useMeGroupsLazyQuery>;
export type MeGroupsSuspenseQueryHookResult = ReturnType<typeof useMeGroupsSuspenseQuery>;
export type MeGroupsQueryResult = Apollo.QueryResult<MeGroupsQuery, MeGroupsQueryVariables>;
export const MeDocument = gql`
    query Me {
  me {
    ...User
    boundRoles {
      ...Role
    }
    unreadNotifications
  }
  clusterInfo {
    version
    platform
    gitCommit
  }
  configuration {
    gitCommit
    isDemoProject
    isSandbox
    pluralLogin
    byok
    externalOidc
    cloud
    installed
    consoleVersion
    sentryEnabled
    manifest {
      ...Manifest
    }
    gitStatus {
      cloned
      output
    }
    features {
      ...AvailableFeatures
    }
  }
}
    ${UserFragmentDoc}
${RoleFragmentDoc}
${ManifestFragmentDoc}
${AvailableFeaturesFragmentDoc}`;

/**
 * __useMeQuery__
 *
 * To run a query within a React component, call `useMeQuery` and pass it any options that fit your needs.
 * When your component renders, `useMeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMeQuery({
 *   variables: {
 *   },
 * });
 */
export function useMeQuery(baseOptions?: Apollo.QueryHookOptions<MeQuery, MeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MeQuery, MeQueryVariables>(MeDocument, options);
      }
export function useMeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MeQuery, MeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MeQuery, MeQueryVariables>(MeDocument, options);
        }
export function useMeSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<MeQuery, MeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<MeQuery, MeQueryVariables>(MeDocument, options);
        }
export type MeQueryHookResult = ReturnType<typeof useMeQuery>;
export type MeLazyQueryHookResult = ReturnType<typeof useMeLazyQuery>;
export type MeSuspenseQueryHookResult = ReturnType<typeof useMeSuspenseQuery>;
export type MeQueryResult = Apollo.QueryResult<MeQuery, MeQueryVariables>;
export const LoginInfoDocument = gql`
    query LoginInfo($redirect: String) {
  loginInfo(redirect: $redirect) {
    oidcUri
    external
    oidcName
  }
}
    `;

/**
 * __useLoginInfoQuery__
 *
 * To run a query within a React component, call `useLoginInfoQuery` and pass it any options that fit your needs.
 * When your component renders, `useLoginInfoQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLoginInfoQuery({
 *   variables: {
 *      redirect: // value for 'redirect'
 *   },
 * });
 */
export function useLoginInfoQuery(baseOptions?: Apollo.QueryHookOptions<LoginInfoQuery, LoginInfoQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LoginInfoQuery, LoginInfoQueryVariables>(LoginInfoDocument, options);
      }
export function useLoginInfoLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LoginInfoQuery, LoginInfoQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LoginInfoQuery, LoginInfoQueryVariables>(LoginInfoDocument, options);
        }
export function useLoginInfoSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<LoginInfoQuery, LoginInfoQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<LoginInfoQuery, LoginInfoQueryVariables>(LoginInfoDocument, options);
        }
export type LoginInfoQueryHookResult = ReturnType<typeof useLoginInfoQuery>;
export type LoginInfoLazyQueryHookResult = ReturnType<typeof useLoginInfoLazyQuery>;
export type LoginInfoSuspenseQueryHookResult = ReturnType<typeof useLoginInfoSuspenseQuery>;
export type LoginInfoQueryResult = Apollo.QueryResult<LoginInfoQuery, LoginInfoQueryVariables>;
export const InviteDocument = gql`
    query Invite($id: String!) {
  invite(id: $id) {
    email
  }
}
    `;

/**
 * __useInviteQuery__
 *
 * To run a query within a React component, call `useInviteQuery` and pass it any options that fit your needs.
 * When your component renders, `useInviteQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useInviteQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useInviteQuery(baseOptions: Apollo.QueryHookOptions<InviteQuery, InviteQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<InviteQuery, InviteQueryVariables>(InviteDocument, options);
      }
export function useInviteLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<InviteQuery, InviteQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<InviteQuery, InviteQueryVariables>(InviteDocument, options);
        }
export function useInviteSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<InviteQuery, InviteQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<InviteQuery, InviteQueryVariables>(InviteDocument, options);
        }
export type InviteQueryHookResult = ReturnType<typeof useInviteQuery>;
export type InviteLazyQueryHookResult = ReturnType<typeof useInviteLazyQuery>;
export type InviteSuspenseQueryHookResult = ReturnType<typeof useInviteSuspenseQuery>;
export type InviteQueryResult = Apollo.QueryResult<InviteQuery, InviteQueryVariables>;
export const RefreshDocument = gql`
    query Refresh($token: String!) {
  refresh(token: $token) {
    ...User
    jwt
  }
}
    ${UserFragmentDoc}`;

/**
 * __useRefreshQuery__
 *
 * To run a query within a React component, call `useRefreshQuery` and pass it any options that fit your needs.
 * When your component renders, `useRefreshQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRefreshQuery({
 *   variables: {
 *      token: // value for 'token'
 *   },
 * });
 */
export function useRefreshQuery(baseOptions: Apollo.QueryHookOptions<RefreshQuery, RefreshQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RefreshQuery, RefreshQueryVariables>(RefreshDocument, options);
      }
export function useRefreshLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RefreshQuery, RefreshQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RefreshQuery, RefreshQueryVariables>(RefreshDocument, options);
        }
export function useRefreshSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<RefreshQuery, RefreshQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<RefreshQuery, RefreshQueryVariables>(RefreshDocument, options);
        }
export type RefreshQueryHookResult = ReturnType<typeof useRefreshQuery>;
export type RefreshLazyQueryHookResult = ReturnType<typeof useRefreshLazyQuery>;
export type RefreshSuspenseQueryHookResult = ReturnType<typeof useRefreshSuspenseQuery>;
export type RefreshQueryResult = Apollo.QueryResult<RefreshQuery, RefreshQueryVariables>;
export const TemporaryTokenDocument = gql`
    query TemporaryToken {
  temporaryToken
}
    `;

/**
 * __useTemporaryTokenQuery__
 *
 * To run a query within a React component, call `useTemporaryTokenQuery` and pass it any options that fit your needs.
 * When your component renders, `useTemporaryTokenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTemporaryTokenQuery({
 *   variables: {
 *   },
 * });
 */
export function useTemporaryTokenQuery(baseOptions?: Apollo.QueryHookOptions<TemporaryTokenQuery, TemporaryTokenQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TemporaryTokenQuery, TemporaryTokenQueryVariables>(TemporaryTokenDocument, options);
      }
export function useTemporaryTokenLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TemporaryTokenQuery, TemporaryTokenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TemporaryTokenQuery, TemporaryTokenQueryVariables>(TemporaryTokenDocument, options);
        }
export function useTemporaryTokenSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<TemporaryTokenQuery, TemporaryTokenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<TemporaryTokenQuery, TemporaryTokenQueryVariables>(TemporaryTokenDocument, options);
        }
export type TemporaryTokenQueryHookResult = ReturnType<typeof useTemporaryTokenQuery>;
export type TemporaryTokenLazyQueryHookResult = ReturnType<typeof useTemporaryTokenLazyQuery>;
export type TemporaryTokenSuspenseQueryHookResult = ReturnType<typeof useTemporaryTokenSuspenseQuery>;
export type TemporaryTokenQueryResult = Apollo.QueryResult<TemporaryTokenQuery, TemporaryTokenQueryVariables>;
export const SignInDocument = gql`
    mutation signIn($email: String!, $password: String!) {
  signIn(email: $email, password: $password) {
    ...User
    jwt
    refreshToken {
      ...RefreshToken
    }
  }
}
    ${UserFragmentDoc}
${RefreshTokenFragmentDoc}`;
export type SignInMutationFn = Apollo.MutationFunction<SignInMutation, SignInMutationVariables>;

/**
 * __useSignInMutation__
 *
 * To run a mutation, you first call `useSignInMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSignInMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [signInMutation, { data, loading, error }] = useSignInMutation({
 *   variables: {
 *      email: // value for 'email'
 *      password: // value for 'password'
 *   },
 * });
 */
export function useSignInMutation(baseOptions?: Apollo.MutationHookOptions<SignInMutation, SignInMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SignInMutation, SignInMutationVariables>(SignInDocument, options);
      }
export type SignInMutationHookResult = ReturnType<typeof useSignInMutation>;
export type SignInMutationResult = Apollo.MutationResult<SignInMutation>;
export type SignInMutationOptions = Apollo.BaseMutationOptions<SignInMutation, SignInMutationVariables>;
export const OauthCallbackDocument = gql`
    mutation OauthCallback($code: String!, $redirect: String, $state: String) {
  oauthCallback(code: $code, redirect: $redirect, state: $state) {
    jwt
    refreshToken {
      ...RefreshToken
    }
  }
}
    ${RefreshTokenFragmentDoc}`;
export type OauthCallbackMutationFn = Apollo.MutationFunction<OauthCallbackMutation, OauthCallbackMutationVariables>;

/**
 * __useOauthCallbackMutation__
 *
 * To run a mutation, you first call `useOauthCallbackMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useOauthCallbackMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [oauthCallbackMutation, { data, loading, error }] = useOauthCallbackMutation({
 *   variables: {
 *      code: // value for 'code'
 *      redirect: // value for 'redirect'
 *      state: // value for 'state'
 *   },
 * });
 */
export function useOauthCallbackMutation(baseOptions?: Apollo.MutationHookOptions<OauthCallbackMutation, OauthCallbackMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<OauthCallbackMutation, OauthCallbackMutationVariables>(OauthCallbackDocument, options);
      }
export type OauthCallbackMutationHookResult = ReturnType<typeof useOauthCallbackMutation>;
export type OauthCallbackMutationResult = Apollo.MutationResult<OauthCallbackMutation>;
export type OauthCallbackMutationOptions = Apollo.BaseMutationOptions<OauthCallbackMutation, OauthCallbackMutationVariables>;
export const LogoutDocument = gql`
    mutation Logout {
  logout {
    ...User
  }
}
    ${UserFragmentDoc}`;
export type LogoutMutationFn = Apollo.MutationFunction<LogoutMutation, LogoutMutationVariables>;

/**
 * __useLogoutMutation__
 *
 * To run a mutation, you first call `useLogoutMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLogoutMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [logoutMutation, { data, loading, error }] = useLogoutMutation({
 *   variables: {
 *   },
 * });
 */
export function useLogoutMutation(baseOptions?: Apollo.MutationHookOptions<LogoutMutation, LogoutMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<LogoutMutation, LogoutMutationVariables>(LogoutDocument, options);
      }
export type LogoutMutationHookResult = ReturnType<typeof useLogoutMutation>;
export type LogoutMutationResult = Apollo.MutationResult<LogoutMutation>;
export type LogoutMutationOptions = Apollo.BaseMutationOptions<LogoutMutation, LogoutMutationVariables>;
export const SignUpDocument = gql`
    mutation SignUp($inviteId: String!, $attributes: UserAttributes!) {
  signup(inviteId: $inviteId, attributes: $attributes) {
    ...User
    jwt
    refreshToken {
      ...RefreshToken
    }
  }
}
    ${UserFragmentDoc}
${RefreshTokenFragmentDoc}`;
export type SignUpMutationFn = Apollo.MutationFunction<SignUpMutation, SignUpMutationVariables>;

/**
 * __useSignUpMutation__
 *
 * To run a mutation, you first call `useSignUpMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSignUpMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [signUpMutation, { data, loading, error }] = useSignUpMutation({
 *   variables: {
 *      inviteId: // value for 'inviteId'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useSignUpMutation(baseOptions?: Apollo.MutationHookOptions<SignUpMutation, SignUpMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SignUpMutation, SignUpMutationVariables>(SignUpDocument, options);
      }
export type SignUpMutationHookResult = ReturnType<typeof useSignUpMutation>;
export type SignUpMutationResult = Apollo.MutationResult<SignUpMutation>;
export type SignUpMutationOptions = Apollo.BaseMutationOptions<SignUpMutation, SignUpMutationVariables>;
export const LoginLinkDocument = gql`
    mutation LoginLink($key: String!) {
  loginLink(key: $key) {
    ...User
    jwt
    refreshToken {
      ...RefreshToken
    }
  }
}
    ${UserFragmentDoc}
${RefreshTokenFragmentDoc}`;
export type LoginLinkMutationFn = Apollo.MutationFunction<LoginLinkMutation, LoginLinkMutationVariables>;

/**
 * __useLoginLinkMutation__
 *
 * To run a mutation, you first call `useLoginLinkMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLoginLinkMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [loginLinkMutation, { data, loading, error }] = useLoginLinkMutation({
 *   variables: {
 *      key: // value for 'key'
 *   },
 * });
 */
export function useLoginLinkMutation(baseOptions?: Apollo.MutationHookOptions<LoginLinkMutation, LoginLinkMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<LoginLinkMutation, LoginLinkMutationVariables>(LoginLinkDocument, options);
      }
export type LoginLinkMutationHookResult = ReturnType<typeof useLoginLinkMutation>;
export type LoginLinkMutationResult = Apollo.MutationResult<LoginLinkMutation>;
export type LoginLinkMutationOptions = Apollo.BaseMutationOptions<LoginLinkMutation, LoginLinkMutationVariables>;
export const LogAggregationDocument = gql`
    query LogAggregation($clusterId: ID, $limit: Int, $query: String, $serviceId: ID, $time: LogTimeRange, $facets: [LogFacetInput]) {
  logAggregation(
    clusterId: $clusterId
    limit: $limit
    query: $query
    serviceId: $serviceId
    time: $time
    facets: $facets
  ) {
    ...LogLine
  }
}
    ${LogLineFragmentDoc}`;

/**
 * __useLogAggregationQuery__
 *
 * To run a query within a React component, call `useLogAggregationQuery` and pass it any options that fit your needs.
 * When your component renders, `useLogAggregationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLogAggregationQuery({
 *   variables: {
 *      clusterId: // value for 'clusterId'
 *      limit: // value for 'limit'
 *      query: // value for 'query'
 *      serviceId: // value for 'serviceId'
 *      time: // value for 'time'
 *      facets: // value for 'facets'
 *   },
 * });
 */
export function useLogAggregationQuery(baseOptions?: Apollo.QueryHookOptions<LogAggregationQuery, LogAggregationQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LogAggregationQuery, LogAggregationQueryVariables>(LogAggregationDocument, options);
      }
export function useLogAggregationLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LogAggregationQuery, LogAggregationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LogAggregationQuery, LogAggregationQueryVariables>(LogAggregationDocument, options);
        }
export function useLogAggregationSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<LogAggregationQuery, LogAggregationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<LogAggregationQuery, LogAggregationQueryVariables>(LogAggregationDocument, options);
        }
export type LogAggregationQueryHookResult = ReturnType<typeof useLogAggregationQuery>;
export type LogAggregationLazyQueryHookResult = ReturnType<typeof useLogAggregationLazyQuery>;
export type LogAggregationSuspenseQueryHookResult = ReturnType<typeof useLogAggregationSuspenseQuery>;
export type LogAggregationQueryResult = Apollo.QueryResult<LogAggregationQuery, LogAggregationQueryVariables>;
export const ClusterHeatMapDocument = gql`
    query ClusterHeatMap($clusterId: ID!, $flavor: HeatMapFlavor!) {
  cluster(id: $clusterId) {
    id
    heatMap(flavor: $flavor) {
      ...UtilizationHeatMap
    }
  }
}
    ${UtilizationHeatMapFragmentDoc}`;

/**
 * __useClusterHeatMapQuery__
 *
 * To run a query within a React component, call `useClusterHeatMapQuery` and pass it any options that fit your needs.
 * When your component renders, `useClusterHeatMapQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClusterHeatMapQuery({
 *   variables: {
 *      clusterId: // value for 'clusterId'
 *      flavor: // value for 'flavor'
 *   },
 * });
 */
export function useClusterHeatMapQuery(baseOptions: Apollo.QueryHookOptions<ClusterHeatMapQuery, ClusterHeatMapQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClusterHeatMapQuery, ClusterHeatMapQueryVariables>(ClusterHeatMapDocument, options);
      }
export function useClusterHeatMapLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClusterHeatMapQuery, ClusterHeatMapQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClusterHeatMapQuery, ClusterHeatMapQueryVariables>(ClusterHeatMapDocument, options);
        }
export function useClusterHeatMapSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClusterHeatMapQuery, ClusterHeatMapQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClusterHeatMapQuery, ClusterHeatMapQueryVariables>(ClusterHeatMapDocument, options);
        }
export type ClusterHeatMapQueryHookResult = ReturnType<typeof useClusterHeatMapQuery>;
export type ClusterHeatMapLazyQueryHookResult = ReturnType<typeof useClusterHeatMapLazyQuery>;
export type ClusterHeatMapSuspenseQueryHookResult = ReturnType<typeof useClusterHeatMapSuspenseQuery>;
export type ClusterHeatMapQueryResult = Apollo.QueryResult<ClusterHeatMapQuery, ClusterHeatMapQueryVariables>;
export const ClusterNoisyNeighborsDocument = gql`
    query ClusterNoisyNeighbors($clusterId: ID!) {
  cluster(id: $clusterId) {
    id
    noisyNeighbors {
      ...UtilizationHeatMap
    }
  }
}
    ${UtilizationHeatMapFragmentDoc}`;

/**
 * __useClusterNoisyNeighborsQuery__
 *
 * To run a query within a React component, call `useClusterNoisyNeighborsQuery` and pass it any options that fit your needs.
 * When your component renders, `useClusterNoisyNeighborsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClusterNoisyNeighborsQuery({
 *   variables: {
 *      clusterId: // value for 'clusterId'
 *   },
 * });
 */
export function useClusterNoisyNeighborsQuery(baseOptions: Apollo.QueryHookOptions<ClusterNoisyNeighborsQuery, ClusterNoisyNeighborsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClusterNoisyNeighborsQuery, ClusterNoisyNeighborsQueryVariables>(ClusterNoisyNeighborsDocument, options);
      }
export function useClusterNoisyNeighborsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClusterNoisyNeighborsQuery, ClusterNoisyNeighborsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClusterNoisyNeighborsQuery, ClusterNoisyNeighborsQueryVariables>(ClusterNoisyNeighborsDocument, options);
        }
export function useClusterNoisyNeighborsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClusterNoisyNeighborsQuery, ClusterNoisyNeighborsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClusterNoisyNeighborsQuery, ClusterNoisyNeighborsQueryVariables>(ClusterNoisyNeighborsDocument, options);
        }
export type ClusterNoisyNeighborsQueryHookResult = ReturnType<typeof useClusterNoisyNeighborsQuery>;
export type ClusterNoisyNeighborsLazyQueryHookResult = ReturnType<typeof useClusterNoisyNeighborsLazyQuery>;
export type ClusterNoisyNeighborsSuspenseQueryHookResult = ReturnType<typeof useClusterNoisyNeighborsSuspenseQuery>;
export type ClusterNoisyNeighborsQueryResult = Apollo.QueryResult<ClusterNoisyNeighborsQuery, ClusterNoisyNeighborsQueryVariables>;
export const ServiceHeatMapDocument = gql`
    query ServiceHeatMap($serviceId: ID!, $flavor: HeatMapFlavor!) {
  serviceDeployment(id: $serviceId) {
    id
    heatMap(flavor: $flavor) {
      ...UtilizationHeatMap
    }
  }
}
    ${UtilizationHeatMapFragmentDoc}`;

/**
 * __useServiceHeatMapQuery__
 *
 * To run a query within a React component, call `useServiceHeatMapQuery` and pass it any options that fit your needs.
 * When your component renders, `useServiceHeatMapQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useServiceHeatMapQuery({
 *   variables: {
 *      serviceId: // value for 'serviceId'
 *      flavor: // value for 'flavor'
 *   },
 * });
 */
export function useServiceHeatMapQuery(baseOptions: Apollo.QueryHookOptions<ServiceHeatMapQuery, ServiceHeatMapQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ServiceHeatMapQuery, ServiceHeatMapQueryVariables>(ServiceHeatMapDocument, options);
      }
export function useServiceHeatMapLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ServiceHeatMapQuery, ServiceHeatMapQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ServiceHeatMapQuery, ServiceHeatMapQueryVariables>(ServiceHeatMapDocument, options);
        }
export function useServiceHeatMapSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ServiceHeatMapQuery, ServiceHeatMapQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ServiceHeatMapQuery, ServiceHeatMapQueryVariables>(ServiceHeatMapDocument, options);
        }
export type ServiceHeatMapQueryHookResult = ReturnType<typeof useServiceHeatMapQuery>;
export type ServiceHeatMapLazyQueryHookResult = ReturnType<typeof useServiceHeatMapLazyQuery>;
export type ServiceHeatMapSuspenseQueryHookResult = ReturnType<typeof useServiceHeatMapSuspenseQuery>;
export type ServiceHeatMapQueryResult = Apollo.QueryResult<ServiceHeatMapQuery, ServiceHeatMapQueryVariables>;
export const UpsertNotificationRouterDocument = gql`
    mutation UpsertNotificationRouter($attributes: NotificationRouterAttributes!) {
  upsertNotificationRouter(attributes: $attributes) {
    ...NotificationRouter
  }
}
    ${NotificationRouterFragmentDoc}`;
export type UpsertNotificationRouterMutationFn = Apollo.MutationFunction<UpsertNotificationRouterMutation, UpsertNotificationRouterMutationVariables>;

/**
 * __useUpsertNotificationRouterMutation__
 *
 * To run a mutation, you first call `useUpsertNotificationRouterMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpsertNotificationRouterMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upsertNotificationRouterMutation, { data, loading, error }] = useUpsertNotificationRouterMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpsertNotificationRouterMutation(baseOptions?: Apollo.MutationHookOptions<UpsertNotificationRouterMutation, UpsertNotificationRouterMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpsertNotificationRouterMutation, UpsertNotificationRouterMutationVariables>(UpsertNotificationRouterDocument, options);
      }
export type UpsertNotificationRouterMutationHookResult = ReturnType<typeof useUpsertNotificationRouterMutation>;
export type UpsertNotificationRouterMutationResult = Apollo.MutationResult<UpsertNotificationRouterMutation>;
export type UpsertNotificationRouterMutationOptions = Apollo.BaseMutationOptions<UpsertNotificationRouterMutation, UpsertNotificationRouterMutationVariables>;
export const NotificationRoutersDocument = gql`
    query NotificationRouters($first: Int = 100, $after: String) {
  notificationRouters(first: $first, after: $after) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...NotificationRouter
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${NotificationRouterFragmentDoc}`;

/**
 * __useNotificationRoutersQuery__
 *
 * To run a query within a React component, call `useNotificationRoutersQuery` and pass it any options that fit your needs.
 * When your component renders, `useNotificationRoutersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNotificationRoutersQuery({
 *   variables: {
 *      first: // value for 'first'
 *      after: // value for 'after'
 *   },
 * });
 */
export function useNotificationRoutersQuery(baseOptions?: Apollo.QueryHookOptions<NotificationRoutersQuery, NotificationRoutersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<NotificationRoutersQuery, NotificationRoutersQueryVariables>(NotificationRoutersDocument, options);
      }
export function useNotificationRoutersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<NotificationRoutersQuery, NotificationRoutersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<NotificationRoutersQuery, NotificationRoutersQueryVariables>(NotificationRoutersDocument, options);
        }
export function useNotificationRoutersSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<NotificationRoutersQuery, NotificationRoutersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<NotificationRoutersQuery, NotificationRoutersQueryVariables>(NotificationRoutersDocument, options);
        }
export type NotificationRoutersQueryHookResult = ReturnType<typeof useNotificationRoutersQuery>;
export type NotificationRoutersLazyQueryHookResult = ReturnType<typeof useNotificationRoutersLazyQuery>;
export type NotificationRoutersSuspenseQueryHookResult = ReturnType<typeof useNotificationRoutersSuspenseQuery>;
export type NotificationRoutersQueryResult = Apollo.QueryResult<NotificationRoutersQuery, NotificationRoutersQueryVariables>;
export const DeleteNotificationRouterDocument = gql`
    mutation DeleteNotificationRouter($id: ID!) {
  deleteNotificationRouter(id: $id) {
    ...NotificationRouter
  }
}
    ${NotificationRouterFragmentDoc}`;
export type DeleteNotificationRouterMutationFn = Apollo.MutationFunction<DeleteNotificationRouterMutation, DeleteNotificationRouterMutationVariables>;

/**
 * __useDeleteNotificationRouterMutation__
 *
 * To run a mutation, you first call `useDeleteNotificationRouterMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteNotificationRouterMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteNotificationRouterMutation, { data, loading, error }] = useDeleteNotificationRouterMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteNotificationRouterMutation(baseOptions?: Apollo.MutationHookOptions<DeleteNotificationRouterMutation, DeleteNotificationRouterMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteNotificationRouterMutation, DeleteNotificationRouterMutationVariables>(DeleteNotificationRouterDocument, options);
      }
export type DeleteNotificationRouterMutationHookResult = ReturnType<typeof useDeleteNotificationRouterMutation>;
export type DeleteNotificationRouterMutationResult = Apollo.MutationResult<DeleteNotificationRouterMutation>;
export type DeleteNotificationRouterMutationOptions = Apollo.BaseMutationOptions<DeleteNotificationRouterMutation, DeleteNotificationRouterMutationVariables>;
export const UpsertNotificationSinkDocument = gql`
    mutation UpsertNotificationSink($attributes: NotificationSinkAttributes!) {
  upsertNotificationSink(attributes: $attributes) {
    ...NotificationSink
  }
}
    ${NotificationSinkFragmentDoc}`;
export type UpsertNotificationSinkMutationFn = Apollo.MutationFunction<UpsertNotificationSinkMutation, UpsertNotificationSinkMutationVariables>;

/**
 * __useUpsertNotificationSinkMutation__
 *
 * To run a mutation, you first call `useUpsertNotificationSinkMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpsertNotificationSinkMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upsertNotificationSinkMutation, { data, loading, error }] = useUpsertNotificationSinkMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpsertNotificationSinkMutation(baseOptions?: Apollo.MutationHookOptions<UpsertNotificationSinkMutation, UpsertNotificationSinkMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpsertNotificationSinkMutation, UpsertNotificationSinkMutationVariables>(UpsertNotificationSinkDocument, options);
      }
export type UpsertNotificationSinkMutationHookResult = ReturnType<typeof useUpsertNotificationSinkMutation>;
export type UpsertNotificationSinkMutationResult = Apollo.MutationResult<UpsertNotificationSinkMutation>;
export type UpsertNotificationSinkMutationOptions = Apollo.BaseMutationOptions<UpsertNotificationSinkMutation, UpsertNotificationSinkMutationVariables>;
export const DeleteNotificationSinkDocument = gql`
    mutation DeleteNotificationSink($id: ID!) {
  deleteNotificationSink(id: $id) {
    ...NotificationSink
  }
}
    ${NotificationSinkFragmentDoc}`;
export type DeleteNotificationSinkMutationFn = Apollo.MutationFunction<DeleteNotificationSinkMutation, DeleteNotificationSinkMutationVariables>;

/**
 * __useDeleteNotificationSinkMutation__
 *
 * To run a mutation, you first call `useDeleteNotificationSinkMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteNotificationSinkMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteNotificationSinkMutation, { data, loading, error }] = useDeleteNotificationSinkMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteNotificationSinkMutation(baseOptions?: Apollo.MutationHookOptions<DeleteNotificationSinkMutation, DeleteNotificationSinkMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteNotificationSinkMutation, DeleteNotificationSinkMutationVariables>(DeleteNotificationSinkDocument, options);
      }
export type DeleteNotificationSinkMutationHookResult = ReturnType<typeof useDeleteNotificationSinkMutation>;
export type DeleteNotificationSinkMutationResult = Apollo.MutationResult<DeleteNotificationSinkMutation>;
export type DeleteNotificationSinkMutationOptions = Apollo.BaseMutationOptions<DeleteNotificationSinkMutation, DeleteNotificationSinkMutationVariables>;
export const NotificationSinksDocument = gql`
    query NotificationSinks($q: String, $first: Int = 100, $after: String) {
  notificationSinks(q: $q, first: $first, after: $after) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...NotificationSink
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${NotificationSinkFragmentDoc}`;

/**
 * __useNotificationSinksQuery__
 *
 * To run a query within a React component, call `useNotificationSinksQuery` and pass it any options that fit your needs.
 * When your component renders, `useNotificationSinksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNotificationSinksQuery({
 *   variables: {
 *      q: // value for 'q'
 *      first: // value for 'first'
 *      after: // value for 'after'
 *   },
 * });
 */
export function useNotificationSinksQuery(baseOptions?: Apollo.QueryHookOptions<NotificationSinksQuery, NotificationSinksQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<NotificationSinksQuery, NotificationSinksQueryVariables>(NotificationSinksDocument, options);
      }
export function useNotificationSinksLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<NotificationSinksQuery, NotificationSinksQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<NotificationSinksQuery, NotificationSinksQueryVariables>(NotificationSinksDocument, options);
        }
export function useNotificationSinksSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<NotificationSinksQuery, NotificationSinksQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<NotificationSinksQuery, NotificationSinksQueryVariables>(NotificationSinksDocument, options);
        }
export type NotificationSinksQueryHookResult = ReturnType<typeof useNotificationSinksQuery>;
export type NotificationSinksLazyQueryHookResult = ReturnType<typeof useNotificationSinksLazyQuery>;
export type NotificationSinksSuspenseQueryHookResult = ReturnType<typeof useNotificationSinksSuspenseQuery>;
export type NotificationSinksQueryResult = Apollo.QueryResult<NotificationSinksQuery, NotificationSinksQueryVariables>;
export const UnreadAppNotificationsDocument = gql`
    query UnreadAppNotifications {
  unreadAppNotifications
}
    `;

/**
 * __useUnreadAppNotificationsQuery__
 *
 * To run a query within a React component, call `useUnreadAppNotificationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUnreadAppNotificationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUnreadAppNotificationsQuery({
 *   variables: {
 *   },
 * });
 */
export function useUnreadAppNotificationsQuery(baseOptions?: Apollo.QueryHookOptions<UnreadAppNotificationsQuery, UnreadAppNotificationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UnreadAppNotificationsQuery, UnreadAppNotificationsQueryVariables>(UnreadAppNotificationsDocument, options);
      }
export function useUnreadAppNotificationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UnreadAppNotificationsQuery, UnreadAppNotificationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UnreadAppNotificationsQuery, UnreadAppNotificationsQueryVariables>(UnreadAppNotificationsDocument, options);
        }
export function useUnreadAppNotificationsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<UnreadAppNotificationsQuery, UnreadAppNotificationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<UnreadAppNotificationsQuery, UnreadAppNotificationsQueryVariables>(UnreadAppNotificationsDocument, options);
        }
export type UnreadAppNotificationsQueryHookResult = ReturnType<typeof useUnreadAppNotificationsQuery>;
export type UnreadAppNotificationsLazyQueryHookResult = ReturnType<typeof useUnreadAppNotificationsLazyQuery>;
export type UnreadAppNotificationsSuspenseQueryHookResult = ReturnType<typeof useUnreadAppNotificationsSuspenseQuery>;
export type UnreadAppNotificationsQueryResult = Apollo.QueryResult<UnreadAppNotificationsQuery, UnreadAppNotificationsQueryVariables>;
export const AppNotificationsDocument = gql`
    query AppNotifications($after: String, $first: Int, $before: String, $last: Int) {
  appNotifications(after: $after, first: $first, before: $before, last: $last) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...AppNotification
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${AppNotificationFragmentDoc}`;

/**
 * __useAppNotificationsQuery__
 *
 * To run a query within a React component, call `useAppNotificationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAppNotificationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAppNotificationsQuery({
 *   variables: {
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      before: // value for 'before'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useAppNotificationsQuery(baseOptions?: Apollo.QueryHookOptions<AppNotificationsQuery, AppNotificationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AppNotificationsQuery, AppNotificationsQueryVariables>(AppNotificationsDocument, options);
      }
export function useAppNotificationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AppNotificationsQuery, AppNotificationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AppNotificationsQuery, AppNotificationsQueryVariables>(AppNotificationsDocument, options);
        }
export function useAppNotificationsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AppNotificationsQuery, AppNotificationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AppNotificationsQuery, AppNotificationsQueryVariables>(AppNotificationsDocument, options);
        }
export type AppNotificationsQueryHookResult = ReturnType<typeof useAppNotificationsQuery>;
export type AppNotificationsLazyQueryHookResult = ReturnType<typeof useAppNotificationsLazyQuery>;
export type AppNotificationsSuspenseQueryHookResult = ReturnType<typeof useAppNotificationsSuspenseQuery>;
export type AppNotificationsQueryResult = Apollo.QueryResult<AppNotificationsQuery, AppNotificationsQueryVariables>;
export const ReadAppNotificationsDocument = gql`
    mutation ReadAppNotifications {
  readAppNotifications
}
    `;
export type ReadAppNotificationsMutationFn = Apollo.MutationFunction<ReadAppNotificationsMutation, ReadAppNotificationsMutationVariables>;

/**
 * __useReadAppNotificationsMutation__
 *
 * To run a mutation, you first call `useReadAppNotificationsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useReadAppNotificationsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [readAppNotificationsMutation, { data, loading, error }] = useReadAppNotificationsMutation({
 *   variables: {
 *   },
 * });
 */
export function useReadAppNotificationsMutation(baseOptions?: Apollo.MutationHookOptions<ReadAppNotificationsMutation, ReadAppNotificationsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ReadAppNotificationsMutation, ReadAppNotificationsMutationVariables>(ReadAppNotificationsDocument, options);
      }
export type ReadAppNotificationsMutationHookResult = ReturnType<typeof useReadAppNotificationsMutation>;
export type ReadAppNotificationsMutationResult = Apollo.MutationResult<ReadAppNotificationsMutation>;
export type ReadAppNotificationsMutationOptions = Apollo.BaseMutationOptions<ReadAppNotificationsMutation, ReadAppNotificationsMutationVariables>;
export const OidcConsentDocument = gql`
    query OIDCConsent($challenge: String!) {
  oidcConsent(challenge: $challenge) {
    consent {
      requestedScope
      skip
    }
  }
}
    `;

/**
 * __useOidcConsentQuery__
 *
 * To run a query within a React component, call `useOidcConsentQuery` and pass it any options that fit your needs.
 * When your component renders, `useOidcConsentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOidcConsentQuery({
 *   variables: {
 *      challenge: // value for 'challenge'
 *   },
 * });
 */
export function useOidcConsentQuery(baseOptions: Apollo.QueryHookOptions<OidcConsentQuery, OidcConsentQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<OidcConsentQuery, OidcConsentQueryVariables>(OidcConsentDocument, options);
      }
export function useOidcConsentLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<OidcConsentQuery, OidcConsentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<OidcConsentQuery, OidcConsentQueryVariables>(OidcConsentDocument, options);
        }
export function useOidcConsentSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<OidcConsentQuery, OidcConsentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<OidcConsentQuery, OidcConsentQueryVariables>(OidcConsentDocument, options);
        }
export type OidcConsentQueryHookResult = ReturnType<typeof useOidcConsentQuery>;
export type OidcConsentLazyQueryHookResult = ReturnType<typeof useOidcConsentLazyQuery>;
export type OidcConsentSuspenseQueryHookResult = ReturnType<typeof useOidcConsentSuspenseQuery>;
export type OidcConsentQueryResult = Apollo.QueryResult<OidcConsentQuery, OidcConsentQueryVariables>;
export const ConsentDocument = gql`
    mutation Consent($challenge: String!, $scopes: [String]) {
  oauthConsent(challenge: $challenge, scopes: $scopes) {
    redirectTo
  }
}
    `;
export type ConsentMutationFn = Apollo.MutationFunction<ConsentMutation, ConsentMutationVariables>;

/**
 * __useConsentMutation__
 *
 * To run a mutation, you first call `useConsentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useConsentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [consentMutation, { data, loading, error }] = useConsentMutation({
 *   variables: {
 *      challenge: // value for 'challenge'
 *      scopes: // value for 'scopes'
 *   },
 * });
 */
export function useConsentMutation(baseOptions?: Apollo.MutationHookOptions<ConsentMutation, ConsentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ConsentMutation, ConsentMutationVariables>(ConsentDocument, options);
      }
export type ConsentMutationHookResult = ReturnType<typeof useConsentMutation>;
export type ConsentMutationResult = Apollo.MutationResult<ConsentMutation>;
export type ConsentMutationOptions = Apollo.BaseMutationOptions<ConsentMutation, ConsentMutationVariables>;
export const AcceptLoginDocument = gql`
    mutation AcceptLogin($challenge: String!) {
  acceptLogin(challenge: $challenge) {
    redirectTo
  }
}
    `;
export type AcceptLoginMutationFn = Apollo.MutationFunction<AcceptLoginMutation, AcceptLoginMutationVariables>;

/**
 * __useAcceptLoginMutation__
 *
 * To run a mutation, you first call `useAcceptLoginMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAcceptLoginMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [acceptLoginMutation, { data, loading, error }] = useAcceptLoginMutation({
 *   variables: {
 *      challenge: // value for 'challenge'
 *   },
 * });
 */
export function useAcceptLoginMutation(baseOptions?: Apollo.MutationHookOptions<AcceptLoginMutation, AcceptLoginMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AcceptLoginMutation, AcceptLoginMutationVariables>(AcceptLoginDocument, options);
      }
export type AcceptLoginMutationHookResult = ReturnType<typeof useAcceptLoginMutation>;
export type AcceptLoginMutationResult = Apollo.MutationResult<AcceptLoginMutation>;
export type AcceptLoginMutationOptions = Apollo.BaseMutationOptions<AcceptLoginMutation, AcceptLoginMutationVariables>;
export const OidcProvidersDocument = gql`
    query OidcProviders($after: String, $first: Int = 100, $before: String, $last: Int, $q: String) {
  oidcProviders(after: $after, first: $first, before: $before, last: $last, q: $q) {
    edges {
      node {
        ...OidcProvider
      }
    }
    pageInfo {
      ...PageInfo
    }
  }
}
    ${OidcProviderFragmentDoc}
${PageInfoFragmentDoc}`;

/**
 * __useOidcProvidersQuery__
 *
 * To run a query within a React component, call `useOidcProvidersQuery` and pass it any options that fit your needs.
 * When your component renders, `useOidcProvidersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOidcProvidersQuery({
 *   variables: {
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      before: // value for 'before'
 *      last: // value for 'last'
 *      q: // value for 'q'
 *   },
 * });
 */
export function useOidcProvidersQuery(baseOptions?: Apollo.QueryHookOptions<OidcProvidersQuery, OidcProvidersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<OidcProvidersQuery, OidcProvidersQueryVariables>(OidcProvidersDocument, options);
      }
export function useOidcProvidersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<OidcProvidersQuery, OidcProvidersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<OidcProvidersQuery, OidcProvidersQueryVariables>(OidcProvidersDocument, options);
        }
export function useOidcProvidersSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<OidcProvidersQuery, OidcProvidersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<OidcProvidersQuery, OidcProvidersQueryVariables>(OidcProvidersDocument, options);
        }
export type OidcProvidersQueryHookResult = ReturnType<typeof useOidcProvidersQuery>;
export type OidcProvidersLazyQueryHookResult = ReturnType<typeof useOidcProvidersLazyQuery>;
export type OidcProvidersSuspenseQueryHookResult = ReturnType<typeof useOidcProvidersSuspenseQuery>;
export type OidcProvidersQueryResult = Apollo.QueryResult<OidcProvidersQuery, OidcProvidersQueryVariables>;
export const CreateOidcProviderDocument = gql`
    mutation CreateOidcProvider($type: OidcProviderType!, $attributes: OidcProviderAttributes!) {
  createOidcProvider(type: $type, attributes: $attributes) {
    ...OidcProvider
  }
}
    ${OidcProviderFragmentDoc}`;
export type CreateOidcProviderMutationFn = Apollo.MutationFunction<CreateOidcProviderMutation, CreateOidcProviderMutationVariables>;

/**
 * __useCreateOidcProviderMutation__
 *
 * To run a mutation, you first call `useCreateOidcProviderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOidcProviderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOidcProviderMutation, { data, loading, error }] = useCreateOidcProviderMutation({
 *   variables: {
 *      type: // value for 'type'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useCreateOidcProviderMutation(baseOptions?: Apollo.MutationHookOptions<CreateOidcProviderMutation, CreateOidcProviderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateOidcProviderMutation, CreateOidcProviderMutationVariables>(CreateOidcProviderDocument, options);
      }
export type CreateOidcProviderMutationHookResult = ReturnType<typeof useCreateOidcProviderMutation>;
export type CreateOidcProviderMutationResult = Apollo.MutationResult<CreateOidcProviderMutation>;
export type CreateOidcProviderMutationOptions = Apollo.BaseMutationOptions<CreateOidcProviderMutation, CreateOidcProviderMutationVariables>;
export const UpdateOidcProviderDocument = gql`
    mutation UpdateOidcProvider($type: OidcProviderType!, $id: ID!, $attributes: OidcProviderAttributes!) {
  updateOidcProvider(type: $type, id: $id, attributes: $attributes) {
    ...OidcProvider
  }
}
    ${OidcProviderFragmentDoc}`;
export type UpdateOidcProviderMutationFn = Apollo.MutationFunction<UpdateOidcProviderMutation, UpdateOidcProviderMutationVariables>;

/**
 * __useUpdateOidcProviderMutation__
 *
 * To run a mutation, you first call `useUpdateOidcProviderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOidcProviderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOidcProviderMutation, { data, loading, error }] = useUpdateOidcProviderMutation({
 *   variables: {
 *      type: // value for 'type'
 *      id: // value for 'id'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpdateOidcProviderMutation(baseOptions?: Apollo.MutationHookOptions<UpdateOidcProviderMutation, UpdateOidcProviderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateOidcProviderMutation, UpdateOidcProviderMutationVariables>(UpdateOidcProviderDocument, options);
      }
export type UpdateOidcProviderMutationHookResult = ReturnType<typeof useUpdateOidcProviderMutation>;
export type UpdateOidcProviderMutationResult = Apollo.MutationResult<UpdateOidcProviderMutation>;
export type UpdateOidcProviderMutationOptions = Apollo.BaseMutationOptions<UpdateOidcProviderMutation, UpdateOidcProviderMutationVariables>;
export const DeleteOidcProviderDocument = gql`
    mutation DeleteOidcProvider($type: OidcProviderType!, $id: ID!) {
  deleteOidcProvider(type: $type, id: $id) {
    ...OidcProvider
  }
}
    ${OidcProviderFragmentDoc}`;
export type DeleteOidcProviderMutationFn = Apollo.MutationFunction<DeleteOidcProviderMutation, DeleteOidcProviderMutationVariables>;

/**
 * __useDeleteOidcProviderMutation__
 *
 * To run a mutation, you first call `useDeleteOidcProviderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOidcProviderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOidcProviderMutation, { data, loading, error }] = useDeleteOidcProviderMutation({
 *   variables: {
 *      type: // value for 'type'
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteOidcProviderMutation(baseOptions?: Apollo.MutationHookOptions<DeleteOidcProviderMutation, DeleteOidcProviderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteOidcProviderMutation, DeleteOidcProviderMutationVariables>(DeleteOidcProviderDocument, options);
      }
export type DeleteOidcProviderMutationHookResult = ReturnType<typeof useDeleteOidcProviderMutation>;
export type DeleteOidcProviderMutationResult = Apollo.MutationResult<DeleteOidcProviderMutation>;
export type DeleteOidcProviderMutationOptions = Apollo.BaseMutationOptions<DeleteOidcProviderMutation, DeleteOidcProviderMutationVariables>;
export const PersonasDocument = gql`
    query Personas($cursor: String) {
  personas(first: 3, after: $cursor) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...Persona
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${PersonaFragmentDoc}`;

/**
 * __usePersonasQuery__
 *
 * To run a query within a React component, call `usePersonasQuery` and pass it any options that fit your needs.
 * When your component renders, `usePersonasQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePersonasQuery({
 *   variables: {
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function usePersonasQuery(baseOptions?: Apollo.QueryHookOptions<PersonasQuery, PersonasQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PersonasQuery, PersonasQueryVariables>(PersonasDocument, options);
      }
export function usePersonasLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PersonasQuery, PersonasQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PersonasQuery, PersonasQueryVariables>(PersonasDocument, options);
        }
export function usePersonasSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<PersonasQuery, PersonasQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PersonasQuery, PersonasQueryVariables>(PersonasDocument, options);
        }
export type PersonasQueryHookResult = ReturnType<typeof usePersonasQuery>;
export type PersonasLazyQueryHookResult = ReturnType<typeof usePersonasLazyQuery>;
export type PersonasSuspenseQueryHookResult = ReturnType<typeof usePersonasSuspenseQuery>;
export type PersonasQueryResult = Apollo.QueryResult<PersonasQuery, PersonasQueryVariables>;
export const CreatePersonaDocument = gql`
    mutation CreatePersona($attributes: PersonaAttributes!) {
  createPersona(attributes: $attributes) {
    ...Persona
  }
}
    ${PersonaFragmentDoc}`;
export type CreatePersonaMutationFn = Apollo.MutationFunction<CreatePersonaMutation, CreatePersonaMutationVariables>;

/**
 * __useCreatePersonaMutation__
 *
 * To run a mutation, you first call `useCreatePersonaMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePersonaMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPersonaMutation, { data, loading, error }] = useCreatePersonaMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useCreatePersonaMutation(baseOptions?: Apollo.MutationHookOptions<CreatePersonaMutation, CreatePersonaMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreatePersonaMutation, CreatePersonaMutationVariables>(CreatePersonaDocument, options);
      }
export type CreatePersonaMutationHookResult = ReturnType<typeof useCreatePersonaMutation>;
export type CreatePersonaMutationResult = Apollo.MutationResult<CreatePersonaMutation>;
export type CreatePersonaMutationOptions = Apollo.BaseMutationOptions<CreatePersonaMutation, CreatePersonaMutationVariables>;
export const UpdatePersonaDocument = gql`
    mutation UpdatePersona($id: ID!, $attributes: PersonaAttributes!) {
  updatePersona(id: $id, attributes: $attributes) {
    ...Persona
  }
}
    ${PersonaFragmentDoc}`;
export type UpdatePersonaMutationFn = Apollo.MutationFunction<UpdatePersonaMutation, UpdatePersonaMutationVariables>;

/**
 * __useUpdatePersonaMutation__
 *
 * To run a mutation, you first call `useUpdatePersonaMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdatePersonaMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updatePersonaMutation, { data, loading, error }] = useUpdatePersonaMutation({
 *   variables: {
 *      id: // value for 'id'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpdatePersonaMutation(baseOptions?: Apollo.MutationHookOptions<UpdatePersonaMutation, UpdatePersonaMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdatePersonaMutation, UpdatePersonaMutationVariables>(UpdatePersonaDocument, options);
      }
export type UpdatePersonaMutationHookResult = ReturnType<typeof useUpdatePersonaMutation>;
export type UpdatePersonaMutationResult = Apollo.MutationResult<UpdatePersonaMutation>;
export type UpdatePersonaMutationOptions = Apollo.BaseMutationOptions<UpdatePersonaMutation, UpdatePersonaMutationVariables>;
export const DeletePersonaDocument = gql`
    mutation DeletePersona($id: ID!) {
  deletePersona(id: $id) {
    ...Persona
  }
}
    ${PersonaFragmentDoc}`;
export type DeletePersonaMutationFn = Apollo.MutationFunction<DeletePersonaMutation, DeletePersonaMutationVariables>;

/**
 * __useDeletePersonaMutation__
 *
 * To run a mutation, you first call `useDeletePersonaMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeletePersonaMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deletePersonaMutation, { data, loading, error }] = useDeletePersonaMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeletePersonaMutation(baseOptions?: Apollo.MutationHookOptions<DeletePersonaMutation, DeletePersonaMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeletePersonaMutation, DeletePersonaMutationVariables>(DeletePersonaDocument, options);
      }
export type DeletePersonaMutationHookResult = ReturnType<typeof useDeletePersonaMutation>;
export type DeletePersonaMutationResult = Apollo.MutationResult<DeletePersonaMutation>;
export type DeletePersonaMutationOptions = Apollo.BaseMutationOptions<DeletePersonaMutation, DeletePersonaMutationVariables>;
export const PolicyConstraintsDocument = gql`
    query PolicyConstraints($after: String, $before: String, $clusters: [ID], $first: Int, $kind: String, $kinds: [String], $last: Int, $namespace: String, $namespaces: [String], $q: String, $violated: Boolean) {
  policyConstraints(
    after: $after
    before: $before
    clusters: $clusters
    first: $first
    kind: $kind
    kinds: $kinds
    last: $last
    namespace: $namespace
    namespaces: $namespaces
    q: $q
    violated: $violated
  ) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...PolicyConstraint
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${PolicyConstraintFragmentDoc}`;

/**
 * __usePolicyConstraintsQuery__
 *
 * To run a query within a React component, call `usePolicyConstraintsQuery` and pass it any options that fit your needs.
 * When your component renders, `usePolicyConstraintsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePolicyConstraintsQuery({
 *   variables: {
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      clusters: // value for 'clusters'
 *      first: // value for 'first'
 *      kind: // value for 'kind'
 *      kinds: // value for 'kinds'
 *      last: // value for 'last'
 *      namespace: // value for 'namespace'
 *      namespaces: // value for 'namespaces'
 *      q: // value for 'q'
 *      violated: // value for 'violated'
 *   },
 * });
 */
export function usePolicyConstraintsQuery(baseOptions?: Apollo.QueryHookOptions<PolicyConstraintsQuery, PolicyConstraintsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PolicyConstraintsQuery, PolicyConstraintsQueryVariables>(PolicyConstraintsDocument, options);
      }
export function usePolicyConstraintsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PolicyConstraintsQuery, PolicyConstraintsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PolicyConstraintsQuery, PolicyConstraintsQueryVariables>(PolicyConstraintsDocument, options);
        }
export function usePolicyConstraintsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<PolicyConstraintsQuery, PolicyConstraintsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PolicyConstraintsQuery, PolicyConstraintsQueryVariables>(PolicyConstraintsDocument, options);
        }
export type PolicyConstraintsQueryHookResult = ReturnType<typeof usePolicyConstraintsQuery>;
export type PolicyConstraintsLazyQueryHookResult = ReturnType<typeof usePolicyConstraintsLazyQuery>;
export type PolicyConstraintsSuspenseQueryHookResult = ReturnType<typeof usePolicyConstraintsSuspenseQuery>;
export type PolicyConstraintsQueryResult = Apollo.QueryResult<PolicyConstraintsQuery, PolicyConstraintsQueryVariables>;
export const PolicyConstraintDocument = gql`
    query PolicyConstraint($id: ID!) {
  policyConstraint(id: $id) {
    ...PolicyConstraint
    object {
      metadata {
        namespace
      }
      kind
    }
    violations {
      group
      id
      insertedAt
      kind
      message
      name
      namespace
      updatedAt
      version
    }
  }
}
    ${PolicyConstraintFragmentDoc}`;

/**
 * __usePolicyConstraintQuery__
 *
 * To run a query within a React component, call `usePolicyConstraintQuery` and pass it any options that fit your needs.
 * When your component renders, `usePolicyConstraintQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePolicyConstraintQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePolicyConstraintQuery(baseOptions: Apollo.QueryHookOptions<PolicyConstraintQuery, PolicyConstraintQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PolicyConstraintQuery, PolicyConstraintQueryVariables>(PolicyConstraintDocument, options);
      }
export function usePolicyConstraintLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PolicyConstraintQuery, PolicyConstraintQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PolicyConstraintQuery, PolicyConstraintQueryVariables>(PolicyConstraintDocument, options);
        }
export function usePolicyConstraintSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<PolicyConstraintQuery, PolicyConstraintQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PolicyConstraintQuery, PolicyConstraintQueryVariables>(PolicyConstraintDocument, options);
        }
export type PolicyConstraintQueryHookResult = ReturnType<typeof usePolicyConstraintQuery>;
export type PolicyConstraintLazyQueryHookResult = ReturnType<typeof usePolicyConstraintLazyQuery>;
export type PolicyConstraintSuspenseQueryHookResult = ReturnType<typeof usePolicyConstraintSuspenseQuery>;
export type PolicyConstraintQueryResult = Apollo.QueryResult<PolicyConstraintQuery, PolicyConstraintQueryVariables>;
export const ViolationStatisticsDocument = gql`
    query ViolationStatistics($field: ConstraintViolationField!) {
  violationStatistics(field: $field) {
    count
    value
    violations
  }
}
    `;

/**
 * __useViolationStatisticsQuery__
 *
 * To run a query within a React component, call `useViolationStatisticsQuery` and pass it any options that fit your needs.
 * When your component renders, `useViolationStatisticsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useViolationStatisticsQuery({
 *   variables: {
 *      field: // value for 'field'
 *   },
 * });
 */
export function useViolationStatisticsQuery(baseOptions: Apollo.QueryHookOptions<ViolationStatisticsQuery, ViolationStatisticsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ViolationStatisticsQuery, ViolationStatisticsQueryVariables>(ViolationStatisticsDocument, options);
      }
export function useViolationStatisticsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ViolationStatisticsQuery, ViolationStatisticsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ViolationStatisticsQuery, ViolationStatisticsQueryVariables>(ViolationStatisticsDocument, options);
        }
export function useViolationStatisticsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ViolationStatisticsQuery, ViolationStatisticsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ViolationStatisticsQuery, ViolationStatisticsQueryVariables>(ViolationStatisticsDocument, options);
        }
export type ViolationStatisticsQueryHookResult = ReturnType<typeof useViolationStatisticsQuery>;
export type ViolationStatisticsLazyQueryHookResult = ReturnType<typeof useViolationStatisticsLazyQuery>;
export type ViolationStatisticsSuspenseQueryHookResult = ReturnType<typeof useViolationStatisticsSuspenseQuery>;
export type ViolationStatisticsQueryResult = Apollo.QueryResult<ViolationStatisticsQuery, ViolationStatisticsQueryVariables>;
export const PolicyStatisticsDocument = gql`
    query PolicyStatistics($aggregate: PolicyAggregate!, $clusters: [ID], $kind: String, $kinds: [String], $namespace: String, $namespaces: [String], $q: String) {
  policyStatistics(
    aggregate: $aggregate
    clusters: $clusters
    kind: $kind
    kinds: $kinds
    namespace: $namespace
    namespaces: $namespaces
    q: $q
  ) {
    count
    aggregate
  }
}
    `;

/**
 * __usePolicyStatisticsQuery__
 *
 * To run a query within a React component, call `usePolicyStatisticsQuery` and pass it any options that fit your needs.
 * When your component renders, `usePolicyStatisticsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePolicyStatisticsQuery({
 *   variables: {
 *      aggregate: // value for 'aggregate'
 *      clusters: // value for 'clusters'
 *      kind: // value for 'kind'
 *      kinds: // value for 'kinds'
 *      namespace: // value for 'namespace'
 *      namespaces: // value for 'namespaces'
 *      q: // value for 'q'
 *   },
 * });
 */
export function usePolicyStatisticsQuery(baseOptions: Apollo.QueryHookOptions<PolicyStatisticsQuery, PolicyStatisticsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PolicyStatisticsQuery, PolicyStatisticsQueryVariables>(PolicyStatisticsDocument, options);
      }
export function usePolicyStatisticsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PolicyStatisticsQuery, PolicyStatisticsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PolicyStatisticsQuery, PolicyStatisticsQueryVariables>(PolicyStatisticsDocument, options);
        }
export function usePolicyStatisticsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<PolicyStatisticsQuery, PolicyStatisticsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PolicyStatisticsQuery, PolicyStatisticsQueryVariables>(PolicyStatisticsDocument, options);
        }
export type PolicyStatisticsQueryHookResult = ReturnType<typeof usePolicyStatisticsQuery>;
export type PolicyStatisticsLazyQueryHookResult = ReturnType<typeof usePolicyStatisticsLazyQuery>;
export type PolicyStatisticsSuspenseQueryHookResult = ReturnType<typeof usePolicyStatisticsSuspenseQuery>;
export type PolicyStatisticsQueryResult = Apollo.QueryResult<PolicyStatisticsQuery, PolicyStatisticsQueryVariables>;
export const ComplianceReportGeneratorsDocument = gql`
    query ComplianceReportGenerators($after: String, $before: String, $first: Int, $last: Int) {
  complianceReportGenerators(
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...ComplianceReportGenerator
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${ComplianceReportGeneratorFragmentDoc}`;

/**
 * __useComplianceReportGeneratorsQuery__
 *
 * To run a query within a React component, call `useComplianceReportGeneratorsQuery` and pass it any options that fit your needs.
 * When your component renders, `useComplianceReportGeneratorsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useComplianceReportGeneratorsQuery({
 *   variables: {
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useComplianceReportGeneratorsQuery(baseOptions?: Apollo.QueryHookOptions<ComplianceReportGeneratorsQuery, ComplianceReportGeneratorsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ComplianceReportGeneratorsQuery, ComplianceReportGeneratorsQueryVariables>(ComplianceReportGeneratorsDocument, options);
      }
export function useComplianceReportGeneratorsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ComplianceReportGeneratorsQuery, ComplianceReportGeneratorsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ComplianceReportGeneratorsQuery, ComplianceReportGeneratorsQueryVariables>(ComplianceReportGeneratorsDocument, options);
        }
export function useComplianceReportGeneratorsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ComplianceReportGeneratorsQuery, ComplianceReportGeneratorsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ComplianceReportGeneratorsQuery, ComplianceReportGeneratorsQueryVariables>(ComplianceReportGeneratorsDocument, options);
        }
export type ComplianceReportGeneratorsQueryHookResult = ReturnType<typeof useComplianceReportGeneratorsQuery>;
export type ComplianceReportGeneratorsLazyQueryHookResult = ReturnType<typeof useComplianceReportGeneratorsLazyQuery>;
export type ComplianceReportGeneratorsSuspenseQueryHookResult = ReturnType<typeof useComplianceReportGeneratorsSuspenseQuery>;
export type ComplianceReportGeneratorsQueryResult = Apollo.QueryResult<ComplianceReportGeneratorsQuery, ComplianceReportGeneratorsQueryVariables>;
export const ComplianceReportGeneratorDocument = gql`
    query ComplianceReportGenerator($id: ID, $name: String) {
  complianceReportGenerator(id: $id, name: $name) {
    ...ComplianceReportGenerator
  }
}
    ${ComplianceReportGeneratorFragmentDoc}`;

/**
 * __useComplianceReportGeneratorQuery__
 *
 * To run a query within a React component, call `useComplianceReportGeneratorQuery` and pass it any options that fit your needs.
 * When your component renders, `useComplianceReportGeneratorQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useComplianceReportGeneratorQuery({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *   },
 * });
 */
export function useComplianceReportGeneratorQuery(baseOptions?: Apollo.QueryHookOptions<ComplianceReportGeneratorQuery, ComplianceReportGeneratorQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ComplianceReportGeneratorQuery, ComplianceReportGeneratorQueryVariables>(ComplianceReportGeneratorDocument, options);
      }
export function useComplianceReportGeneratorLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ComplianceReportGeneratorQuery, ComplianceReportGeneratorQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ComplianceReportGeneratorQuery, ComplianceReportGeneratorQueryVariables>(ComplianceReportGeneratorDocument, options);
        }
export function useComplianceReportGeneratorSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ComplianceReportGeneratorQuery, ComplianceReportGeneratorQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ComplianceReportGeneratorQuery, ComplianceReportGeneratorQueryVariables>(ComplianceReportGeneratorDocument, options);
        }
export type ComplianceReportGeneratorQueryHookResult = ReturnType<typeof useComplianceReportGeneratorQuery>;
export type ComplianceReportGeneratorLazyQueryHookResult = ReturnType<typeof useComplianceReportGeneratorLazyQuery>;
export type ComplianceReportGeneratorSuspenseQueryHookResult = ReturnType<typeof useComplianceReportGeneratorSuspenseQuery>;
export type ComplianceReportGeneratorQueryResult = Apollo.QueryResult<ComplianceReportGeneratorQuery, ComplianceReportGeneratorQueryVariables>;
export const UpsertComplianceReportGeneratorDocument = gql`
    mutation UpsertComplianceReportGenerator($attributes: ComplianceReportGeneratorAttributes!) {
  upsertComplianceReportGenerator(attributes: $attributes) {
    ...ComplianceReportGenerator
  }
}
    ${ComplianceReportGeneratorFragmentDoc}`;
export type UpsertComplianceReportGeneratorMutationFn = Apollo.MutationFunction<UpsertComplianceReportGeneratorMutation, UpsertComplianceReportGeneratorMutationVariables>;

/**
 * __useUpsertComplianceReportGeneratorMutation__
 *
 * To run a mutation, you first call `useUpsertComplianceReportGeneratorMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpsertComplianceReportGeneratorMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upsertComplianceReportGeneratorMutation, { data, loading, error }] = useUpsertComplianceReportGeneratorMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpsertComplianceReportGeneratorMutation(baseOptions?: Apollo.MutationHookOptions<UpsertComplianceReportGeneratorMutation, UpsertComplianceReportGeneratorMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpsertComplianceReportGeneratorMutation, UpsertComplianceReportGeneratorMutationVariables>(UpsertComplianceReportGeneratorDocument, options);
      }
export type UpsertComplianceReportGeneratorMutationHookResult = ReturnType<typeof useUpsertComplianceReportGeneratorMutation>;
export type UpsertComplianceReportGeneratorMutationResult = Apollo.MutationResult<UpsertComplianceReportGeneratorMutation>;
export type UpsertComplianceReportGeneratorMutationOptions = Apollo.BaseMutationOptions<UpsertComplianceReportGeneratorMutation, UpsertComplianceReportGeneratorMutationVariables>;
export const DeleteComplianceReportDocument = gql`
    mutation DeleteComplianceReport($id: ID!) {
  deleteComplianceReportGenerator(id: $id) {
    ...ComplianceReportGenerator
  }
}
    ${ComplianceReportGeneratorFragmentDoc}`;
export type DeleteComplianceReportMutationFn = Apollo.MutationFunction<DeleteComplianceReportMutation, DeleteComplianceReportMutationVariables>;

/**
 * __useDeleteComplianceReportMutation__
 *
 * To run a mutation, you first call `useDeleteComplianceReportMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteComplianceReportMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteComplianceReportMutation, { data, loading, error }] = useDeleteComplianceReportMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteComplianceReportMutation(baseOptions?: Apollo.MutationHookOptions<DeleteComplianceReportMutation, DeleteComplianceReportMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteComplianceReportMutation, DeleteComplianceReportMutationVariables>(DeleteComplianceReportDocument, options);
      }
export type DeleteComplianceReportMutationHookResult = ReturnType<typeof useDeleteComplianceReportMutation>;
export type DeleteComplianceReportMutationResult = Apollo.MutationResult<DeleteComplianceReportMutation>;
export type DeleteComplianceReportMutationOptions = Apollo.BaseMutationOptions<DeleteComplianceReportMutation, DeleteComplianceReportMutationVariables>;
export const ComplianceReportsDocument = gql`
    query ComplianceReports($id: ID, $name: String, $after: String, $before: String, $first: Int, $last: Int) {
  complianceReportGenerator(id: $id, name: $name) {
    complianceReports(after: $after, before: $before, first: $first, last: $last) {
      pageInfo {
        ...PageInfo
      }
      edges {
        node {
          ...ComplianceReport
        }
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${ComplianceReportFragmentDoc}`;

/**
 * __useComplianceReportsQuery__
 *
 * To run a query within a React component, call `useComplianceReportsQuery` and pass it any options that fit your needs.
 * When your component renders, `useComplianceReportsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useComplianceReportsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useComplianceReportsQuery(baseOptions?: Apollo.QueryHookOptions<ComplianceReportsQuery, ComplianceReportsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ComplianceReportsQuery, ComplianceReportsQueryVariables>(ComplianceReportsDocument, options);
      }
export function useComplianceReportsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ComplianceReportsQuery, ComplianceReportsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ComplianceReportsQuery, ComplianceReportsQueryVariables>(ComplianceReportsDocument, options);
        }
export function useComplianceReportsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ComplianceReportsQuery, ComplianceReportsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ComplianceReportsQuery, ComplianceReportsQueryVariables>(ComplianceReportsDocument, options);
        }
export type ComplianceReportsQueryHookResult = ReturnType<typeof useComplianceReportsQuery>;
export type ComplianceReportsLazyQueryHookResult = ReturnType<typeof useComplianceReportsLazyQuery>;
export type ComplianceReportsSuspenseQueryHookResult = ReturnType<typeof useComplianceReportsSuspenseQuery>;
export type ComplianceReportsQueryResult = Apollo.QueryResult<ComplianceReportsQuery, ComplianceReportsQueryVariables>;
export const ProjectsDocument = gql`
    query Projects($after: String, $before: String, $first: Int = 100, $last: Int, $q: String) {
  projects(after: $after, before: $before, first: $first, last: $last, q: $q) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...Project
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${ProjectFragmentDoc}`;

/**
 * __useProjectsQuery__
 *
 * To run a query within a React component, call `useProjectsQuery` and pass it any options that fit your needs.
 * When your component renders, `useProjectsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProjectsQuery({
 *   variables: {
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      q: // value for 'q'
 *   },
 * });
 */
export function useProjectsQuery(baseOptions?: Apollo.QueryHookOptions<ProjectsQuery, ProjectsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProjectsQuery, ProjectsQueryVariables>(ProjectsDocument, options);
      }
export function useProjectsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProjectsQuery, ProjectsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProjectsQuery, ProjectsQueryVariables>(ProjectsDocument, options);
        }
export function useProjectsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ProjectsQuery, ProjectsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ProjectsQuery, ProjectsQueryVariables>(ProjectsDocument, options);
        }
export type ProjectsQueryHookResult = ReturnType<typeof useProjectsQuery>;
export type ProjectsLazyQueryHookResult = ReturnType<typeof useProjectsLazyQuery>;
export type ProjectsSuspenseQueryHookResult = ReturnType<typeof useProjectsSuspenseQuery>;
export type ProjectsQueryResult = Apollo.QueryResult<ProjectsQuery, ProjectsQueryVariables>;
export const ProjectsTinyDocument = gql`
    query ProjectsTiny($after: String, $before: String, $first: Int = 100, $last: Int, $q: String) {
  projects(after: $after, before: $before, first: $first, last: $last, q: $q) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...ProjectTiny
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${ProjectTinyFragmentDoc}`;

/**
 * __useProjectsTinyQuery__
 *
 * To run a query within a React component, call `useProjectsTinyQuery` and pass it any options that fit your needs.
 * When your component renders, `useProjectsTinyQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProjectsTinyQuery({
 *   variables: {
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      q: // value for 'q'
 *   },
 * });
 */
export function useProjectsTinyQuery(baseOptions?: Apollo.QueryHookOptions<ProjectsTinyQuery, ProjectsTinyQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProjectsTinyQuery, ProjectsTinyQueryVariables>(ProjectsTinyDocument, options);
      }
export function useProjectsTinyLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProjectsTinyQuery, ProjectsTinyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProjectsTinyQuery, ProjectsTinyQueryVariables>(ProjectsTinyDocument, options);
        }
export function useProjectsTinySuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ProjectsTinyQuery, ProjectsTinyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ProjectsTinyQuery, ProjectsTinyQueryVariables>(ProjectsTinyDocument, options);
        }
export type ProjectsTinyQueryHookResult = ReturnType<typeof useProjectsTinyQuery>;
export type ProjectsTinyLazyQueryHookResult = ReturnType<typeof useProjectsTinyLazyQuery>;
export type ProjectsTinySuspenseQueryHookResult = ReturnType<typeof useProjectsTinySuspenseQuery>;
export type ProjectsTinyQueryResult = Apollo.QueryResult<ProjectsTinyQuery, ProjectsTinyQueryVariables>;
export const ProjectDocument = gql`
    query Project($id: ID, $name: String) {
  project(id: $id, name: $name) {
    ...Project
  }
}
    ${ProjectFragmentDoc}`;

/**
 * __useProjectQuery__
 *
 * To run a query within a React component, call `useProjectQuery` and pass it any options that fit your needs.
 * When your component renders, `useProjectQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProjectQuery({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *   },
 * });
 */
export function useProjectQuery(baseOptions?: Apollo.QueryHookOptions<ProjectQuery, ProjectQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProjectQuery, ProjectQueryVariables>(ProjectDocument, options);
      }
export function useProjectLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProjectQuery, ProjectQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProjectQuery, ProjectQueryVariables>(ProjectDocument, options);
        }
export function useProjectSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ProjectQuery, ProjectQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ProjectQuery, ProjectQueryVariables>(ProjectDocument, options);
        }
export type ProjectQueryHookResult = ReturnType<typeof useProjectQuery>;
export type ProjectLazyQueryHookResult = ReturnType<typeof useProjectLazyQuery>;
export type ProjectSuspenseQueryHookResult = ReturnType<typeof useProjectSuspenseQuery>;
export type ProjectQueryResult = Apollo.QueryResult<ProjectQuery, ProjectQueryVariables>;
export const ProjectBindingsDocument = gql`
    query ProjectBindings($id: ID!) {
  project(id: $id) {
    ...ProjectBindings
  }
}
    ${ProjectBindingsFragmentDoc}`;

/**
 * __useProjectBindingsQuery__
 *
 * To run a query within a React component, call `useProjectBindingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useProjectBindingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProjectBindingsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useProjectBindingsQuery(baseOptions: Apollo.QueryHookOptions<ProjectBindingsQuery, ProjectBindingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProjectBindingsQuery, ProjectBindingsQueryVariables>(ProjectBindingsDocument, options);
      }
export function useProjectBindingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProjectBindingsQuery, ProjectBindingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProjectBindingsQuery, ProjectBindingsQueryVariables>(ProjectBindingsDocument, options);
        }
export function useProjectBindingsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ProjectBindingsQuery, ProjectBindingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ProjectBindingsQuery, ProjectBindingsQueryVariables>(ProjectBindingsDocument, options);
        }
export type ProjectBindingsQueryHookResult = ReturnType<typeof useProjectBindingsQuery>;
export type ProjectBindingsLazyQueryHookResult = ReturnType<typeof useProjectBindingsLazyQuery>;
export type ProjectBindingsSuspenseQueryHookResult = ReturnType<typeof useProjectBindingsSuspenseQuery>;
export type ProjectBindingsQueryResult = Apollo.QueryResult<ProjectBindingsQuery, ProjectBindingsQueryVariables>;
export const CreateProjectDocument = gql`
    mutation CreateProject($attributes: ProjectAttributes!) {
  createProject(attributes: $attributes) {
    ...Project
  }
}
    ${ProjectFragmentDoc}`;
export type CreateProjectMutationFn = Apollo.MutationFunction<CreateProjectMutation, CreateProjectMutationVariables>;

/**
 * __useCreateProjectMutation__
 *
 * To run a mutation, you first call `useCreateProjectMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateProjectMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createProjectMutation, { data, loading, error }] = useCreateProjectMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useCreateProjectMutation(baseOptions?: Apollo.MutationHookOptions<CreateProjectMutation, CreateProjectMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateProjectMutation, CreateProjectMutationVariables>(CreateProjectDocument, options);
      }
export type CreateProjectMutationHookResult = ReturnType<typeof useCreateProjectMutation>;
export type CreateProjectMutationResult = Apollo.MutationResult<CreateProjectMutation>;
export type CreateProjectMutationOptions = Apollo.BaseMutationOptions<CreateProjectMutation, CreateProjectMutationVariables>;
export const UpdateProjectDocument = gql`
    mutation UpdateProject($id: ID!, $attributes: ProjectAttributes!) {
  updateProject(id: $id, attributes: $attributes) {
    ...Project
  }
}
    ${ProjectFragmentDoc}`;
export type UpdateProjectMutationFn = Apollo.MutationFunction<UpdateProjectMutation, UpdateProjectMutationVariables>;

/**
 * __useUpdateProjectMutation__
 *
 * To run a mutation, you first call `useUpdateProjectMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateProjectMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateProjectMutation, { data, loading, error }] = useUpdateProjectMutation({
 *   variables: {
 *      id: // value for 'id'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpdateProjectMutation(baseOptions?: Apollo.MutationHookOptions<UpdateProjectMutation, UpdateProjectMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateProjectMutation, UpdateProjectMutationVariables>(UpdateProjectDocument, options);
      }
export type UpdateProjectMutationHookResult = ReturnType<typeof useUpdateProjectMutation>;
export type UpdateProjectMutationResult = Apollo.MutationResult<UpdateProjectMutation>;
export type UpdateProjectMutationOptions = Apollo.BaseMutationOptions<UpdateProjectMutation, UpdateProjectMutationVariables>;
export const DeleteProjectDocument = gql`
    mutation DeleteProject($id: ID!) {
  deleteProject(id: $id) {
    ...Project
  }
}
    ${ProjectFragmentDoc}`;
export type DeleteProjectMutationFn = Apollo.MutationFunction<DeleteProjectMutation, DeleteProjectMutationVariables>;

/**
 * __useDeleteProjectMutation__
 *
 * To run a mutation, you first call `useDeleteProjectMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteProjectMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteProjectMutation, { data, loading, error }] = useDeleteProjectMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteProjectMutation(baseOptions?: Apollo.MutationHookOptions<DeleteProjectMutation, DeleteProjectMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteProjectMutation, DeleteProjectMutationVariables>(DeleteProjectDocument, options);
      }
export type DeleteProjectMutationHookResult = ReturnType<typeof useDeleteProjectMutation>;
export type DeleteProjectMutationResult = Apollo.MutationResult<DeleteProjectMutation>;
export type DeleteProjectMutationOptions = Apollo.BaseMutationOptions<DeleteProjectMutation, DeleteProjectMutationVariables>;
export const UpdateRbacDocument = gql`
    mutation UpdateRbac($serviceId: ID, $clusterId: ID, $pipelineId: ID, $stackId: ID, $projectId: ID, $flowId: ID, $serverId: ID, $rbac: RbacAttributes!) {
  updateRbac(
    serviceId: $serviceId
    clusterId: $clusterId
    pipelineId: $pipelineId
    stackId: $stackId
    projectId: $projectId
    flowId: $flowId
    serverId: $serverId
    rbac: $rbac
  )
}
    `;
export type UpdateRbacMutationFn = Apollo.MutationFunction<UpdateRbacMutation, UpdateRbacMutationVariables>;

/**
 * __useUpdateRbacMutation__
 *
 * To run a mutation, you first call `useUpdateRbacMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRbacMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRbacMutation, { data, loading, error }] = useUpdateRbacMutation({
 *   variables: {
 *      serviceId: // value for 'serviceId'
 *      clusterId: // value for 'clusterId'
 *      pipelineId: // value for 'pipelineId'
 *      stackId: // value for 'stackId'
 *      projectId: // value for 'projectId'
 *      flowId: // value for 'flowId'
 *      serverId: // value for 'serverId'
 *      rbac: // value for 'rbac'
 *   },
 * });
 */
export function useUpdateRbacMutation(baseOptions?: Apollo.MutationHookOptions<UpdateRbacMutation, UpdateRbacMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateRbacMutation, UpdateRbacMutationVariables>(UpdateRbacDocument, options);
      }
export type UpdateRbacMutationHookResult = ReturnType<typeof useUpdateRbacMutation>;
export type UpdateRbacMutationResult = Apollo.MutationResult<UpdateRbacMutation>;
export type UpdateRbacMutationOptions = Apollo.BaseMutationOptions<UpdateRbacMutation, UpdateRbacMutationVariables>;
export const ServiceAccountsDocument = gql`
    query ServiceAccounts($q: String, $first: Int = 100, $after: String) {
  serviceAccounts(q: $q, first: $first, after: $after) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...User
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${UserFragmentDoc}`;

/**
 * __useServiceAccountsQuery__
 *
 * To run a query within a React component, call `useServiceAccountsQuery` and pass it any options that fit your needs.
 * When your component renders, `useServiceAccountsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useServiceAccountsQuery({
 *   variables: {
 *      q: // value for 'q'
 *      first: // value for 'first'
 *      after: // value for 'after'
 *   },
 * });
 */
export function useServiceAccountsQuery(baseOptions?: Apollo.QueryHookOptions<ServiceAccountsQuery, ServiceAccountsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ServiceAccountsQuery, ServiceAccountsQueryVariables>(ServiceAccountsDocument, options);
      }
export function useServiceAccountsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ServiceAccountsQuery, ServiceAccountsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ServiceAccountsQuery, ServiceAccountsQueryVariables>(ServiceAccountsDocument, options);
        }
export function useServiceAccountsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ServiceAccountsQuery, ServiceAccountsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ServiceAccountsQuery, ServiceAccountsQueryVariables>(ServiceAccountsDocument, options);
        }
export type ServiceAccountsQueryHookResult = ReturnType<typeof useServiceAccountsQuery>;
export type ServiceAccountsLazyQueryHookResult = ReturnType<typeof useServiceAccountsLazyQuery>;
export type ServiceAccountsSuspenseQueryHookResult = ReturnType<typeof useServiceAccountsSuspenseQuery>;
export type ServiceAccountsQueryResult = Apollo.QueryResult<ServiceAccountsQuery, ServiceAccountsQueryVariables>;
export const CreateServiceAccountDocument = gql`
    mutation CreateServiceAccount($attributes: ServiceAccountAttributes!) {
  createServiceAccount(attributes: $attributes) {
    ...User
  }
}
    ${UserFragmentDoc}`;
export type CreateServiceAccountMutationFn = Apollo.MutationFunction<CreateServiceAccountMutation, CreateServiceAccountMutationVariables>;

/**
 * __useCreateServiceAccountMutation__
 *
 * To run a mutation, you first call `useCreateServiceAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateServiceAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createServiceAccountMutation, { data, loading, error }] = useCreateServiceAccountMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useCreateServiceAccountMutation(baseOptions?: Apollo.MutationHookOptions<CreateServiceAccountMutation, CreateServiceAccountMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateServiceAccountMutation, CreateServiceAccountMutationVariables>(CreateServiceAccountDocument, options);
      }
export type CreateServiceAccountMutationHookResult = ReturnType<typeof useCreateServiceAccountMutation>;
export type CreateServiceAccountMutationResult = Apollo.MutationResult<CreateServiceAccountMutation>;
export type CreateServiceAccountMutationOptions = Apollo.BaseMutationOptions<CreateServiceAccountMutation, CreateServiceAccountMutationVariables>;
export const UpdateServiceAccountDocument = gql`
    mutation UpdateServiceAccount($id: ID!, $attributes: ServiceAccountAttributes!) {
  updateServiceAccount(id: $id, attributes: $attributes) {
    ...User
  }
}
    ${UserFragmentDoc}`;
export type UpdateServiceAccountMutationFn = Apollo.MutationFunction<UpdateServiceAccountMutation, UpdateServiceAccountMutationVariables>;

/**
 * __useUpdateServiceAccountMutation__
 *
 * To run a mutation, you first call `useUpdateServiceAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateServiceAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateServiceAccountMutation, { data, loading, error }] = useUpdateServiceAccountMutation({
 *   variables: {
 *      id: // value for 'id'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpdateServiceAccountMutation(baseOptions?: Apollo.MutationHookOptions<UpdateServiceAccountMutation, UpdateServiceAccountMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateServiceAccountMutation, UpdateServiceAccountMutationVariables>(UpdateServiceAccountDocument, options);
      }
export type UpdateServiceAccountMutationHookResult = ReturnType<typeof useUpdateServiceAccountMutation>;
export type UpdateServiceAccountMutationResult = Apollo.MutationResult<UpdateServiceAccountMutation>;
export type UpdateServiceAccountMutationOptions = Apollo.BaseMutationOptions<UpdateServiceAccountMutation, UpdateServiceAccountMutationVariables>;
export const StackPrsDocument = gql`
    query StackPrs($id: ID!, $after: String, $before: String, $first: Int = 100, $last: Int) {
  infrastructureStack(id: $id) {
    id
    pullRequests(after: $after, before: $before, first: $first, last: $last) {
      pageInfo {
        ...PageInfo
      }
      edges {
        node {
          ...PullRequest
        }
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${PullRequestFragmentDoc}`;

/**
 * __useStackPrsQuery__
 *
 * To run a query within a React component, call `useStackPrsQuery` and pass it any options that fit your needs.
 * When your component renders, `useStackPrsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStackPrsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useStackPrsQuery(baseOptions: Apollo.QueryHookOptions<StackPrsQuery, StackPrsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StackPrsQuery, StackPrsQueryVariables>(StackPrsDocument, options);
      }
export function useStackPrsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StackPrsQuery, StackPrsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StackPrsQuery, StackPrsQueryVariables>(StackPrsDocument, options);
        }
export function useStackPrsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<StackPrsQuery, StackPrsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<StackPrsQuery, StackPrsQueryVariables>(StackPrsDocument, options);
        }
export type StackPrsQueryHookResult = ReturnType<typeof useStackPrsQuery>;
export type StackPrsLazyQueryHookResult = ReturnType<typeof useStackPrsLazyQuery>;
export type StackPrsSuspenseQueryHookResult = ReturnType<typeof useStackPrsSuspenseQuery>;
export type StackPrsQueryResult = Apollo.QueryResult<StackPrsQuery, StackPrsQueryVariables>;
export const StacksDocument = gql`
    query Stacks($q: String, $after: String, $before: String, $first: Int = 100, $last: Int, $projectId: ID, $tagQuery: TagQuery) {
  infrastructureStacks(
    q: $q
    after: $after
    before: $before
    first: $first
    last: $last
    projectId: $projectId
    tagQuery: $tagQuery
  ) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...StackTiny
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${StackTinyFragmentDoc}`;

/**
 * __useStacksQuery__
 *
 * To run a query within a React component, call `useStacksQuery` and pass it any options that fit your needs.
 * When your component renders, `useStacksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStacksQuery({
 *   variables: {
 *      q: // value for 'q'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      projectId: // value for 'projectId'
 *      tagQuery: // value for 'tagQuery'
 *   },
 * });
 */
export function useStacksQuery(baseOptions?: Apollo.QueryHookOptions<StacksQuery, StacksQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StacksQuery, StacksQueryVariables>(StacksDocument, options);
      }
export function useStacksLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StacksQuery, StacksQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StacksQuery, StacksQueryVariables>(StacksDocument, options);
        }
export function useStacksSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<StacksQuery, StacksQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<StacksQuery, StacksQueryVariables>(StacksDocument, options);
        }
export type StacksQueryHookResult = ReturnType<typeof useStacksQuery>;
export type StacksLazyQueryHookResult = ReturnType<typeof useStacksLazyQuery>;
export type StacksSuspenseQueryHookResult = ReturnType<typeof useStacksSuspenseQuery>;
export type StacksQueryResult = Apollo.QueryResult<StacksQuery, StacksQueryVariables>;
export const StackDocument = gql`
    query Stack($id: ID!) {
  infrastructureStack(id: $id) {
    ...Stack
  }
}
    ${StackFragmentDoc}`;

/**
 * __useStackQuery__
 *
 * To run a query within a React component, call `useStackQuery` and pass it any options that fit your needs.
 * When your component renders, `useStackQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStackQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useStackQuery(baseOptions: Apollo.QueryHookOptions<StackQuery, StackQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StackQuery, StackQueryVariables>(StackDocument, options);
      }
export function useStackLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StackQuery, StackQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StackQuery, StackQueryVariables>(StackDocument, options);
        }
export function useStackSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<StackQuery, StackQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<StackQuery, StackQueryVariables>(StackDocument, options);
        }
export type StackQueryHookResult = ReturnType<typeof useStackQuery>;
export type StackLazyQueryHookResult = ReturnType<typeof useStackLazyQuery>;
export type StackSuspenseQueryHookResult = ReturnType<typeof useStackSuspenseQuery>;
export type StackQueryResult = Apollo.QueryResult<StackQuery, StackQueryVariables>;
export const StackTinyDocument = gql`
    query StackTiny($id: ID!) {
  infrastructureStack(id: $id) {
    ...StackTiny
  }
}
    ${StackTinyFragmentDoc}`;

/**
 * __useStackTinyQuery__
 *
 * To run a query within a React component, call `useStackTinyQuery` and pass it any options that fit your needs.
 * When your component renders, `useStackTinyQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStackTinyQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useStackTinyQuery(baseOptions: Apollo.QueryHookOptions<StackTinyQuery, StackTinyQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StackTinyQuery, StackTinyQueryVariables>(StackTinyDocument, options);
      }
export function useStackTinyLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StackTinyQuery, StackTinyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StackTinyQuery, StackTinyQueryVariables>(StackTinyDocument, options);
        }
export function useStackTinySuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<StackTinyQuery, StackTinyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<StackTinyQuery, StackTinyQueryVariables>(StackTinyDocument, options);
        }
export type StackTinyQueryHookResult = ReturnType<typeof useStackTinyQuery>;
export type StackTinyLazyQueryHookResult = ReturnType<typeof useStackTinyLazyQuery>;
export type StackTinySuspenseQueryHookResult = ReturnType<typeof useStackTinySuspenseQuery>;
export type StackTinyQueryResult = Apollo.QueryResult<StackTinyQuery, StackTinyQueryVariables>;
export const StackStateDocument = gql`
    query StackState($id: ID!) {
  infrastructureStack(id: $id) {
    state {
      id
      plan
      state {
        name
        identifier
        configuration
        links
        resource
      }
    }
  }
}
    `;

/**
 * __useStackStateQuery__
 *
 * To run a query within a React component, call `useStackStateQuery` and pass it any options that fit your needs.
 * When your component renders, `useStackStateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStackStateQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useStackStateQuery(baseOptions: Apollo.QueryHookOptions<StackStateQuery, StackStateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StackStateQuery, StackStateQueryVariables>(StackStateDocument, options);
      }
export function useStackStateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StackStateQuery, StackStateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StackStateQuery, StackStateQueryVariables>(StackStateDocument, options);
        }
export function useStackStateSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<StackStateQuery, StackStateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<StackStateQuery, StackStateQueryVariables>(StackStateDocument, options);
        }
export type StackStateQueryHookResult = ReturnType<typeof useStackStateQuery>;
export type StackStateLazyQueryHookResult = ReturnType<typeof useStackStateLazyQuery>;
export type StackStateSuspenseQueryHookResult = ReturnType<typeof useStackStateSuspenseQuery>;
export type StackStateQueryResult = Apollo.QueryResult<StackStateQuery, StackStateQueryVariables>;
export const StackOutputDocument = gql`
    query StackOutput($id: ID!) {
  infrastructureStack(id: $id) {
    output {
      name
      secret
      value
    }
  }
}
    `;

/**
 * __useStackOutputQuery__
 *
 * To run a query within a React component, call `useStackOutputQuery` and pass it any options that fit your needs.
 * When your component renders, `useStackOutputQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStackOutputQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useStackOutputQuery(baseOptions: Apollo.QueryHookOptions<StackOutputQuery, StackOutputQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StackOutputQuery, StackOutputQueryVariables>(StackOutputDocument, options);
      }
export function useStackOutputLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StackOutputQuery, StackOutputQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StackOutputQuery, StackOutputQueryVariables>(StackOutputDocument, options);
        }
export function useStackOutputSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<StackOutputQuery, StackOutputQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<StackOutputQuery, StackOutputQueryVariables>(StackOutputDocument, options);
        }
export type StackOutputQueryHookResult = ReturnType<typeof useStackOutputQuery>;
export type StackOutputLazyQueryHookResult = ReturnType<typeof useStackOutputLazyQuery>;
export type StackOutputSuspenseQueryHookResult = ReturnType<typeof useStackOutputSuspenseQuery>;
export type StackOutputQueryResult = Apollo.QueryResult<StackOutputQuery, StackOutputQueryVariables>;
export const StackFilesDocument = gql`
    query StackFiles($id: ID!) {
  infrastructureStack(id: $id) {
    files {
      path
      content
    }
  }
}
    `;

/**
 * __useStackFilesQuery__
 *
 * To run a query within a React component, call `useStackFilesQuery` and pass it any options that fit your needs.
 * When your component renders, `useStackFilesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStackFilesQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useStackFilesQuery(baseOptions: Apollo.QueryHookOptions<StackFilesQuery, StackFilesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StackFilesQuery, StackFilesQueryVariables>(StackFilesDocument, options);
      }
export function useStackFilesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StackFilesQuery, StackFilesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StackFilesQuery, StackFilesQueryVariables>(StackFilesDocument, options);
        }
export function useStackFilesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<StackFilesQuery, StackFilesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<StackFilesQuery, StackFilesQueryVariables>(StackFilesDocument, options);
        }
export type StackFilesQueryHookResult = ReturnType<typeof useStackFilesQuery>;
export type StackFilesLazyQueryHookResult = ReturnType<typeof useStackFilesLazyQuery>;
export type StackFilesSuspenseQueryHookResult = ReturnType<typeof useStackFilesSuspenseQuery>;
export type StackFilesQueryResult = Apollo.QueryResult<StackFilesQuery, StackFilesQueryVariables>;
export const StackBindingsDocument = gql`
    query StackBindings($id: ID!) {
  infrastructureStack(id: $id) {
    writeBindings {
      ...PolicyBinding
    }
    readBindings {
      ...PolicyBinding
    }
  }
}
    ${PolicyBindingFragmentDoc}`;

/**
 * __useStackBindingsQuery__
 *
 * To run a query within a React component, call `useStackBindingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useStackBindingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStackBindingsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useStackBindingsQuery(baseOptions: Apollo.QueryHookOptions<StackBindingsQuery, StackBindingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StackBindingsQuery, StackBindingsQueryVariables>(StackBindingsDocument, options);
      }
export function useStackBindingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StackBindingsQuery, StackBindingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StackBindingsQuery, StackBindingsQueryVariables>(StackBindingsDocument, options);
        }
export function useStackBindingsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<StackBindingsQuery, StackBindingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<StackBindingsQuery, StackBindingsQueryVariables>(StackBindingsDocument, options);
        }
export type StackBindingsQueryHookResult = ReturnType<typeof useStackBindingsQuery>;
export type StackBindingsLazyQueryHookResult = ReturnType<typeof useStackBindingsLazyQuery>;
export type StackBindingsSuspenseQueryHookResult = ReturnType<typeof useStackBindingsSuspenseQuery>;
export type StackBindingsQueryResult = Apollo.QueryResult<StackBindingsQuery, StackBindingsQueryVariables>;
export const StackRunsDocument = gql`
    query StackRuns($id: ID!, $after: String, $before: String, $first: Int = 100, $last: Int, $pullRequestId: ID) {
  infrastructureStack(id: $id) {
    id
    runs(
      after: $after
      before: $before
      first: $first
      last: $last
      pullRequestId: $pullRequestId
    ) {
      pageInfo {
        ...PageInfo
      }
      edges {
        node {
          ...StackRun
        }
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${StackRunFragmentDoc}`;

/**
 * __useStackRunsQuery__
 *
 * To run a query within a React component, call `useStackRunsQuery` and pass it any options that fit your needs.
 * When your component renders, `useStackRunsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStackRunsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      pullRequestId: // value for 'pullRequestId'
 *   },
 * });
 */
export function useStackRunsQuery(baseOptions: Apollo.QueryHookOptions<StackRunsQuery, StackRunsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StackRunsQuery, StackRunsQueryVariables>(StackRunsDocument, options);
      }
export function useStackRunsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StackRunsQuery, StackRunsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StackRunsQuery, StackRunsQueryVariables>(StackRunsDocument, options);
        }
export function useStackRunsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<StackRunsQuery, StackRunsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<StackRunsQuery, StackRunsQueryVariables>(StackRunsDocument, options);
        }
export type StackRunsQueryHookResult = ReturnType<typeof useStackRunsQuery>;
export type StackRunsLazyQueryHookResult = ReturnType<typeof useStackRunsLazyQuery>;
export type StackRunsSuspenseQueryHookResult = ReturnType<typeof useStackRunsSuspenseQuery>;
export type StackRunsQueryResult = Apollo.QueryResult<StackRunsQuery, StackRunsQueryVariables>;
export const StackRunDocument = gql`
    query StackRun($id: ID!) {
  stackRun(id: $id) {
    ...StackRunDetails
  }
}
    ${StackRunDetailsFragmentDoc}`;

/**
 * __useStackRunQuery__
 *
 * To run a query within a React component, call `useStackRunQuery` and pass it any options that fit your needs.
 * When your component renders, `useStackRunQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStackRunQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useStackRunQuery(baseOptions: Apollo.QueryHookOptions<StackRunQuery, StackRunQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StackRunQuery, StackRunQueryVariables>(StackRunDocument, options);
      }
export function useStackRunLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StackRunQuery, StackRunQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StackRunQuery, StackRunQueryVariables>(StackRunDocument, options);
        }
export function useStackRunSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<StackRunQuery, StackRunQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<StackRunQuery, StackRunQueryVariables>(StackRunDocument, options);
        }
export type StackRunQueryHookResult = ReturnType<typeof useStackRunQuery>;
export type StackRunLazyQueryHookResult = ReturnType<typeof useStackRunLazyQuery>;
export type StackRunSuspenseQueryHookResult = ReturnType<typeof useStackRunSuspenseQuery>;
export type StackRunQueryResult = Apollo.QueryResult<StackRunQuery, StackRunQueryVariables>;
export const StackRunJobDocument = gql`
    query StackRunJob($id: ID!) {
  stackRun(id: $id) {
    job {
      ...PipelineGateJob
    }
  }
}
    ${PipelineGateJobFragmentDoc}`;

/**
 * __useStackRunJobQuery__
 *
 * To run a query within a React component, call `useStackRunJobQuery` and pass it any options that fit your needs.
 * When your component renders, `useStackRunJobQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStackRunJobQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useStackRunJobQuery(baseOptions: Apollo.QueryHookOptions<StackRunJobQuery, StackRunJobQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StackRunJobQuery, StackRunJobQueryVariables>(StackRunJobDocument, options);
      }
export function useStackRunJobLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StackRunJobQuery, StackRunJobQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StackRunJobQuery, StackRunJobQueryVariables>(StackRunJobDocument, options);
        }
export function useStackRunJobSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<StackRunJobQuery, StackRunJobQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<StackRunJobQuery, StackRunJobQueryVariables>(StackRunJobDocument, options);
        }
export type StackRunJobQueryHookResult = ReturnType<typeof useStackRunJobQuery>;
export type StackRunJobLazyQueryHookResult = ReturnType<typeof useStackRunJobLazyQuery>;
export type StackRunJobSuspenseQueryHookResult = ReturnType<typeof useStackRunJobSuspenseQuery>;
export type StackRunJobQueryResult = Apollo.QueryResult<StackRunJobQuery, StackRunJobQueryVariables>;
export const StackRunJobLogsDocument = gql`
    query StackRunJobLogs($id: ID!, $container: String!, $sinceSeconds: Int!) {
  stackRun(id: $id) {
    job {
      logs(container: $container, sinceSeconds: $sinceSeconds)
    }
  }
}
    `;

/**
 * __useStackRunJobLogsQuery__
 *
 * To run a query within a React component, call `useStackRunJobLogsQuery` and pass it any options that fit your needs.
 * When your component renders, `useStackRunJobLogsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStackRunJobLogsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      container: // value for 'container'
 *      sinceSeconds: // value for 'sinceSeconds'
 *   },
 * });
 */
export function useStackRunJobLogsQuery(baseOptions: Apollo.QueryHookOptions<StackRunJobLogsQuery, StackRunJobLogsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StackRunJobLogsQuery, StackRunJobLogsQueryVariables>(StackRunJobLogsDocument, options);
      }
export function useStackRunJobLogsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StackRunJobLogsQuery, StackRunJobLogsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StackRunJobLogsQuery, StackRunJobLogsQueryVariables>(StackRunJobLogsDocument, options);
        }
export function useStackRunJobLogsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<StackRunJobLogsQuery, StackRunJobLogsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<StackRunJobLogsQuery, StackRunJobLogsQueryVariables>(StackRunJobLogsDocument, options);
        }
export type StackRunJobLogsQueryHookResult = ReturnType<typeof useStackRunJobLogsQuery>;
export type StackRunJobLogsLazyQueryHookResult = ReturnType<typeof useStackRunJobLogsLazyQuery>;
export type StackRunJobLogsSuspenseQueryHookResult = ReturnType<typeof useStackRunJobLogsSuspenseQuery>;
export type StackRunJobLogsQueryResult = Apollo.QueryResult<StackRunJobLogsQuery, StackRunJobLogsQueryVariables>;
export const CustomStackRunsDocument = gql`
    query CustomStackRuns($id: ID!, $after: String, $before: String, $first: Int = 100, $last: Int) {
  infrastructureStack(id: $id) {
    id
    customStackRuns(after: $after, before: $before, first: $first, last: $last) {
      pageInfo {
        ...PageInfo
      }
      edges {
        node {
          ...CustomStackRun
        }
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${CustomStackRunFragmentDoc}`;

/**
 * __useCustomStackRunsQuery__
 *
 * To run a query within a React component, call `useCustomStackRunsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCustomStackRunsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCustomStackRunsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useCustomStackRunsQuery(baseOptions: Apollo.QueryHookOptions<CustomStackRunsQuery, CustomStackRunsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CustomStackRunsQuery, CustomStackRunsQueryVariables>(CustomStackRunsDocument, options);
      }
export function useCustomStackRunsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CustomStackRunsQuery, CustomStackRunsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CustomStackRunsQuery, CustomStackRunsQueryVariables>(CustomStackRunsDocument, options);
        }
export function useCustomStackRunsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<CustomStackRunsQuery, CustomStackRunsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CustomStackRunsQuery, CustomStackRunsQueryVariables>(CustomStackRunsDocument, options);
        }
export type CustomStackRunsQueryHookResult = ReturnType<typeof useCustomStackRunsQuery>;
export type CustomStackRunsLazyQueryHookResult = ReturnType<typeof useCustomStackRunsLazyQuery>;
export type CustomStackRunsSuspenseQueryHookResult = ReturnType<typeof useCustomStackRunsSuspenseQuery>;
export type CustomStackRunsQueryResult = Apollo.QueryResult<CustomStackRunsQuery, CustomStackRunsQueryVariables>;
export const CreateStackDocument = gql`
    mutation CreateStack($attributes: StackAttributes!) {
  createStack(attributes: $attributes) {
    id
  }
}
    `;
export type CreateStackMutationFn = Apollo.MutationFunction<CreateStackMutation, CreateStackMutationVariables>;

/**
 * __useCreateStackMutation__
 *
 * To run a mutation, you first call `useCreateStackMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateStackMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createStackMutation, { data, loading, error }] = useCreateStackMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useCreateStackMutation(baseOptions?: Apollo.MutationHookOptions<CreateStackMutation, CreateStackMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateStackMutation, CreateStackMutationVariables>(CreateStackDocument, options);
      }
export type CreateStackMutationHookResult = ReturnType<typeof useCreateStackMutation>;
export type CreateStackMutationResult = Apollo.MutationResult<CreateStackMutation>;
export type CreateStackMutationOptions = Apollo.BaseMutationOptions<CreateStackMutation, CreateStackMutationVariables>;
export const CreateOnDemandRunDocument = gql`
    mutation CreateOnDemandRun($stackId: ID!, $context: Json, $commands: [CommandAttributes]) {
  onDemandRun(stackId: $stackId, context: $context, commands: $commands) {
    ...StackRun
  }
}
    ${StackRunFragmentDoc}`;
export type CreateOnDemandRunMutationFn = Apollo.MutationFunction<CreateOnDemandRunMutation, CreateOnDemandRunMutationVariables>;

/**
 * __useCreateOnDemandRunMutation__
 *
 * To run a mutation, you first call `useCreateOnDemandRunMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOnDemandRunMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOnDemandRunMutation, { data, loading, error }] = useCreateOnDemandRunMutation({
 *   variables: {
 *      stackId: // value for 'stackId'
 *      context: // value for 'context'
 *      commands: // value for 'commands'
 *   },
 * });
 */
export function useCreateOnDemandRunMutation(baseOptions?: Apollo.MutationHookOptions<CreateOnDemandRunMutation, CreateOnDemandRunMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateOnDemandRunMutation, CreateOnDemandRunMutationVariables>(CreateOnDemandRunDocument, options);
      }
export type CreateOnDemandRunMutationHookResult = ReturnType<typeof useCreateOnDemandRunMutation>;
export type CreateOnDemandRunMutationResult = Apollo.MutationResult<CreateOnDemandRunMutation>;
export type CreateOnDemandRunMutationOptions = Apollo.BaseMutationOptions<CreateOnDemandRunMutation, CreateOnDemandRunMutationVariables>;
export const UpdateStackDocument = gql`
    mutation UpdateStack($id: ID!, $attributes: StackAttributes!) {
  updateStack(id: $id, attributes: $attributes) {
    id
  }
}
    `;
export type UpdateStackMutationFn = Apollo.MutationFunction<UpdateStackMutation, UpdateStackMutationVariables>;

/**
 * __useUpdateStackMutation__
 *
 * To run a mutation, you first call `useUpdateStackMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateStackMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateStackMutation, { data, loading, error }] = useUpdateStackMutation({
 *   variables: {
 *      id: // value for 'id'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpdateStackMutation(baseOptions?: Apollo.MutationHookOptions<UpdateStackMutation, UpdateStackMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateStackMutation, UpdateStackMutationVariables>(UpdateStackDocument, options);
      }
export type UpdateStackMutationHookResult = ReturnType<typeof useUpdateStackMutation>;
export type UpdateStackMutationResult = Apollo.MutationResult<UpdateStackMutation>;
export type UpdateStackMutationOptions = Apollo.BaseMutationOptions<UpdateStackMutation, UpdateStackMutationVariables>;
export const DetachStackDocument = gql`
    mutation DetachStack($id: ID!) {
  detachStack(id: $id) {
    id
  }
}
    `;
export type DetachStackMutationFn = Apollo.MutationFunction<DetachStackMutation, DetachStackMutationVariables>;

/**
 * __useDetachStackMutation__
 *
 * To run a mutation, you first call `useDetachStackMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDetachStackMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [detachStackMutation, { data, loading, error }] = useDetachStackMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDetachStackMutation(baseOptions?: Apollo.MutationHookOptions<DetachStackMutation, DetachStackMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DetachStackMutation, DetachStackMutationVariables>(DetachStackDocument, options);
      }
export type DetachStackMutationHookResult = ReturnType<typeof useDetachStackMutation>;
export type DetachStackMutationResult = Apollo.MutationResult<DetachStackMutation>;
export type DetachStackMutationOptions = Apollo.BaseMutationOptions<DetachStackMutation, DetachStackMutationVariables>;
export const DeleteStackDocument = gql`
    mutation DeleteStack($id: ID!) {
  deleteStack(id: $id) {
    id
  }
}
    `;
export type DeleteStackMutationFn = Apollo.MutationFunction<DeleteStackMutation, DeleteStackMutationVariables>;

/**
 * __useDeleteStackMutation__
 *
 * To run a mutation, you first call `useDeleteStackMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteStackMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteStackMutation, { data, loading, error }] = useDeleteStackMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteStackMutation(baseOptions?: Apollo.MutationHookOptions<DeleteStackMutation, DeleteStackMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteStackMutation, DeleteStackMutationVariables>(DeleteStackDocument, options);
      }
export type DeleteStackMutationHookResult = ReturnType<typeof useDeleteStackMutation>;
export type DeleteStackMutationResult = Apollo.MutationResult<DeleteStackMutation>;
export type DeleteStackMutationOptions = Apollo.BaseMutationOptions<DeleteStackMutation, DeleteStackMutationVariables>;
export const KickStackDocument = gql`
    mutation KickStack($id: ID!) {
  kickStack(id: $id) {
    ...StackRun
  }
}
    ${StackRunFragmentDoc}`;
export type KickStackMutationFn = Apollo.MutationFunction<KickStackMutation, KickStackMutationVariables>;

/**
 * __useKickStackMutation__
 *
 * To run a mutation, you first call `useKickStackMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useKickStackMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [kickStackMutation, { data, loading, error }] = useKickStackMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useKickStackMutation(baseOptions?: Apollo.MutationHookOptions<KickStackMutation, KickStackMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<KickStackMutation, KickStackMutationVariables>(KickStackDocument, options);
      }
export type KickStackMutationHookResult = ReturnType<typeof useKickStackMutation>;
export type KickStackMutationResult = Apollo.MutationResult<KickStackMutation>;
export type KickStackMutationOptions = Apollo.BaseMutationOptions<KickStackMutation, KickStackMutationVariables>;
export const KickStackPullRequestDocument = gql`
    mutation kickStackPullRequest($id: ID!) {
  kickStackPullRequest(id: $id) {
    ...StackRun
  }
}
    ${StackRunFragmentDoc}`;
export type KickStackPullRequestMutationFn = Apollo.MutationFunction<KickStackPullRequestMutation, KickStackPullRequestMutationVariables>;

/**
 * __useKickStackPullRequestMutation__
 *
 * To run a mutation, you first call `useKickStackPullRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useKickStackPullRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [kickStackPullRequestMutation, { data, loading, error }] = useKickStackPullRequestMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useKickStackPullRequestMutation(baseOptions?: Apollo.MutationHookOptions<KickStackPullRequestMutation, KickStackPullRequestMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<KickStackPullRequestMutation, KickStackPullRequestMutationVariables>(KickStackPullRequestDocument, options);
      }
export type KickStackPullRequestMutationHookResult = ReturnType<typeof useKickStackPullRequestMutation>;
export type KickStackPullRequestMutationResult = Apollo.MutationResult<KickStackPullRequestMutation>;
export type KickStackPullRequestMutationOptions = Apollo.BaseMutationOptions<KickStackPullRequestMutation, KickStackPullRequestMutationVariables>;
export const UpdateStackRunDocument = gql`
    mutation UpdateStackRun($id: ID!, $attributes: StackRunAttributes!) {
  updateStackRun(id: $id, attributes: $attributes) {
    ...StackRun
  }
}
    ${StackRunFragmentDoc}`;
export type UpdateStackRunMutationFn = Apollo.MutationFunction<UpdateStackRunMutation, UpdateStackRunMutationVariables>;

/**
 * __useUpdateStackRunMutation__
 *
 * To run a mutation, you first call `useUpdateStackRunMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateStackRunMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateStackRunMutation, { data, loading, error }] = useUpdateStackRunMutation({
 *   variables: {
 *      id: // value for 'id'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpdateStackRunMutation(baseOptions?: Apollo.MutationHookOptions<UpdateStackRunMutation, UpdateStackRunMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateStackRunMutation, UpdateStackRunMutationVariables>(UpdateStackRunDocument, options);
      }
export type UpdateStackRunMutationHookResult = ReturnType<typeof useUpdateStackRunMutation>;
export type UpdateStackRunMutationResult = Apollo.MutationResult<UpdateStackRunMutation>;
export type UpdateStackRunMutationOptions = Apollo.BaseMutationOptions<UpdateStackRunMutation, UpdateStackRunMutationVariables>;
export const CompleteStackRunDocument = gql`
    mutation CompleteStackRun($id: ID!, $attributes: StackRunAttributes!) {
  completeStackRun(id: $id, attributes: $attributes) {
    ...StackRun
  }
}
    ${StackRunFragmentDoc}`;
export type CompleteStackRunMutationFn = Apollo.MutationFunction<CompleteStackRunMutation, CompleteStackRunMutationVariables>;

/**
 * __useCompleteStackRunMutation__
 *
 * To run a mutation, you first call `useCompleteStackRunMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCompleteStackRunMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [completeStackRunMutation, { data, loading, error }] = useCompleteStackRunMutation({
 *   variables: {
 *      id: // value for 'id'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useCompleteStackRunMutation(baseOptions?: Apollo.MutationHookOptions<CompleteStackRunMutation, CompleteStackRunMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CompleteStackRunMutation, CompleteStackRunMutationVariables>(CompleteStackRunDocument, options);
      }
export type CompleteStackRunMutationHookResult = ReturnType<typeof useCompleteStackRunMutation>;
export type CompleteStackRunMutationResult = Apollo.MutationResult<CompleteStackRunMutation>;
export type CompleteStackRunMutationOptions = Apollo.BaseMutationOptions<CompleteStackRunMutation, CompleteStackRunMutationVariables>;
export const ApproveStackRunDocument = gql`
    mutation ApproveStackRun($id: ID!) {
  approveStackRun(id: $id) {
    ...StackRun
  }
}
    ${StackRunFragmentDoc}`;
export type ApproveStackRunMutationFn = Apollo.MutationFunction<ApproveStackRunMutation, ApproveStackRunMutationVariables>;

/**
 * __useApproveStackRunMutation__
 *
 * To run a mutation, you first call `useApproveStackRunMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useApproveStackRunMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [approveStackRunMutation, { data, loading, error }] = useApproveStackRunMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useApproveStackRunMutation(baseOptions?: Apollo.MutationHookOptions<ApproveStackRunMutation, ApproveStackRunMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ApproveStackRunMutation, ApproveStackRunMutationVariables>(ApproveStackRunDocument, options);
      }
export type ApproveStackRunMutationHookResult = ReturnType<typeof useApproveStackRunMutation>;
export type ApproveStackRunMutationResult = Apollo.MutationResult<ApproveStackRunMutation>;
export type ApproveStackRunMutationOptions = Apollo.BaseMutationOptions<ApproveStackRunMutation, ApproveStackRunMutationVariables>;
export const RestartStackRunDocument = gql`
    mutation RestartStackRun($id: ID!) {
  restartStackRun(id: $id) {
    ...StackRun
  }
}
    ${StackRunFragmentDoc}`;
export type RestartStackRunMutationFn = Apollo.MutationFunction<RestartStackRunMutation, RestartStackRunMutationVariables>;

/**
 * __useRestartStackRunMutation__
 *
 * To run a mutation, you first call `useRestartStackRunMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRestartStackRunMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [restartStackRunMutation, { data, loading, error }] = useRestartStackRunMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRestartStackRunMutation(baseOptions?: Apollo.MutationHookOptions<RestartStackRunMutation, RestartStackRunMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RestartStackRunMutation, RestartStackRunMutationVariables>(RestartStackRunDocument, options);
      }
export type RestartStackRunMutationHookResult = ReturnType<typeof useRestartStackRunMutation>;
export type RestartStackRunMutationResult = Apollo.MutationResult<RestartStackRunMutation>;
export type RestartStackRunMutationOptions = Apollo.BaseMutationOptions<RestartStackRunMutation, RestartStackRunMutationVariables>;
export const RestoreStackDocument = gql`
    mutation RestoreStack($id: ID!) {
  restoreStack(id: $id) {
    ...StackTiny
  }
}
    ${StackTinyFragmentDoc}`;
export type RestoreStackMutationFn = Apollo.MutationFunction<RestoreStackMutation, RestoreStackMutationVariables>;

/**
 * __useRestoreStackMutation__
 *
 * To run a mutation, you first call `useRestoreStackMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRestoreStackMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [restoreStackMutation, { data, loading, error }] = useRestoreStackMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRestoreStackMutation(baseOptions?: Apollo.MutationHookOptions<RestoreStackMutation, RestoreStackMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RestoreStackMutation, RestoreStackMutationVariables>(RestoreStackDocument, options);
      }
export type RestoreStackMutationHookResult = ReturnType<typeof useRestoreStackMutation>;
export type RestoreStackMutationResult = Apollo.MutationResult<RestoreStackMutation>;
export type RestoreStackMutationOptions = Apollo.BaseMutationOptions<RestoreStackMutation, RestoreStackMutationVariables>;
export const LogsDeltaDocument = gql`
    subscription LogsDelta($id: ID!) {
  runLogsDelta(stepId: $id) {
    delta
    payload {
      id
      logs
      insertedAt
      updatedAt
    }
  }
}
    `;

/**
 * __useLogsDeltaSubscription__
 *
 * To run a query within a React component, call `useLogsDeltaSubscription` and pass it any options that fit your needs.
 * When your component renders, `useLogsDeltaSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLogsDeltaSubscription({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useLogsDeltaSubscription(baseOptions: Apollo.SubscriptionHookOptions<LogsDeltaSubscription, LogsDeltaSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<LogsDeltaSubscription, LogsDeltaSubscriptionVariables>(LogsDeltaDocument, options);
      }
export type LogsDeltaSubscriptionHookResult = ReturnType<typeof useLogsDeltaSubscription>;
export type LogsDeltaSubscriptionResult = Apollo.SubscriptionResult<LogsDeltaSubscription>;
export const AccessTokensDocument = gql`
    query AccessTokens {
  accessTokens(first: 500) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...AccessToken
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${AccessTokenFragmentDoc}`;

/**
 * __useAccessTokensQuery__
 *
 * To run a query within a React component, call `useAccessTokensQuery` and pass it any options that fit your needs.
 * When your component renders, `useAccessTokensQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAccessTokensQuery({
 *   variables: {
 *   },
 * });
 */
export function useAccessTokensQuery(baseOptions?: Apollo.QueryHookOptions<AccessTokensQuery, AccessTokensQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AccessTokensQuery, AccessTokensQueryVariables>(AccessTokensDocument, options);
      }
export function useAccessTokensLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AccessTokensQuery, AccessTokensQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AccessTokensQuery, AccessTokensQueryVariables>(AccessTokensDocument, options);
        }
export function useAccessTokensSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AccessTokensQuery, AccessTokensQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AccessTokensQuery, AccessTokensQueryVariables>(AccessTokensDocument, options);
        }
export type AccessTokensQueryHookResult = ReturnType<typeof useAccessTokensQuery>;
export type AccessTokensLazyQueryHookResult = ReturnType<typeof useAccessTokensLazyQuery>;
export type AccessTokensSuspenseQueryHookResult = ReturnType<typeof useAccessTokensSuspenseQuery>;
export type AccessTokensQueryResult = Apollo.QueryResult<AccessTokensQuery, AccessTokensQueryVariables>;
export const TokenAuditsDocument = gql`
    query TokenAudits($id: ID!, $cursor: String) {
  accessToken(id: $id) {
    id
    audits(first: 500, after: $cursor) {
      pageInfo {
        ...PageInfo
      }
      edges {
        node {
          ...AccessTokenAudit
        }
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${AccessTokenAuditFragmentDoc}`;

/**
 * __useTokenAuditsQuery__
 *
 * To run a query within a React component, call `useTokenAuditsQuery` and pass it any options that fit your needs.
 * When your component renders, `useTokenAuditsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTokenAuditsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useTokenAuditsQuery(baseOptions: Apollo.QueryHookOptions<TokenAuditsQuery, TokenAuditsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TokenAuditsQuery, TokenAuditsQueryVariables>(TokenAuditsDocument, options);
      }
export function useTokenAuditsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TokenAuditsQuery, TokenAuditsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TokenAuditsQuery, TokenAuditsQueryVariables>(TokenAuditsDocument, options);
        }
export function useTokenAuditsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<TokenAuditsQuery, TokenAuditsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<TokenAuditsQuery, TokenAuditsQueryVariables>(TokenAuditsDocument, options);
        }
export type TokenAuditsQueryHookResult = ReturnType<typeof useTokenAuditsQuery>;
export type TokenAuditsLazyQueryHookResult = ReturnType<typeof useTokenAuditsLazyQuery>;
export type TokenAuditsSuspenseQueryHookResult = ReturnType<typeof useTokenAuditsSuspenseQuery>;
export type TokenAuditsQueryResult = Apollo.QueryResult<TokenAuditsQuery, TokenAuditsQueryVariables>;
export const CreateAccessTokenDocument = gql`
    mutation CreateAccessToken($scopes: [ScopeAttributes]) {
  createAccessToken(scopes: $scopes) {
    ...AccessToken
    token
  }
}
    ${AccessTokenFragmentDoc}`;
export type CreateAccessTokenMutationFn = Apollo.MutationFunction<CreateAccessTokenMutation, CreateAccessTokenMutationVariables>;

/**
 * __useCreateAccessTokenMutation__
 *
 * To run a mutation, you first call `useCreateAccessTokenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateAccessTokenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createAccessTokenMutation, { data, loading, error }] = useCreateAccessTokenMutation({
 *   variables: {
 *      scopes: // value for 'scopes'
 *   },
 * });
 */
export function useCreateAccessTokenMutation(baseOptions?: Apollo.MutationHookOptions<CreateAccessTokenMutation, CreateAccessTokenMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateAccessTokenMutation, CreateAccessTokenMutationVariables>(CreateAccessTokenDocument, options);
      }
export type CreateAccessTokenMutationHookResult = ReturnType<typeof useCreateAccessTokenMutation>;
export type CreateAccessTokenMutationResult = Apollo.MutationResult<CreateAccessTokenMutation>;
export type CreateAccessTokenMutationOptions = Apollo.BaseMutationOptions<CreateAccessTokenMutation, CreateAccessTokenMutationVariables>;
export const DeleteAccessTokenDocument = gql`
    mutation DeleteAccessToken($id: ID!) {
  deleteAccessToken(id: $id) {
    ...AccessToken
  }
}
    ${AccessTokenFragmentDoc}`;
export type DeleteAccessTokenMutationFn = Apollo.MutationFunction<DeleteAccessTokenMutation, DeleteAccessTokenMutationVariables>;

/**
 * __useDeleteAccessTokenMutation__
 *
 * To run a mutation, you first call `useDeleteAccessTokenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteAccessTokenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteAccessTokenMutation, { data, loading, error }] = useDeleteAccessTokenMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteAccessTokenMutation(baseOptions?: Apollo.MutationHookOptions<DeleteAccessTokenMutation, DeleteAccessTokenMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteAccessTokenMutation, DeleteAccessTokenMutationVariables>(DeleteAccessTokenDocument, options);
      }
export type DeleteAccessTokenMutationHookResult = ReturnType<typeof useDeleteAccessTokenMutation>;
export type DeleteAccessTokenMutationResult = Apollo.MutationResult<DeleteAccessTokenMutation>;
export type DeleteAccessTokenMutationOptions = Apollo.BaseMutationOptions<DeleteAccessTokenMutation, DeleteAccessTokenMutationVariables>;
export const ShareSecretDocument = gql`
    mutation ShareSecret($attributes: SharedSecretAttributes!) {
  shareSecret(attributes: $attributes) {
    ...SharedSecret
  }
}
    ${SharedSecretFragmentDoc}`;
export type ShareSecretMutationFn = Apollo.MutationFunction<ShareSecretMutation, ShareSecretMutationVariables>;

/**
 * __useShareSecretMutation__
 *
 * To run a mutation, you first call `useShareSecretMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useShareSecretMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [shareSecretMutation, { data, loading, error }] = useShareSecretMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useShareSecretMutation(baseOptions?: Apollo.MutationHookOptions<ShareSecretMutation, ShareSecretMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ShareSecretMutation, ShareSecretMutationVariables>(ShareSecretDocument, options);
      }
export type ShareSecretMutationHookResult = ReturnType<typeof useShareSecretMutation>;
export type ShareSecretMutationResult = Apollo.MutationResult<ShareSecretMutation>;
export type ShareSecretMutationOptions = Apollo.BaseMutationOptions<ShareSecretMutation, ShareSecretMutationVariables>;
export const ConsumeSecretDocument = gql`
    mutation ConsumeSecret($handle: String!) {
  consumeSecret(handle: $handle) {
    ...SharedSecret
  }
}
    ${SharedSecretFragmentDoc}`;
export type ConsumeSecretMutationFn = Apollo.MutationFunction<ConsumeSecretMutation, ConsumeSecretMutationVariables>;

/**
 * __useConsumeSecretMutation__
 *
 * To run a mutation, you first call `useConsumeSecretMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useConsumeSecretMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [consumeSecretMutation, { data, loading, error }] = useConsumeSecretMutation({
 *   variables: {
 *      handle: // value for 'handle'
 *   },
 * });
 */
export function useConsumeSecretMutation(baseOptions?: Apollo.MutationHookOptions<ConsumeSecretMutation, ConsumeSecretMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ConsumeSecretMutation, ConsumeSecretMutationVariables>(ConsumeSecretDocument, options);
      }
export type ConsumeSecretMutationHookResult = ReturnType<typeof useConsumeSecretMutation>;
export type ConsumeSecretMutationResult = Apollo.MutationResult<ConsumeSecretMutation>;
export type ConsumeSecretMutationOptions = Apollo.BaseMutationOptions<ConsumeSecretMutation, ConsumeSecretMutationVariables>;
export const UsersDocument = gql`
    query Users($q: String, $after: String) {
  users(q: $q, first: 20, after: $after) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...User
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${UserFragmentDoc}`;

/**
 * __useUsersQuery__
 *
 * To run a query within a React component, call `useUsersQuery` and pass it any options that fit your needs.
 * When your component renders, `useUsersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUsersQuery({
 *   variables: {
 *      q: // value for 'q'
 *      after: // value for 'after'
 *   },
 * });
 */
export function useUsersQuery(baseOptions?: Apollo.QueryHookOptions<UsersQuery, UsersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UsersQuery, UsersQueryVariables>(UsersDocument, options);
      }
export function useUsersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UsersQuery, UsersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UsersQuery, UsersQueryVariables>(UsersDocument, options);
        }
export function useUsersSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<UsersQuery, UsersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<UsersQuery, UsersQueryVariables>(UsersDocument, options);
        }
export type UsersQueryHookResult = ReturnType<typeof useUsersQuery>;
export type UsersLazyQueryHookResult = ReturnType<typeof useUsersLazyQuery>;
export type UsersSuspenseQueryHookResult = ReturnType<typeof useUsersSuspenseQuery>;
export type UsersQueryResult = Apollo.QueryResult<UsersQuery, UsersQueryVariables>;
export const SearchUsersDocument = gql`
    query SearchUsers($q: String, $cursor: String) {
  users(q: $q, after: $cursor, first: 5) {
    pageInfo {
      ...PageInfo
    }
    edges {
      node {
        ...User
      }
    }
  }
}
    ${PageInfoFragmentDoc}
${UserFragmentDoc}`;

/**
 * __useSearchUsersQuery__
 *
 * To run a query within a React component, call `useSearchUsersQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchUsersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchUsersQuery({
 *   variables: {
 *      q: // value for 'q'
 *      cursor: // value for 'cursor'
 *   },
 * });
 */
export function useSearchUsersQuery(baseOptions?: Apollo.QueryHookOptions<SearchUsersQuery, SearchUsersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SearchUsersQuery, SearchUsersQueryVariables>(SearchUsersDocument, options);
      }
export function useSearchUsersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchUsersQuery, SearchUsersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SearchUsersQuery, SearchUsersQueryVariables>(SearchUsersDocument, options);
        }
export function useSearchUsersSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<SearchUsersQuery, SearchUsersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SearchUsersQuery, SearchUsersQueryVariables>(SearchUsersDocument, options);
        }
export type SearchUsersQueryHookResult = ReturnType<typeof useSearchUsersQuery>;
export type SearchUsersLazyQueryHookResult = ReturnType<typeof useSearchUsersLazyQuery>;
export type SearchUsersSuspenseQueryHookResult = ReturnType<typeof useSearchUsersSuspenseQuery>;
export type SearchUsersQueryResult = Apollo.QueryResult<SearchUsersQuery, SearchUsersQueryVariables>;
export const UpdateUserDocument = gql`
    mutation UpdateUser($id: ID, $attributes: UserAttributes!) {
  updateUser(id: $id, attributes: $attributes) {
    ...User
  }
}
    ${UserFragmentDoc}`;
export type UpdateUserMutationFn = Apollo.MutationFunction<UpdateUserMutation, UpdateUserMutationVariables>;

/**
 * __useUpdateUserMutation__
 *
 * To run a mutation, you first call `useUpdateUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUserMutation, { data, loading, error }] = useUpdateUserMutation({
 *   variables: {
 *      id: // value for 'id'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpdateUserMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUserMutation, UpdateUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateUserMutation, UpdateUserMutationVariables>(UpdateUserDocument, options);
      }
export type UpdateUserMutationHookResult = ReturnType<typeof useUpdateUserMutation>;
export type UpdateUserMutationResult = Apollo.MutationResult<UpdateUserMutation>;
export type UpdateUserMutationOptions = Apollo.BaseMutationOptions<UpdateUserMutation, UpdateUserMutationVariables>;
export const DeleteUserDocument = gql`
    mutation DeleteUser($id: ID!) {
  deleteUser(id: $id) {
    ...User
  }
}
    ${UserFragmentDoc}`;
export type DeleteUserMutationFn = Apollo.MutationFunction<DeleteUserMutation, DeleteUserMutationVariables>;

/**
 * __useDeleteUserMutation__
 *
 * To run a mutation, you first call `useDeleteUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteUserMutation, { data, loading, error }] = useDeleteUserMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteUserMutation(baseOptions?: Apollo.MutationHookOptions<DeleteUserMutation, DeleteUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteUserMutation, DeleteUserMutationVariables>(DeleteUserDocument, options);
      }
export type DeleteUserMutationHookResult = ReturnType<typeof useDeleteUserMutation>;
export type DeleteUserMutationResult = Apollo.MutationResult<DeleteUserMutation>;
export type DeleteUserMutationOptions = Apollo.BaseMutationOptions<DeleteUserMutation, DeleteUserMutationVariables>;
export const CreateInviteDocument = gql`
    mutation CreateInvite($attributes: InviteAttributes!) {
  createInvite(attributes: $attributes) {
    ...Invite
  }
}
    ${InviteFragmentDoc}`;
export type CreateInviteMutationFn = Apollo.MutationFunction<CreateInviteMutation, CreateInviteMutationVariables>;

/**
 * __useCreateInviteMutation__
 *
 * To run a mutation, you first call `useCreateInviteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateInviteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createInviteMutation, { data, loading, error }] = useCreateInviteMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useCreateInviteMutation(baseOptions?: Apollo.MutationHookOptions<CreateInviteMutation, CreateInviteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateInviteMutation, CreateInviteMutationVariables>(CreateInviteDocument, options);
      }
export type CreateInviteMutationHookResult = ReturnType<typeof useCreateInviteMutation>;
export type CreateInviteMutationResult = Apollo.MutationResult<CreateInviteMutation>;
export type CreateInviteMutationOptions = Apollo.BaseMutationOptions<CreateInviteMutation, CreateInviteMutationVariables>;
export const VulnerabilityReportsDocument = gql`
    query VulnerabilityReports($clusters: [ID], $namespaces: [String], $q: String, $grade: VulnReportGrade, $first: Int, $after: String) {
  vulnerabilityReports(
    clusters: $clusters
    namespaces: $namespaces
    q: $q
    grade: $grade
    first: $first
    after: $after
  ) {
    ...VulnerabilityReportConnection
  }
}
    ${VulnerabilityReportConnectionFragmentDoc}`;

/**
 * __useVulnerabilityReportsQuery__
 *
 * To run a query within a React component, call `useVulnerabilityReportsQuery` and pass it any options that fit your needs.
 * When your component renders, `useVulnerabilityReportsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useVulnerabilityReportsQuery({
 *   variables: {
 *      clusters: // value for 'clusters'
 *      namespaces: // value for 'namespaces'
 *      q: // value for 'q'
 *      grade: // value for 'grade'
 *      first: // value for 'first'
 *      after: // value for 'after'
 *   },
 * });
 */
export function useVulnerabilityReportsQuery(baseOptions?: Apollo.QueryHookOptions<VulnerabilityReportsQuery, VulnerabilityReportsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<VulnerabilityReportsQuery, VulnerabilityReportsQueryVariables>(VulnerabilityReportsDocument, options);
      }
export function useVulnerabilityReportsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<VulnerabilityReportsQuery, VulnerabilityReportsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<VulnerabilityReportsQuery, VulnerabilityReportsQueryVariables>(VulnerabilityReportsDocument, options);
        }
export function useVulnerabilityReportsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<VulnerabilityReportsQuery, VulnerabilityReportsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<VulnerabilityReportsQuery, VulnerabilityReportsQueryVariables>(VulnerabilityReportsDocument, options);
        }
export type VulnerabilityReportsQueryHookResult = ReturnType<typeof useVulnerabilityReportsQuery>;
export type VulnerabilityReportsLazyQueryHookResult = ReturnType<typeof useVulnerabilityReportsLazyQuery>;
export type VulnerabilityReportsSuspenseQueryHookResult = ReturnType<typeof useVulnerabilityReportsSuspenseQuery>;
export type VulnerabilityReportsQueryResult = Apollo.QueryResult<VulnerabilityReportsQuery, VulnerabilityReportsQueryVariables>;
export const VulnerabilityReportDocument = gql`
    query VulnerabilityReport($id: ID!) {
  vulnerabilityReport(id: $id) {
    ...VulnerabilityReport
  }
}
    ${VulnerabilityReportFragmentDoc}`;

/**
 * __useVulnerabilityReportQuery__
 *
 * To run a query within a React component, call `useVulnerabilityReportQuery` and pass it any options that fit your needs.
 * When your component renders, `useVulnerabilityReportQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useVulnerabilityReportQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useVulnerabilityReportQuery(baseOptions: Apollo.QueryHookOptions<VulnerabilityReportQuery, VulnerabilityReportQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<VulnerabilityReportQuery, VulnerabilityReportQueryVariables>(VulnerabilityReportDocument, options);
      }
export function useVulnerabilityReportLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<VulnerabilityReportQuery, VulnerabilityReportQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<VulnerabilityReportQuery, VulnerabilityReportQueryVariables>(VulnerabilityReportDocument, options);
        }
export function useVulnerabilityReportSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<VulnerabilityReportQuery, VulnerabilityReportQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<VulnerabilityReportQuery, VulnerabilityReportQueryVariables>(VulnerabilityReportDocument, options);
        }
export type VulnerabilityReportQueryHookResult = ReturnType<typeof useVulnerabilityReportQuery>;
export type VulnerabilityReportLazyQueryHookResult = ReturnType<typeof useVulnerabilityReportLazyQuery>;
export type VulnerabilityReportSuspenseQueryHookResult = ReturnType<typeof useVulnerabilityReportSuspenseQuery>;
export type VulnerabilityReportQueryResult = Apollo.QueryResult<VulnerabilityReportQuery, VulnerabilityReportQueryVariables>;
export const VulnerabilityStatisticsDocument = gql`
    query VulnerabilityStatistics($clusters: [ID], $namespaces: [String], $q: String) {
  vulnerabilityStatistics(clusters: $clusters, namespaces: $namespaces, q: $q) {
    ...VulnerabilityStatistic
  }
}
    ${VulnerabilityStatisticFragmentDoc}`;

/**
 * __useVulnerabilityStatisticsQuery__
 *
 * To run a query within a React component, call `useVulnerabilityStatisticsQuery` and pass it any options that fit your needs.
 * When your component renders, `useVulnerabilityStatisticsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useVulnerabilityStatisticsQuery({
 *   variables: {
 *      clusters: // value for 'clusters'
 *      namespaces: // value for 'namespaces'
 *      q: // value for 'q'
 *   },
 * });
 */
export function useVulnerabilityStatisticsQuery(baseOptions?: Apollo.QueryHookOptions<VulnerabilityStatisticsQuery, VulnerabilityStatisticsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<VulnerabilityStatisticsQuery, VulnerabilityStatisticsQueryVariables>(VulnerabilityStatisticsDocument, options);
      }
export function useVulnerabilityStatisticsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<VulnerabilityStatisticsQuery, VulnerabilityStatisticsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<VulnerabilityStatisticsQuery, VulnerabilityStatisticsQueryVariables>(VulnerabilityStatisticsDocument, options);
        }
export function useVulnerabilityStatisticsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<VulnerabilityStatisticsQuery, VulnerabilityStatisticsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<VulnerabilityStatisticsQuery, VulnerabilityStatisticsQueryVariables>(VulnerabilityStatisticsDocument, options);
        }
export type VulnerabilityStatisticsQueryHookResult = ReturnType<typeof useVulnerabilityStatisticsQuery>;
export type VulnerabilityStatisticsLazyQueryHookResult = ReturnType<typeof useVulnerabilityStatisticsLazyQuery>;
export type VulnerabilityStatisticsSuspenseQueryHookResult = ReturnType<typeof useVulnerabilityStatisticsSuspenseQuery>;
export type VulnerabilityStatisticsQueryResult = Apollo.QueryResult<VulnerabilityStatisticsQuery, VulnerabilityStatisticsQueryVariables>;
export const ClusterVulnerabilityAggregateDocument = gql`
    query ClusterVulnerabilityAggregate($grade: VulnReportGrade!) {
  clusterVulnerabilityAggregate(grade: $grade) {
    ...ClusterVulnAggregate
  }
}
    ${ClusterVulnAggregateFragmentDoc}`;

/**
 * __useClusterVulnerabilityAggregateQuery__
 *
 * To run a query within a React component, call `useClusterVulnerabilityAggregateQuery` and pass it any options that fit your needs.
 * When your component renders, `useClusterVulnerabilityAggregateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useClusterVulnerabilityAggregateQuery({
 *   variables: {
 *      grade: // value for 'grade'
 *   },
 * });
 */
export function useClusterVulnerabilityAggregateQuery(baseOptions: Apollo.QueryHookOptions<ClusterVulnerabilityAggregateQuery, ClusterVulnerabilityAggregateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ClusterVulnerabilityAggregateQuery, ClusterVulnerabilityAggregateQueryVariables>(ClusterVulnerabilityAggregateDocument, options);
      }
export function useClusterVulnerabilityAggregateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ClusterVulnerabilityAggregateQuery, ClusterVulnerabilityAggregateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ClusterVulnerabilityAggregateQuery, ClusterVulnerabilityAggregateQueryVariables>(ClusterVulnerabilityAggregateDocument, options);
        }
export function useClusterVulnerabilityAggregateSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ClusterVulnerabilityAggregateQuery, ClusterVulnerabilityAggregateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ClusterVulnerabilityAggregateQuery, ClusterVulnerabilityAggregateQueryVariables>(ClusterVulnerabilityAggregateDocument, options);
        }
export type ClusterVulnerabilityAggregateQueryHookResult = ReturnType<typeof useClusterVulnerabilityAggregateQuery>;
export type ClusterVulnerabilityAggregateLazyQueryHookResult = ReturnType<typeof useClusterVulnerabilityAggregateLazyQuery>;
export type ClusterVulnerabilityAggregateSuspenseQueryHookResult = ReturnType<typeof useClusterVulnerabilityAggregateSuspenseQuery>;
export type ClusterVulnerabilityAggregateQueryResult = Apollo.QueryResult<ClusterVulnerabilityAggregateQuery, ClusterVulnerabilityAggregateQueryVariables>;
export const namedOperations = {
  Query: {
    ChatThreads: 'ChatThreads',
    ChatAgentSession: 'ChatAgentSession',
    ChatThreadDetails: 'ChatThreadDetails',
    ChatThreadMessages: 'ChatThreadMessages',
    AgentSessions: 'AgentSessions',
    CloudConnections: 'CloudConnections',
    AiInsight: 'AiInsight',
    AICompletion: 'AICompletion',
    AISuggestedFix: 'AISuggestedFix',
    ClusterInsightComponent: 'ClusterInsightComponent',
    McpServers: 'McpServers',
    McpServer: 'McpServer',
    McpServerAudits: 'McpServerAudits',
    GenerateMcpToken: 'GenerateMcpToken',
    ClusterAlerts: 'ClusterAlerts',
    ServiceAlerts: 'ServiceAlerts',
    Audits: 'Audits',
    AuditMetrics: 'AuditMetrics',
    PrAutomations: 'PrAutomations',
    ScmConnections: 'ScmConnections',
    ScmConnection: 'ScmConnection',
    ScmWebhooks: 'ScmWebhooks',
    ObjectStores: 'ObjectStores',
    ClustersObjectStores: 'ClustersObjectStores',
    ClusterBackup: 'ClusterBackup',
    ClusterBackups: 'ClusterBackups',
    ClusterRestores: 'ClusterRestores',
    Catalogs: 'Catalogs',
    Catalog: 'Catalog',
    Clusters: 'Clusters',
    ClustersTiny: 'ClustersTiny',
    VClusters: 'VClusters',
    ClusterSelector: 'ClusterSelector',
    Cluster: 'Cluster',
    ClusterBasic: 'ClusterBasic',
    ClusterInsight: 'ClusterInsight',
    ClusterNodes: 'ClusterNodes',
    ClusterPods: 'ClusterPods',
    ClusterNamespaces: 'ClusterNamespaces',
    ClusterBindings: 'ClusterBindings',
    RuntimeServices: 'RuntimeServices',
    RuntimeService: 'RuntimeService',
    ClusterStatuses: 'ClusterStatuses',
    TagPairs: 'TagPairs',
    ClusterMetrics: 'ClusterMetrics',
    ClusterNodeMetrics: 'ClusterNodeMetrics',
    ClusterNetworkGraph: 'ClusterNetworkGraph',
    ServiceDeploymentComponentMetrics: 'ServiceDeploymentComponentMetrics',
    Usage: 'Usage',
    GitRepositories: 'GitRepositories',
    HelmRepositories: 'HelmRepositories',
    FluxHelmRepositories: 'FluxHelmRepositories',
    FluxHelmRepository: 'FluxHelmRepository',
    GitRepository: 'GitRepository',
    GlobalServices: 'GlobalServices',
    GetGlobalService: 'GetGlobalService',
    GetGlobalServiceServices: 'GetGlobalServiceServices',
    DeploymentSettings: 'DeploymentSettings',
    ObservabilityProviders: 'ObservabilityProviders',
    ObservabilityWebhooks: 'ObservabilityWebhooks',
    ManagedNamespaces: 'ManagedNamespaces',
    GetManagedNamespaceName: 'GetManagedNamespaceName',
    GetManagedNamespace: 'GetManagedNamespace',
    GetManagedNamespaceServices: 'GetManagedNamespaceServices',
    Observers: 'Observers',
    Observer: 'Observer',
    Pipelines: 'Pipelines',
    PipelineBindings: 'PipelineBindings',
    JobGate: 'JobGate',
    JobGateLogs: 'JobGateLogs',
    Pipeline: 'Pipeline',
    PipelineContexts: 'PipelineContexts',
    PipelineContext: 'PipelineContext',
    ClusterProviders: 'ClusterProviders',
    PullRequests: 'PullRequests',
    ServiceDeployments: 'ServiceDeployments',
    ServiceDeploymentsTiny: 'ServiceDeploymentsTiny',
    ServiceTree: 'ServiceTree',
    ServiceDeployment: 'ServiceDeployment',
    ServiceDeploymentTiny: 'ServiceDeploymentTiny',
    ServiceDeploymentComponents: 'ServiceDeploymentComponents',
    ServiceDeploymentComponentsWithChildren: 'ServiceDeploymentComponentsWithChildren',
    ServiceDeploymentSecrets: 'ServiceDeploymentSecrets',
    ServiceDeploymentRevisions: 'ServiceDeploymentRevisions',
    ServiceDeploymentBindings: 'ServiceDeploymentBindings',
    ServiceStatuses: 'ServiceStatuses',
    ServiceNetworkGraph: 'ServiceNetworkGraph',
    ServiceComponentRaw: 'ServiceComponentRaw',
    ComponentTree: 'ComponentTree',
    ClusterUsages: 'ClusterUsages',
    ClusterUsageHistory: 'ClusterUsageHistory',
    ClusterUsageNamespaces: 'ClusterUsageNamespaces',
    ClusterUsageScalingRecommendations: 'ClusterUsageScalingRecommendations',
    ProjectUsageHistory: 'ProjectUsageHistory',
    ClusterRegistration: 'ClusterRegistration',
    ClusterRegistrations: 'ClusterRegistrations',
    ClusterISOImages: 'ClusterISOImages',
    Flows: 'Flows',
    Flow: 'Flow',
    FlowServices: 'FlowServices',
    FlowPipelines: 'FlowPipelines',
    FlowAlerts: 'FlowAlerts',
    FlowPrs: 'FlowPrs',
    FlowPreviewEnvironmentInstances: 'FlowPreviewEnvironmentInstances',
    FlowPreviewEnvironmentTemplates: 'FlowPreviewEnvironmentTemplates',
    FlowMcpServers: 'FlowMcpServers',
    FlowVulnerabilityReports: 'FlowVulnerabilityReports',
    Groups: 'Groups',
    SearchGroups: 'SearchGroups',
    GroupMembers: 'GroupMembers',
    ClusterOverviewDetails: 'ClusterOverviewDetails',
    UpgradeStatistics: 'UpgradeStatistics',
    ClusterHealthScores: 'ClusterHealthScores',
    KubernetesClusters: 'KubernetesClusters',
    KubernetesClusterAuditLogs: 'KubernetesClusterAuditLogs',
    ArgoRollout: 'ArgoRollout',
    Canary: 'Canary',
    Certificate: 'Certificate',
    CronJob: 'CronJob',
    DaemonSet: 'DaemonSet',
    Deployment: 'Deployment',
    Ingress: 'Ingress',
    Job: 'Job',
    Node: 'Node',
    NodeMetric: 'NodeMetric',
    PluralServiceDeployment: 'PluralServiceDeployment',
    Pod: 'Pod',
    PodLogs: 'PodLogs',
    Service: 'Service',
    StatefulSet: 'StatefulSet',
    UnstructuredResource: 'UnstructuredResource',
    Subscription: 'Subscription',
    MeGroups: 'MeGroups',
    Me: 'Me',
    LoginInfo: 'LoginInfo',
    Invite: 'Invite',
    Refresh: 'Refresh',
    TemporaryToken: 'TemporaryToken',
    LogAggregation: 'LogAggregation',
    ClusterHeatMap: 'ClusterHeatMap',
    ClusterNoisyNeighbors: 'ClusterNoisyNeighbors',
    ServiceHeatMap: 'ServiceHeatMap',
    NotificationRouters: 'NotificationRouters',
    NotificationSinks: 'NotificationSinks',
    UnreadAppNotifications: 'UnreadAppNotifications',
    AppNotifications: 'AppNotifications',
    OIDCConsent: 'OIDCConsent',
    OidcProviders: 'OidcProviders',
    Personas: 'Personas',
    PolicyConstraints: 'PolicyConstraints',
    PolicyConstraint: 'PolicyConstraint',
    ViolationStatistics: 'ViolationStatistics',
    PolicyStatistics: 'PolicyStatistics',
    ComplianceReportGenerators: 'ComplianceReportGenerators',
    ComplianceReportGenerator: 'ComplianceReportGenerator',
    ComplianceReports: 'ComplianceReports',
    Projects: 'Projects',
    ProjectsTiny: 'ProjectsTiny',
    Project: 'Project',
    ProjectBindings: 'ProjectBindings',
    ServiceAccounts: 'ServiceAccounts',
    StackPrs: 'StackPrs',
    Stacks: 'Stacks',
    Stack: 'Stack',
    StackTiny: 'StackTiny',
    StackState: 'StackState',
    StackOutput: 'StackOutput',
    StackFiles: 'StackFiles',
    StackBindings: 'StackBindings',
    StackRuns: 'StackRuns',
    StackRun: 'StackRun',
    StackRunJob: 'StackRunJob',
    StackRunJobLogs: 'StackRunJobLogs',
    CustomStackRuns: 'CustomStackRuns',
    AccessTokens: 'AccessTokens',
    TokenAudits: 'TokenAudits',
    Users: 'Users',
    SearchUsers: 'SearchUsers',
    VulnerabilityReports: 'VulnerabilityReports',
    VulnerabilityReport: 'VulnerabilityReport',
    VulnerabilityStatistics: 'VulnerabilityStatistics',
    ClusterVulnerabilityAggregate: 'ClusterVulnerabilityAggregate'
  },
  Mutation: {
    HybridChat: 'HybridChat',
    ConfirmChat: 'ConfirmChat',
    ConfirmChatPlan: 'ConfirmChatPlan',
    DeleteChat: 'DeleteChat',
    CreateChatThread: 'CreateChatThread',
    UpdateChatThread: 'UpdateChatThread',
    DeleteChatThread: 'DeleteChatThread',
    CloneChatThread: 'CloneChatThread',
    AddChatContext: 'AddChatContext',
    CreateAgentSession: 'CreateAgentSession',
    AiFixPr: 'AiFixPr',
    RefreshInsight: 'RefreshInsight',
    UpsertMcpServer: 'UpsertMcpServer',
    DeleteMcpServer: 'DeleteMcpServer',
    UpsertAlertResolution: 'UpsertAlertResolution',
    CreatePrAutomation: 'CreatePrAutomation',
    UpdatePrAutomation: 'UpdatePrAutomation',
    DeletePrAutomation: 'DeletePrAutomation',
    CreateScmConnection: 'CreateScmConnection',
    UpdateScmConnection: 'UpdateScmConnection',
    DeleteScmConnection: 'DeleteScmConnection',
    SetupRenovate: 'SetupRenovate',
    CreateScmWebhook: 'CreateScmWebhook',
    DeleteScmWebhook: 'DeleteScmWebhook',
    CreateScmWebhookPointer: 'CreateScmWebhookPointer',
    RegisterGitHubApp: 'RegisterGitHubApp',
    CreateObjectStore: 'CreateObjectStore',
    UpdateObjectStore: 'UpdateObjectStore',
    DeleteObjectStore: 'DeleteObjectStore',
    ConfigureBackups: 'ConfigureBackups',
    DelinkBackups: 'DelinkBackups',
    CreateClusterRestore: 'CreateClusterRestore',
    UpsertCatalog: 'UpsertCatalog',
    DeleteCatalog: 'DeleteCatalog',
    UpdateClusterBindings: 'UpdateClusterBindings',
    UpdateCluster: 'UpdateCluster',
    CreateCluster: 'CreateCluster',
    DeleteCluster: 'DeleteCluster',
    DetachCluster: 'DetachCluster',
    CreateGitRepository: 'CreateGitRepository',
    DeleteGitRepository: 'DeleteGitRepository',
    UpdateGitRepository: 'UpdateGitRepository',
    CreateGlobalService: 'CreateGlobalService',
    UpdateGlobalService: 'UpdateGlobalService',
    DeleteGlobalService: 'DeleteGlobalService',
    SyncGlobalService: 'SyncGlobalService',
    UpdateDeploymentSettings: 'UpdateDeploymentSettings',
    UpsertObservabilityProvider: 'UpsertObservabilityProvider',
    UpsertObservabilityWebhook: 'UpsertObservabilityWebhook',
    DeleteObservabilityProvider: 'DeleteObservabilityProvider',
    DeleteObservabilityWebhook: 'DeleteObservabilityWebhook',
    DissmissOnboarding: 'DissmissOnboarding',
    UpsertObserver: 'UpsertObserver',
    DeleteObserver: 'DeleteObserver',
    KickObserver: 'KickObserver',
    deletePipeline: 'deletePipeline',
    ApproveGate: 'ApproveGate',
    CreatePipelineContext: 'CreatePipelineContext',
    ForceGate: 'ForceGate',
    CreateClusterProvider: 'CreateClusterProvider',
    UpdateClusterProvider: 'UpdateClusterProvider',
    DeleteClusterProvider: 'DeleteClusterProvider',
    CreatePullRequest: 'CreatePullRequest',
    UpdatePullRequest: 'UpdatePullRequest',
    DeletePullRequest: 'DeletePullRequest',
    CreateServiceDeployment: 'CreateServiceDeployment',
    UpdateServiceDeployment: 'UpdateServiceDeployment',
    MergeService: 'MergeService',
    DeleteServiceDeployment: 'DeleteServiceDeployment',
    DetachServiceDeployment: 'DetachServiceDeployment',
    RollbackService: 'RollbackService',
    ProceedService: 'ProceedService',
    SelfManage: 'SelfManage',
    KickService: 'KickService',
    SuggestScalingRecommendation: 'SuggestScalingRecommendation',
    ApplyScalingRecommendation: 'ApplyScalingRecommendation',
    CreateClusterRegistration: 'CreateClusterRegistration',
    UpdateClusterRegistration: 'UpdateClusterRegistration',
    DeleteClusterRegistration: 'DeleteClusterRegistration',
    UpsertFlow: 'UpsertFlow',
    CreateGroupMember: 'CreateGroupMember',
    DeleteGroupMember: 'DeleteGroupMember',
    CreateGroup: 'CreateGroup',
    UpdateGroup: 'UpdateGroup',
    DeleteGroup: 'DeleteGroup',
    PinCustomResource: 'PinCustomResource',
    UnpinCustomResource: 'UnpinCustomResource',
    DeleteJob: 'DeleteJob',
    DeletePod: 'DeletePod',
    signIn: 'signIn',
    OauthCallback: 'OauthCallback',
    Logout: 'Logout',
    SignUp: 'SignUp',
    LoginLink: 'LoginLink',
    UpsertNotificationRouter: 'UpsertNotificationRouter',
    DeleteNotificationRouter: 'DeleteNotificationRouter',
    UpsertNotificationSink: 'UpsertNotificationSink',
    DeleteNotificationSink: 'DeleteNotificationSink',
    ReadAppNotifications: 'ReadAppNotifications',
    Consent: 'Consent',
    AcceptLogin: 'AcceptLogin',
    CreateOidcProvider: 'CreateOidcProvider',
    UpdateOidcProvider: 'UpdateOidcProvider',
    DeleteOidcProvider: 'DeleteOidcProvider',
    CreatePersona: 'CreatePersona',
    UpdatePersona: 'UpdatePersona',
    DeletePersona: 'DeletePersona',
    UpsertComplianceReportGenerator: 'UpsertComplianceReportGenerator',
    DeleteComplianceReport: 'DeleteComplianceReport',
    CreateProject: 'CreateProject',
    UpdateProject: 'UpdateProject',
    DeleteProject: 'DeleteProject',
    UpdateRbac: 'UpdateRbac',
    CreateServiceAccount: 'CreateServiceAccount',
    UpdateServiceAccount: 'UpdateServiceAccount',
    CreateStack: 'CreateStack',
    CreateOnDemandRun: 'CreateOnDemandRun',
    UpdateStack: 'UpdateStack',
    DetachStack: 'DetachStack',
    DeleteStack: 'DeleteStack',
    KickStack: 'KickStack',
    kickStackPullRequest: 'kickStackPullRequest',
    UpdateStackRun: 'UpdateStackRun',
    CompleteStackRun: 'CompleteStackRun',
    ApproveStackRun: 'ApproveStackRun',
    RestartStackRun: 'RestartStackRun',
    RestoreStack: 'RestoreStack',
    CreateAccessToken: 'CreateAccessToken',
    DeleteAccessToken: 'DeleteAccessToken',
    ShareSecret: 'ShareSecret',
    ConsumeSecret: 'ConsumeSecret',
    UpdateUser: 'UpdateUser',
    DeleteUser: 'DeleteUser',
    CreateInvite: 'CreateInvite'
  },
  Subscription: {
    AIChatStream: 'AIChatStream',
    LogsDelta: 'LogsDelta'
  },
  Fragment: {
    Chat: 'Chat',
    ChatThreadTiny: 'ChatThreadTiny',
    ChatThreadDetails: 'ChatThreadDetails',
    ChatThreadMessages: 'ChatThreadMessages',
    ChatThreadSettings: 'ChatThreadSettings',
    CloudConnectionTiny: 'CloudConnectionTiny',
    AgentSession: 'AgentSession',
    ServiceDeploymentChat: 'ServiceDeploymentChat',
    StackChat: 'StackChat',
    AiDelta: 'AiDelta',
    AiInsight: 'AiInsight',
    AiInsightSummary: 'AiInsightSummary',
    AiInsightContext: 'AiInsightContext',
    AiInsightEvidence: 'AiInsightEvidence',
    LogsEvidence: 'LogsEvidence',
    PullRequestEvidence: 'PullRequestEvidence',
    AlertEvidence: 'AlertEvidence',
    KnowledgeEvidence: 'KnowledgeEvidence',
    ClusterInsightComponent: 'ClusterInsightComponent',
    ClusterInsightComponentDetail: 'ClusterInsightComponentDetail',
    McpServer: 'McpServer',
    McpServerAudit: 'McpServerAudit',
    McpTool: 'McpTool',
    McpServerTool: 'McpServerTool',
    McpServerConnection: 'McpServerConnection',
    Alert: 'Alert',
    AlertResolution: 'AlertResolution',
    AlertConnection: 'AlertConnection',
    Audit: 'Audit',
    PrAutomation: 'PrAutomation',
    PrConfiguration: 'PrConfiguration',
    PrConfirmation: 'PrConfirmation',
    ScmConnection: 'ScmConnection',
    ScmWebhook: 'ScmWebhook',
    ObjectStore: 'ObjectStore',
    ClustersObjectStores: 'ClustersObjectStores',
    ClusterBackup: 'ClusterBackup',
    ClusterRestore: 'ClusterRestore',
    PageInfo: 'PageInfo',
    Catalog: 'Catalog',
    ClusterNode: 'ClusterNode',
    ClusterCondition: 'ClusterCondition',
    Taint: 'Taint',
    NodePool: 'NodePool',
    ApiDeprecation: 'ApiDeprecation',
    UpgradeInsight: 'UpgradeInsight',
    UpgradeInsightDetail: 'UpgradeInsightDetail',
    InsightClientInfo: 'InsightClientInfo',
    RuntimeService: 'RuntimeService',
    RuntimeServiceDetails: 'RuntimeServiceDetails',
    AddonVersion: 'AddonVersion',
    AddonVersionBlocking: 'AddonVersionBlocking',
    ClustersRow: 'ClustersRow',
    ClusterUpgradePlan: 'ClusterUpgradePlan',
    ClusterNodeMetrics: 'ClusterNodeMetrics',
    Cluster: 'Cluster',
    ClusterInsight: 'ClusterInsight',
    CloudAddon: 'CloudAddon',
    CloudAddonVersionInformation: 'CloudAddonVersionInformation',
    ClusterMinimal: 'ClusterMinimal',
    ClusterTiny: 'ClusterTiny',
    ClusterBasic: 'ClusterBasic',
    ClusterRuntimeServices: 'ClusterRuntimeServices',
    ClusterWithNodes: 'ClusterWithNodes',
    ClusterWithMetrics: 'ClusterWithMetrics',
    PolicyBinding: 'PolicyBinding',
    ClusterBindings: 'ClusterBindings',
    ClusterStatusInfo: 'ClusterStatusInfo',
    NetworkMeshWorkload: 'NetworkMeshWorkload',
    NetworkMeshStatistics: 'NetworkMeshStatistics',
    NetworkMeshEdge: 'NetworkMeshEdge',
    ComponentMetricsFragment: 'ComponentMetricsFragment',
    GitRepository: 'GitRepository',
    HelmRepository: 'HelmRepository',
    FluxHelmRepository: 'FluxHelmRepository',
    HelmChartVersion: 'HelmChartVersion',
    GlobalService: 'GlobalService',
    ServiceTemplateWithoutConfiguration: 'ServiceTemplateWithoutConfiguration',
    HttpConnection: 'HttpConnection',
    SmtpSettings: 'SmtpSettings',
    AiSettings: 'AiSettings',
    DeploymentSettings: 'DeploymentSettings',
    ObservabilityProvider: 'ObservabilityProvider',
    ObservabilityWebhook: 'ObservabilityWebhook',
    ManagedNamespace: 'ManagedNamespace',
    ServiceTemplate: 'ServiceTemplate',
    Observer: 'Observer',
    ObserverTarget: 'ObserverTarget',
    ServiceError: 'ServiceError',
    PipelineServiceDeployment: 'PipelineServiceDeployment',
    ContainerSpec: 'ContainerSpec',
    JobGateSpec: 'JobGateSpec',
    PipelineGate: 'PipelineGate',
    Revision: 'Revision',
    PromotionService: 'PromotionService',
    PipelinePromotion: 'PipelinePromotion',
    PromotionCriteria: 'PromotionCriteria',
    StageService: 'StageService',
    PipelineStage: 'PipelineStage',
    PipelineStageEdge: 'PipelineStageEdge',
    PipelineStatus: 'PipelineStatus',
    PipelinePullRequest: 'PipelinePullRequest',
    PipelineContext: 'PipelineContext',
    Pipeline: 'Pipeline',
    PipelineConnection: 'PipelineConnection',
    PipelineBindings: 'PipelineBindings',
    PipelineGateJob: 'PipelineGateJob',
    ProviderCredential: 'ProviderCredential',
    ClusterProvider: 'ClusterProvider',
    PullRequest: 'PullRequest',
    PullRequestConnection: 'PullRequestConnection',
    ServiceDeploymentRevision: 'ServiceDeploymentRevision',
    ServiceDeploymentsRow: 'ServiceDeploymentsRow',
    ServiceDeploymentDetails: 'ServiceDeploymentDetails',
    ServiceDeploymentComponent: 'ServiceDeploymentComponent',
    ServiceDeploymentComponentWithChildren: 'ServiceDeploymentComponentWithChildren',
    ServiceComponentChild: 'ServiceComponentChild',
    ServiceDeploymentRevisions: 'ServiceDeploymentRevisions',
    ServiceDeploymentTiny: 'ServiceDeploymentTiny',
    ServiceTreeNode: 'ServiceTreeNode',
    ServiceDeploymentsConnection: 'ServiceDeploymentsConnection',
    ServiceContext: 'ServiceContext',
    ServiceDependency: 'ServiceDependency',
    ServiceDeploymentBindings: 'ServiceDeploymentBindings',
    ServiceStatusCount: 'ServiceStatusCount',
    ComponentTree: 'ComponentTree',
    ClusterUsageTiny: 'ClusterUsageTiny',
    ClusterUsageHistory: 'ClusterUsageHistory',
    ProjectUsageHistory: 'ProjectUsageHistory',
    ClusterNamespaceUsage: 'ClusterNamespaceUsage',
    ClusterScalingRecommendation: 'ClusterScalingRecommendation',
    ClusterRegistration: 'ClusterRegistration',
    Tag: 'Tag',
    IsoImage: 'IsoImage',
    FlowBasic: 'FlowBasic',
    FlowBasicWithBindings: 'FlowBasicWithBindings',
    PreviewEnvironmentTemplate: 'PreviewEnvironmentTemplate',
    PreviewEnvironmentInstance: 'PreviewEnvironmentInstance',
    PreviewEnvironmentInstanceConnection: 'PreviewEnvironmentInstanceConnection',
    PreviewEnvironmentTemplateConnection: 'PreviewEnvironmentTemplateConnection',
    GroupMember: 'GroupMember',
    Group: 'Group',
    UpgradeStatistics: 'UpgradeStatistics',
    NodeStatistic: 'NodeStatistic',
    ClusterUpgradeDeprecatedCustomResource: 'ClusterUpgradeDeprecatedCustomResource',
    ClusterUpgrade: 'ClusterUpgrade',
    ClusterOverviewDetails: 'ClusterOverviewDetails',
    ClusterHealthScore: 'ClusterHealthScore',
    KubernetesCluster: 'KubernetesCluster',
    PinnedCustomResource: 'PinnedCustomResource',
    ArgoRolloutStatus: 'ArgoRolloutStatus',
    ArgoRolloutSpec: 'ArgoRolloutSpec',
    ArgoRollout: 'ArgoRollout',
    CanaryStatus: 'CanaryStatus',
    CanarySpec: 'CanarySpec',
    Canary: 'Canary',
    StatusCondition: 'StatusCondition',
    CertificateStatus: 'CertificateStatus',
    CertificateSpec: 'CertificateSpec',
    Certificate: 'Certificate',
    CronJob: 'CronJob',
    CronJobJob: 'CronJobJob',
    DaemonSetStatus: 'DaemonSetStatus',
    DaemonSetSpec: 'DaemonSetSpec',
    DaemonSet: 'DaemonSet',
    Deployment: 'Deployment',
    Ingress: 'Ingress',
    Job: 'Job',
    Metadata: 'Metadata',
    Event: 'Event',
    ResourceSpec: 'ResourceSpec',
    Resources: 'Resources',
    Container: 'Container',
    ContainerStatus: 'ContainerStatus',
    Pod: 'Pod',
    JobStatus: 'JobStatus',
    Node: 'Node',
    NodeMetric: 'NodeMetric',
    PluralObjectStatus: 'PluralObjectStatus',
    PluralServiceDeployment: 'PluralServiceDeployment',
    PodWithEvents: 'PodWithEvents',
    Service: 'Service',
    StatefulSet: 'StatefulSet',
    UnstructuredResource: 'UnstructuredResource',
    RefreshToken: 'RefreshToken',
    Account: 'Account',
    LogLine: 'LogLine',
    MetricResponse: 'MetricResponse',
    MetricPointResponse: 'MetricPointResponse',
    UtilizationHeatMap: 'UtilizationHeatMap',
    UrlSinkConfiguration: 'UrlSinkConfiguration',
    SinkConfiguration: 'SinkConfiguration',
    NotificationSink: 'NotificationSink',
    NotificationFilter: 'NotificationFilter',
    NotificationRouter: 'NotificationRouter',
    AppNotification: 'AppNotification',
    OidcProvider: 'OidcProvider',
    PersonaConfiguration: 'PersonaConfiguration',
    Persona: 'Persona',
    PolicyConstraint: 'PolicyConstraint',
    ComplianceReportGenerator: 'ComplianceReportGenerator',
    ComplianceReport: 'ComplianceReport',
    Project: 'Project',
    ProjectTiny: 'ProjectTiny',
    ProjectBindings: 'ProjectBindings',
    StackPolicyViolation: 'StackPolicyViolation',
    StackMinimal: 'StackMinimal',
    StackTiny: 'StackTiny',
    Stack: 'Stack',
    StackRun: 'StackRun',
    ObservableMetric: 'ObservableMetric',
    StackRunDetails: 'StackRunDetails',
    CustomStackRun: 'CustomStackRun',
    StackConfiguration: 'StackConfiguration',
    StackStateResource: 'StackStateResource',
    StackState: 'StackState',
    StackOutput: 'StackOutput',
    StackEnvironment: 'StackEnvironment',
    ServiceErrors: 'ServiceErrors',
    StackFile: 'StackFile',
    RunStep: 'RunStep',
    AccessToken: 'AccessToken',
    AccessTokenAudit: 'AccessTokenAudit',
    SharedSecret: 'SharedSecret',
    User: 'User',
    UserTiny: 'UserTiny',
    Invite: 'Invite',
    RoleBinding: 'RoleBinding',
    Role: 'Role',
    AvailableFeatures: 'AvailableFeatures',
    Manifest: 'Manifest',
    VulnerabilityReportTiny: 'VulnerabilityReportTiny',
    VulnerabilityReport: 'VulnerabilityReport',
    Vulnerability: 'Vulnerability',
    VulnerabilityStatistic: 'VulnerabilityStatistic',
    ClusterVulnAggregate: 'ClusterVulnAggregate',
    CvssBundle: 'CvssBundle',
    VulnerabilityReportConnection: 'VulnerabilityReportConnection'
  }
}