// This file is auto-generated by @hey-api/openapi-ts

import { type DefaultError, type InfiniteData, infiniteQueryOptions, queryOptions, type UseMutationOptions } from '@tanstack/react-query';
import type { AxiosError } from 'axios';

import { client } from '../client.gen';
import { createAppDeployment, createAppDeploymentFromFile, createImagePullSecret, createNamespace, deleteNamespacedResource, deleteResource, drainNode, execShell, getAllConfigMaps, getAllCronJobs, getAllDaemonSets, getAllDeployments, getAllEvents, getAllHorizontalPodAutoscalers, getAllIngresses, getAllJobs, getAllNetworkPolicies, getAllPersistentVolumeClaims, getAllPodDisruptionBudgets, getAllPods, getAllReplicaSets, getAllReplicationControllers, getAllRoleBindings, getAllRoles, getAllSecrets, getAllServiceAccounts, getAllServices, getAllStatefulSets, getAvailableProtocols, getClusterRole, getClusterRoleBinding, getClusterRoleBindings, getClusterRoles, getConfigMap, getConfigMaps, getContainerLogs, getCronJob, getCronJobEvents, getCronJobJobs, getCronJobs, getCsrfToken, getCustomResourceDefinition, getCustomResourceDefinitions, getCustomResourceObject, getCustomResourceObjectEvents, getCustomResourceObjects, getDaemonSet, getDaemonSetEvents, getDaemonSetPods, getDaemonSets, getDaemonSetServices, getDeployment, getDeploymentEvents, getDeploymentNewReplicaSet, getDeploymentOldReplicaSets, getDeployments, getEvents, getHorizontalPodAutoscaler, getHorizontalPodAutoscalers, getHorizontalPodAutoscalersForResource, getIngress, getIngressClass, getIngressClasses, getIngresses, getIngressEvents, getJob, getJobEvents, getJobPods, getJobs, getLogFile, getLogSource, getNamespace, getNamespacedResource, getNamespacedResourceReplicas, getNamespaceEvents, getNamespaces, getNetworkPolicies, getNetworkPolicy, getNode, getNodeEvents, getNodePods, getNodes, getPersistentVolume, getPersistentVolumeClaim, getPersistentVolumeClaims, getPersistentVolumes, getPersistentVolumeWithNamespace, getPod, getPodContainers, getPodDisruptionBudget, getPodDisruptionBudgets, getPodEvents, getPodLogs, getPodPersistentVolumeClaims, getPods, getReplicaSet, getReplicaSetEvents, getReplicaSetPods, getReplicaSets, getReplicaSetServices, getReplicationController, getReplicationControllerEvents, getReplicationControllerPods, getReplicationControllers, getReplicationControllerServices, getResource, getResourceReplicas, getRole, getRoleBinding, getRoleBindings, getRoles, getSecret, getSecrets, getService, getServiceAccount, getServiceAccountImagePullSecrets, getServiceAccounts, getServiceAccountSecrets, getServiceEvents, getServiceIngresses, getServicePods, getServices, getStatefulSet, getStatefulSetEvents, getStatefulSetPods, getStatefulSets, getStorageClass, getStorageClasses, getStorageClassPersistentVolumes, handleGetState, type Options, pauseDeployment, restartDaemonSet, restartDeployment, restartStatefulSet, resumeDeployment, rollbackDeployment, scaleNamespacedResource, scaleResource, triggerCronJob, updateNamespacedResource, updateReplicationControllerReplicas, updateResource, validateAppName, validateImageReference, validateProtocol } from '../sdk.gen';
import type { CreateAppDeploymentData, CreateAppDeploymentFromFileData, CreateAppDeploymentFromFileResponse, CreateAppDeploymentResponse, CreateImagePullSecretData, CreateImagePullSecretResponse, CreateNamespaceData, CreateNamespaceResponse, DeleteNamespacedResourceData, DeleteResourceData, DrainNodeData, ExecShellData, ExecShellResponse, GetAllConfigMapsData, GetAllConfigMapsResponse, GetAllCronJobsData, GetAllCronJobsResponse, GetAllDaemonSetsData, GetAllDaemonSetsResponse, GetAllDeploymentsData, GetAllDeploymentsResponse, GetAllEventsData, GetAllEventsResponse, GetAllHorizontalPodAutoscalersData, GetAllHorizontalPodAutoscalersResponse, GetAllIngressesData, GetAllIngressesResponse, GetAllJobsData, GetAllJobsResponse, GetAllNetworkPoliciesData, GetAllNetworkPoliciesResponse, GetAllPersistentVolumeClaimsData, GetAllPersistentVolumeClaimsResponse, GetAllPodDisruptionBudgetsData, GetAllPodDisruptionBudgetsResponse, GetAllPodsData, GetAllPodsResponse, GetAllReplicaSetsData, GetAllReplicaSetsResponse, GetAllReplicationControllersData, GetAllReplicationControllersResponse, GetAllRoleBindingsData, GetAllRoleBindingsResponse, GetAllRolesData, GetAllRolesResponse, GetAllSecretsData, GetAllSecretsResponse, GetAllServiceAccountsData, GetAllServiceAccountsResponse, GetAllServicesData, GetAllServicesResponse, GetAllStatefulSetsData, GetAllStatefulSetsResponse, GetAvailableProtocolsData, GetAvailableProtocolsResponse, GetClusterRoleBindingData, GetClusterRoleBindingResponse, GetClusterRoleBindingsData, GetClusterRoleBindingsResponse, GetClusterRoleData, GetClusterRoleResponse, GetClusterRolesData, GetClusterRolesResponse, GetConfigMapData, GetConfigMapResponse, GetConfigMapsData, GetConfigMapsResponse, GetContainerLogsData, GetContainerLogsResponse, GetCronJobData, GetCronJobEventsData, GetCronJobEventsResponse, GetCronJobJobsData, GetCronJobJobsResponse, GetCronJobResponse, GetCronJobsData, GetCronJobsResponse, GetCsrfTokenData, GetCsrfTokenResponse, GetCustomResourceDefinitionData, GetCustomResourceDefinitionResponse, GetCustomResourceDefinitionsData, GetCustomResourceDefinitionsResponse, GetCustomResourceObjectData, GetCustomResourceObjectEventsData, GetCustomResourceObjectEventsResponse, GetCustomResourceObjectResponse, GetCustomResourceObjectsData, GetCustomResourceObjectsResponse, GetDaemonSetData, GetDaemonSetEventsData, GetDaemonSetEventsResponse, GetDaemonSetPodsData, GetDaemonSetPodsResponse, GetDaemonSetResponse, GetDaemonSetsData, GetDaemonSetServicesData, GetDaemonSetServicesResponse, GetDaemonSetsResponse, GetDeploymentData, GetDeploymentEventsData, GetDeploymentEventsResponse, GetDeploymentNewReplicaSetData, GetDeploymentNewReplicaSetResponse, GetDeploymentOldReplicaSetsData, GetDeploymentOldReplicaSetsResponse, GetDeploymentResponse, GetDeploymentsData, GetDeploymentsResponse, GetEventsData, GetEventsResponse, GetHorizontalPodAutoscalerData, GetHorizontalPodAutoscalerResponse, GetHorizontalPodAutoscalersData, GetHorizontalPodAutoscalersForResourceData, GetHorizontalPodAutoscalersForResourceResponse, GetHorizontalPodAutoscalersResponse, GetIngressClassData, GetIngressClassesData, GetIngressClassesResponse, GetIngressClassResponse, GetIngressData, GetIngressesData, GetIngressesResponse, GetIngressEventsData, GetIngressEventsResponse, GetIngressResponse, GetJobData, GetJobEventsData, GetJobEventsResponse, GetJobPodsData, GetJobPodsResponse, GetJobResponse, GetJobsData, GetJobsResponse, GetLogFileData, GetLogFileResponse, GetLogSourceData, GetLogSourceResponse, GetNamespaceData, GetNamespacedResourceData, GetNamespacedResourceReplicasData, GetNamespacedResourceReplicasResponse, GetNamespacedResourceResponse, GetNamespaceEventsData, GetNamespaceEventsResponse, GetNamespaceResponse, GetNamespacesData, GetNamespacesResponse, GetNetworkPoliciesData, GetNetworkPoliciesResponse, GetNetworkPolicyData, GetNetworkPolicyResponse, GetNodeData, GetNodeEventsData, GetNodeEventsResponse, GetNodePodsData, GetNodePodsResponse, GetNodeResponse, GetNodesData, GetNodesResponse, GetPersistentVolumeClaimData, GetPersistentVolumeClaimResponse, GetPersistentVolumeClaimsData, GetPersistentVolumeClaimsResponse, GetPersistentVolumeData, GetPersistentVolumeResponse, GetPersistentVolumesData, GetPersistentVolumesResponse, GetPersistentVolumeWithNamespaceData, GetPersistentVolumeWithNamespaceResponse, GetPodContainersData, GetPodContainersResponse, GetPodData, GetPodDisruptionBudgetData, GetPodDisruptionBudgetResponse, GetPodDisruptionBudgetsData, GetPodDisruptionBudgetsResponse, GetPodEventsData, GetPodEventsResponse, GetPodLogsData, GetPodLogsResponse, GetPodPersistentVolumeClaimsData, GetPodPersistentVolumeClaimsResponse, GetPodResponse, GetPodsData, GetPodsResponse, GetReplicaSetData, GetReplicaSetEventsData, GetReplicaSetEventsResponse, GetReplicaSetPodsData, GetReplicaSetPodsResponse, GetReplicaSetResponse, GetReplicaSetsData, GetReplicaSetServicesData, GetReplicaSetServicesResponse, GetReplicaSetsResponse, GetReplicationControllerData, GetReplicationControllerEventsData, GetReplicationControllerEventsResponse, GetReplicationControllerPodsData, GetReplicationControllerPodsResponse, GetReplicationControllerResponse, GetReplicationControllersData, GetReplicationControllerServicesData, GetReplicationControllerServicesResponse, GetReplicationControllersResponse, GetResourceData, GetResourceReplicasData, GetResourceReplicasResponse, GetResourceResponse, GetRoleBindingData, GetRoleBindingResponse, GetRoleBindingsData, GetRoleBindingsResponse, GetRoleData, GetRoleResponse, GetRolesData, GetRolesResponse, GetSecretData, GetSecretResponse, GetSecretsData, GetSecretsResponse, GetServiceAccountData, GetServiceAccountImagePullSecretsData, GetServiceAccountImagePullSecretsResponse, GetServiceAccountResponse, GetServiceAccountsData, GetServiceAccountSecretsData, GetServiceAccountSecretsResponse, GetServiceAccountsResponse, GetServiceData, GetServiceEventsData, GetServiceEventsResponse, GetServiceIngressesData, GetServiceIngressesResponse, GetServicePodsData, GetServicePodsResponse, GetServiceResponse, GetServicesData, GetServicesResponse, GetStatefulSetData, GetStatefulSetEventsData, GetStatefulSetEventsResponse, GetStatefulSetPodsData, GetStatefulSetPodsResponse, GetStatefulSetResponse, GetStatefulSetsData, GetStatefulSetsResponse, GetStorageClassData, GetStorageClassesData, GetStorageClassesResponse, GetStorageClassPersistentVolumesData, GetStorageClassPersistentVolumesResponse, GetStorageClassResponse, HandleGetStateData, PauseDeploymentData, PauseDeploymentResponse, RestartDaemonSetData, RestartDaemonSetResponse, RestartDeploymentData, RestartDeploymentResponse, RestartStatefulSetData, RestartStatefulSetResponse, ResumeDeploymentData, ResumeDeploymentResponse, RollbackDeploymentData, RollbackDeploymentResponse, ScaleNamespacedResourceData, ScaleNamespacedResourceResponse, ScaleResourceData, ScaleResourceResponse, TriggerCronJobData, UpdateNamespacedResourceData, UpdateReplicationControllerReplicasData, UpdateResourceData, ValidateAppNameData, ValidateAppNameResponse, ValidateImageReferenceData, ValidateImageReferenceResponse, ValidateProtocolData, ValidateProtocolResponse } from '../types.gen';

/**
 * deletes a non-namespaced resource
 */
export const deleteResourceMutation = (options?: Partial<Options<DeleteResourceData>>): UseMutationOptions<unknown, AxiosError<DefaultError>, Options<DeleteResourceData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<DefaultError>, Options<DeleteResourceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteResource({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseURL' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseURL: options?.baseURL || (options?.client ?? client).getConfig().baseURL } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [params];
};

export const getResourceQueryKey = (options: Options<GetResourceData>) => createQueryKey('getResource', options);

/**
 * returns a non-namespaced resource
 */
export const getResourceOptions = (options: Options<GetResourceData>) => queryOptions<GetResourceResponse, AxiosError<DefaultError>, GetResourceResponse, ReturnType<typeof getResourceQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getResource({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getResourceQueryKey(options)
});

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = { ...queryKey[0] };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const getResourceInfiniteQueryKey = (options: Options<GetResourceData>): QueryKey<Options<GetResourceData>> => createQueryKey('getResource', options, true);

/**
 * returns a non-namespaced resource
 */
export const getResourceInfiniteOptions = (options: Options<GetResourceData>) => infiniteQueryOptions<GetResourceResponse, AxiosError<DefaultError>, InfiniteData<GetResourceResponse>, QueryKey<Options<GetResourceData>>, string | Pick<QueryKey<Options<GetResourceData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetResourceData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getResource({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getResourceInfiniteQueryKey(options)
});

/**
 * creates or updates a non-namespaced resource
 */
export const updateResourceMutation = (options?: Partial<Options<UpdateResourceData>>): UseMutationOptions<unknown, AxiosError<DefaultError>, Options<UpdateResourceData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<DefaultError>, Options<UpdateResourceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateResource({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * deletes a resource from a namespace
 */
export const deleteNamespacedResourceMutation = (options?: Partial<Options<DeleteNamespacedResourceData>>): UseMutationOptions<unknown, AxiosError<DefaultError>, Options<DeleteNamespacedResourceData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<DefaultError>, Options<DeleteNamespacedResourceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteNamespacedResource({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getNamespacedResourceQueryKey = (options: Options<GetNamespacedResourceData>) => createQueryKey('getNamespacedResource', options);

/**
 * returns unstructured resource from a namespace
 */
export const getNamespacedResourceOptions = (options: Options<GetNamespacedResourceData>) => queryOptions<GetNamespacedResourceResponse, AxiosError<DefaultError>, GetNamespacedResourceResponse, ReturnType<typeof getNamespacedResourceQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getNamespacedResource({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getNamespacedResourceQueryKey(options)
});

export const getNamespacedResourceInfiniteQueryKey = (options: Options<GetNamespacedResourceData>): QueryKey<Options<GetNamespacedResourceData>> => createQueryKey('getNamespacedResource', options, true);

/**
 * returns unstructured resource from a namespace
 */
export const getNamespacedResourceInfiniteOptions = (options: Options<GetNamespacedResourceData>) => infiniteQueryOptions<GetNamespacedResourceResponse, AxiosError<DefaultError>, InfiniteData<GetNamespacedResourceResponse>, QueryKey<Options<GetNamespacedResourceData>>, string | Pick<QueryKey<Options<GetNamespacedResourceData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetNamespacedResourceData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getNamespacedResource({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getNamespacedResourceInfiniteQueryKey(options)
});

/**
 * creates or updates a resource in a namespace
 */
export const updateNamespacedResourceMutation = (options?: Partial<Options<UpdateNamespacedResourceData>>): UseMutationOptions<unknown, AxiosError<DefaultError>, Options<UpdateNamespacedResourceData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<DefaultError>, Options<UpdateNamespacedResourceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateNamespacedResource({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * creates an application based on provided deployment.AppDeploymentSpec
 */
export const createAppDeploymentMutation = (options?: Partial<Options<CreateAppDeploymentData>>): UseMutationOptions<CreateAppDeploymentResponse, AxiosError<DefaultError>, Options<CreateAppDeploymentData>> => {
    const mutationOptions: UseMutationOptions<CreateAppDeploymentResponse, AxiosError<DefaultError>, Options<CreateAppDeploymentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createAppDeployment({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAvailableProtocolsQueryKey = (options?: Options<GetAvailableProtocolsData>) => createQueryKey('getAvailableProtocols', options);

/**
 * returns a list of available protocols for the service
 */
export const getAvailableProtocolsOptions = (options?: Options<GetAvailableProtocolsData>) => queryOptions<GetAvailableProtocolsResponse, AxiosError<DefaultError>, GetAvailableProtocolsResponse, ReturnType<typeof getAvailableProtocolsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAvailableProtocols({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAvailableProtocolsQueryKey(options)
});

export const getAvailableProtocolsInfiniteQueryKey = (options?: Options<GetAvailableProtocolsData>): QueryKey<Options<GetAvailableProtocolsData>> => createQueryKey('getAvailableProtocols', options, true);

/**
 * returns a list of available protocols for the service
 */
export const getAvailableProtocolsInfiniteOptions = (options?: Options<GetAvailableProtocolsData>) => infiniteQueryOptions<GetAvailableProtocolsResponse, AxiosError<DefaultError>, InfiniteData<GetAvailableProtocolsResponse>, QueryKey<Options<GetAvailableProtocolsData>>, string | Pick<QueryKey<Options<GetAvailableProtocolsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetAvailableProtocolsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAvailableProtocols({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAvailableProtocolsInfiniteQueryKey(options)
});

/**
 * checks if provided image is valid
 */
export const validateImageReferenceMutation = (options?: Partial<Options<ValidateImageReferenceData>>): UseMutationOptions<ValidateImageReferenceResponse, AxiosError<DefaultError>, Options<ValidateImageReferenceData>> => {
    const mutationOptions: UseMutationOptions<ValidateImageReferenceResponse, AxiosError<DefaultError>, Options<ValidateImageReferenceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await validateImageReference({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * checks if provided name is valid
 */
export const validateAppNameMutation = (options?: Partial<Options<ValidateAppNameData>>): UseMutationOptions<ValidateAppNameResponse, AxiosError<DefaultError>, Options<ValidateAppNameData>> => {
    const mutationOptions: UseMutationOptions<ValidateAppNameResponse, AxiosError<DefaultError>, Options<ValidateAppNameData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await validateAppName({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * checks if provided service protocol is valid
 */
export const validateProtocolMutation = (options?: Partial<Options<ValidateProtocolData>>): UseMutationOptions<ValidateProtocolResponse, AxiosError<DefaultError>, Options<ValidateProtocolData>> => {
    const mutationOptions: UseMutationOptions<ValidateProtocolResponse, AxiosError<DefaultError>, Options<ValidateProtocolData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await validateProtocol({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * create an application from file
 */
export const createAppDeploymentFromFileMutation = (options?: Partial<Options<CreateAppDeploymentFromFileData>>): UseMutationOptions<CreateAppDeploymentFromFileResponse, AxiosError<DefaultError>, Options<CreateAppDeploymentFromFileData>> => {
    const mutationOptions: UseMutationOptions<CreateAppDeploymentFromFileResponse, AxiosError<DefaultError>, Options<CreateAppDeploymentFromFileData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createAppDeploymentFromFile({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getClusterRolesQueryKey = (options?: Options<GetClusterRolesData>) => createQueryKey('getClusterRoles', options);

/**
 * returns a list of ClusterRoles
 */
export const getClusterRolesOptions = (options?: Options<GetClusterRolesData>) => queryOptions<GetClusterRolesResponse, AxiosError<DefaultError>, GetClusterRolesResponse, ReturnType<typeof getClusterRolesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getClusterRoles({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getClusterRolesQueryKey(options)
});

export const getClusterRolesInfiniteQueryKey = (options?: Options<GetClusterRolesData>): QueryKey<Options<GetClusterRolesData>> => createQueryKey('getClusterRoles', options, true);

/**
 * returns a list of ClusterRoles
 */
export const getClusterRolesInfiniteOptions = (options?: Options<GetClusterRolesData>) => infiniteQueryOptions<GetClusterRolesResponse, AxiosError<DefaultError>, InfiniteData<GetClusterRolesResponse>, QueryKey<Options<GetClusterRolesData>>, string | Pick<QueryKey<Options<GetClusterRolesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetClusterRolesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getClusterRoles({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getClusterRolesInfiniteQueryKey(options)
});

export const getClusterRoleQueryKey = (options: Options<GetClusterRoleData>) => createQueryKey('getClusterRole', options);

/**
 * returns detailed information about ClusterRole
 */
export const getClusterRoleOptions = (options: Options<GetClusterRoleData>) => queryOptions<GetClusterRoleResponse, AxiosError<DefaultError>, GetClusterRoleResponse, ReturnType<typeof getClusterRoleQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getClusterRole({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getClusterRoleQueryKey(options)
});

export const getClusterRoleInfiniteQueryKey = (options: Options<GetClusterRoleData>): QueryKey<Options<GetClusterRoleData>> => createQueryKey('getClusterRole', options, true);

/**
 * returns detailed information about ClusterRole
 */
export const getClusterRoleInfiniteOptions = (options: Options<GetClusterRoleData>) => infiniteQueryOptions<GetClusterRoleResponse, AxiosError<DefaultError>, InfiniteData<GetClusterRoleResponse>, QueryKey<Options<GetClusterRoleData>>, string | Pick<QueryKey<Options<GetClusterRoleData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetClusterRoleData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getClusterRole({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getClusterRoleInfiniteQueryKey(options)
});

export const getClusterRoleBindingsQueryKey = (options?: Options<GetClusterRoleBindingsData>) => createQueryKey('getClusterRoleBindings', options);

/**
 * returns a list of ClusterRoleBindings
 */
export const getClusterRoleBindingsOptions = (options?: Options<GetClusterRoleBindingsData>) => queryOptions<GetClusterRoleBindingsResponse, AxiosError<DefaultError>, GetClusterRoleBindingsResponse, ReturnType<typeof getClusterRoleBindingsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getClusterRoleBindings({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getClusterRoleBindingsQueryKey(options)
});

export const getClusterRoleBindingsInfiniteQueryKey = (options?: Options<GetClusterRoleBindingsData>): QueryKey<Options<GetClusterRoleBindingsData>> => createQueryKey('getClusterRoleBindings', options, true);

/**
 * returns a list of ClusterRoleBindings
 */
export const getClusterRoleBindingsInfiniteOptions = (options?: Options<GetClusterRoleBindingsData>) => infiniteQueryOptions<GetClusterRoleBindingsResponse, AxiosError<DefaultError>, InfiniteData<GetClusterRoleBindingsResponse>, QueryKey<Options<GetClusterRoleBindingsData>>, string | Pick<QueryKey<Options<GetClusterRoleBindingsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetClusterRoleBindingsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getClusterRoleBindings({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getClusterRoleBindingsInfiniteQueryKey(options)
});

export const getClusterRoleBindingQueryKey = (options: Options<GetClusterRoleBindingData>) => createQueryKey('getClusterRoleBinding', options);

/**
 * returns detailed information about ClusterRoleBinding
 */
export const getClusterRoleBindingOptions = (options: Options<GetClusterRoleBindingData>) => queryOptions<GetClusterRoleBindingResponse, AxiosError<DefaultError>, GetClusterRoleBindingResponse, ReturnType<typeof getClusterRoleBindingQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getClusterRoleBinding({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getClusterRoleBindingQueryKey(options)
});

export const getClusterRoleBindingInfiniteQueryKey = (options: Options<GetClusterRoleBindingData>): QueryKey<Options<GetClusterRoleBindingData>> => createQueryKey('getClusterRoleBinding', options, true);

/**
 * returns detailed information about ClusterRoleBinding
 */
export const getClusterRoleBindingInfiniteOptions = (options: Options<GetClusterRoleBindingData>) => infiniteQueryOptions<GetClusterRoleBindingResponse, AxiosError<DefaultError>, InfiniteData<GetClusterRoleBindingResponse>, QueryKey<Options<GetClusterRoleBindingData>>, string | Pick<QueryKey<Options<GetClusterRoleBindingData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetClusterRoleBindingData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getClusterRoleBinding({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getClusterRoleBindingInfiniteQueryKey(options)
});

export const getAllConfigMapsQueryKey = (options?: Options<GetAllConfigMapsData>) => createQueryKey('getAllConfigMaps', options);

/**
 * returns a list of ConfigMaps from all namespaces
 */
export const getAllConfigMapsOptions = (options?: Options<GetAllConfigMapsData>) => queryOptions<GetAllConfigMapsResponse, AxiosError<DefaultError>, GetAllConfigMapsResponse, ReturnType<typeof getAllConfigMapsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAllConfigMaps({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllConfigMapsQueryKey(options)
});

export const getAllConfigMapsInfiniteQueryKey = (options?: Options<GetAllConfigMapsData>): QueryKey<Options<GetAllConfigMapsData>> => createQueryKey('getAllConfigMaps', options, true);

/**
 * returns a list of ConfigMaps from all namespaces
 */
export const getAllConfigMapsInfiniteOptions = (options?: Options<GetAllConfigMapsData>) => infiniteQueryOptions<GetAllConfigMapsResponse, AxiosError<DefaultError>, InfiniteData<GetAllConfigMapsResponse>, QueryKey<Options<GetAllConfigMapsData>>, string | Pick<QueryKey<Options<GetAllConfigMapsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetAllConfigMapsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllConfigMaps({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllConfigMapsInfiniteQueryKey(options)
});

export const getConfigMapsQueryKey = (options: Options<GetConfigMapsData>) => createQueryKey('getConfigMaps', options);

/**
 * returns a list of ConfigMaps in a namespaces
 */
export const getConfigMapsOptions = (options: Options<GetConfigMapsData>) => queryOptions<GetConfigMapsResponse, AxiosError<DefaultError>, GetConfigMapsResponse, ReturnType<typeof getConfigMapsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getConfigMaps({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getConfigMapsQueryKey(options)
});

export const getConfigMapsInfiniteQueryKey = (options: Options<GetConfigMapsData>): QueryKey<Options<GetConfigMapsData>> => createQueryKey('getConfigMaps', options, true);

/**
 * returns a list of ConfigMaps in a namespaces
 */
export const getConfigMapsInfiniteOptions = (options: Options<GetConfigMapsData>) => infiniteQueryOptions<GetConfigMapsResponse, AxiosError<DefaultError>, InfiniteData<GetConfigMapsResponse>, QueryKey<Options<GetConfigMapsData>>, string | Pick<QueryKey<Options<GetConfigMapsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetConfigMapsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getConfigMaps({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getConfigMapsInfiniteQueryKey(options)
});

export const getConfigMapQueryKey = (options: Options<GetConfigMapData>) => createQueryKey('getConfigMap', options);

/**
 * returns detailed information about ConfigMap
 */
export const getConfigMapOptions = (options: Options<GetConfigMapData>) => queryOptions<GetConfigMapResponse, AxiosError<DefaultError>, GetConfigMapResponse, ReturnType<typeof getConfigMapQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getConfigMap({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getConfigMapQueryKey(options)
});

export const getConfigMapInfiniteQueryKey = (options: Options<GetConfigMapData>): QueryKey<Options<GetConfigMapData>> => createQueryKey('getConfigMap', options, true);

/**
 * returns detailed information about ConfigMap
 */
export const getConfigMapInfiniteOptions = (options: Options<GetConfigMapData>) => infiniteQueryOptions<GetConfigMapResponse, AxiosError<DefaultError>, InfiniteData<GetConfigMapResponse>, QueryKey<Options<GetConfigMapData>>, string | Pick<QueryKey<Options<GetConfigMapData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetConfigMapData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getConfigMap({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getConfigMapInfiniteQueryKey(options)
});

export const getCustomResourceDefinitionsQueryKey = (options?: Options<GetCustomResourceDefinitionsData>) => createQueryKey('getCustomResourceDefinitions', options);

/**
 * returns a list of CustomResourceDefinition
 */
export const getCustomResourceDefinitionsOptions = (options?: Options<GetCustomResourceDefinitionsData>) => queryOptions<GetCustomResourceDefinitionsResponse, AxiosError<DefaultError>, GetCustomResourceDefinitionsResponse, ReturnType<typeof getCustomResourceDefinitionsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCustomResourceDefinitions({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCustomResourceDefinitionsQueryKey(options)
});

export const getCustomResourceDefinitionsInfiniteQueryKey = (options?: Options<GetCustomResourceDefinitionsData>): QueryKey<Options<GetCustomResourceDefinitionsData>> => createQueryKey('getCustomResourceDefinitions', options, true);

/**
 * returns a list of CustomResourceDefinition
 */
export const getCustomResourceDefinitionsInfiniteOptions = (options?: Options<GetCustomResourceDefinitionsData>) => infiniteQueryOptions<GetCustomResourceDefinitionsResponse, AxiosError<DefaultError>, InfiniteData<GetCustomResourceDefinitionsResponse>, QueryKey<Options<GetCustomResourceDefinitionsData>>, string | Pick<QueryKey<Options<GetCustomResourceDefinitionsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetCustomResourceDefinitionsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getCustomResourceDefinitions({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCustomResourceDefinitionsInfiniteQueryKey(options)
});

export const getCustomResourceDefinitionQueryKey = (options: Options<GetCustomResourceDefinitionData>) => createQueryKey('getCustomResourceDefinition', options);

/**
 * returns detailed information about CustomResourceDefinition
 */
export const getCustomResourceDefinitionOptions = (options: Options<GetCustomResourceDefinitionData>) => queryOptions<GetCustomResourceDefinitionResponse, AxiosError<DefaultError>, GetCustomResourceDefinitionResponse, ReturnType<typeof getCustomResourceDefinitionQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCustomResourceDefinition({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCustomResourceDefinitionQueryKey(options)
});

export const getCustomResourceDefinitionInfiniteQueryKey = (options: Options<GetCustomResourceDefinitionData>): QueryKey<Options<GetCustomResourceDefinitionData>> => createQueryKey('getCustomResourceDefinition', options, true);

/**
 * returns detailed information about CustomResourceDefinition
 */
export const getCustomResourceDefinitionInfiniteOptions = (options: Options<GetCustomResourceDefinitionData>) => infiniteQueryOptions<GetCustomResourceDefinitionResponse, AxiosError<DefaultError>, InfiniteData<GetCustomResourceDefinitionResponse>, QueryKey<Options<GetCustomResourceDefinitionData>>, string | Pick<QueryKey<Options<GetCustomResourceDefinitionData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetCustomResourceDefinitionData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getCustomResourceDefinition({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCustomResourceDefinitionInfiniteQueryKey(options)
});

export const getCustomResourceObjectsQueryKey = (options: Options<GetCustomResourceObjectsData>) => createQueryKey('getCustomResourceObjects', options);

/**
 * returns a list of objects of CustomResourceDefinition
 */
export const getCustomResourceObjectsOptions = (options: Options<GetCustomResourceObjectsData>) => queryOptions<GetCustomResourceObjectsResponse, AxiosError<DefaultError>, GetCustomResourceObjectsResponse, ReturnType<typeof getCustomResourceObjectsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCustomResourceObjects({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCustomResourceObjectsQueryKey(options)
});

export const getCustomResourceObjectsInfiniteQueryKey = (options: Options<GetCustomResourceObjectsData>): QueryKey<Options<GetCustomResourceObjectsData>> => createQueryKey('getCustomResourceObjects', options, true);

/**
 * returns a list of objects of CustomResourceDefinition
 */
export const getCustomResourceObjectsInfiniteOptions = (options: Options<GetCustomResourceObjectsData>) => infiniteQueryOptions<GetCustomResourceObjectsResponse, AxiosError<DefaultError>, InfiniteData<GetCustomResourceObjectsResponse>, QueryKey<Options<GetCustomResourceObjectsData>>, string | Pick<QueryKey<Options<GetCustomResourceObjectsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetCustomResourceObjectsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getCustomResourceObjects({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCustomResourceObjectsInfiniteQueryKey(options)
});

export const getCustomResourceObjectQueryKey = (options: Options<GetCustomResourceObjectData>) => createQueryKey('getCustomResourceObject', options);

/**
 * returns detailed information about custom resource object
 */
export const getCustomResourceObjectOptions = (options: Options<GetCustomResourceObjectData>) => queryOptions<GetCustomResourceObjectResponse, AxiosError<DefaultError>, GetCustomResourceObjectResponse, ReturnType<typeof getCustomResourceObjectQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCustomResourceObject({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCustomResourceObjectQueryKey(options)
});

export const getCustomResourceObjectInfiniteQueryKey = (options: Options<GetCustomResourceObjectData>): QueryKey<Options<GetCustomResourceObjectData>> => createQueryKey('getCustomResourceObject', options, true);

/**
 * returns detailed information about custom resource object
 */
export const getCustomResourceObjectInfiniteOptions = (options: Options<GetCustomResourceObjectData>) => infiniteQueryOptions<GetCustomResourceObjectResponse, AxiosError<DefaultError>, InfiniteData<GetCustomResourceObjectResponse>, QueryKey<Options<GetCustomResourceObjectData>>, string | Pick<QueryKey<Options<GetCustomResourceObjectData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetCustomResourceObjectData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getCustomResourceObject({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCustomResourceObjectInfiniteQueryKey(options)
});

export const getCustomResourceObjectEventsQueryKey = (options: Options<GetCustomResourceObjectEventsData>) => createQueryKey('getCustomResourceObjectEvents', options);

/**
 * returns Events for custom resource object
 */
export const getCustomResourceObjectEventsOptions = (options: Options<GetCustomResourceObjectEventsData>) => queryOptions<GetCustomResourceObjectEventsResponse, AxiosError<DefaultError>, GetCustomResourceObjectEventsResponse, ReturnType<typeof getCustomResourceObjectEventsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCustomResourceObjectEvents({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCustomResourceObjectEventsQueryKey(options)
});

export const getCustomResourceObjectEventsInfiniteQueryKey = (options: Options<GetCustomResourceObjectEventsData>): QueryKey<Options<GetCustomResourceObjectEventsData>> => createQueryKey('getCustomResourceObjectEvents', options, true);

/**
 * returns Events for custom resource object
 */
export const getCustomResourceObjectEventsInfiniteOptions = (options: Options<GetCustomResourceObjectEventsData>) => infiniteQueryOptions<GetCustomResourceObjectEventsResponse, AxiosError<DefaultError>, InfiniteData<GetCustomResourceObjectEventsResponse>, QueryKey<Options<GetCustomResourceObjectEventsData>>, string | Pick<QueryKey<Options<GetCustomResourceObjectEventsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetCustomResourceObjectEventsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getCustomResourceObjectEvents({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCustomResourceObjectEventsInfiniteQueryKey(options)
});

export const getAllCronJobsQueryKey = (options?: Options<GetAllCronJobsData>) => createQueryKey('getAllCronJobs', options);

/**
 * returns a list of CronJobs from all namespaces
 */
export const getAllCronJobsOptions = (options?: Options<GetAllCronJobsData>) => queryOptions<GetAllCronJobsResponse, AxiosError<DefaultError>, GetAllCronJobsResponse, ReturnType<typeof getAllCronJobsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAllCronJobs({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllCronJobsQueryKey(options)
});

export const getAllCronJobsInfiniteQueryKey = (options?: Options<GetAllCronJobsData>): QueryKey<Options<GetAllCronJobsData>> => createQueryKey('getAllCronJobs', options, true);

/**
 * returns a list of CronJobs from all namespaces
 */
export const getAllCronJobsInfiniteOptions = (options?: Options<GetAllCronJobsData>) => infiniteQueryOptions<GetAllCronJobsResponse, AxiosError<DefaultError>, InfiniteData<GetAllCronJobsResponse>, QueryKey<Options<GetAllCronJobsData>>, string | Pick<QueryKey<Options<GetAllCronJobsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetAllCronJobsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllCronJobs({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllCronJobsInfiniteQueryKey(options)
});

export const getCronJobsQueryKey = (options: Options<GetCronJobsData>) => createQueryKey('getCronJobs', options);

/**
 * returns a list of CronJobs in a namespaces
 */
export const getCronJobsOptions = (options: Options<GetCronJobsData>) => queryOptions<GetCronJobsResponse, AxiosError<DefaultError>, GetCronJobsResponse, ReturnType<typeof getCronJobsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCronJobs({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCronJobsQueryKey(options)
});

export const getCronJobsInfiniteQueryKey = (options: Options<GetCronJobsData>): QueryKey<Options<GetCronJobsData>> => createQueryKey('getCronJobs', options, true);

/**
 * returns a list of CronJobs in a namespaces
 */
export const getCronJobsInfiniteOptions = (options: Options<GetCronJobsData>) => infiniteQueryOptions<GetCronJobsResponse, AxiosError<DefaultError>, InfiniteData<GetCronJobsResponse>, QueryKey<Options<GetCronJobsData>>, string | Pick<QueryKey<Options<GetCronJobsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetCronJobsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getCronJobs({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCronJobsInfiniteQueryKey(options)
});

export const getCronJobQueryKey = (options: Options<GetCronJobData>) => createQueryKey('getCronJob', options);

/**
 * returns detailed information about CronJob
 */
export const getCronJobOptions = (options: Options<GetCronJobData>) => queryOptions<GetCronJobResponse, AxiosError<DefaultError>, GetCronJobResponse, ReturnType<typeof getCronJobQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCronJob({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCronJobQueryKey(options)
});

export const getCronJobInfiniteQueryKey = (options: Options<GetCronJobData>): QueryKey<Options<GetCronJobData>> => createQueryKey('getCronJob', options, true);

/**
 * returns detailed information about CronJob
 */
export const getCronJobInfiniteOptions = (options: Options<GetCronJobData>) => infiniteQueryOptions<GetCronJobResponse, AxiosError<DefaultError>, InfiniteData<GetCronJobResponse>, QueryKey<Options<GetCronJobData>>, string | Pick<QueryKey<Options<GetCronJobData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetCronJobData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getCronJob({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCronJobInfiniteQueryKey(options)
});

export const getCronJobEventsQueryKey = (options: Options<GetCronJobEventsData>) => createQueryKey('getCronJobEvents', options);

/**
 * returns a list of Events for CronJob
 */
export const getCronJobEventsOptions = (options: Options<GetCronJobEventsData>) => queryOptions<GetCronJobEventsResponse, AxiosError<DefaultError>, GetCronJobEventsResponse, ReturnType<typeof getCronJobEventsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCronJobEvents({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCronJobEventsQueryKey(options)
});

export const getCronJobEventsInfiniteQueryKey = (options: Options<GetCronJobEventsData>): QueryKey<Options<GetCronJobEventsData>> => createQueryKey('getCronJobEvents', options, true);

/**
 * returns a list of Events for CronJob
 */
export const getCronJobEventsInfiniteOptions = (options: Options<GetCronJobEventsData>) => infiniteQueryOptions<GetCronJobEventsResponse, AxiosError<DefaultError>, InfiniteData<GetCronJobEventsResponse>, QueryKey<Options<GetCronJobEventsData>>, string | Pick<QueryKey<Options<GetCronJobEventsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetCronJobEventsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getCronJobEvents({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCronJobEventsInfiniteQueryKey(options)
});

export const getCronJobJobsQueryKey = (options: Options<GetCronJobJobsData>) => createQueryKey('getCronJobJobs', options);

/**
 * returns a list of Jobs for CronJob
 */
export const getCronJobJobsOptions = (options: Options<GetCronJobJobsData>) => queryOptions<GetCronJobJobsResponse, AxiosError<DefaultError>, GetCronJobJobsResponse, ReturnType<typeof getCronJobJobsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCronJobJobs({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCronJobJobsQueryKey(options)
});

export const getCronJobJobsInfiniteQueryKey = (options: Options<GetCronJobJobsData>): QueryKey<Options<GetCronJobJobsData>> => createQueryKey('getCronJobJobs', options, true);

/**
 * returns a list of Jobs for CronJob
 */
export const getCronJobJobsInfiniteOptions = (options: Options<GetCronJobJobsData>) => infiniteQueryOptions<GetCronJobJobsResponse, AxiosError<DefaultError>, InfiniteData<GetCronJobJobsResponse>, QueryKey<Options<GetCronJobJobsData>>, string | Pick<QueryKey<Options<GetCronJobJobsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetCronJobJobsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getCronJobJobs({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCronJobJobsInfiniteQueryKey(options)
});

/**
 * triggers a Job based on CronJob
 */
export const triggerCronJobMutation = (options?: Partial<Options<TriggerCronJobData>>): UseMutationOptions<unknown, AxiosError<DefaultError>, Options<TriggerCronJobData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<DefaultError>, Options<TriggerCronJobData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await triggerCronJob({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCsrfTokenQueryKey = (options: Options<GetCsrfTokenData>) => createQueryKey('getCsrfToken', options);

/**
 * generates a one-time CSRF token that can be used by POST request
 */
export const getCsrfTokenOptions = (options: Options<GetCsrfTokenData>) => queryOptions<GetCsrfTokenResponse, AxiosError<DefaultError>, GetCsrfTokenResponse, ReturnType<typeof getCsrfTokenQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCsrfToken({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCsrfTokenQueryKey(options)
});

export const getCsrfTokenInfiniteQueryKey = (options: Options<GetCsrfTokenData>): QueryKey<Options<GetCsrfTokenData>> => createQueryKey('getCsrfToken', options, true);

/**
 * generates a one-time CSRF token that can be used by POST request
 */
export const getCsrfTokenInfiniteOptions = (options: Options<GetCsrfTokenData>) => infiniteQueryOptions<GetCsrfTokenResponse, AxiosError<DefaultError>, InfiniteData<GetCsrfTokenResponse>, QueryKey<Options<GetCsrfTokenData>>, string | Pick<QueryKey<Options<GetCsrfTokenData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetCsrfTokenData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getCsrfToken({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCsrfTokenInfiniteQueryKey(options)
});

export const getAllDaemonSetsQueryKey = (options?: Options<GetAllDaemonSetsData>) => createQueryKey('getAllDaemonSets', options);

/**
 * returns a list of DaemonSets from all namespaces
 */
export const getAllDaemonSetsOptions = (options?: Options<GetAllDaemonSetsData>) => queryOptions<GetAllDaemonSetsResponse, AxiosError<DefaultError>, GetAllDaemonSetsResponse, ReturnType<typeof getAllDaemonSetsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAllDaemonSets({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllDaemonSetsQueryKey(options)
});

export const getAllDaemonSetsInfiniteQueryKey = (options?: Options<GetAllDaemonSetsData>): QueryKey<Options<GetAllDaemonSetsData>> => createQueryKey('getAllDaemonSets', options, true);

/**
 * returns a list of DaemonSets from all namespaces
 */
export const getAllDaemonSetsInfiniteOptions = (options?: Options<GetAllDaemonSetsData>) => infiniteQueryOptions<GetAllDaemonSetsResponse, AxiosError<DefaultError>, InfiniteData<GetAllDaemonSetsResponse>, QueryKey<Options<GetAllDaemonSetsData>>, string | Pick<QueryKey<Options<GetAllDaemonSetsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetAllDaemonSetsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllDaemonSets({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllDaemonSetsInfiniteQueryKey(options)
});

export const getDaemonSetsQueryKey = (options: Options<GetDaemonSetsData>) => createQueryKey('getDaemonSets', options);

/**
 * returns a list of DaemonSets in a namespaces
 */
export const getDaemonSetsOptions = (options: Options<GetDaemonSetsData>) => queryOptions<GetDaemonSetsResponse, AxiosError<DefaultError>, GetDaemonSetsResponse, ReturnType<typeof getDaemonSetsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getDaemonSets({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDaemonSetsQueryKey(options)
});

export const getDaemonSetsInfiniteQueryKey = (options: Options<GetDaemonSetsData>): QueryKey<Options<GetDaemonSetsData>> => createQueryKey('getDaemonSets', options, true);

/**
 * returns a list of DaemonSets in a namespaces
 */
export const getDaemonSetsInfiniteOptions = (options: Options<GetDaemonSetsData>) => infiniteQueryOptions<GetDaemonSetsResponse, AxiosError<DefaultError>, InfiniteData<GetDaemonSetsResponse>, QueryKey<Options<GetDaemonSetsData>>, string | Pick<QueryKey<Options<GetDaemonSetsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetDaemonSetsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getDaemonSets({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDaemonSetsInfiniteQueryKey(options)
});

export const getDaemonSetQueryKey = (options: Options<GetDaemonSetData>) => createQueryKey('getDaemonSet', options);

/**
 * returns detailed information about DaemonSet
 */
export const getDaemonSetOptions = (options: Options<GetDaemonSetData>) => queryOptions<GetDaemonSetResponse, AxiosError<DefaultError>, GetDaemonSetResponse, ReturnType<typeof getDaemonSetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getDaemonSet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDaemonSetQueryKey(options)
});

export const getDaemonSetInfiniteQueryKey = (options: Options<GetDaemonSetData>): QueryKey<Options<GetDaemonSetData>> => createQueryKey('getDaemonSet', options, true);

/**
 * returns detailed information about DaemonSet
 */
export const getDaemonSetInfiniteOptions = (options: Options<GetDaemonSetData>) => infiniteQueryOptions<GetDaemonSetResponse, AxiosError<DefaultError>, InfiniteData<GetDaemonSetResponse>, QueryKey<Options<GetDaemonSetData>>, string | Pick<QueryKey<Options<GetDaemonSetData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetDaemonSetData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getDaemonSet({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDaemonSetInfiniteQueryKey(options)
});

export const getDaemonSetEventsQueryKey = (options: Options<GetDaemonSetEventsData>) => createQueryKey('getDaemonSetEvents', options);

/**
 * returns a list of Events for DaemonSet
 */
export const getDaemonSetEventsOptions = (options: Options<GetDaemonSetEventsData>) => queryOptions<GetDaemonSetEventsResponse, AxiosError<DefaultError>, GetDaemonSetEventsResponse, ReturnType<typeof getDaemonSetEventsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getDaemonSetEvents({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDaemonSetEventsQueryKey(options)
});

export const getDaemonSetEventsInfiniteQueryKey = (options: Options<GetDaemonSetEventsData>): QueryKey<Options<GetDaemonSetEventsData>> => createQueryKey('getDaemonSetEvents', options, true);

/**
 * returns a list of Events for DaemonSet
 */
export const getDaemonSetEventsInfiniteOptions = (options: Options<GetDaemonSetEventsData>) => infiniteQueryOptions<GetDaemonSetEventsResponse, AxiosError<DefaultError>, InfiniteData<GetDaemonSetEventsResponse>, QueryKey<Options<GetDaemonSetEventsData>>, string | Pick<QueryKey<Options<GetDaemonSetEventsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetDaemonSetEventsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getDaemonSetEvents({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDaemonSetEventsInfiniteQueryKey(options)
});

export const getDaemonSetPodsQueryKey = (options: Options<GetDaemonSetPodsData>) => createQueryKey('getDaemonSetPods', options);

/**
 * returns a list of Pods for DaemonSet
 */
export const getDaemonSetPodsOptions = (options: Options<GetDaemonSetPodsData>) => queryOptions<GetDaemonSetPodsResponse, AxiosError<DefaultError>, GetDaemonSetPodsResponse, ReturnType<typeof getDaemonSetPodsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getDaemonSetPods({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDaemonSetPodsQueryKey(options)
});

export const getDaemonSetPodsInfiniteQueryKey = (options: Options<GetDaemonSetPodsData>): QueryKey<Options<GetDaemonSetPodsData>> => createQueryKey('getDaemonSetPods', options, true);

/**
 * returns a list of Pods for DaemonSet
 */
export const getDaemonSetPodsInfiniteOptions = (options: Options<GetDaemonSetPodsData>) => infiniteQueryOptions<GetDaemonSetPodsResponse, AxiosError<DefaultError>, InfiniteData<GetDaemonSetPodsResponse>, QueryKey<Options<GetDaemonSetPodsData>>, string | Pick<QueryKey<Options<GetDaemonSetPodsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetDaemonSetPodsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getDaemonSetPods({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDaemonSetPodsInfiniteQueryKey(options)
});

/**
 * rollout restart of the Daemon Set
 */
export const restartDaemonSetMutation = (options?: Partial<Options<RestartDaemonSetData>>): UseMutationOptions<RestartDaemonSetResponse, AxiosError<DefaultError>, Options<RestartDaemonSetData>> => {
    const mutationOptions: UseMutationOptions<RestartDaemonSetResponse, AxiosError<DefaultError>, Options<RestartDaemonSetData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await restartDaemonSet({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDaemonSetServicesQueryKey = (options: Options<GetDaemonSetServicesData>) => createQueryKey('getDaemonSetServices', options);

/**
 * returns a list of Services for DaemonSet
 */
export const getDaemonSetServicesOptions = (options: Options<GetDaemonSetServicesData>) => queryOptions<GetDaemonSetServicesResponse, AxiosError<DefaultError>, GetDaemonSetServicesResponse, ReturnType<typeof getDaemonSetServicesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getDaemonSetServices({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDaemonSetServicesQueryKey(options)
});

export const getDaemonSetServicesInfiniteQueryKey = (options: Options<GetDaemonSetServicesData>): QueryKey<Options<GetDaemonSetServicesData>> => createQueryKey('getDaemonSetServices', options, true);

/**
 * returns a list of Services for DaemonSet
 */
export const getDaemonSetServicesInfiniteOptions = (options: Options<GetDaemonSetServicesData>) => infiniteQueryOptions<GetDaemonSetServicesResponse, AxiosError<DefaultError>, InfiniteData<GetDaemonSetServicesResponse>, QueryKey<Options<GetDaemonSetServicesData>>, string | Pick<QueryKey<Options<GetDaemonSetServicesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetDaemonSetServicesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getDaemonSetServices({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDaemonSetServicesInfiniteQueryKey(options)
});

export const getAllDeploymentsQueryKey = (options?: Options<GetAllDeploymentsData>) => createQueryKey('getAllDeployments', options);

/**
 * returns a list of Deployments from all namespaces
 */
export const getAllDeploymentsOptions = (options?: Options<GetAllDeploymentsData>) => queryOptions<GetAllDeploymentsResponse, AxiosError<DefaultError>, GetAllDeploymentsResponse, ReturnType<typeof getAllDeploymentsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAllDeployments({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllDeploymentsQueryKey(options)
});

export const getAllDeploymentsInfiniteQueryKey = (options?: Options<GetAllDeploymentsData>): QueryKey<Options<GetAllDeploymentsData>> => createQueryKey('getAllDeployments', options, true);

/**
 * returns a list of Deployments from all namespaces
 */
export const getAllDeploymentsInfiniteOptions = (options?: Options<GetAllDeploymentsData>) => infiniteQueryOptions<GetAllDeploymentsResponse, AxiosError<DefaultError>, InfiniteData<GetAllDeploymentsResponse>, QueryKey<Options<GetAllDeploymentsData>>, string | Pick<QueryKey<Options<GetAllDeploymentsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetAllDeploymentsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllDeployments({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllDeploymentsInfiniteQueryKey(options)
});

export const getDeploymentsQueryKey = (options: Options<GetDeploymentsData>) => createQueryKey('getDeployments', options);

/**
 * returns a list of Deployments in a namespaces
 */
export const getDeploymentsOptions = (options: Options<GetDeploymentsData>) => queryOptions<GetDeploymentsResponse, AxiosError<DefaultError>, GetDeploymentsResponse, ReturnType<typeof getDeploymentsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getDeployments({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDeploymentsQueryKey(options)
});

export const getDeploymentsInfiniteQueryKey = (options: Options<GetDeploymentsData>): QueryKey<Options<GetDeploymentsData>> => createQueryKey('getDeployments', options, true);

/**
 * returns a list of Deployments in a namespaces
 */
export const getDeploymentsInfiniteOptions = (options: Options<GetDeploymentsData>) => infiniteQueryOptions<GetDeploymentsResponse, AxiosError<DefaultError>, InfiniteData<GetDeploymentsResponse>, QueryKey<Options<GetDeploymentsData>>, string | Pick<QueryKey<Options<GetDeploymentsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetDeploymentsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getDeployments({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDeploymentsInfiniteQueryKey(options)
});

export const getDeploymentQueryKey = (options: Options<GetDeploymentData>) => createQueryKey('getDeployment', options);

/**
 * returns detailed information about Deployment
 */
export const getDeploymentOptions = (options: Options<GetDeploymentData>) => queryOptions<GetDeploymentResponse, AxiosError<DefaultError>, GetDeploymentResponse, ReturnType<typeof getDeploymentQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getDeployment({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDeploymentQueryKey(options)
});

export const getDeploymentInfiniteQueryKey = (options: Options<GetDeploymentData>): QueryKey<Options<GetDeploymentData>> => createQueryKey('getDeployment', options, true);

/**
 * returns detailed information about Deployment
 */
export const getDeploymentInfiniteOptions = (options: Options<GetDeploymentData>) => infiniteQueryOptions<GetDeploymentResponse, AxiosError<DefaultError>, InfiniteData<GetDeploymentResponse>, QueryKey<Options<GetDeploymentData>>, string | Pick<QueryKey<Options<GetDeploymentData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetDeploymentData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getDeployment({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDeploymentInfiniteQueryKey(options)
});

export const getDeploymentEventsQueryKey = (options: Options<GetDeploymentEventsData>) => createQueryKey('getDeploymentEvents', options);

/**
 * returns a list of Events for Deployment
 */
export const getDeploymentEventsOptions = (options: Options<GetDeploymentEventsData>) => queryOptions<GetDeploymentEventsResponse, AxiosError<DefaultError>, GetDeploymentEventsResponse, ReturnType<typeof getDeploymentEventsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getDeploymentEvents({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDeploymentEventsQueryKey(options)
});

export const getDeploymentEventsInfiniteQueryKey = (options: Options<GetDeploymentEventsData>): QueryKey<Options<GetDeploymentEventsData>> => createQueryKey('getDeploymentEvents', options, true);

/**
 * returns a list of Events for Deployment
 */
export const getDeploymentEventsInfiniteOptions = (options: Options<GetDeploymentEventsData>) => infiniteQueryOptions<GetDeploymentEventsResponse, AxiosError<DefaultError>, InfiniteData<GetDeploymentEventsResponse>, QueryKey<Options<GetDeploymentEventsData>>, string | Pick<QueryKey<Options<GetDeploymentEventsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetDeploymentEventsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getDeploymentEvents({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDeploymentEventsInfiniteQueryKey(options)
});

export const getDeploymentNewReplicaSetQueryKey = (options: Options<GetDeploymentNewReplicaSetData>) => createQueryKey('getDeploymentNewReplicaSet', options);

/**
 * returns a list of new ReplicaSets for Deployment
 */
export const getDeploymentNewReplicaSetOptions = (options: Options<GetDeploymentNewReplicaSetData>) => queryOptions<GetDeploymentNewReplicaSetResponse, AxiosError<DefaultError>, GetDeploymentNewReplicaSetResponse, ReturnType<typeof getDeploymentNewReplicaSetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getDeploymentNewReplicaSet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDeploymentNewReplicaSetQueryKey(options)
});

export const getDeploymentNewReplicaSetInfiniteQueryKey = (options: Options<GetDeploymentNewReplicaSetData>): QueryKey<Options<GetDeploymentNewReplicaSetData>> => createQueryKey('getDeploymentNewReplicaSet', options, true);

/**
 * returns a list of new ReplicaSets for Deployment
 */
export const getDeploymentNewReplicaSetInfiniteOptions = (options: Options<GetDeploymentNewReplicaSetData>) => infiniteQueryOptions<GetDeploymentNewReplicaSetResponse, AxiosError<DefaultError>, InfiniteData<GetDeploymentNewReplicaSetResponse>, QueryKey<Options<GetDeploymentNewReplicaSetData>>, string | Pick<QueryKey<Options<GetDeploymentNewReplicaSetData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetDeploymentNewReplicaSetData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getDeploymentNewReplicaSet({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDeploymentNewReplicaSetInfiniteQueryKey(options)
});

export const getDeploymentOldReplicaSetsQueryKey = (options: Options<GetDeploymentOldReplicaSetsData>) => createQueryKey('getDeploymentOldReplicaSets', options);

/**
 * returns a list of old ReplicaSets for Deployment
 */
export const getDeploymentOldReplicaSetsOptions = (options: Options<GetDeploymentOldReplicaSetsData>) => queryOptions<GetDeploymentOldReplicaSetsResponse, AxiosError<DefaultError>, GetDeploymentOldReplicaSetsResponse, ReturnType<typeof getDeploymentOldReplicaSetsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getDeploymentOldReplicaSets({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDeploymentOldReplicaSetsQueryKey(options)
});

export const getDeploymentOldReplicaSetsInfiniteQueryKey = (options: Options<GetDeploymentOldReplicaSetsData>): QueryKey<Options<GetDeploymentOldReplicaSetsData>> => createQueryKey('getDeploymentOldReplicaSets', options, true);

/**
 * returns a list of old ReplicaSets for Deployment
 */
export const getDeploymentOldReplicaSetsInfiniteOptions = (options: Options<GetDeploymentOldReplicaSetsData>) => infiniteQueryOptions<GetDeploymentOldReplicaSetsResponse, AxiosError<DefaultError>, InfiniteData<GetDeploymentOldReplicaSetsResponse>, QueryKey<Options<GetDeploymentOldReplicaSetsData>>, string | Pick<QueryKey<Options<GetDeploymentOldReplicaSetsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetDeploymentOldReplicaSetsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getDeploymentOldReplicaSets({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDeploymentOldReplicaSetsInfiniteQueryKey(options)
});

/**
 * pauses the Deployment
 */
export const pauseDeploymentMutation = (options?: Partial<Options<PauseDeploymentData>>): UseMutationOptions<PauseDeploymentResponse, AxiosError<DefaultError>, Options<PauseDeploymentData>> => {
    const mutationOptions: UseMutationOptions<PauseDeploymentResponse, AxiosError<DefaultError>, Options<PauseDeploymentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await pauseDeployment({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * rollout restart of the Deployment
 */
export const restartDeploymentMutation = (options?: Partial<Options<RestartDeploymentData>>): UseMutationOptions<RestartDeploymentResponse, AxiosError<DefaultError>, Options<RestartDeploymentData>> => {
    const mutationOptions: UseMutationOptions<RestartDeploymentResponse, AxiosError<DefaultError>, Options<RestartDeploymentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await restartDeployment({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * resumes the Deployment
 */
export const resumeDeploymentMutation = (options?: Partial<Options<ResumeDeploymentData>>): UseMutationOptions<ResumeDeploymentResponse, AxiosError<DefaultError>, Options<ResumeDeploymentData>> => {
    const mutationOptions: UseMutationOptions<ResumeDeploymentResponse, AxiosError<DefaultError>, Options<ResumeDeploymentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await resumeDeployment({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * rolls back the Deployment to the target revision
 */
export const rollbackDeploymentMutation = (options?: Partial<Options<RollbackDeploymentData>>): UseMutationOptions<RollbackDeploymentResponse, AxiosError<DefaultError>, Options<RollbackDeploymentData>> => {
    const mutationOptions: UseMutationOptions<RollbackDeploymentResponse, AxiosError<DefaultError>, Options<RollbackDeploymentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await rollbackDeployment({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAllEventsQueryKey = (options?: Options<GetAllEventsData>) => createQueryKey('getAllEvents', options);

/**
 * returns a list of Events from all namespaces
 */
export const getAllEventsOptions = (options?: Options<GetAllEventsData>) => queryOptions<GetAllEventsResponse, AxiosError<DefaultError>, GetAllEventsResponse, ReturnType<typeof getAllEventsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAllEvents({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllEventsQueryKey(options)
});

export const getAllEventsInfiniteQueryKey = (options?: Options<GetAllEventsData>): QueryKey<Options<GetAllEventsData>> => createQueryKey('getAllEvents', options, true);

/**
 * returns a list of Events from all namespaces
 */
export const getAllEventsInfiniteOptions = (options?: Options<GetAllEventsData>) => infiniteQueryOptions<GetAllEventsResponse, AxiosError<DefaultError>, InfiniteData<GetAllEventsResponse>, QueryKey<Options<GetAllEventsData>>, string | Pick<QueryKey<Options<GetAllEventsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetAllEventsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllEvents({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllEventsInfiniteQueryKey(options)
});

export const getEventsQueryKey = (options: Options<GetEventsData>) => createQueryKey('getEvents', options);

/**
 * returns a list of Events in a namespace
 */
export const getEventsOptions = (options: Options<GetEventsData>) => queryOptions<GetEventsResponse, AxiosError<DefaultError>, GetEventsResponse, ReturnType<typeof getEventsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getEvents({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getEventsQueryKey(options)
});

export const getEventsInfiniteQueryKey = (options: Options<GetEventsData>): QueryKey<Options<GetEventsData>> => createQueryKey('getEvents', options, true);

/**
 * returns a list of Events in a namespace
 */
export const getEventsInfiniteOptions = (options: Options<GetEventsData>) => infiniteQueryOptions<GetEventsResponse, AxiosError<DefaultError>, InfiniteData<GetEventsResponse>, QueryKey<Options<GetEventsData>>, string | Pick<QueryKey<Options<GetEventsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetEventsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getEvents({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getEventsInfiniteQueryKey(options)
});

export const getAllHorizontalPodAutoscalersQueryKey = (options?: Options<GetAllHorizontalPodAutoscalersData>) => createQueryKey('getAllHorizontalPodAutoscalers', options);

/**
 * returns a list of HorizontalPodAutoscalers from all namespaces
 */
export const getAllHorizontalPodAutoscalersOptions = (options?: Options<GetAllHorizontalPodAutoscalersData>) => queryOptions<GetAllHorizontalPodAutoscalersResponse, AxiosError<DefaultError>, GetAllHorizontalPodAutoscalersResponse, ReturnType<typeof getAllHorizontalPodAutoscalersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAllHorizontalPodAutoscalers({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllHorizontalPodAutoscalersQueryKey(options)
});

export const getAllHorizontalPodAutoscalersInfiniteQueryKey = (options?: Options<GetAllHorizontalPodAutoscalersData>): QueryKey<Options<GetAllHorizontalPodAutoscalersData>> => createQueryKey('getAllHorizontalPodAutoscalers', options, true);

/**
 * returns a list of HorizontalPodAutoscalers from all namespaces
 */
export const getAllHorizontalPodAutoscalersInfiniteOptions = (options?: Options<GetAllHorizontalPodAutoscalersData>) => infiniteQueryOptions<GetAllHorizontalPodAutoscalersResponse, AxiosError<DefaultError>, InfiniteData<GetAllHorizontalPodAutoscalersResponse>, QueryKey<Options<GetAllHorizontalPodAutoscalersData>>, string | Pick<QueryKey<Options<GetAllHorizontalPodAutoscalersData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetAllHorizontalPodAutoscalersData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllHorizontalPodAutoscalers({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllHorizontalPodAutoscalersInfiniteQueryKey(options)
});

export const getHorizontalPodAutoscalersQueryKey = (options: Options<GetHorizontalPodAutoscalersData>) => createQueryKey('getHorizontalPodAutoscalers', options);

/**
 * returns a list of HorizontalPodAutoscalers in a namespaces
 */
export const getHorizontalPodAutoscalersOptions = (options: Options<GetHorizontalPodAutoscalersData>) => queryOptions<GetHorizontalPodAutoscalersResponse, AxiosError<DefaultError>, GetHorizontalPodAutoscalersResponse, ReturnType<typeof getHorizontalPodAutoscalersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getHorizontalPodAutoscalers({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getHorizontalPodAutoscalersQueryKey(options)
});

export const getHorizontalPodAutoscalersInfiniteQueryKey = (options: Options<GetHorizontalPodAutoscalersData>): QueryKey<Options<GetHorizontalPodAutoscalersData>> => createQueryKey('getHorizontalPodAutoscalers', options, true);

/**
 * returns a list of HorizontalPodAutoscalers in a namespaces
 */
export const getHorizontalPodAutoscalersInfiniteOptions = (options: Options<GetHorizontalPodAutoscalersData>) => infiniteQueryOptions<GetHorizontalPodAutoscalersResponse, AxiosError<DefaultError>, InfiniteData<GetHorizontalPodAutoscalersResponse>, QueryKey<Options<GetHorizontalPodAutoscalersData>>, string | Pick<QueryKey<Options<GetHorizontalPodAutoscalersData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetHorizontalPodAutoscalersData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getHorizontalPodAutoscalers({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getHorizontalPodAutoscalersInfiniteQueryKey(options)
});

export const getHorizontalPodAutoscalerQueryKey = (options: Options<GetHorizontalPodAutoscalerData>) => createQueryKey('getHorizontalPodAutoscaler', options);

/**
 * returns detailed information about HorizontalPodAutoscaler
 */
export const getHorizontalPodAutoscalerOptions = (options: Options<GetHorizontalPodAutoscalerData>) => queryOptions<GetHorizontalPodAutoscalerResponse, AxiosError<DefaultError>, GetHorizontalPodAutoscalerResponse, ReturnType<typeof getHorizontalPodAutoscalerQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getHorizontalPodAutoscaler({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getHorizontalPodAutoscalerQueryKey(options)
});

export const getHorizontalPodAutoscalerInfiniteQueryKey = (options: Options<GetHorizontalPodAutoscalerData>): QueryKey<Options<GetHorizontalPodAutoscalerData>> => createQueryKey('getHorizontalPodAutoscaler', options, true);

/**
 * returns detailed information about HorizontalPodAutoscaler
 */
export const getHorizontalPodAutoscalerInfiniteOptions = (options: Options<GetHorizontalPodAutoscalerData>) => infiniteQueryOptions<GetHorizontalPodAutoscalerResponse, AxiosError<DefaultError>, InfiniteData<GetHorizontalPodAutoscalerResponse>, QueryKey<Options<GetHorizontalPodAutoscalerData>>, string | Pick<QueryKey<Options<GetHorizontalPodAutoscalerData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetHorizontalPodAutoscalerData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getHorizontalPodAutoscaler({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getHorizontalPodAutoscalerInfiniteQueryKey(options)
});

export const getAllIngressesQueryKey = (options?: Options<GetAllIngressesData>) => createQueryKey('getAllIngresses', options);

/**
 * returns a list of Ingresses from all namespaces
 */
export const getAllIngressesOptions = (options?: Options<GetAllIngressesData>) => queryOptions<GetAllIngressesResponse, AxiosError<DefaultError>, GetAllIngressesResponse, ReturnType<typeof getAllIngressesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAllIngresses({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllIngressesQueryKey(options)
});

export const getAllIngressesInfiniteQueryKey = (options?: Options<GetAllIngressesData>): QueryKey<Options<GetAllIngressesData>> => createQueryKey('getAllIngresses', options, true);

/**
 * returns a list of Ingresses from all namespaces
 */
export const getAllIngressesInfiniteOptions = (options?: Options<GetAllIngressesData>) => infiniteQueryOptions<GetAllIngressesResponse, AxiosError<DefaultError>, InfiniteData<GetAllIngressesResponse>, QueryKey<Options<GetAllIngressesData>>, string | Pick<QueryKey<Options<GetAllIngressesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetAllIngressesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllIngresses({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllIngressesInfiniteQueryKey(options)
});

export const getIngressesQueryKey = (options: Options<GetIngressesData>) => createQueryKey('getIngresses', options);

/**
 * returns a list of Ingresses in a namespaces
 */
export const getIngressesOptions = (options: Options<GetIngressesData>) => queryOptions<GetIngressesResponse, AxiosError<DefaultError>, GetIngressesResponse, ReturnType<typeof getIngressesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getIngresses({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getIngressesQueryKey(options)
});

export const getIngressesInfiniteQueryKey = (options: Options<GetIngressesData>): QueryKey<Options<GetIngressesData>> => createQueryKey('getIngresses', options, true);

/**
 * returns a list of Ingresses in a namespaces
 */
export const getIngressesInfiniteOptions = (options: Options<GetIngressesData>) => infiniteQueryOptions<GetIngressesResponse, AxiosError<DefaultError>, InfiniteData<GetIngressesResponse>, QueryKey<Options<GetIngressesData>>, string | Pick<QueryKey<Options<GetIngressesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetIngressesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getIngresses({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getIngressesInfiniteQueryKey(options)
});

export const getIngressEventsQueryKey = (options: Options<GetIngressEventsData>) => createQueryKey('getIngressEvents', options);

/**
 * returns a list of Events for Ingress
 */
export const getIngressEventsOptions = (options: Options<GetIngressEventsData>) => queryOptions<GetIngressEventsResponse, AxiosError<DefaultError>, GetIngressEventsResponse, ReturnType<typeof getIngressEventsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getIngressEvents({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getIngressEventsQueryKey(options)
});

export const getIngressEventsInfiniteQueryKey = (options: Options<GetIngressEventsData>): QueryKey<Options<GetIngressEventsData>> => createQueryKey('getIngressEvents', options, true);

/**
 * returns a list of Events for Ingress
 */
export const getIngressEventsInfiniteOptions = (options: Options<GetIngressEventsData>) => infiniteQueryOptions<GetIngressEventsResponse, AxiosError<DefaultError>, InfiniteData<GetIngressEventsResponse>, QueryKey<Options<GetIngressEventsData>>, string | Pick<QueryKey<Options<GetIngressEventsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetIngressEventsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getIngressEvents({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getIngressEventsInfiniteQueryKey(options)
});

export const getIngressQueryKey = (options: Options<GetIngressData>) => createQueryKey('getIngress', options);

/**
 * returns detailed information about Ingress
 */
export const getIngressOptions = (options: Options<GetIngressData>) => queryOptions<GetIngressResponse, AxiosError<DefaultError>, GetIngressResponse, ReturnType<typeof getIngressQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getIngress({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getIngressQueryKey(options)
});

export const getIngressInfiniteQueryKey = (options: Options<GetIngressData>): QueryKey<Options<GetIngressData>> => createQueryKey('getIngress', options, true);

/**
 * returns detailed information about Ingress
 */
export const getIngressInfiniteOptions = (options: Options<GetIngressData>) => infiniteQueryOptions<GetIngressResponse, AxiosError<DefaultError>, InfiniteData<GetIngressResponse>, QueryKey<Options<GetIngressData>>, string | Pick<QueryKey<Options<GetIngressData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetIngressData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getIngress({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getIngressInfiniteQueryKey(options)
});

export const getIngressClassesQueryKey = (options?: Options<GetIngressClassesData>) => createQueryKey('getIngressClasses', options);

/**
 * returns a list of IngressClasses
 */
export const getIngressClassesOptions = (options?: Options<GetIngressClassesData>) => queryOptions<GetIngressClassesResponse, AxiosError<DefaultError>, GetIngressClassesResponse, ReturnType<typeof getIngressClassesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getIngressClasses({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getIngressClassesQueryKey(options)
});

export const getIngressClassesInfiniteQueryKey = (options?: Options<GetIngressClassesData>): QueryKey<Options<GetIngressClassesData>> => createQueryKey('getIngressClasses', options, true);

/**
 * returns a list of IngressClasses
 */
export const getIngressClassesInfiniteOptions = (options?: Options<GetIngressClassesData>) => infiniteQueryOptions<GetIngressClassesResponse, AxiosError<DefaultError>, InfiniteData<GetIngressClassesResponse>, QueryKey<Options<GetIngressClassesData>>, string | Pick<QueryKey<Options<GetIngressClassesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetIngressClassesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getIngressClasses({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getIngressClassesInfiniteQueryKey(options)
});

export const getIngressClassQueryKey = (options: Options<GetIngressClassData>) => createQueryKey('getIngressClass', options);

/**
 * returns detailed information about IngressClass
 */
export const getIngressClassOptions = (options: Options<GetIngressClassData>) => queryOptions<GetIngressClassResponse, AxiosError<DefaultError>, GetIngressClassResponse, ReturnType<typeof getIngressClassQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getIngressClass({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getIngressClassQueryKey(options)
});

export const getIngressClassInfiniteQueryKey = (options: Options<GetIngressClassData>): QueryKey<Options<GetIngressClassData>> => createQueryKey('getIngressClass', options, true);

/**
 * returns detailed information about IngressClass
 */
export const getIngressClassInfiniteOptions = (options: Options<GetIngressClassData>) => infiniteQueryOptions<GetIngressClassResponse, AxiosError<DefaultError>, InfiniteData<GetIngressClassResponse>, QueryKey<Options<GetIngressClassData>>, string | Pick<QueryKey<Options<GetIngressClassData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetIngressClassData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getIngressClass({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getIngressClassInfiniteQueryKey(options)
});

export const handleGetStateQueryKey = (options?: Options<HandleGetStateData>) => createQueryKey('handleGetState', options);

export const handleGetStateOptions = (options?: Options<HandleGetStateData>) => queryOptions<unknown, AxiosError<DefaultError>, unknown, ReturnType<typeof handleGetStateQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await handleGetState({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: handleGetStateQueryKey(options)
});

export const handleGetStateInfiniteQueryKey = (options?: Options<HandleGetStateData>): QueryKey<Options<HandleGetStateData>> => createQueryKey('handleGetState', options, true);

export const handleGetStateInfiniteOptions = (options?: Options<HandleGetStateData>) => infiniteQueryOptions<unknown, AxiosError<DefaultError>, InfiniteData<unknown>, QueryKey<Options<HandleGetStateData>>, string | Pick<QueryKey<Options<HandleGetStateData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<HandleGetStateData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await handleGetState({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: handleGetStateInfiniteQueryKey(options)
});

export const getAllJobsQueryKey = (options?: Options<GetAllJobsData>) => createQueryKey('getAllJobs', options);

/**
 * returns a list of Jobs from all namespaces
 */
export const getAllJobsOptions = (options?: Options<GetAllJobsData>) => queryOptions<GetAllJobsResponse, AxiosError<DefaultError>, GetAllJobsResponse, ReturnType<typeof getAllJobsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAllJobs({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllJobsQueryKey(options)
});

export const getAllJobsInfiniteQueryKey = (options?: Options<GetAllJobsData>): QueryKey<Options<GetAllJobsData>> => createQueryKey('getAllJobs', options, true);

/**
 * returns a list of Jobs from all namespaces
 */
export const getAllJobsInfiniteOptions = (options?: Options<GetAllJobsData>) => infiniteQueryOptions<GetAllJobsResponse, AxiosError<DefaultError>, InfiniteData<GetAllJobsResponse>, QueryKey<Options<GetAllJobsData>>, string | Pick<QueryKey<Options<GetAllJobsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetAllJobsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllJobs({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllJobsInfiniteQueryKey(options)
});

export const getJobsQueryKey = (options: Options<GetJobsData>) => createQueryKey('getJobs', options);

/**
 * returns a list of Jobs in a namespaces
 */
export const getJobsOptions = (options: Options<GetJobsData>) => queryOptions<GetJobsResponse, AxiosError<DefaultError>, GetJobsResponse, ReturnType<typeof getJobsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getJobs({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getJobsQueryKey(options)
});

export const getJobsInfiniteQueryKey = (options: Options<GetJobsData>): QueryKey<Options<GetJobsData>> => createQueryKey('getJobs', options, true);

/**
 * returns a list of Jobs in a namespaces
 */
export const getJobsInfiniteOptions = (options: Options<GetJobsData>) => infiniteQueryOptions<GetJobsResponse, AxiosError<DefaultError>, InfiniteData<GetJobsResponse>, QueryKey<Options<GetJobsData>>, string | Pick<QueryKey<Options<GetJobsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetJobsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getJobs({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getJobsInfiniteQueryKey(options)
});

export const getJobQueryKey = (options: Options<GetJobData>) => createQueryKey('getJob', options);

/**
 * returns detailed information about Job
 */
export const getJobOptions = (options: Options<GetJobData>) => queryOptions<GetJobResponse, AxiosError<DefaultError>, GetJobResponse, ReturnType<typeof getJobQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getJob({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getJobQueryKey(options)
});

export const getJobInfiniteQueryKey = (options: Options<GetJobData>): QueryKey<Options<GetJobData>> => createQueryKey('getJob', options, true);

/**
 * returns detailed information about Job
 */
export const getJobInfiniteOptions = (options: Options<GetJobData>) => infiniteQueryOptions<GetJobResponse, AxiosError<DefaultError>, InfiniteData<GetJobResponse>, QueryKey<Options<GetJobData>>, string | Pick<QueryKey<Options<GetJobData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetJobData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getJob({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getJobInfiniteQueryKey(options)
});

export const getJobEventsQueryKey = (options: Options<GetJobEventsData>) => createQueryKey('getJobEvents', options);

/**
 * returns a list of Events for Job
 */
export const getJobEventsOptions = (options: Options<GetJobEventsData>) => queryOptions<GetJobEventsResponse, AxiosError<DefaultError>, GetJobEventsResponse, ReturnType<typeof getJobEventsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getJobEvents({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getJobEventsQueryKey(options)
});

export const getJobEventsInfiniteQueryKey = (options: Options<GetJobEventsData>): QueryKey<Options<GetJobEventsData>> => createQueryKey('getJobEvents', options, true);

/**
 * returns a list of Events for Job
 */
export const getJobEventsInfiniteOptions = (options: Options<GetJobEventsData>) => infiniteQueryOptions<GetJobEventsResponse, AxiosError<DefaultError>, InfiniteData<GetJobEventsResponse>, QueryKey<Options<GetJobEventsData>>, string | Pick<QueryKey<Options<GetJobEventsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetJobEventsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getJobEvents({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getJobEventsInfiniteQueryKey(options)
});

export const getJobPodsQueryKey = (options: Options<GetJobPodsData>) => createQueryKey('getJobPods', options);

/**
 * returns a list of Pods for Job
 */
export const getJobPodsOptions = (options: Options<GetJobPodsData>) => queryOptions<GetJobPodsResponse, AxiosError<DefaultError>, GetJobPodsResponse, ReturnType<typeof getJobPodsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getJobPods({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getJobPodsQueryKey(options)
});

export const getJobPodsInfiniteQueryKey = (options: Options<GetJobPodsData>): QueryKey<Options<GetJobPodsData>> => createQueryKey('getJobPods', options, true);

/**
 * returns a list of Pods for Job
 */
export const getJobPodsInfiniteOptions = (options: Options<GetJobPodsData>) => infiniteQueryOptions<GetJobPodsResponse, AxiosError<DefaultError>, InfiniteData<GetJobPodsResponse>, QueryKey<Options<GetJobPodsData>>, string | Pick<QueryKey<Options<GetJobPodsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetJobPodsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getJobPods({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getJobPodsInfiniteQueryKey(options)
});

export const getLogFileQueryKey = (options: Options<GetLogFileData>) => createQueryKey('getLogFile', options);

/**
 * returns a text file with logs from a Container
 */
export const getLogFileOptions = (options: Options<GetLogFileData>) => queryOptions<GetLogFileResponse, AxiosError<DefaultError>, GetLogFileResponse, ReturnType<typeof getLogFileQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getLogFile({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getLogFileQueryKey(options)
});

export const getLogFileInfiniteQueryKey = (options: Options<GetLogFileData>): QueryKey<Options<GetLogFileData>> => createQueryKey('getLogFile', options, true);

/**
 * returns a text file with logs from a Container
 */
export const getLogFileInfiniteOptions = (options: Options<GetLogFileData>) => infiniteQueryOptions<GetLogFileResponse, AxiosError<DefaultError>, InfiniteData<GetLogFileResponse>, QueryKey<Options<GetLogFileData>>, string | Pick<QueryKey<Options<GetLogFileData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetLogFileData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getLogFile({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getLogFileInfiniteQueryKey(options)
});

export const getLogSourceQueryKey = (options: Options<GetLogSourceData>) => createQueryKey('getLogSource', options);

/**
 * returns log sources for a resource
 */
export const getLogSourceOptions = (options: Options<GetLogSourceData>) => queryOptions<GetLogSourceResponse, AxiosError<DefaultError>, GetLogSourceResponse, ReturnType<typeof getLogSourceQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getLogSource({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getLogSourceQueryKey(options)
});

export const getLogSourceInfiniteQueryKey = (options: Options<GetLogSourceData>): QueryKey<Options<GetLogSourceData>> => createQueryKey('getLogSource', options, true);

/**
 * returns log sources for a resource
 */
export const getLogSourceInfiniteOptions = (options: Options<GetLogSourceData>) => infiniteQueryOptions<GetLogSourceResponse, AxiosError<DefaultError>, InfiniteData<GetLogSourceResponse>, QueryKey<Options<GetLogSourceData>>, string | Pick<QueryKey<Options<GetLogSourceData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetLogSourceData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getLogSource({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getLogSourceInfiniteQueryKey(options)
});

export const getPodLogsQueryKey = (options: Options<GetPodLogsData>) => createQueryKey('getPodLogs', options);

/**
 * returns logs from a Pod
 */
export const getPodLogsOptions = (options: Options<GetPodLogsData>) => queryOptions<GetPodLogsResponse, AxiosError<DefaultError>, GetPodLogsResponse, ReturnType<typeof getPodLogsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPodLogs({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPodLogsQueryKey(options)
});

export const getPodLogsInfiniteQueryKey = (options: Options<GetPodLogsData>): QueryKey<Options<GetPodLogsData>> => createQueryKey('getPodLogs', options, true);

/**
 * returns logs from a Pod
 */
export const getPodLogsInfiniteOptions = (options: Options<GetPodLogsData>) => infiniteQueryOptions<GetPodLogsResponse, AxiosError<DefaultError>, InfiniteData<GetPodLogsResponse>, QueryKey<Options<GetPodLogsData>>, string | Pick<QueryKey<Options<GetPodLogsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetPodLogsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getPodLogs({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPodLogsInfiniteQueryKey(options)
});

export const getContainerLogsQueryKey = (options: Options<GetContainerLogsData>) => createQueryKey('getContainerLogs', options);

/**
 * returns logs from a Container
 */
export const getContainerLogsOptions = (options: Options<GetContainerLogsData>) => queryOptions<GetContainerLogsResponse, AxiosError<DefaultError>, GetContainerLogsResponse, ReturnType<typeof getContainerLogsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getContainerLogs({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getContainerLogsQueryKey(options)
});

export const getContainerLogsInfiniteQueryKey = (options: Options<GetContainerLogsData>): QueryKey<Options<GetContainerLogsData>> => createQueryKey('getContainerLogs', options, true);

/**
 * returns logs from a Container
 */
export const getContainerLogsInfiniteOptions = (options: Options<GetContainerLogsData>) => infiniteQueryOptions<GetContainerLogsResponse, AxiosError<DefaultError>, InfiniteData<GetContainerLogsResponse>, QueryKey<Options<GetContainerLogsData>>, string | Pick<QueryKey<Options<GetContainerLogsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetContainerLogsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getContainerLogs({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getContainerLogsInfiniteQueryKey(options)
});

export const getNamespacesQueryKey = (options?: Options<GetNamespacesData>) => createQueryKey('getNamespaces', options);

/**
 * returns a list of Namespaces
 */
export const getNamespacesOptions = (options?: Options<GetNamespacesData>) => queryOptions<GetNamespacesResponse, AxiosError<DefaultError>, GetNamespacesResponse, ReturnType<typeof getNamespacesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getNamespaces({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getNamespacesQueryKey(options)
});

export const getNamespacesInfiniteQueryKey = (options?: Options<GetNamespacesData>): QueryKey<Options<GetNamespacesData>> => createQueryKey('getNamespaces', options, true);

/**
 * returns a list of Namespaces
 */
export const getNamespacesInfiniteOptions = (options?: Options<GetNamespacesData>) => infiniteQueryOptions<GetNamespacesResponse, AxiosError<DefaultError>, InfiniteData<GetNamespacesResponse>, QueryKey<Options<GetNamespacesData>>, string | Pick<QueryKey<Options<GetNamespacesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetNamespacesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getNamespaces({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getNamespacesInfiniteQueryKey(options)
});

/**
 * create a Namespace
 */
export const createNamespaceMutation = (options?: Partial<Options<CreateNamespaceData>>): UseMutationOptions<CreateNamespaceResponse, AxiosError<DefaultError>, Options<CreateNamespaceData>> => {
    const mutationOptions: UseMutationOptions<CreateNamespaceResponse, AxiosError<DefaultError>, Options<CreateNamespaceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createNamespace({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getNamespaceQueryKey = (options: Options<GetNamespaceData>) => createQueryKey('getNamespace', options);

/**
 * returns detailed information about Namespace
 */
export const getNamespaceOptions = (options: Options<GetNamespaceData>) => queryOptions<GetNamespaceResponse, AxiosError<DefaultError>, GetNamespaceResponse, ReturnType<typeof getNamespaceQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getNamespace({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getNamespaceQueryKey(options)
});

export const getNamespaceInfiniteQueryKey = (options: Options<GetNamespaceData>): QueryKey<Options<GetNamespaceData>> => createQueryKey('getNamespace', options, true);

/**
 * returns detailed information about Namespace
 */
export const getNamespaceInfiniteOptions = (options: Options<GetNamespaceData>) => infiniteQueryOptions<GetNamespaceResponse, AxiosError<DefaultError>, InfiniteData<GetNamespaceResponse>, QueryKey<Options<GetNamespaceData>>, string | Pick<QueryKey<Options<GetNamespaceData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetNamespaceData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getNamespace({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getNamespaceInfiniteQueryKey(options)
});

export const getNamespaceEventsQueryKey = (options: Options<GetNamespaceEventsData>) => createQueryKey('getNamespaceEvents', options);

/**
 * returns a list of Events for Namespace
 */
export const getNamespaceEventsOptions = (options: Options<GetNamespaceEventsData>) => queryOptions<GetNamespaceEventsResponse, AxiosError<DefaultError>, GetNamespaceEventsResponse, ReturnType<typeof getNamespaceEventsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getNamespaceEvents({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getNamespaceEventsQueryKey(options)
});

export const getNamespaceEventsInfiniteQueryKey = (options: Options<GetNamespaceEventsData>): QueryKey<Options<GetNamespaceEventsData>> => createQueryKey('getNamespaceEvents', options, true);

/**
 * returns a list of Events for Namespace
 */
export const getNamespaceEventsInfiniteOptions = (options: Options<GetNamespaceEventsData>) => infiniteQueryOptions<GetNamespaceEventsResponse, AxiosError<DefaultError>, InfiniteData<GetNamespaceEventsResponse>, QueryKey<Options<GetNamespaceEventsData>>, string | Pick<QueryKey<Options<GetNamespaceEventsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetNamespaceEventsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getNamespaceEvents({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getNamespaceEventsInfiniteQueryKey(options)
});

export const getAllNetworkPoliciesQueryKey = (options?: Options<GetAllNetworkPoliciesData>) => createQueryKey('getAllNetworkPolicies', options);

/**
 * returns a list of NetworkPolicies from all namespaces
 */
export const getAllNetworkPoliciesOptions = (options?: Options<GetAllNetworkPoliciesData>) => queryOptions<GetAllNetworkPoliciesResponse, AxiosError<DefaultError>, GetAllNetworkPoliciesResponse, ReturnType<typeof getAllNetworkPoliciesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAllNetworkPolicies({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllNetworkPoliciesQueryKey(options)
});

export const getAllNetworkPoliciesInfiniteQueryKey = (options?: Options<GetAllNetworkPoliciesData>): QueryKey<Options<GetAllNetworkPoliciesData>> => createQueryKey('getAllNetworkPolicies', options, true);

/**
 * returns a list of NetworkPolicies from all namespaces
 */
export const getAllNetworkPoliciesInfiniteOptions = (options?: Options<GetAllNetworkPoliciesData>) => infiniteQueryOptions<GetAllNetworkPoliciesResponse, AxiosError<DefaultError>, InfiniteData<GetAllNetworkPoliciesResponse>, QueryKey<Options<GetAllNetworkPoliciesData>>, string | Pick<QueryKey<Options<GetAllNetworkPoliciesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetAllNetworkPoliciesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllNetworkPolicies({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllNetworkPoliciesInfiniteQueryKey(options)
});

export const getNetworkPoliciesQueryKey = (options: Options<GetNetworkPoliciesData>) => createQueryKey('getNetworkPolicies', options);

/**
 * returns a list of NetworkPolicies in a namespaces
 */
export const getNetworkPoliciesOptions = (options: Options<GetNetworkPoliciesData>) => queryOptions<GetNetworkPoliciesResponse, AxiosError<DefaultError>, GetNetworkPoliciesResponse, ReturnType<typeof getNetworkPoliciesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getNetworkPolicies({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getNetworkPoliciesQueryKey(options)
});

export const getNetworkPoliciesInfiniteQueryKey = (options: Options<GetNetworkPoliciesData>): QueryKey<Options<GetNetworkPoliciesData>> => createQueryKey('getNetworkPolicies', options, true);

/**
 * returns a list of NetworkPolicies in a namespaces
 */
export const getNetworkPoliciesInfiniteOptions = (options: Options<GetNetworkPoliciesData>) => infiniteQueryOptions<GetNetworkPoliciesResponse, AxiosError<DefaultError>, InfiniteData<GetNetworkPoliciesResponse>, QueryKey<Options<GetNetworkPoliciesData>>, string | Pick<QueryKey<Options<GetNetworkPoliciesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetNetworkPoliciesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getNetworkPolicies({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getNetworkPoliciesInfiniteQueryKey(options)
});

export const getNetworkPolicyQueryKey = (options: Options<GetNetworkPolicyData>) => createQueryKey('getNetworkPolicy', options);

/**
 * returns detailed information about NetworkPolicy
 */
export const getNetworkPolicyOptions = (options: Options<GetNetworkPolicyData>) => queryOptions<GetNetworkPolicyResponse, AxiosError<DefaultError>, GetNetworkPolicyResponse, ReturnType<typeof getNetworkPolicyQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getNetworkPolicy({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getNetworkPolicyQueryKey(options)
});

export const getNetworkPolicyInfiniteQueryKey = (options: Options<GetNetworkPolicyData>): QueryKey<Options<GetNetworkPolicyData>> => createQueryKey('getNetworkPolicy', options, true);

/**
 * returns detailed information about NetworkPolicy
 */
export const getNetworkPolicyInfiniteOptions = (options: Options<GetNetworkPolicyData>) => infiniteQueryOptions<GetNetworkPolicyResponse, AxiosError<DefaultError>, InfiniteData<GetNetworkPolicyResponse>, QueryKey<Options<GetNetworkPolicyData>>, string | Pick<QueryKey<Options<GetNetworkPolicyData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetNetworkPolicyData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getNetworkPolicy({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getNetworkPolicyInfiniteQueryKey(options)
});

export const getNodesQueryKey = (options?: Options<GetNodesData>) => createQueryKey('getNodes', options);

/**
 * returns a list of Nodes
 */
export const getNodesOptions = (options?: Options<GetNodesData>) => queryOptions<GetNodesResponse, AxiosError<DefaultError>, GetNodesResponse, ReturnType<typeof getNodesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getNodes({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getNodesQueryKey(options)
});

export const getNodesInfiniteQueryKey = (options?: Options<GetNodesData>): QueryKey<Options<GetNodesData>> => createQueryKey('getNodes', options, true);

/**
 * returns a list of Nodes
 */
export const getNodesInfiniteOptions = (options?: Options<GetNodesData>) => infiniteQueryOptions<GetNodesResponse, AxiosError<DefaultError>, InfiniteData<GetNodesResponse>, QueryKey<Options<GetNodesData>>, string | Pick<QueryKey<Options<GetNodesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetNodesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getNodes({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getNodesInfiniteQueryKey(options)
});

export const getNodeQueryKey = (options: Options<GetNodeData>) => createQueryKey('getNode', options);

/**
 * returns detailed information about Node
 */
export const getNodeOptions = (options: Options<GetNodeData>) => queryOptions<GetNodeResponse, AxiosError<DefaultError>, GetNodeResponse, ReturnType<typeof getNodeQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getNode({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getNodeQueryKey(options)
});

export const getNodeInfiniteQueryKey = (options: Options<GetNodeData>): QueryKey<Options<GetNodeData>> => createQueryKey('getNode', options, true);

/**
 * returns detailed information about Node
 */
export const getNodeInfiniteOptions = (options: Options<GetNodeData>) => infiniteQueryOptions<GetNodeResponse, AxiosError<DefaultError>, InfiniteData<GetNodeResponse>, QueryKey<Options<GetNodeData>>, string | Pick<QueryKey<Options<GetNodeData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetNodeData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getNode({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getNodeInfiniteQueryKey(options)
});

/**
 * drains Node
 */
export const drainNodeMutation = (options?: Partial<Options<DrainNodeData>>): UseMutationOptions<unknown, AxiosError<DefaultError>, Options<DrainNodeData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<DefaultError>, Options<DrainNodeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await drainNode({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getNodeEventsQueryKey = (options: Options<GetNodeEventsData>) => createQueryKey('getNodeEvents', options);

/**
 * returns a list of Events for Node
 */
export const getNodeEventsOptions = (options: Options<GetNodeEventsData>) => queryOptions<GetNodeEventsResponse, AxiosError<DefaultError>, GetNodeEventsResponse, ReturnType<typeof getNodeEventsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getNodeEvents({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getNodeEventsQueryKey(options)
});

export const getNodeEventsInfiniteQueryKey = (options: Options<GetNodeEventsData>): QueryKey<Options<GetNodeEventsData>> => createQueryKey('getNodeEvents', options, true);

/**
 * returns a list of Events for Node
 */
export const getNodeEventsInfiniteOptions = (options: Options<GetNodeEventsData>) => infiniteQueryOptions<GetNodeEventsResponse, AxiosError<DefaultError>, InfiniteData<GetNodeEventsResponse>, QueryKey<Options<GetNodeEventsData>>, string | Pick<QueryKey<Options<GetNodeEventsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetNodeEventsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getNodeEvents({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getNodeEventsInfiniteQueryKey(options)
});

export const getNodePodsQueryKey = (options: Options<GetNodePodsData>) => createQueryKey('getNodePods', options);

/**
 * returns a list of Pods for Node
 */
export const getNodePodsOptions = (options: Options<GetNodePodsData>) => queryOptions<GetNodePodsResponse, AxiosError<DefaultError>, GetNodePodsResponse, ReturnType<typeof getNodePodsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getNodePods({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getNodePodsQueryKey(options)
});

export const getNodePodsInfiniteQueryKey = (options: Options<GetNodePodsData>): QueryKey<Options<GetNodePodsData>> => createQueryKey('getNodePods', options, true);

/**
 * returns a list of Pods for Node
 */
export const getNodePodsInfiniteOptions = (options: Options<GetNodePodsData>) => infiniteQueryOptions<GetNodePodsResponse, AxiosError<DefaultError>, InfiniteData<GetNodePodsResponse>, QueryKey<Options<GetNodePodsData>>, string | Pick<QueryKey<Options<GetNodePodsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetNodePodsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getNodePods({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getNodePodsInfiniteQueryKey(options)
});

export const getPersistentVolumesQueryKey = (options?: Options<GetPersistentVolumesData>) => createQueryKey('getPersistentVolumes', options);

/**
 * returns a list of PersistentVolumes from all namespaces
 */
export const getPersistentVolumesOptions = (options?: Options<GetPersistentVolumesData>) => queryOptions<GetPersistentVolumesResponse, AxiosError<DefaultError>, GetPersistentVolumesResponse, ReturnType<typeof getPersistentVolumesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPersistentVolumes({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPersistentVolumesQueryKey(options)
});

export const getPersistentVolumesInfiniteQueryKey = (options?: Options<GetPersistentVolumesData>): QueryKey<Options<GetPersistentVolumesData>> => createQueryKey('getPersistentVolumes', options, true);

/**
 * returns a list of PersistentVolumes from all namespaces
 */
export const getPersistentVolumesInfiniteOptions = (options?: Options<GetPersistentVolumesData>) => infiniteQueryOptions<GetPersistentVolumesResponse, AxiosError<DefaultError>, InfiniteData<GetPersistentVolumesResponse>, QueryKey<Options<GetPersistentVolumesData>>, string | Pick<QueryKey<Options<GetPersistentVolumesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetPersistentVolumesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getPersistentVolumes({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPersistentVolumesInfiniteQueryKey(options)
});

export const getPersistentVolumeWithNamespaceQueryKey = (options: Options<GetPersistentVolumeWithNamespaceData>) => createQueryKey('getPersistentVolumeWithNamespace', options);

/**
 * returns detailed information about PersistentVolume
 */
export const getPersistentVolumeWithNamespaceOptions = (options: Options<GetPersistentVolumeWithNamespaceData>) => queryOptions<GetPersistentVolumeWithNamespaceResponse, AxiosError<DefaultError>, GetPersistentVolumeWithNamespaceResponse, ReturnType<typeof getPersistentVolumeWithNamespaceQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPersistentVolumeWithNamespace({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPersistentVolumeWithNamespaceQueryKey(options)
});

export const getPersistentVolumeWithNamespaceInfiniteQueryKey = (options: Options<GetPersistentVolumeWithNamespaceData>): QueryKey<Options<GetPersistentVolumeWithNamespaceData>> => createQueryKey('getPersistentVolumeWithNamespace', options, true);

/**
 * returns detailed information about PersistentVolume
 */
export const getPersistentVolumeWithNamespaceInfiniteOptions = (options: Options<GetPersistentVolumeWithNamespaceData>) => infiniteQueryOptions<GetPersistentVolumeWithNamespaceResponse, AxiosError<DefaultError>, InfiniteData<GetPersistentVolumeWithNamespaceResponse>, QueryKey<Options<GetPersistentVolumeWithNamespaceData>>, string | Pick<QueryKey<Options<GetPersistentVolumeWithNamespaceData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetPersistentVolumeWithNamespaceData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getPersistentVolumeWithNamespace({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPersistentVolumeWithNamespaceInfiniteQueryKey(options)
});

export const getPersistentVolumeQueryKey = (options: Options<GetPersistentVolumeData>) => createQueryKey('getPersistentVolume', options);

/**
 * returns detailed information about PersistentVolume
 */
export const getPersistentVolumeOptions = (options: Options<GetPersistentVolumeData>) => queryOptions<GetPersistentVolumeResponse, AxiosError<DefaultError>, GetPersistentVolumeResponse, ReturnType<typeof getPersistentVolumeQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPersistentVolume({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPersistentVolumeQueryKey(options)
});

export const getPersistentVolumeInfiniteQueryKey = (options: Options<GetPersistentVolumeData>): QueryKey<Options<GetPersistentVolumeData>> => createQueryKey('getPersistentVolume', options, true);

/**
 * returns detailed information about PersistentVolume
 */
export const getPersistentVolumeInfiniteOptions = (options: Options<GetPersistentVolumeData>) => infiniteQueryOptions<GetPersistentVolumeResponse, AxiosError<DefaultError>, InfiniteData<GetPersistentVolumeResponse>, QueryKey<Options<GetPersistentVolumeData>>, string | Pick<QueryKey<Options<GetPersistentVolumeData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetPersistentVolumeData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getPersistentVolume({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPersistentVolumeInfiniteQueryKey(options)
});

export const getAllPersistentVolumeClaimsQueryKey = (options?: Options<GetAllPersistentVolumeClaimsData>) => createQueryKey('getAllPersistentVolumeClaims', options);

/**
 * returns a list of PersistentVolumeClaim
 */
export const getAllPersistentVolumeClaimsOptions = (options?: Options<GetAllPersistentVolumeClaimsData>) => queryOptions<GetAllPersistentVolumeClaimsResponse, AxiosError<DefaultError>, GetAllPersistentVolumeClaimsResponse, ReturnType<typeof getAllPersistentVolumeClaimsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAllPersistentVolumeClaims({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllPersistentVolumeClaimsQueryKey(options)
});

export const getAllPersistentVolumeClaimsInfiniteQueryKey = (options?: Options<GetAllPersistentVolumeClaimsData>): QueryKey<Options<GetAllPersistentVolumeClaimsData>> => createQueryKey('getAllPersistentVolumeClaims', options, true);

/**
 * returns a list of PersistentVolumeClaim
 */
export const getAllPersistentVolumeClaimsInfiniteOptions = (options?: Options<GetAllPersistentVolumeClaimsData>) => infiniteQueryOptions<GetAllPersistentVolumeClaimsResponse, AxiosError<DefaultError>, InfiniteData<GetAllPersistentVolumeClaimsResponse>, QueryKey<Options<GetAllPersistentVolumeClaimsData>>, string | Pick<QueryKey<Options<GetAllPersistentVolumeClaimsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetAllPersistentVolumeClaimsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllPersistentVolumeClaims({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllPersistentVolumeClaimsInfiniteQueryKey(options)
});

export const getPersistentVolumeClaimsQueryKey = (options: Options<GetPersistentVolumeClaimsData>) => createQueryKey('getPersistentVolumeClaims', options);

/**
 * returns a list of PersistentVolumeClaim from specified namespace
 */
export const getPersistentVolumeClaimsOptions = (options: Options<GetPersistentVolumeClaimsData>) => queryOptions<GetPersistentVolumeClaimsResponse, AxiosError<DefaultError>, GetPersistentVolumeClaimsResponse, ReturnType<typeof getPersistentVolumeClaimsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPersistentVolumeClaims({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPersistentVolumeClaimsQueryKey(options)
});

export const getPersistentVolumeClaimsInfiniteQueryKey = (options: Options<GetPersistentVolumeClaimsData>): QueryKey<Options<GetPersistentVolumeClaimsData>> => createQueryKey('getPersistentVolumeClaims', options, true);

/**
 * returns a list of PersistentVolumeClaim from specified namespace
 */
export const getPersistentVolumeClaimsInfiniteOptions = (options: Options<GetPersistentVolumeClaimsData>) => infiniteQueryOptions<GetPersistentVolumeClaimsResponse, AxiosError<DefaultError>, InfiniteData<GetPersistentVolumeClaimsResponse>, QueryKey<Options<GetPersistentVolumeClaimsData>>, string | Pick<QueryKey<Options<GetPersistentVolumeClaimsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetPersistentVolumeClaimsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getPersistentVolumeClaims({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPersistentVolumeClaimsInfiniteQueryKey(options)
});

export const getPersistentVolumeClaimQueryKey = (options: Options<GetPersistentVolumeClaimData>) => createQueryKey('getPersistentVolumeClaim', options);

/**
 * returns detailed information about PersistentVolumeClaim
 */
export const getPersistentVolumeClaimOptions = (options: Options<GetPersistentVolumeClaimData>) => queryOptions<GetPersistentVolumeClaimResponse, AxiosError<DefaultError>, GetPersistentVolumeClaimResponse, ReturnType<typeof getPersistentVolumeClaimQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPersistentVolumeClaim({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPersistentVolumeClaimQueryKey(options)
});

export const getPersistentVolumeClaimInfiniteQueryKey = (options: Options<GetPersistentVolumeClaimData>): QueryKey<Options<GetPersistentVolumeClaimData>> => createQueryKey('getPersistentVolumeClaim', options, true);

/**
 * returns detailed information about PersistentVolumeClaim
 */
export const getPersistentVolumeClaimInfiniteOptions = (options: Options<GetPersistentVolumeClaimData>) => infiniteQueryOptions<GetPersistentVolumeClaimResponse, AxiosError<DefaultError>, InfiniteData<GetPersistentVolumeClaimResponse>, QueryKey<Options<GetPersistentVolumeClaimData>>, string | Pick<QueryKey<Options<GetPersistentVolumeClaimData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetPersistentVolumeClaimData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getPersistentVolumeClaim({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPersistentVolumeClaimInfiniteQueryKey(options)
});

export const getAllPodsQueryKey = (options?: Options<GetAllPodsData>) => createQueryKey('getAllPods', options);

/**
 * returns a list of Pods from all namespaces
 */
export const getAllPodsOptions = (options?: Options<GetAllPodsData>) => queryOptions<GetAllPodsResponse, AxiosError<DefaultError>, GetAllPodsResponse, ReturnType<typeof getAllPodsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAllPods({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllPodsQueryKey(options)
});

export const getAllPodsInfiniteQueryKey = (options?: Options<GetAllPodsData>): QueryKey<Options<GetAllPodsData>> => createQueryKey('getAllPods', options, true);

/**
 * returns a list of Pods from all namespaces
 */
export const getAllPodsInfiniteOptions = (options?: Options<GetAllPodsData>) => infiniteQueryOptions<GetAllPodsResponse, AxiosError<DefaultError>, InfiniteData<GetAllPodsResponse>, QueryKey<Options<GetAllPodsData>>, string | Pick<QueryKey<Options<GetAllPodsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetAllPodsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllPods({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllPodsInfiniteQueryKey(options)
});

export const getPodsQueryKey = (options: Options<GetPodsData>) => createQueryKey('getPods', options);

/**
 * returns a list of Pods in a namespaces
 */
export const getPodsOptions = (options: Options<GetPodsData>) => queryOptions<GetPodsResponse, AxiosError<DefaultError>, GetPodsResponse, ReturnType<typeof getPodsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPods({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPodsQueryKey(options)
});

export const getPodsInfiniteQueryKey = (options: Options<GetPodsData>): QueryKey<Options<GetPodsData>> => createQueryKey('getPods', options, true);

/**
 * returns a list of Pods in a namespaces
 */
export const getPodsInfiniteOptions = (options: Options<GetPodsData>) => infiniteQueryOptions<GetPodsResponse, AxiosError<DefaultError>, InfiniteData<GetPodsResponse>, QueryKey<Options<GetPodsData>>, string | Pick<QueryKey<Options<GetPodsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetPodsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getPods({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPodsInfiniteQueryKey(options)
});

export const getPodQueryKey = (options: Options<GetPodData>) => createQueryKey('getPod', options);

/**
 * returns detailed information about Pod
 */
export const getPodOptions = (options: Options<GetPodData>) => queryOptions<GetPodResponse, AxiosError<DefaultError>, GetPodResponse, ReturnType<typeof getPodQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPod({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPodQueryKey(options)
});

export const getPodInfiniteQueryKey = (options: Options<GetPodData>): QueryKey<Options<GetPodData>> => createQueryKey('getPod', options, true);

/**
 * returns detailed information about Pod
 */
export const getPodInfiniteOptions = (options: Options<GetPodData>) => infiniteQueryOptions<GetPodResponse, AxiosError<DefaultError>, InfiniteData<GetPodResponse>, QueryKey<Options<GetPodData>>, string | Pick<QueryKey<Options<GetPodData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetPodData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getPod({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPodInfiniteQueryKey(options)
});

export const getPodContainersQueryKey = (options: Options<GetPodContainersData>) => createQueryKey('getPodContainers', options);

/**
 * returns a list of containers for Pod
 */
export const getPodContainersOptions = (options: Options<GetPodContainersData>) => queryOptions<GetPodContainersResponse, AxiosError<DefaultError>, GetPodContainersResponse, ReturnType<typeof getPodContainersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPodContainers({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPodContainersQueryKey(options)
});

export const getPodContainersInfiniteQueryKey = (options: Options<GetPodContainersData>): QueryKey<Options<GetPodContainersData>> => createQueryKey('getPodContainers', options, true);

/**
 * returns a list of containers for Pod
 */
export const getPodContainersInfiniteOptions = (options: Options<GetPodContainersData>) => infiniteQueryOptions<GetPodContainersResponse, AxiosError<DefaultError>, InfiniteData<GetPodContainersResponse>, QueryKey<Options<GetPodContainersData>>, string | Pick<QueryKey<Options<GetPodContainersData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetPodContainersData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getPodContainers({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPodContainersInfiniteQueryKey(options)
});

export const getPodEventsQueryKey = (options: Options<GetPodEventsData>) => createQueryKey('getPodEvents', options);

/**
 * returns a list of Events for Pod
 */
export const getPodEventsOptions = (options: Options<GetPodEventsData>) => queryOptions<GetPodEventsResponse, AxiosError<DefaultError>, GetPodEventsResponse, ReturnType<typeof getPodEventsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPodEvents({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPodEventsQueryKey(options)
});

export const getPodEventsInfiniteQueryKey = (options: Options<GetPodEventsData>): QueryKey<Options<GetPodEventsData>> => createQueryKey('getPodEvents', options, true);

/**
 * returns a list of Events for Pod
 */
export const getPodEventsInfiniteOptions = (options: Options<GetPodEventsData>) => infiniteQueryOptions<GetPodEventsResponse, AxiosError<DefaultError>, InfiniteData<GetPodEventsResponse>, QueryKey<Options<GetPodEventsData>>, string | Pick<QueryKey<Options<GetPodEventsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetPodEventsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getPodEvents({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPodEventsInfiniteQueryKey(options)
});

export const getPodPersistentVolumeClaimsQueryKey = (options: Options<GetPodPersistentVolumeClaimsData>) => createQueryKey('getPodPersistentVolumeClaims', options);

/**
 * returns a list of containers for Pod
 */
export const getPodPersistentVolumeClaimsOptions = (options: Options<GetPodPersistentVolumeClaimsData>) => queryOptions<GetPodPersistentVolumeClaimsResponse, AxiosError<DefaultError>, GetPodPersistentVolumeClaimsResponse, ReturnType<typeof getPodPersistentVolumeClaimsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPodPersistentVolumeClaims({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPodPersistentVolumeClaimsQueryKey(options)
});

export const getPodPersistentVolumeClaimsInfiniteQueryKey = (options: Options<GetPodPersistentVolumeClaimsData>): QueryKey<Options<GetPodPersistentVolumeClaimsData>> => createQueryKey('getPodPersistentVolumeClaims', options, true);

/**
 * returns a list of containers for Pod
 */
export const getPodPersistentVolumeClaimsInfiniteOptions = (options: Options<GetPodPersistentVolumeClaimsData>) => infiniteQueryOptions<GetPodPersistentVolumeClaimsResponse, AxiosError<DefaultError>, InfiniteData<GetPodPersistentVolumeClaimsResponse>, QueryKey<Options<GetPodPersistentVolumeClaimsData>>, string | Pick<QueryKey<Options<GetPodPersistentVolumeClaimsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetPodPersistentVolumeClaimsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getPodPersistentVolumeClaims({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPodPersistentVolumeClaimsInfiniteQueryKey(options)
});

export const execShellQueryKey = (options: Options<ExecShellData>) => createQueryKey('execShell', options);

/**
 * handles exec into pod
 */
export const execShellOptions = (options: Options<ExecShellData>) => queryOptions<ExecShellResponse, AxiosError<DefaultError>, ExecShellResponse, ReturnType<typeof execShellQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await execShell({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: execShellQueryKey(options)
});

export const execShellInfiniteQueryKey = (options: Options<ExecShellData>): QueryKey<Options<ExecShellData>> => createQueryKey('execShell', options, true);

/**
 * handles exec into pod
 */
export const execShellInfiniteOptions = (options: Options<ExecShellData>) => infiniteQueryOptions<ExecShellResponse, AxiosError<DefaultError>, InfiniteData<ExecShellResponse>, QueryKey<Options<ExecShellData>>, string | Pick<QueryKey<Options<ExecShellData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ExecShellData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await execShell({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: execShellInfiniteQueryKey(options)
});

export const getAllPodDisruptionBudgetsQueryKey = (options?: Options<GetAllPodDisruptionBudgetsData>) => createQueryKey('getAllPodDisruptionBudgets', options);

/**
 * returns a list of PodDisruptionBudget
 */
export const getAllPodDisruptionBudgetsOptions = (options?: Options<GetAllPodDisruptionBudgetsData>) => queryOptions<GetAllPodDisruptionBudgetsResponse, AxiosError<DefaultError>, GetAllPodDisruptionBudgetsResponse, ReturnType<typeof getAllPodDisruptionBudgetsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAllPodDisruptionBudgets({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllPodDisruptionBudgetsQueryKey(options)
});

export const getAllPodDisruptionBudgetsInfiniteQueryKey = (options?: Options<GetAllPodDisruptionBudgetsData>): QueryKey<Options<GetAllPodDisruptionBudgetsData>> => createQueryKey('getAllPodDisruptionBudgets', options, true);

/**
 * returns a list of PodDisruptionBudget
 */
export const getAllPodDisruptionBudgetsInfiniteOptions = (options?: Options<GetAllPodDisruptionBudgetsData>) => infiniteQueryOptions<GetAllPodDisruptionBudgetsResponse, AxiosError<DefaultError>, InfiniteData<GetAllPodDisruptionBudgetsResponse>, QueryKey<Options<GetAllPodDisruptionBudgetsData>>, string | Pick<QueryKey<Options<GetAllPodDisruptionBudgetsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetAllPodDisruptionBudgetsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllPodDisruptionBudgets({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllPodDisruptionBudgetsInfiniteQueryKey(options)
});

export const getPodDisruptionBudgetsQueryKey = (options: Options<GetPodDisruptionBudgetsData>) => createQueryKey('getPodDisruptionBudgets', options);

/**
 * returns a list of PodDisruptionBudget from specified namespace
 */
export const getPodDisruptionBudgetsOptions = (options: Options<GetPodDisruptionBudgetsData>) => queryOptions<GetPodDisruptionBudgetsResponse, AxiosError<DefaultError>, GetPodDisruptionBudgetsResponse, ReturnType<typeof getPodDisruptionBudgetsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPodDisruptionBudgets({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPodDisruptionBudgetsQueryKey(options)
});

export const getPodDisruptionBudgetsInfiniteQueryKey = (options: Options<GetPodDisruptionBudgetsData>): QueryKey<Options<GetPodDisruptionBudgetsData>> => createQueryKey('getPodDisruptionBudgets', options, true);

/**
 * returns a list of PodDisruptionBudget from specified namespace
 */
export const getPodDisruptionBudgetsInfiniteOptions = (options: Options<GetPodDisruptionBudgetsData>) => infiniteQueryOptions<GetPodDisruptionBudgetsResponse, AxiosError<DefaultError>, InfiniteData<GetPodDisruptionBudgetsResponse>, QueryKey<Options<GetPodDisruptionBudgetsData>>, string | Pick<QueryKey<Options<GetPodDisruptionBudgetsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetPodDisruptionBudgetsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getPodDisruptionBudgets({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPodDisruptionBudgetsInfiniteQueryKey(options)
});

export const getPodDisruptionBudgetQueryKey = (options: Options<GetPodDisruptionBudgetData>) => createQueryKey('getPodDisruptionBudget', options);

/**
 * returns detailed information about PodDisruptionBudget
 */
export const getPodDisruptionBudgetOptions = (options: Options<GetPodDisruptionBudgetData>) => queryOptions<GetPodDisruptionBudgetResponse, AxiosError<DefaultError>, GetPodDisruptionBudgetResponse, ReturnType<typeof getPodDisruptionBudgetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPodDisruptionBudget({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPodDisruptionBudgetQueryKey(options)
});

export const getPodDisruptionBudgetInfiniteQueryKey = (options: Options<GetPodDisruptionBudgetData>): QueryKey<Options<GetPodDisruptionBudgetData>> => createQueryKey('getPodDisruptionBudget', options, true);

/**
 * returns detailed information about PodDisruptionBudget
 */
export const getPodDisruptionBudgetInfiniteOptions = (options: Options<GetPodDisruptionBudgetData>) => infiniteQueryOptions<GetPodDisruptionBudgetResponse, AxiosError<DefaultError>, InfiniteData<GetPodDisruptionBudgetResponse>, QueryKey<Options<GetPodDisruptionBudgetData>>, string | Pick<QueryKey<Options<GetPodDisruptionBudgetData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetPodDisruptionBudgetData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getPodDisruptionBudget({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPodDisruptionBudgetInfiniteQueryKey(options)
});

export const getAllReplicaSetsQueryKey = (options?: Options<GetAllReplicaSetsData>) => createQueryKey('getAllReplicaSets', options);

/**
 * returns a list of ReplicaSets from all namespaces
 */
export const getAllReplicaSetsOptions = (options?: Options<GetAllReplicaSetsData>) => queryOptions<GetAllReplicaSetsResponse, AxiosError<DefaultError>, GetAllReplicaSetsResponse, ReturnType<typeof getAllReplicaSetsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAllReplicaSets({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllReplicaSetsQueryKey(options)
});

export const getAllReplicaSetsInfiniteQueryKey = (options?: Options<GetAllReplicaSetsData>): QueryKey<Options<GetAllReplicaSetsData>> => createQueryKey('getAllReplicaSets', options, true);

/**
 * returns a list of ReplicaSets from all namespaces
 */
export const getAllReplicaSetsInfiniteOptions = (options?: Options<GetAllReplicaSetsData>) => infiniteQueryOptions<GetAllReplicaSetsResponse, AxiosError<DefaultError>, InfiniteData<GetAllReplicaSetsResponse>, QueryKey<Options<GetAllReplicaSetsData>>, string | Pick<QueryKey<Options<GetAllReplicaSetsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetAllReplicaSetsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllReplicaSets({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllReplicaSetsInfiniteQueryKey(options)
});

export const getReplicaSetsQueryKey = (options: Options<GetReplicaSetsData>) => createQueryKey('getReplicaSets', options);

/**
 * returns a list of ReplicaSets in a namespace
 */
export const getReplicaSetsOptions = (options: Options<GetReplicaSetsData>) => queryOptions<GetReplicaSetsResponse, AxiosError<DefaultError>, GetReplicaSetsResponse, ReturnType<typeof getReplicaSetsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getReplicaSets({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getReplicaSetsQueryKey(options)
});

export const getReplicaSetsInfiniteQueryKey = (options: Options<GetReplicaSetsData>): QueryKey<Options<GetReplicaSetsData>> => createQueryKey('getReplicaSets', options, true);

/**
 * returns a list of ReplicaSets in a namespace
 */
export const getReplicaSetsInfiniteOptions = (options: Options<GetReplicaSetsData>) => infiniteQueryOptions<GetReplicaSetsResponse, AxiosError<DefaultError>, InfiniteData<GetReplicaSetsResponse>, QueryKey<Options<GetReplicaSetsData>>, string | Pick<QueryKey<Options<GetReplicaSetsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetReplicaSetsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getReplicaSets({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getReplicaSetsInfiniteQueryKey(options)
});

export const getReplicaSetQueryKey = (options: Options<GetReplicaSetData>) => createQueryKey('getReplicaSet', options);

/**
 * returns detailed information about ReplicaSet
 */
export const getReplicaSetOptions = (options: Options<GetReplicaSetData>) => queryOptions<GetReplicaSetResponse, AxiosError<DefaultError>, GetReplicaSetResponse, ReturnType<typeof getReplicaSetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getReplicaSet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getReplicaSetQueryKey(options)
});

export const getReplicaSetInfiniteQueryKey = (options: Options<GetReplicaSetData>): QueryKey<Options<GetReplicaSetData>> => createQueryKey('getReplicaSet', options, true);

/**
 * returns detailed information about ReplicaSet
 */
export const getReplicaSetInfiniteOptions = (options: Options<GetReplicaSetData>) => infiniteQueryOptions<GetReplicaSetResponse, AxiosError<DefaultError>, InfiniteData<GetReplicaSetResponse>, QueryKey<Options<GetReplicaSetData>>, string | Pick<QueryKey<Options<GetReplicaSetData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetReplicaSetData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getReplicaSet({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getReplicaSetInfiniteQueryKey(options)
});

export const getReplicaSetEventsQueryKey = (options: Options<GetReplicaSetEventsData>) => createQueryKey('getReplicaSetEvents', options);

/**
 * returns a list of Events for ReplicaSet
 */
export const getReplicaSetEventsOptions = (options: Options<GetReplicaSetEventsData>) => queryOptions<GetReplicaSetEventsResponse, AxiosError<DefaultError>, GetReplicaSetEventsResponse, ReturnType<typeof getReplicaSetEventsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getReplicaSetEvents({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getReplicaSetEventsQueryKey(options)
});

export const getReplicaSetEventsInfiniteQueryKey = (options: Options<GetReplicaSetEventsData>): QueryKey<Options<GetReplicaSetEventsData>> => createQueryKey('getReplicaSetEvents', options, true);

/**
 * returns a list of Events for ReplicaSet
 */
export const getReplicaSetEventsInfiniteOptions = (options: Options<GetReplicaSetEventsData>) => infiniteQueryOptions<GetReplicaSetEventsResponse, AxiosError<DefaultError>, InfiniteData<GetReplicaSetEventsResponse>, QueryKey<Options<GetReplicaSetEventsData>>, string | Pick<QueryKey<Options<GetReplicaSetEventsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetReplicaSetEventsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getReplicaSetEvents({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getReplicaSetEventsInfiniteQueryKey(options)
});

export const getReplicaSetPodsQueryKey = (options: Options<GetReplicaSetPodsData>) => createQueryKey('getReplicaSetPods', options);

/**
 * returns a list of Pods for ReplicaSet
 */
export const getReplicaSetPodsOptions = (options: Options<GetReplicaSetPodsData>) => queryOptions<GetReplicaSetPodsResponse, AxiosError<DefaultError>, GetReplicaSetPodsResponse, ReturnType<typeof getReplicaSetPodsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getReplicaSetPods({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getReplicaSetPodsQueryKey(options)
});

export const getReplicaSetPodsInfiniteQueryKey = (options: Options<GetReplicaSetPodsData>): QueryKey<Options<GetReplicaSetPodsData>> => createQueryKey('getReplicaSetPods', options, true);

/**
 * returns a list of Pods for ReplicaSet
 */
export const getReplicaSetPodsInfiniteOptions = (options: Options<GetReplicaSetPodsData>) => infiniteQueryOptions<GetReplicaSetPodsResponse, AxiosError<DefaultError>, InfiniteData<GetReplicaSetPodsResponse>, QueryKey<Options<GetReplicaSetPodsData>>, string | Pick<QueryKey<Options<GetReplicaSetPodsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetReplicaSetPodsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getReplicaSetPods({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getReplicaSetPodsInfiniteQueryKey(options)
});

export const getReplicaSetServicesQueryKey = (options: Options<GetReplicaSetServicesData>) => createQueryKey('getReplicaSetServices', options);

/**
 * returns a list of Services for ReplicaSet
 */
export const getReplicaSetServicesOptions = (options: Options<GetReplicaSetServicesData>) => queryOptions<GetReplicaSetServicesResponse, AxiosError<DefaultError>, GetReplicaSetServicesResponse, ReturnType<typeof getReplicaSetServicesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getReplicaSetServices({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getReplicaSetServicesQueryKey(options)
});

export const getReplicaSetServicesInfiniteQueryKey = (options: Options<GetReplicaSetServicesData>): QueryKey<Options<GetReplicaSetServicesData>> => createQueryKey('getReplicaSetServices', options, true);

/**
 * returns a list of Services for ReplicaSet
 */
export const getReplicaSetServicesInfiniteOptions = (options: Options<GetReplicaSetServicesData>) => infiniteQueryOptions<GetReplicaSetServicesResponse, AxiosError<DefaultError>, InfiniteData<GetReplicaSetServicesResponse>, QueryKey<Options<GetReplicaSetServicesData>>, string | Pick<QueryKey<Options<GetReplicaSetServicesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetReplicaSetServicesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getReplicaSetServices({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getReplicaSetServicesInfiniteQueryKey(options)
});

export const getAllReplicationControllersQueryKey = (options?: Options<GetAllReplicationControllersData>) => createQueryKey('getAllReplicationControllers', options);

/**
 * returns a list of ReplicationControllers from all namespaces
 */
export const getAllReplicationControllersOptions = (options?: Options<GetAllReplicationControllersData>) => queryOptions<GetAllReplicationControllersResponse, AxiosError<DefaultError>, GetAllReplicationControllersResponse, ReturnType<typeof getAllReplicationControllersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAllReplicationControllers({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllReplicationControllersQueryKey(options)
});

export const getAllReplicationControllersInfiniteQueryKey = (options?: Options<GetAllReplicationControllersData>): QueryKey<Options<GetAllReplicationControllersData>> => createQueryKey('getAllReplicationControllers', options, true);

/**
 * returns a list of ReplicationControllers from all namespaces
 */
export const getAllReplicationControllersInfiniteOptions = (options?: Options<GetAllReplicationControllersData>) => infiniteQueryOptions<GetAllReplicationControllersResponse, AxiosError<DefaultError>, InfiniteData<GetAllReplicationControllersResponse>, QueryKey<Options<GetAllReplicationControllersData>>, string | Pick<QueryKey<Options<GetAllReplicationControllersData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetAllReplicationControllersData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllReplicationControllers({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllReplicationControllersInfiniteQueryKey(options)
});

export const getReplicationControllersQueryKey = (options: Options<GetReplicationControllersData>) => createQueryKey('getReplicationControllers', options);

/**
 * returns a list of ReplicationController in a namespace
 */
export const getReplicationControllersOptions = (options: Options<GetReplicationControllersData>) => queryOptions<GetReplicationControllersResponse, AxiosError<DefaultError>, GetReplicationControllersResponse, ReturnType<typeof getReplicationControllersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getReplicationControllers({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getReplicationControllersQueryKey(options)
});

export const getReplicationControllersInfiniteQueryKey = (options: Options<GetReplicationControllersData>): QueryKey<Options<GetReplicationControllersData>> => createQueryKey('getReplicationControllers', options, true);

/**
 * returns a list of ReplicationController in a namespace
 */
export const getReplicationControllersInfiniteOptions = (options: Options<GetReplicationControllersData>) => infiniteQueryOptions<GetReplicationControllersResponse, AxiosError<DefaultError>, InfiniteData<GetReplicationControllersResponse>, QueryKey<Options<GetReplicationControllersData>>, string | Pick<QueryKey<Options<GetReplicationControllersData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetReplicationControllersData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getReplicationControllers({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getReplicationControllersInfiniteQueryKey(options)
});

export const getReplicationControllerQueryKey = (options: Options<GetReplicationControllerData>) => createQueryKey('getReplicationController', options);

/**
 * returns detailed information about ReplicationController
 */
export const getReplicationControllerOptions = (options: Options<GetReplicationControllerData>) => queryOptions<GetReplicationControllerResponse, AxiosError<DefaultError>, GetReplicationControllerResponse, ReturnType<typeof getReplicationControllerQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getReplicationController({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getReplicationControllerQueryKey(options)
});

export const getReplicationControllerInfiniteQueryKey = (options: Options<GetReplicationControllerData>): QueryKey<Options<GetReplicationControllerData>> => createQueryKey('getReplicationController', options, true);

/**
 * returns detailed information about ReplicationController
 */
export const getReplicationControllerInfiniteOptions = (options: Options<GetReplicationControllerData>) => infiniteQueryOptions<GetReplicationControllerResponse, AxiosError<DefaultError>, InfiniteData<GetReplicationControllerResponse>, QueryKey<Options<GetReplicationControllerData>>, string | Pick<QueryKey<Options<GetReplicationControllerData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetReplicationControllerData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getReplicationController({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getReplicationControllerInfiniteQueryKey(options)
});

export const getReplicationControllerEventsQueryKey = (options: Options<GetReplicationControllerEventsData>) => createQueryKey('getReplicationControllerEvents', options);

/**
 * returns a list of Events for ReplicationController
 */
export const getReplicationControllerEventsOptions = (options: Options<GetReplicationControllerEventsData>) => queryOptions<GetReplicationControllerEventsResponse, AxiosError<DefaultError>, GetReplicationControllerEventsResponse, ReturnType<typeof getReplicationControllerEventsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getReplicationControllerEvents({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getReplicationControllerEventsQueryKey(options)
});

export const getReplicationControllerEventsInfiniteQueryKey = (options: Options<GetReplicationControllerEventsData>): QueryKey<Options<GetReplicationControllerEventsData>> => createQueryKey('getReplicationControllerEvents', options, true);

/**
 * returns a list of Events for ReplicationController
 */
export const getReplicationControllerEventsInfiniteOptions = (options: Options<GetReplicationControllerEventsData>) => infiniteQueryOptions<GetReplicationControllerEventsResponse, AxiosError<DefaultError>, InfiniteData<GetReplicationControllerEventsResponse>, QueryKey<Options<GetReplicationControllerEventsData>>, string | Pick<QueryKey<Options<GetReplicationControllerEventsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetReplicationControllerEventsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getReplicationControllerEvents({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getReplicationControllerEventsInfiniteQueryKey(options)
});

export const getReplicationControllerPodsQueryKey = (options: Options<GetReplicationControllerPodsData>) => createQueryKey('getReplicationControllerPods', options);

/**
 * returns a list of Pods for ReplicationController
 */
export const getReplicationControllerPodsOptions = (options: Options<GetReplicationControllerPodsData>) => queryOptions<GetReplicationControllerPodsResponse, AxiosError<DefaultError>, GetReplicationControllerPodsResponse, ReturnType<typeof getReplicationControllerPodsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getReplicationControllerPods({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getReplicationControllerPodsQueryKey(options)
});

export const getReplicationControllerPodsInfiniteQueryKey = (options: Options<GetReplicationControllerPodsData>): QueryKey<Options<GetReplicationControllerPodsData>> => createQueryKey('getReplicationControllerPods', options, true);

/**
 * returns a list of Pods for ReplicationController
 */
export const getReplicationControllerPodsInfiniteOptions = (options: Options<GetReplicationControllerPodsData>) => infiniteQueryOptions<GetReplicationControllerPodsResponse, AxiosError<DefaultError>, InfiniteData<GetReplicationControllerPodsResponse>, QueryKey<Options<GetReplicationControllerPodsData>>, string | Pick<QueryKey<Options<GetReplicationControllerPodsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetReplicationControllerPodsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getReplicationControllerPods({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getReplicationControllerPodsInfiniteQueryKey(options)
});

export const getReplicationControllerServicesQueryKey = (options: Options<GetReplicationControllerServicesData>) => createQueryKey('getReplicationControllerServices', options);

/**
 * returns a list of Services for ReplicationController
 */
export const getReplicationControllerServicesOptions = (options: Options<GetReplicationControllerServicesData>) => queryOptions<GetReplicationControllerServicesResponse, AxiosError<DefaultError>, GetReplicationControllerServicesResponse, ReturnType<typeof getReplicationControllerServicesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getReplicationControllerServices({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getReplicationControllerServicesQueryKey(options)
});

export const getReplicationControllerServicesInfiniteQueryKey = (options: Options<GetReplicationControllerServicesData>): QueryKey<Options<GetReplicationControllerServicesData>> => createQueryKey('getReplicationControllerServices', options, true);

/**
 * returns a list of Services for ReplicationController
 */
export const getReplicationControllerServicesInfiniteOptions = (options: Options<GetReplicationControllerServicesData>) => infiniteQueryOptions<GetReplicationControllerServicesResponse, AxiosError<DefaultError>, InfiniteData<GetReplicationControllerServicesResponse>, QueryKey<Options<GetReplicationControllerServicesData>>, string | Pick<QueryKey<Options<GetReplicationControllerServicesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetReplicationControllerServicesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getReplicationControllerServices({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getReplicationControllerServicesInfiniteQueryKey(options)
});

/**
 * scales ReplicationController to a number of replicas
 */
export const updateReplicationControllerReplicasMutation = (options?: Partial<Options<UpdateReplicationControllerReplicasData>>): UseMutationOptions<unknown, AxiosError<DefaultError>, Options<UpdateReplicationControllerReplicasData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<DefaultError>, Options<UpdateReplicationControllerReplicasData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateReplicationControllerReplicas({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAllRolesQueryKey = (options?: Options<GetAllRolesData>) => createQueryKey('getAllRoles', options);

/**
 * returns a list of Roles from all namespace
 */
export const getAllRolesOptions = (options?: Options<GetAllRolesData>) => queryOptions<GetAllRolesResponse, AxiosError<DefaultError>, GetAllRolesResponse, ReturnType<typeof getAllRolesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAllRoles({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllRolesQueryKey(options)
});

export const getAllRolesInfiniteQueryKey = (options?: Options<GetAllRolesData>): QueryKey<Options<GetAllRolesData>> => createQueryKey('getAllRoles', options, true);

/**
 * returns a list of Roles from all namespace
 */
export const getAllRolesInfiniteOptions = (options?: Options<GetAllRolesData>) => infiniteQueryOptions<GetAllRolesResponse, AxiosError<DefaultError>, InfiniteData<GetAllRolesResponse>, QueryKey<Options<GetAllRolesData>>, string | Pick<QueryKey<Options<GetAllRolesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetAllRolesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllRoles({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllRolesInfiniteQueryKey(options)
});

export const getRolesQueryKey = (options: Options<GetRolesData>) => createQueryKey('getRoles', options);

/**
 * returns a list of Roles in a namespace
 */
export const getRolesOptions = (options: Options<GetRolesData>) => queryOptions<GetRolesResponse, AxiosError<DefaultError>, GetRolesResponse, ReturnType<typeof getRolesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getRoles({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getRolesQueryKey(options)
});

export const getRolesInfiniteQueryKey = (options: Options<GetRolesData>): QueryKey<Options<GetRolesData>> => createQueryKey('getRoles', options, true);

/**
 * returns a list of Roles in a namespace
 */
export const getRolesInfiniteOptions = (options: Options<GetRolesData>) => infiniteQueryOptions<GetRolesResponse, AxiosError<DefaultError>, InfiniteData<GetRolesResponse>, QueryKey<Options<GetRolesData>>, string | Pick<QueryKey<Options<GetRolesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetRolesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getRoles({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getRolesInfiniteQueryKey(options)
});

export const getRoleQueryKey = (options: Options<GetRoleData>) => createQueryKey('getRole', options);

/**
 * returns detailed information about Role
 */
export const getRoleOptions = (options: Options<GetRoleData>) => queryOptions<GetRoleResponse, AxiosError<DefaultError>, GetRoleResponse, ReturnType<typeof getRoleQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getRole({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getRoleQueryKey(options)
});

export const getRoleInfiniteQueryKey = (options: Options<GetRoleData>): QueryKey<Options<GetRoleData>> => createQueryKey('getRole', options, true);

/**
 * returns detailed information about Role
 */
export const getRoleInfiniteOptions = (options: Options<GetRoleData>) => infiniteQueryOptions<GetRoleResponse, AxiosError<DefaultError>, InfiniteData<GetRoleResponse>, QueryKey<Options<GetRoleData>>, string | Pick<QueryKey<Options<GetRoleData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetRoleData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getRole({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getRoleInfiniteQueryKey(options)
});

export const getAllRoleBindingsQueryKey = (options?: Options<GetAllRoleBindingsData>) => createQueryKey('getAllRoleBindings', options);

/**
 * returns a list of RoleBindings from all namespace
 */
export const getAllRoleBindingsOptions = (options?: Options<GetAllRoleBindingsData>) => queryOptions<GetAllRoleBindingsResponse, AxiosError<DefaultError>, GetAllRoleBindingsResponse, ReturnType<typeof getAllRoleBindingsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAllRoleBindings({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllRoleBindingsQueryKey(options)
});

export const getAllRoleBindingsInfiniteQueryKey = (options?: Options<GetAllRoleBindingsData>): QueryKey<Options<GetAllRoleBindingsData>> => createQueryKey('getAllRoleBindings', options, true);

/**
 * returns a list of RoleBindings from all namespace
 */
export const getAllRoleBindingsInfiniteOptions = (options?: Options<GetAllRoleBindingsData>) => infiniteQueryOptions<GetAllRoleBindingsResponse, AxiosError<DefaultError>, InfiniteData<GetAllRoleBindingsResponse>, QueryKey<Options<GetAllRoleBindingsData>>, string | Pick<QueryKey<Options<GetAllRoleBindingsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetAllRoleBindingsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllRoleBindings({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllRoleBindingsInfiniteQueryKey(options)
});

export const getRoleBindingsQueryKey = (options: Options<GetRoleBindingsData>) => createQueryKey('getRoleBindings', options);

/**
 * returns a list of RoleBindings in a namespace
 */
export const getRoleBindingsOptions = (options: Options<GetRoleBindingsData>) => queryOptions<GetRoleBindingsResponse, AxiosError<DefaultError>, GetRoleBindingsResponse, ReturnType<typeof getRoleBindingsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getRoleBindings({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getRoleBindingsQueryKey(options)
});

export const getRoleBindingsInfiniteQueryKey = (options: Options<GetRoleBindingsData>): QueryKey<Options<GetRoleBindingsData>> => createQueryKey('getRoleBindings', options, true);

/**
 * returns a list of RoleBindings in a namespace
 */
export const getRoleBindingsInfiniteOptions = (options: Options<GetRoleBindingsData>) => infiniteQueryOptions<GetRoleBindingsResponse, AxiosError<DefaultError>, InfiniteData<GetRoleBindingsResponse>, QueryKey<Options<GetRoleBindingsData>>, string | Pick<QueryKey<Options<GetRoleBindingsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetRoleBindingsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getRoleBindings({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getRoleBindingsInfiniteQueryKey(options)
});

export const getRoleBindingQueryKey = (options: Options<GetRoleBindingData>) => createQueryKey('getRoleBinding', options);

/**
 * returns detailed information about RoleBinding
 */
export const getRoleBindingOptions = (options: Options<GetRoleBindingData>) => queryOptions<GetRoleBindingResponse, AxiosError<DefaultError>, GetRoleBindingResponse, ReturnType<typeof getRoleBindingQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getRoleBinding({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getRoleBindingQueryKey(options)
});

export const getRoleBindingInfiniteQueryKey = (options: Options<GetRoleBindingData>): QueryKey<Options<GetRoleBindingData>> => createQueryKey('getRoleBinding', options, true);

/**
 * returns detailed information about RoleBinding
 */
export const getRoleBindingInfiniteOptions = (options: Options<GetRoleBindingData>) => infiniteQueryOptions<GetRoleBindingResponse, AxiosError<DefaultError>, InfiniteData<GetRoleBindingResponse>, QueryKey<Options<GetRoleBindingData>>, string | Pick<QueryKey<Options<GetRoleBindingData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetRoleBindingData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getRoleBinding({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getRoleBindingInfiniteQueryKey(options)
});

export const getNamespacedResourceReplicasQueryKey = (options: Options<GetNamespacedResourceReplicasData>) => createQueryKey('getNamespacedResourceReplicas', options);

/**
 * returns a number of replicas of namespaced resource
 */
export const getNamespacedResourceReplicasOptions = (options: Options<GetNamespacedResourceReplicasData>) => queryOptions<GetNamespacedResourceReplicasResponse, AxiosError<DefaultError>, GetNamespacedResourceReplicasResponse, ReturnType<typeof getNamespacedResourceReplicasQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getNamespacedResourceReplicas({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getNamespacedResourceReplicasQueryKey(options)
});

export const getNamespacedResourceReplicasInfiniteQueryKey = (options: Options<GetNamespacedResourceReplicasData>): QueryKey<Options<GetNamespacedResourceReplicasData>> => createQueryKey('getNamespacedResourceReplicas', options, true);

/**
 * returns a number of replicas of namespaced resource
 */
export const getNamespacedResourceReplicasInfiniteOptions = (options: Options<GetNamespacedResourceReplicasData>) => infiniteQueryOptions<GetNamespacedResourceReplicasResponse, AxiosError<DefaultError>, InfiniteData<GetNamespacedResourceReplicasResponse>, QueryKey<Options<GetNamespacedResourceReplicasData>>, string | Pick<QueryKey<Options<GetNamespacedResourceReplicasData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetNamespacedResourceReplicasData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getNamespacedResourceReplicas({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getNamespacedResourceReplicasInfiniteQueryKey(options)
});

/**
 * scales a namespaced resource
 */
export const scaleNamespacedResourceMutation = (options?: Partial<Options<ScaleNamespacedResourceData>>): UseMutationOptions<ScaleNamespacedResourceResponse, AxiosError<DefaultError>, Options<ScaleNamespacedResourceData>> => {
    const mutationOptions: UseMutationOptions<ScaleNamespacedResourceResponse, AxiosError<DefaultError>, Options<ScaleNamespacedResourceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await scaleNamespacedResource({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getResourceReplicasQueryKey = (options: Options<GetResourceReplicasData>) => createQueryKey('getResourceReplicas', options);

/**
 * returns a number of replicas of non-namespaced resource
 */
export const getResourceReplicasOptions = (options: Options<GetResourceReplicasData>) => queryOptions<GetResourceReplicasResponse, AxiosError<DefaultError>, GetResourceReplicasResponse, ReturnType<typeof getResourceReplicasQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getResourceReplicas({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getResourceReplicasQueryKey(options)
});

export const getResourceReplicasInfiniteQueryKey = (options: Options<GetResourceReplicasData>): QueryKey<Options<GetResourceReplicasData>> => createQueryKey('getResourceReplicas', options, true);

/**
 * returns a number of replicas of non-namespaced resource
 */
export const getResourceReplicasInfiniteOptions = (options: Options<GetResourceReplicasData>) => infiniteQueryOptions<GetResourceReplicasResponse, AxiosError<DefaultError>, InfiniteData<GetResourceReplicasResponse>, QueryKey<Options<GetResourceReplicasData>>, string | Pick<QueryKey<Options<GetResourceReplicasData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetResourceReplicasData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getResourceReplicas({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getResourceReplicasInfiniteQueryKey(options)
});

/**
 * scales a non-namespaced resource
 */
export const scaleResourceMutation = (options?: Partial<Options<ScaleResourceData>>): UseMutationOptions<ScaleResourceResponse, AxiosError<DefaultError>, Options<ScaleResourceData>> => {
    const mutationOptions: UseMutationOptions<ScaleResourceResponse, AxiosError<DefaultError>, Options<ScaleResourceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await scaleResource({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAllSecretsQueryKey = (options?: Options<GetAllSecretsData>) => createQueryKey('getAllSecrets', options);

/**
 * returns a list of Secrets from all namespaces
 */
export const getAllSecretsOptions = (options?: Options<GetAllSecretsData>) => queryOptions<GetAllSecretsResponse, AxiosError<DefaultError>, GetAllSecretsResponse, ReturnType<typeof getAllSecretsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAllSecrets({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllSecretsQueryKey(options)
});

export const getAllSecretsInfiniteQueryKey = (options?: Options<GetAllSecretsData>): QueryKey<Options<GetAllSecretsData>> => createQueryKey('getAllSecrets', options, true);

/**
 * returns a list of Secrets from all namespaces
 */
export const getAllSecretsInfiniteOptions = (options?: Options<GetAllSecretsData>) => infiniteQueryOptions<GetAllSecretsResponse, AxiosError<DefaultError>, InfiniteData<GetAllSecretsResponse>, QueryKey<Options<GetAllSecretsData>>, string | Pick<QueryKey<Options<GetAllSecretsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetAllSecretsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllSecrets({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllSecretsInfiniteQueryKey(options)
});

/**
 * stores ImagePullSecret in a Kubernetes Secret
 */
export const createImagePullSecretMutation = (options?: Partial<Options<CreateImagePullSecretData>>): UseMutationOptions<CreateImagePullSecretResponse, AxiosError<DefaultError>, Options<CreateImagePullSecretData>> => {
    const mutationOptions: UseMutationOptions<CreateImagePullSecretResponse, AxiosError<DefaultError>, Options<CreateImagePullSecretData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createImagePullSecret({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSecretsQueryKey = (options: Options<GetSecretsData>) => createQueryKey('getSecrets', options);

/**
 * returns a list of Secrets in a namespace
 */
export const getSecretsOptions = (options: Options<GetSecretsData>) => queryOptions<GetSecretsResponse, AxiosError<DefaultError>, GetSecretsResponse, ReturnType<typeof getSecretsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getSecrets({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getSecretsQueryKey(options)
});

export const getSecretsInfiniteQueryKey = (options: Options<GetSecretsData>): QueryKey<Options<GetSecretsData>> => createQueryKey('getSecrets', options, true);

/**
 * returns a list of Secrets in a namespace
 */
export const getSecretsInfiniteOptions = (options: Options<GetSecretsData>) => infiniteQueryOptions<GetSecretsResponse, AxiosError<DefaultError>, InfiniteData<GetSecretsResponse>, QueryKey<Options<GetSecretsData>>, string | Pick<QueryKey<Options<GetSecretsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetSecretsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getSecrets({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getSecretsInfiniteQueryKey(options)
});

export const getSecretQueryKey = (options: Options<GetSecretData>) => createQueryKey('getSecret', options);

/**
 * returns detailed information about Secret
 */
export const getSecretOptions = (options: Options<GetSecretData>) => queryOptions<GetSecretResponse, AxiosError<DefaultError>, GetSecretResponse, ReturnType<typeof getSecretQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getSecret({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getSecretQueryKey(options)
});

export const getSecretInfiniteQueryKey = (options: Options<GetSecretData>): QueryKey<Options<GetSecretData>> => createQueryKey('getSecret', options, true);

/**
 * returns detailed information about Secret
 */
export const getSecretInfiniteOptions = (options: Options<GetSecretData>) => infiniteQueryOptions<GetSecretResponse, AxiosError<DefaultError>, InfiniteData<GetSecretResponse>, QueryKey<Options<GetSecretData>>, string | Pick<QueryKey<Options<GetSecretData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetSecretData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getSecret({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getSecretInfiniteQueryKey(options)
});

export const getAllServicesQueryKey = (options?: Options<GetAllServicesData>) => createQueryKey('getAllServices', options);

/**
 * returns a list of Services from all namespaces
 */
export const getAllServicesOptions = (options?: Options<GetAllServicesData>) => queryOptions<GetAllServicesResponse, AxiosError<DefaultError>, GetAllServicesResponse, ReturnType<typeof getAllServicesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAllServices({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllServicesQueryKey(options)
});

export const getAllServicesInfiniteQueryKey = (options?: Options<GetAllServicesData>): QueryKey<Options<GetAllServicesData>> => createQueryKey('getAllServices', options, true);

/**
 * returns a list of Services from all namespaces
 */
export const getAllServicesInfiniteOptions = (options?: Options<GetAllServicesData>) => infiniteQueryOptions<GetAllServicesResponse, AxiosError<DefaultError>, InfiniteData<GetAllServicesResponse>, QueryKey<Options<GetAllServicesData>>, string | Pick<QueryKey<Options<GetAllServicesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetAllServicesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllServices({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllServicesInfiniteQueryKey(options)
});

export const getServicesQueryKey = (options: Options<GetServicesData>) => createQueryKey('getServices', options);

/**
 * returns a list of Services in a namespace
 */
export const getServicesOptions = (options: Options<GetServicesData>) => queryOptions<GetServicesResponse, AxiosError<DefaultError>, GetServicesResponse, ReturnType<typeof getServicesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getServices({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getServicesQueryKey(options)
});

export const getServicesInfiniteQueryKey = (options: Options<GetServicesData>): QueryKey<Options<GetServicesData>> => createQueryKey('getServices', options, true);

/**
 * returns a list of Services in a namespace
 */
export const getServicesInfiniteOptions = (options: Options<GetServicesData>) => infiniteQueryOptions<GetServicesResponse, AxiosError<DefaultError>, InfiniteData<GetServicesResponse>, QueryKey<Options<GetServicesData>>, string | Pick<QueryKey<Options<GetServicesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetServicesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getServices({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getServicesInfiniteQueryKey(options)
});

export const getServiceQueryKey = (options: Options<GetServiceData>) => createQueryKey('getService', options);

/**
 * returns detailed information about Service
 */
export const getServiceOptions = (options: Options<GetServiceData>) => queryOptions<GetServiceResponse, AxiosError<DefaultError>, GetServiceResponse, ReturnType<typeof getServiceQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getService({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getServiceQueryKey(options)
});

export const getServiceInfiniteQueryKey = (options: Options<GetServiceData>): QueryKey<Options<GetServiceData>> => createQueryKey('getService', options, true);

/**
 * returns detailed information about Service
 */
export const getServiceInfiniteOptions = (options: Options<GetServiceData>) => infiniteQueryOptions<GetServiceResponse, AxiosError<DefaultError>, InfiniteData<GetServiceResponse>, QueryKey<Options<GetServiceData>>, string | Pick<QueryKey<Options<GetServiceData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetServiceData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getService({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getServiceInfiniteQueryKey(options)
});

export const getServiceEventsQueryKey = (options: Options<GetServiceEventsData>) => createQueryKey('getServiceEvents', options);

/**
 * returns a list of Events for Service
 */
export const getServiceEventsOptions = (options: Options<GetServiceEventsData>) => queryOptions<GetServiceEventsResponse, AxiosError<DefaultError>, GetServiceEventsResponse, ReturnType<typeof getServiceEventsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getServiceEvents({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getServiceEventsQueryKey(options)
});

export const getServiceEventsInfiniteQueryKey = (options: Options<GetServiceEventsData>): QueryKey<Options<GetServiceEventsData>> => createQueryKey('getServiceEvents', options, true);

/**
 * returns a list of Events for Service
 */
export const getServiceEventsInfiniteOptions = (options: Options<GetServiceEventsData>) => infiniteQueryOptions<GetServiceEventsResponse, AxiosError<DefaultError>, InfiniteData<GetServiceEventsResponse>, QueryKey<Options<GetServiceEventsData>>, string | Pick<QueryKey<Options<GetServiceEventsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetServiceEventsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getServiceEvents({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getServiceEventsInfiniteQueryKey(options)
});

export const getServiceIngressesQueryKey = (options: Options<GetServiceIngressesData>) => createQueryKey('getServiceIngresses', options);

/**
 * returns a list of Ingresses for Service
 */
export const getServiceIngressesOptions = (options: Options<GetServiceIngressesData>) => queryOptions<GetServiceIngressesResponse, AxiosError<DefaultError>, GetServiceIngressesResponse, ReturnType<typeof getServiceIngressesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getServiceIngresses({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getServiceIngressesQueryKey(options)
});

export const getServiceIngressesInfiniteQueryKey = (options: Options<GetServiceIngressesData>): QueryKey<Options<GetServiceIngressesData>> => createQueryKey('getServiceIngresses', options, true);

/**
 * returns a list of Ingresses for Service
 */
export const getServiceIngressesInfiniteOptions = (options: Options<GetServiceIngressesData>) => infiniteQueryOptions<GetServiceIngressesResponse, AxiosError<DefaultError>, InfiniteData<GetServiceIngressesResponse>, QueryKey<Options<GetServiceIngressesData>>, string | Pick<QueryKey<Options<GetServiceIngressesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetServiceIngressesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getServiceIngresses({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getServiceIngressesInfiniteQueryKey(options)
});

export const getServicePodsQueryKey = (options: Options<GetServicePodsData>) => createQueryKey('getServicePods', options);

/**
 * returns a list of Pods for Service
 */
export const getServicePodsOptions = (options: Options<GetServicePodsData>) => queryOptions<GetServicePodsResponse, AxiosError<DefaultError>, GetServicePodsResponse, ReturnType<typeof getServicePodsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getServicePods({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getServicePodsQueryKey(options)
});

export const getServicePodsInfiniteQueryKey = (options: Options<GetServicePodsData>): QueryKey<Options<GetServicePodsData>> => createQueryKey('getServicePods', options, true);

/**
 * returns a list of Pods for Service
 */
export const getServicePodsInfiniteOptions = (options: Options<GetServicePodsData>) => infiniteQueryOptions<GetServicePodsResponse, AxiosError<DefaultError>, InfiniteData<GetServicePodsResponse>, QueryKey<Options<GetServicePodsData>>, string | Pick<QueryKey<Options<GetServicePodsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetServicePodsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getServicePods({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getServicePodsInfiniteQueryKey(options)
});

export const getAllServiceAccountsQueryKey = (options?: Options<GetAllServiceAccountsData>) => createQueryKey('getAllServiceAccounts', options);

/**
 * returns a list of ServiceAccounts from all namespaces
 */
export const getAllServiceAccountsOptions = (options?: Options<GetAllServiceAccountsData>) => queryOptions<GetAllServiceAccountsResponse, AxiosError<DefaultError>, GetAllServiceAccountsResponse, ReturnType<typeof getAllServiceAccountsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAllServiceAccounts({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllServiceAccountsQueryKey(options)
});

export const getAllServiceAccountsInfiniteQueryKey = (options?: Options<GetAllServiceAccountsData>): QueryKey<Options<GetAllServiceAccountsData>> => createQueryKey('getAllServiceAccounts', options, true);

/**
 * returns a list of ServiceAccounts from all namespaces
 */
export const getAllServiceAccountsInfiniteOptions = (options?: Options<GetAllServiceAccountsData>) => infiniteQueryOptions<GetAllServiceAccountsResponse, AxiosError<DefaultError>, InfiniteData<GetAllServiceAccountsResponse>, QueryKey<Options<GetAllServiceAccountsData>>, string | Pick<QueryKey<Options<GetAllServiceAccountsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetAllServiceAccountsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllServiceAccounts({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllServiceAccountsInfiniteQueryKey(options)
});

export const getServiceAccountsQueryKey = (options: Options<GetServiceAccountsData>) => createQueryKey('getServiceAccounts', options);

/**
 * returns a list of ServiceAccounts in a namespaces
 */
export const getServiceAccountsOptions = (options: Options<GetServiceAccountsData>) => queryOptions<GetServiceAccountsResponse, AxiosError<DefaultError>, GetServiceAccountsResponse, ReturnType<typeof getServiceAccountsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getServiceAccounts({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getServiceAccountsQueryKey(options)
});

export const getServiceAccountsInfiniteQueryKey = (options: Options<GetServiceAccountsData>): QueryKey<Options<GetServiceAccountsData>> => createQueryKey('getServiceAccounts', options, true);

/**
 * returns a list of ServiceAccounts in a namespaces
 */
export const getServiceAccountsInfiniteOptions = (options: Options<GetServiceAccountsData>) => infiniteQueryOptions<GetServiceAccountsResponse, AxiosError<DefaultError>, InfiniteData<GetServiceAccountsResponse>, QueryKey<Options<GetServiceAccountsData>>, string | Pick<QueryKey<Options<GetServiceAccountsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetServiceAccountsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getServiceAccounts({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getServiceAccountsInfiniteQueryKey(options)
});

export const getServiceAccountQueryKey = (options: Options<GetServiceAccountData>) => createQueryKey('getServiceAccount', options);

/**
 * returns detailed information about ServiceAccount
 */
export const getServiceAccountOptions = (options: Options<GetServiceAccountData>) => queryOptions<GetServiceAccountResponse, AxiosError<DefaultError>, GetServiceAccountResponse, ReturnType<typeof getServiceAccountQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getServiceAccount({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getServiceAccountQueryKey(options)
});

export const getServiceAccountInfiniteQueryKey = (options: Options<GetServiceAccountData>): QueryKey<Options<GetServiceAccountData>> => createQueryKey('getServiceAccount', options, true);

/**
 * returns detailed information about ServiceAccount
 */
export const getServiceAccountInfiniteOptions = (options: Options<GetServiceAccountData>) => infiniteQueryOptions<GetServiceAccountResponse, AxiosError<DefaultError>, InfiniteData<GetServiceAccountResponse>, QueryKey<Options<GetServiceAccountData>>, string | Pick<QueryKey<Options<GetServiceAccountData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetServiceAccountData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getServiceAccount({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getServiceAccountInfiniteQueryKey(options)
});

export const getServiceAccountImagePullSecretsQueryKey = (options: Options<GetServiceAccountImagePullSecretsData>) => createQueryKey('getServiceAccountImagePullSecrets', options);

/**
 * returns a list of ImagePullSecret Secrets for ServiceAccount
 */
export const getServiceAccountImagePullSecretsOptions = (options: Options<GetServiceAccountImagePullSecretsData>) => queryOptions<GetServiceAccountImagePullSecretsResponse, AxiosError<DefaultError>, GetServiceAccountImagePullSecretsResponse, ReturnType<typeof getServiceAccountImagePullSecretsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getServiceAccountImagePullSecrets({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getServiceAccountImagePullSecretsQueryKey(options)
});

export const getServiceAccountImagePullSecretsInfiniteQueryKey = (options: Options<GetServiceAccountImagePullSecretsData>): QueryKey<Options<GetServiceAccountImagePullSecretsData>> => createQueryKey('getServiceAccountImagePullSecrets', options, true);

/**
 * returns a list of ImagePullSecret Secrets for ServiceAccount
 */
export const getServiceAccountImagePullSecretsInfiniteOptions = (options: Options<GetServiceAccountImagePullSecretsData>) => infiniteQueryOptions<GetServiceAccountImagePullSecretsResponse, AxiosError<DefaultError>, InfiniteData<GetServiceAccountImagePullSecretsResponse>, QueryKey<Options<GetServiceAccountImagePullSecretsData>>, string | Pick<QueryKey<Options<GetServiceAccountImagePullSecretsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetServiceAccountImagePullSecretsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getServiceAccountImagePullSecrets({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getServiceAccountImagePullSecretsInfiniteQueryKey(options)
});

export const getServiceAccountSecretsQueryKey = (options: Options<GetServiceAccountSecretsData>) => createQueryKey('getServiceAccountSecrets', options);

/**
 * returns a list of Secrets for ServiceAccount
 */
export const getServiceAccountSecretsOptions = (options: Options<GetServiceAccountSecretsData>) => queryOptions<GetServiceAccountSecretsResponse, AxiosError<DefaultError>, GetServiceAccountSecretsResponse, ReturnType<typeof getServiceAccountSecretsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getServiceAccountSecrets({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getServiceAccountSecretsQueryKey(options)
});

export const getServiceAccountSecretsInfiniteQueryKey = (options: Options<GetServiceAccountSecretsData>): QueryKey<Options<GetServiceAccountSecretsData>> => createQueryKey('getServiceAccountSecrets', options, true);

/**
 * returns a list of Secrets for ServiceAccount
 */
export const getServiceAccountSecretsInfiniteOptions = (options: Options<GetServiceAccountSecretsData>) => infiniteQueryOptions<GetServiceAccountSecretsResponse, AxiosError<DefaultError>, InfiniteData<GetServiceAccountSecretsResponse>, QueryKey<Options<GetServiceAccountSecretsData>>, string | Pick<QueryKey<Options<GetServiceAccountSecretsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetServiceAccountSecretsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getServiceAccountSecrets({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getServiceAccountSecretsInfiniteQueryKey(options)
});

export const getAllStatefulSetsQueryKey = (options?: Options<GetAllStatefulSetsData>) => createQueryKey('getAllStatefulSets', options);

/**
 * returns a list of StatefulSets from all namespaces
 */
export const getAllStatefulSetsOptions = (options?: Options<GetAllStatefulSetsData>) => queryOptions<GetAllStatefulSetsResponse, AxiosError<DefaultError>, GetAllStatefulSetsResponse, ReturnType<typeof getAllStatefulSetsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAllStatefulSets({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllStatefulSetsQueryKey(options)
});

export const getAllStatefulSetsInfiniteQueryKey = (options?: Options<GetAllStatefulSetsData>): QueryKey<Options<GetAllStatefulSetsData>> => createQueryKey('getAllStatefulSets', options, true);

/**
 * returns a list of StatefulSets from all namespaces
 */
export const getAllStatefulSetsInfiniteOptions = (options?: Options<GetAllStatefulSetsData>) => infiniteQueryOptions<GetAllStatefulSetsResponse, AxiosError<DefaultError>, InfiniteData<GetAllStatefulSetsResponse>, QueryKey<Options<GetAllStatefulSetsData>>, string | Pick<QueryKey<Options<GetAllStatefulSetsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetAllStatefulSetsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllStatefulSets({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllStatefulSetsInfiniteQueryKey(options)
});

export const getStatefulSetsQueryKey = (options: Options<GetStatefulSetsData>) => createQueryKey('getStatefulSets', options);

/**
 * returns a list of StatefulSets in a namespaces
 */
export const getStatefulSetsOptions = (options: Options<GetStatefulSetsData>) => queryOptions<GetStatefulSetsResponse, AxiosError<DefaultError>, GetStatefulSetsResponse, ReturnType<typeof getStatefulSetsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getStatefulSets({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getStatefulSetsQueryKey(options)
});

export const getStatefulSetsInfiniteQueryKey = (options: Options<GetStatefulSetsData>): QueryKey<Options<GetStatefulSetsData>> => createQueryKey('getStatefulSets', options, true);

/**
 * returns a list of StatefulSets in a namespaces
 */
export const getStatefulSetsInfiniteOptions = (options: Options<GetStatefulSetsData>) => infiniteQueryOptions<GetStatefulSetsResponse, AxiosError<DefaultError>, InfiniteData<GetStatefulSetsResponse>, QueryKey<Options<GetStatefulSetsData>>, string | Pick<QueryKey<Options<GetStatefulSetsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetStatefulSetsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getStatefulSets({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getStatefulSetsInfiniteQueryKey(options)
});

export const getStatefulSetQueryKey = (options: Options<GetStatefulSetData>) => createQueryKey('getStatefulSet', options);

/**
 * returns detailed information about StatefulSets
 */
export const getStatefulSetOptions = (options: Options<GetStatefulSetData>) => queryOptions<GetStatefulSetResponse, AxiosError<DefaultError>, GetStatefulSetResponse, ReturnType<typeof getStatefulSetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getStatefulSet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getStatefulSetQueryKey(options)
});

export const getStatefulSetInfiniteQueryKey = (options: Options<GetStatefulSetData>): QueryKey<Options<GetStatefulSetData>> => createQueryKey('getStatefulSet', options, true);

/**
 * returns detailed information about StatefulSets
 */
export const getStatefulSetInfiniteOptions = (options: Options<GetStatefulSetData>) => infiniteQueryOptions<GetStatefulSetResponse, AxiosError<DefaultError>, InfiniteData<GetStatefulSetResponse>, QueryKey<Options<GetStatefulSetData>>, string | Pick<QueryKey<Options<GetStatefulSetData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetStatefulSetData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getStatefulSet({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getStatefulSetInfiniteQueryKey(options)
});

export const getStatefulSetEventsQueryKey = (options: Options<GetStatefulSetEventsData>) => createQueryKey('getStatefulSetEvents', options);

/**
 * returns a list of Events for StatefulSets
 */
export const getStatefulSetEventsOptions = (options: Options<GetStatefulSetEventsData>) => queryOptions<GetStatefulSetEventsResponse, AxiosError<DefaultError>, GetStatefulSetEventsResponse, ReturnType<typeof getStatefulSetEventsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getStatefulSetEvents({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getStatefulSetEventsQueryKey(options)
});

export const getStatefulSetEventsInfiniteQueryKey = (options: Options<GetStatefulSetEventsData>): QueryKey<Options<GetStatefulSetEventsData>> => createQueryKey('getStatefulSetEvents', options, true);

/**
 * returns a list of Events for StatefulSets
 */
export const getStatefulSetEventsInfiniteOptions = (options: Options<GetStatefulSetEventsData>) => infiniteQueryOptions<GetStatefulSetEventsResponse, AxiosError<DefaultError>, InfiniteData<GetStatefulSetEventsResponse>, QueryKey<Options<GetStatefulSetEventsData>>, string | Pick<QueryKey<Options<GetStatefulSetEventsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetStatefulSetEventsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getStatefulSetEvents({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getStatefulSetEventsInfiniteQueryKey(options)
});

export const getStatefulSetPodsQueryKey = (options: Options<GetStatefulSetPodsData>) => createQueryKey('getStatefulSetPods', options);

/**
 * returns  a list of Pods for StatefulSets
 */
export const getStatefulSetPodsOptions = (options: Options<GetStatefulSetPodsData>) => queryOptions<GetStatefulSetPodsResponse, AxiosError<DefaultError>, GetStatefulSetPodsResponse, ReturnType<typeof getStatefulSetPodsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getStatefulSetPods({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getStatefulSetPodsQueryKey(options)
});

export const getStatefulSetPodsInfiniteQueryKey = (options: Options<GetStatefulSetPodsData>): QueryKey<Options<GetStatefulSetPodsData>> => createQueryKey('getStatefulSetPods', options, true);

/**
 * returns  a list of Pods for StatefulSets
 */
export const getStatefulSetPodsInfiniteOptions = (options: Options<GetStatefulSetPodsData>) => infiniteQueryOptions<GetStatefulSetPodsResponse, AxiosError<DefaultError>, InfiniteData<GetStatefulSetPodsResponse>, QueryKey<Options<GetStatefulSetPodsData>>, string | Pick<QueryKey<Options<GetStatefulSetPodsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetStatefulSetPodsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getStatefulSetPods({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getStatefulSetPodsInfiniteQueryKey(options)
});

/**
 * rollout restart of the Daemon Set
 */
export const restartStatefulSetMutation = (options?: Partial<Options<RestartStatefulSetData>>): UseMutationOptions<RestartStatefulSetResponse, AxiosError<DefaultError>, Options<RestartStatefulSetData>> => {
    const mutationOptions: UseMutationOptions<RestartStatefulSetResponse, AxiosError<DefaultError>, Options<RestartStatefulSetData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await restartStatefulSet({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getStorageClassesQueryKey = (options?: Options<GetStorageClassesData>) => createQueryKey('getStorageClasses', options);

/**
 * returns a list of StorageClasses
 */
export const getStorageClassesOptions = (options?: Options<GetStorageClassesData>) => queryOptions<GetStorageClassesResponse, AxiosError<DefaultError>, GetStorageClassesResponse, ReturnType<typeof getStorageClassesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getStorageClasses({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getStorageClassesQueryKey(options)
});

export const getStorageClassesInfiniteQueryKey = (options?: Options<GetStorageClassesData>): QueryKey<Options<GetStorageClassesData>> => createQueryKey('getStorageClasses', options, true);

/**
 * returns a list of StorageClasses
 */
export const getStorageClassesInfiniteOptions = (options?: Options<GetStorageClassesData>) => infiniteQueryOptions<GetStorageClassesResponse, AxiosError<DefaultError>, InfiniteData<GetStorageClassesResponse>, QueryKey<Options<GetStorageClassesData>>, string | Pick<QueryKey<Options<GetStorageClassesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetStorageClassesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getStorageClasses({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getStorageClassesInfiniteQueryKey(options)
});

export const getStorageClassQueryKey = (options: Options<GetStorageClassData>) => createQueryKey('getStorageClass', options);

/**
 * returns detailed information about StorageClass
 */
export const getStorageClassOptions = (options: Options<GetStorageClassData>) => queryOptions<GetStorageClassResponse, AxiosError<DefaultError>, GetStorageClassResponse, ReturnType<typeof getStorageClassQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getStorageClass({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getStorageClassQueryKey(options)
});

export const getStorageClassInfiniteQueryKey = (options: Options<GetStorageClassData>): QueryKey<Options<GetStorageClassData>> => createQueryKey('getStorageClass', options, true);

/**
 * returns detailed information about StorageClass
 */
export const getStorageClassInfiniteOptions = (options: Options<GetStorageClassData>) => infiniteQueryOptions<GetStorageClassResponse, AxiosError<DefaultError>, InfiniteData<GetStorageClassResponse>, QueryKey<Options<GetStorageClassData>>, string | Pick<QueryKey<Options<GetStorageClassData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetStorageClassData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getStorageClass({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getStorageClassInfiniteQueryKey(options)
});

export const getStorageClassPersistentVolumesQueryKey = (options: Options<GetStorageClassPersistentVolumesData>) => createQueryKey('getStorageClassPersistentVolumes', options);

/**
 * returns a list of PersistentVolumes assigned to StorageClass
 */
export const getStorageClassPersistentVolumesOptions = (options: Options<GetStorageClassPersistentVolumesData>) => queryOptions<GetStorageClassPersistentVolumesResponse, AxiosError<DefaultError>, GetStorageClassPersistentVolumesResponse, ReturnType<typeof getStorageClassPersistentVolumesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getStorageClassPersistentVolumes({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getStorageClassPersistentVolumesQueryKey(options)
});

export const getStorageClassPersistentVolumesInfiniteQueryKey = (options: Options<GetStorageClassPersistentVolumesData>): QueryKey<Options<GetStorageClassPersistentVolumesData>> => createQueryKey('getStorageClassPersistentVolumes', options, true);

/**
 * returns a list of PersistentVolumes assigned to StorageClass
 */
export const getStorageClassPersistentVolumesInfiniteOptions = (options: Options<GetStorageClassPersistentVolumesData>) => infiniteQueryOptions<GetStorageClassPersistentVolumesResponse, AxiosError<DefaultError>, InfiniteData<GetStorageClassPersistentVolumesResponse>, QueryKey<Options<GetStorageClassPersistentVolumesData>>, string | Pick<QueryKey<Options<GetStorageClassPersistentVolumesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetStorageClassPersistentVolumesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getStorageClassPersistentVolumes({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getStorageClassPersistentVolumesInfiniteQueryKey(options)
});

export const getHorizontalPodAutoscalersForResourceQueryKey = (options: Options<GetHorizontalPodAutoscalersForResourceData>) => createQueryKey('getHorizontalPodAutoscalersForResource', options);

/**
 * returns a list of HorizontalPodAutoscalers for resource
 */
export const getHorizontalPodAutoscalersForResourceOptions = (options: Options<GetHorizontalPodAutoscalersForResourceData>) => queryOptions<GetHorizontalPodAutoscalersForResourceResponse, AxiosError<DefaultError>, GetHorizontalPodAutoscalersForResourceResponse, ReturnType<typeof getHorizontalPodAutoscalersForResourceQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getHorizontalPodAutoscalersForResource({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getHorizontalPodAutoscalersForResourceQueryKey(options)
});

export const getHorizontalPodAutoscalersForResourceInfiniteQueryKey = (options: Options<GetHorizontalPodAutoscalersForResourceData>): QueryKey<Options<GetHorizontalPodAutoscalersForResourceData>> => createQueryKey('getHorizontalPodAutoscalersForResource', options, true);

/**
 * returns a list of HorizontalPodAutoscalers for resource
 */
export const getHorizontalPodAutoscalersForResourceInfiniteOptions = (options: Options<GetHorizontalPodAutoscalersForResourceData>) => infiniteQueryOptions<GetHorizontalPodAutoscalersForResourceResponse, AxiosError<DefaultError>, InfiniteData<GetHorizontalPodAutoscalersForResourceResponse>, QueryKey<Options<GetHorizontalPodAutoscalersForResourceData>>, string | Pick<QueryKey<Options<GetHorizontalPodAutoscalersForResourceData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetHorizontalPodAutoscalersForResourceData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getHorizontalPodAutoscalersForResource({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getHorizontalPodAutoscalersForResourceInfiniteQueryKey(options)
});
