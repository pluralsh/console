//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../axios-client';
import { useQuery, useMutation } from '@tanstack/react-query';
import type { UseQueryResult, QueryFunctionContext, UseQueryOptions, QueryClient, QueryKey, MutationKey, UseMutationOptions, UseMutationResult, QueryMeta, MutationMeta } from '@tanstack/react-query';
import { trimArrayEnd, isParameterObject, getBaseUrl, addMetaToOptions } from './helpers';
import type { QueryMetaContextValue } from 'react-query-swagger';
import { QueryMetaContext } from 'react-query-swagger';
import { useContext } from 'react';
import { Client as ClientClass } from '../axios-client';
import { createClient, getClientFactory } from './helpers';

export const Client = () => getClientFactory()(ClientClass);
import type { AxiosRequestConfig } from 'axios';

export type HandleGetResourceQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  kind: string ;
  name: string ;
}

export type HandlePutResourceQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  kind: string ;
  name: string ;
}

export type HandleDeleteResourceQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  kind: string ;
  name: string ;
  deleteNow: string | null | undefined ;
  propagation: string | null | undefined ;
}

export type HandleGetResource2QueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  kind: string ;
  namespace: string ;
  name: string ;
}

export type HandlePutResource2QueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  kind: string ;
  namespace: string ;
  name: string ;
}

export type HandleDeleteResource2QueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  kind: string ;
  namespace: string ;
  name: string ;
  deleteNow: string | null | undefined ;
  propagation: string | null | undefined ;
}

export type HandleDeployQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleGetAvailableProtocolsQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleImageReferenceValidityQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleNameValidityQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleProtocolValidityQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleDeployFromFileQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleGetClusterRoleListQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleGetClusterRoleDetailQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  name: string ;
}

export type HandleGetClusterRoleBindingListQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleGetClusterRoleBindingDetailQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  name: string ;
}

export type HandleGetConfigMapListQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleGetConfigMapList2QueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
}

export type HandleGetConfigMapDetailQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  configmap: string ;
}

export type HandleGetCustomResourceDefinitionListQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleGetCustomResourceDefinitionDetailQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  crd: string ;
}

export type HandleGetCustomResourceObjectListQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  crd: string ;
}

export type HandleGetCustomResourceObjectDetailQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  crd: string ;
  object: string ;
}

export type HandleGetCustomResourceObjectEventsQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  crd: string ;
  object: string ;
}

export type HandleGetCronJobListQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleGetCronJobList2QueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
}

export type HandleGetCronJobDetailQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  name: string ;
}

export type HandleGetCronJobEventsQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  name: string ;
}

export type HandleGetCronJobJobsQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  name: string ;
  active: string | null | undefined ;
}

export type HandleTriggerCronJobQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  name: string ;
}

export type HandleGetCsrfTokenQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  action: string ;
}

export type HandleGetDaemonSetListQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleGetDaemonSetList2QueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
}

export type HandleGetDaemonSetDetailQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  daemonSet: string ;
}

export type HandleGetDaemonSetEventsQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  daemonSet: string ;
}

export type HandleGetDaemonSetPodsQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  daemonSet: string ;
}

export type HandleDaemonSetRestartQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  daemonSet: string ;
}

export type HandleGetDaemonSetServicesQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  daemonSet: string ;
}

export type HandleGetDeploymentsQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleGetDeployments2QueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
}

export type HandleGetDeploymentDetailQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  deployment: string ;
}

export type HandleGetDeploymentEventsQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  deployment: string ;
}

export type HandleGetDeploymentNewReplicaSetQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  deployment: string ;
}

export type HandleGetDeploymentOldReplicaSetsQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  deployment: string ;
}

export type HandleDeploymentPauseQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  deployment: string ;
}

export type HandleDeploymentRestartQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  deployment: string ;
}

export type HandleDeploymentResumeQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  deployment: string ;
}

export type HandleDeploymentRollbackQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  deployment: string ;
}

export type HandleGetEventListQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleGetEventList2QueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
}

export type HandleGetHorizontalPodAutoscalerListQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleGetHorizontalPodAutoscalerList2QueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
}

export type HandleGetHorizontalPodAutoscalerDetailQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  horizontalpodautoscaler: string ;
}

export type HandleGetIngressListQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleGetIngressList2QueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
}

export type HandleGetIngressEventQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  ingress: string ;
}

export type HandleGetIngressDetailQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  name: string ;
}

export type HandleGetIngressClassListQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleGetIngressClassQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  ingressclass: string ;
}

export type HandleGetStateQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleGetJobListQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleGetJobList2QueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
}

export type HandleGetJobDetailQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  name: string ;
}

export type HandleGetJobEventsQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  name: string ;
}

export type HandleGetJobPodsQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  name: string ;
}

export type HandleLogFileQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  pod: string ;
  container: string ;
}

export type HandleLogSourceQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  resourceName: string ;
  resourceType: string ;
}

export type HandleLogsQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  pod: string ;
}

export type HandleLogs2QueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  pod: string ;
  container: string ;
}

export type HandleGetNamespacesQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleCreateNamespaceQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleGetNamespaceDetailQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  name: string ;
}

export type HandleGetNamespaceEventsQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  name: string ;
}

export type HandleGetNetworkPolicyListQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleGetNetworkPolicyList2QueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
}

export type HandleGetNetworkPolicyDetailQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  networkpolicy: string ;
}

export type HandleGetNodeListQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleGetNodeDetailQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  name: string ;
}

export type HandleNodeDrainQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  name: string ;
}

export type HandleGetNodeEventsQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  name: string ;
}

export type HandleGetNodePodsQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  name: string ;
}

export type HandleGetPersistentVolumeListQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleGetPersistentVolumeDetailQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  persistentvolume: string ;
}

export type HandleGetPersistentVolumeDetail2QueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  persistentvolume: string ;
}

export type HandleGetPersistentVolumeClaimListQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleGetPersistentVolumeClaimList2QueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
}

export type HandleGetPersistentVolumeClaimDetailQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  name: string ;
  namespace: string ;
}

export type HandleGetPodsQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleGetPods2QueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
}

export type HandleGetPodDetailQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  pod: string ;
}

export type HandleGetPodContainersQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  pod: string ;
}

export type HandleGetPodEventsQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  pod: string ;
}

export type HandleGetPodPersistentVolumeClaimsQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  pod: string ;
}

export type HandleExecShellQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  pod: string ;
  container: string ;
}

export type HandleGetPodDisruptionBudgetListQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleGetPodDisruptionBudgetList2QueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
}

export type HandleGetPodDisruptionBudgetDetailQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  name: string ;
  namespace: string ;
}

export type HandleGetReplicaSetsQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleGetReplicaSets2QueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
}

export type HandleGetReplicaSetDetailQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  replicaSet: string ;
}

export type HandleGetReplicaSetEventsQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  replicaSet: string ;
}

export type HandleGetReplicaSetPodsQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  replicaSet: string ;
}

export type HandleGetReplicaSetServicesQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  replicaSet: string ;
}

export type HandleGetReplicationControllerListQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleGetReplicationControllerList2QueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
}

export type HandleGetReplicationControllerDetailQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  replicationController: string ;
}

export type HandleGetReplicationControllerEventsQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  replicationController: string ;
}

export type HandleGetReplicationControllerPodsQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  replicationController: string ;
}

export type HandleGetReplicationControllerServicesQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  replicationController: string ;
}

export type HandleUpdateReplicasCountQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  replicationController: string ;
}

export type HandleGetRoleListQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleGetRoleList2QueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
}

export type HandleGetRoleDetailQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  name: string ;
}

export type HandleGetRoleBindingListQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleGetRoleBindingList2QueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
}

export type HandleGetRoleBindingDetailQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  name: string ;
}

export type HandleGetReplicaCountQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  kind: string ;
  namespace: string ;
  name: string ;
}

export type HandleScaleResourceQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  kind: string ;
  namespace: string ;
  name: string ;
  scaleBy: string | null | undefined ;
}

export type HandleGetReplicaCount2QueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  kind: string ;
  name: string ;
}

export type HandleScaleResource2QueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  kind: string ;
  name: string ;
  scaleBy: string | null | undefined ;
}

export type HandleGetSecretListQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleCreateImagePullSecretQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleGetSecretList2QueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
}

export type HandleGetSecretDetailQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  name: string ;
}

export type HandleGetServiceListQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleGetServiceList2QueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
}

export type HandleGetServiceDetailQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  service: string ;
}

export type HandleGetServiceEventQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  service: string ;
}

export type HandleGetServiceIngressListQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  service: string ;
}

export type HandleGetServicePodsQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  service: string ;
}

export type HandleGetServiceAccountListQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleGetServiceAccountList2QueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
}

export type HandleGetServiceAccountDetailQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  serviceaccount: string ;
}

export type HandleGetServiceAccountImagePullSecretsQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  serviceaccount: string ;
}

export type HandleGetServiceAccountSecretsQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  serviceaccount: string ;
}

export type HandleGetStatefulSetListQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleGetStatefulSetList2QueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
}

export type HandleGetStatefulSetDetailQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  statefulset: string ;
}

export type HandleGetStatefulSetEventsQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  statefulset: string ;
}

export type HandleGetStatefulSetPodsQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  statefulset: string ;
}

export type HandleStatefulSetRestartQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  namespace: string ;
  statefulset: string ;
}

export type HandleGetStorageClassListQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
}

export type HandleGetStorageClassQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  storageclass: string ;
}

export type HandleGetStorageClassPersistentVolumesQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  storageclass: string ;
}

export type HandleGetHorizontalPodAutoscalerListForResourceQueryParameters = {
  filterBy: string | null | undefined ;
  sortBy: string | null | undefined ;
  itemsPerPage: string | null | undefined ;
  page: string | null | undefined ;
  metricNames: string | null | undefined ;
  aggregations: string | null | undefined ;
  kind: string ;
  namespace: string ;
  name: string ;
}

export function handleGetResourceUrl(kind: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/_raw/{kind}/name/{name}?";
if (kind === undefined || kind === null)
  throw new Error("The parameter 'kind' must be defined.");
url_ = url_.replace("{kind}", encodeURIComponent("" + kind));
if (name === undefined || name === null)
  throw new Error("The parameter 'name' must be defined.");
url_ = url_.replace("{name}", encodeURIComponent("" + name));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetResourceDefaultOptions: Omit<UseQueryOptions<Types.Unstructured, unknown, Types.Unstructured>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.Unstructured, unknown, Types.Unstructured>, 'queryFn'>> = {
};
export function getHandleGetResourceDefaultOptions() {
  return handleGetResourceDefaultOptions;
};
export function setHandleGetResourceDefaultOptions(options: typeof handleGetResourceDefaultOptions) {
  handleGetResourceDefaultOptions = options;
}

export function handleGetResourceQueryKey(dto: HandleGetResourceQueryParameters): QueryKey;
export function handleGetResourceQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, kind: string, name: string): QueryKey;
export function handleGetResourceQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, kind, name,  } = params[0] as HandleGetResourceQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetResource',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        kind as any,
        name as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetResource',
        ...params
      ]);
  }
}
export function __handleGetResource(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetResource(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetResourceQuery<TSelectData = Types.Unstructured, TError = unknown>(dto: HandleGetResourceQueryParameters, options?: Omit<UseQueryOptions<Types.Unstructured, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a non-namespaced resource
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param kind kind of the resource
 * @param name name of the resource
 * @return OK
 */
export function useHandleGetResourceQuery<TSelectData = Types.Unstructured, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, kind: string, name: string, options?: Omit<UseQueryOptions<Types.Unstructured, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetResourceQuery<TSelectData = Types.Unstructured, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Unstructured, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let kind: any = undefined;
  let name: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, kind, name,  } = params[0] as HandleGetResourceQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, kind, name, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Unstructured, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetResource(context, axiosConfig) : __handleGetResource,
    queryKey: handleGetResourceQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, kind, name),
    ...handleGetResourceDefaultOptions as unknown as Omit<UseQueryOptions<Types.Unstructured, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a non-namespaced resource
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param kind kind of the resource
 * @param name name of the resource
 * @return OK
 */
export function setHandleGetResourceData(queryClient: QueryClient, updater: (data: Types.Unstructured | undefined) => Types.Unstructured, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, kind: string, name: string) {
  queryClient.setQueryData(handleGetResourceQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, kind, name),
    updater
  );
}

/**
 * returns a non-namespaced resource
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param kind kind of the resource
 * @param name name of the resource
 * @return OK
 */
export function setHandleGetResourceDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Unstructured | undefined) => Types.Unstructured) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handlePutResourceUrl(kind: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/_raw/{kind}/name/{name}?";
if (kind === undefined || kind === null)
  throw new Error("The parameter 'kind' must be defined.");
url_ = url_.replace("{kind}", encodeURIComponent("" + kind));
if (name === undefined || name === null)
  throw new Error("The parameter 'name' must be defined.");
url_ = url_.replace("{name}", encodeURIComponent("" + name));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function handlePutResourceMutationKey(kind: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'handlePutResource',
      kind as any,
      name as any,
      filterBy as any,
      sortBy as any,
      itemsPerPage as any,
      page as any,
      metricNames as any,
      aggregations as any,
    ]);
}

/**
 * creates or updates a non-namespaced resource
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param kind kind of the resource
 * @param name name of the resource
 */
export function useHandlePutResourceMutation<TContext>(kind: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseMutationOptions<void, unknown, Types.JSON, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.JSON, TContext> {
  const key = handlePutResourceMutationKey(kind, name, filterBy, sortBy, itemsPerPage, page, metricNames, aggregations);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.JSON) => Client().handlePutResource(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, kind, name, body),
    mutationKey: key,
  });
}
  
type HandlePutResource__MutationParameters = HandlePutResourceQueryParameters & {
  body: Types.JSON;
}

/**
 * creates or updates a non-namespaced resource
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param kind kind of the resource
 * @param name name of the resource
 */
export function useHandlePutResourceMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, HandlePutResource__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: HandlePutResourceQueryParameters}): UseMutationResult<void, unknown, HandlePutResource__MutationParameters, TContext> {
  const key = handlePutResourceMutationKey(options?.parameters?.kind!, options?.parameters?.name!, options?.parameters?.filterBy!, options?.parameters?.sortBy!, options?.parameters?.itemsPerPage!, options?.parameters?.page!, options?.parameters?.metricNames!, options?.parameters?.aggregations!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: HandlePutResource__MutationParameters) => Client().handlePutResource(data.filterBy ?? options?.parameters?.filterBy!, data.sortBy ?? options?.parameters?.sortBy!, data.itemsPerPage ?? options?.parameters?.itemsPerPage!, data.page ?? options?.parameters?.page!, data.metricNames ?? options?.parameters?.metricNames!, data.aggregations ?? options?.parameters?.aggregations!, data.kind ?? options?.parameters?.kind!, data.name ?? options?.parameters?.name!, data.body),
  mutationKey: key,
});
}
  
export function handleDeleteResourceUrl(kind: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, deleteNow: string | null | undefined, propagation: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/_raw/{kind}/name/{name}?";
if (kind === undefined || kind === null)
  throw new Error("The parameter 'kind' must be defined.");
url_ = url_.replace("{kind}", encodeURIComponent("" + kind));
if (name === undefined || name === null)
  throw new Error("The parameter 'name' must be defined.");
url_ = url_.replace("{name}", encodeURIComponent("" + name));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
if (deleteNow !== undefined && deleteNow !== null)
    url_ += "deleteNow=" + encodeURIComponent("" + deleteNow) + "&";
if (propagation !== undefined && propagation !== null)
    url_ += "propagation=" + encodeURIComponent("" + propagation) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function handleDeleteResourceMutationKey(kind: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, deleteNow: string | null | undefined, propagation: string | null | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'handleDeleteResource',
      kind as any,
      name as any,
      filterBy as any,
      sortBy as any,
      itemsPerPage as any,
      page as any,
      metricNames as any,
      aggregations as any,
      deleteNow as any,
      propagation as any,
    ]);
}

/**
 * deletes a non-namespaced resource
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param kind kind of the resource
 * @param name name of the resource
 * @param deleteNow (optional) override graceful delete options and enforce immediate deletion
 * @param propagation (optional) override default delete propagation policy
 */
export function useHandleDeleteResourceMutation<TContext>(kind: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, deleteNow: string | null | undefined, propagation: string | null | undefined, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = handleDeleteResourceMutationKey(kind, name, filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, deleteNow, propagation);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client().handleDeleteResource(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, kind, name, deleteNow, propagation),
    mutationKey: key,
  });
}
  
type HandleDeleteResource__MutationParameters = HandleDeleteResourceQueryParameters

/**
 * deletes a non-namespaced resource
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param kind kind of the resource
 * @param name name of the resource
 * @param deleteNow (optional) override graceful delete options and enforce immediate deletion
 * @param propagation (optional) override default delete propagation policy
 */
export function useHandleDeleteResourceMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, HandleDeleteResource__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: HandleDeleteResourceQueryParameters}): UseMutationResult<void, unknown, HandleDeleteResource__MutationParameters, TContext> {
  const key = handleDeleteResourceMutationKey(options?.parameters?.kind!, options?.parameters?.name!, options?.parameters?.filterBy!, options?.parameters?.sortBy!, options?.parameters?.itemsPerPage!, options?.parameters?.page!, options?.parameters?.metricNames!, options?.parameters?.aggregations!, options?.parameters?.deleteNow!, options?.parameters?.propagation!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: HandleDeleteResource__MutationParameters) => Client().handleDeleteResource(data.filterBy ?? options?.parameters?.filterBy!, data.sortBy ?? options?.parameters?.sortBy!, data.itemsPerPage ?? options?.parameters?.itemsPerPage!, data.page ?? options?.parameters?.page!, data.metricNames ?? options?.parameters?.metricNames!, data.aggregations ?? options?.parameters?.aggregations!, data.kind ?? options?.parameters?.kind!, data.name ?? options?.parameters?.name!, data.deleteNow ?? options?.parameters?.deleteNow!, data.propagation ?? options?.parameters?.propagation!),
  mutationKey: key,
});
}
  
export function handleGetResource2Url(kind: string, namespace: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/_raw/{kind}/namespace/{namespace}/name/{name}?";
if (kind === undefined || kind === null)
  throw new Error("The parameter 'kind' must be defined.");
url_ = url_.replace("{kind}", encodeURIComponent("" + kind));
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (name === undefined || name === null)
  throw new Error("The parameter 'name' must be defined.");
url_ = url_.replace("{name}", encodeURIComponent("" + name));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetResource2DefaultOptions: Omit<UseQueryOptions<Types.Unstructured, unknown, Types.Unstructured>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.Unstructured, unknown, Types.Unstructured>, 'queryFn'>> = {
};
export function getHandleGetResource2DefaultOptions() {
  return handleGetResource2DefaultOptions;
};
export function setHandleGetResource2DefaultOptions(options: typeof handleGetResource2DefaultOptions) {
  handleGetResource2DefaultOptions = options;
}

export function handleGetResource2QueryKey(dto: HandleGetResource2QueryParameters): QueryKey;
export function handleGetResource2QueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, kind: string, namespace: string, name: string): QueryKey;
export function handleGetResource2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, kind, namespace, name,  } = params[0] as HandleGetResource2QueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetResource2',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        kind as any,
        namespace as any,
        name as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetResource2',
        ...params
      ]);
  }
}
export function __handleGetResource2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetResource2(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string,       context.queryKey[10] as string);
}

export function useHandleGetResource2Query<TSelectData = Types.Unstructured, TError = unknown>(dto: HandleGetResource2QueryParameters, options?: Omit<UseQueryOptions<Types.Unstructured, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns unstructured resource from a namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param kind kind of the resource
 * @param namespace namespace of the resource
 * @param name name of the resource
 * @return OK
 */
export function useHandleGetResource2Query<TSelectData = Types.Unstructured, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, kind: string, namespace: string, name: string, options?: Omit<UseQueryOptions<Types.Unstructured, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetResource2Query<TSelectData = Types.Unstructured, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Unstructured, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let kind: any = undefined;
  let namespace: any = undefined;
  let name: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, kind, namespace, name,  } = params[0] as HandleGetResource2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, kind, namespace, name, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Unstructured, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetResource2(context, axiosConfig) : __handleGetResource2,
    queryKey: handleGetResource2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, kind, namespace, name),
    ...handleGetResource2DefaultOptions as unknown as Omit<UseQueryOptions<Types.Unstructured, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns unstructured resource from a namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param kind kind of the resource
 * @param namespace namespace of the resource
 * @param name name of the resource
 * @return OK
 */
export function setHandleGetResource2Data(queryClient: QueryClient, updater: (data: Types.Unstructured | undefined) => Types.Unstructured, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, kind: string, namespace: string, name: string) {
  queryClient.setQueryData(handleGetResource2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, kind, namespace, name),
    updater
  );
}

/**
 * returns unstructured resource from a namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param kind kind of the resource
 * @param namespace namespace of the resource
 * @param name name of the resource
 * @return OK
 */
export function setHandleGetResource2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Unstructured | undefined) => Types.Unstructured) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handlePutResource2Url(kind: string, namespace: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/_raw/{kind}/namespace/{namespace}/name/{name}?";
if (kind === undefined || kind === null)
  throw new Error("The parameter 'kind' must be defined.");
url_ = url_.replace("{kind}", encodeURIComponent("" + kind));
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (name === undefined || name === null)
  throw new Error("The parameter 'name' must be defined.");
url_ = url_.replace("{name}", encodeURIComponent("" + name));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function handlePutResource2MutationKey(kind: string, namespace: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'handlePutResource2',
      kind as any,
      namespace as any,
      name as any,
      filterBy as any,
      sortBy as any,
      itemsPerPage as any,
      page as any,
      metricNames as any,
      aggregations as any,
    ]);
}

/**
 * creates or updates a resource in a namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param kind kind of the resource
 * @param namespace namespace of the resource
 * @param name name of the resource
 */
export function useHandlePutResource2Mutation<TContext>(kind: string, namespace: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseMutationOptions<void, unknown, Types.JSON, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.JSON, TContext> {
  const key = handlePutResource2MutationKey(kind, namespace, name, filterBy, sortBy, itemsPerPage, page, metricNames, aggregations);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.JSON) => Client().handlePutResource2(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, kind, namespace, name, body),
    mutationKey: key,
  });
}
  
type HandlePutResource2__MutationParameters = HandlePutResource2QueryParameters & {
  body: Types.JSON;
}

/**
 * creates or updates a resource in a namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param kind kind of the resource
 * @param namespace namespace of the resource
 * @param name name of the resource
 */
export function useHandlePutResource2MutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, HandlePutResource2__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: HandlePutResource2QueryParameters}): UseMutationResult<void, unknown, HandlePutResource2__MutationParameters, TContext> {
  const key = handlePutResource2MutationKey(options?.parameters?.kind!, options?.parameters?.namespace!, options?.parameters?.name!, options?.parameters?.filterBy!, options?.parameters?.sortBy!, options?.parameters?.itemsPerPage!, options?.parameters?.page!, options?.parameters?.metricNames!, options?.parameters?.aggregations!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: HandlePutResource2__MutationParameters) => Client().handlePutResource2(data.filterBy ?? options?.parameters?.filterBy!, data.sortBy ?? options?.parameters?.sortBy!, data.itemsPerPage ?? options?.parameters?.itemsPerPage!, data.page ?? options?.parameters?.page!, data.metricNames ?? options?.parameters?.metricNames!, data.aggregations ?? options?.parameters?.aggregations!, data.kind ?? options?.parameters?.kind!, data.namespace ?? options?.parameters?.namespace!, data.name ?? options?.parameters?.name!, data.body),
  mutationKey: key,
});
}
  
export function handleDeleteResource2Url(kind: string, namespace: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, deleteNow: string | null | undefined, propagation: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/_raw/{kind}/namespace/{namespace}/name/{name}?";
if (kind === undefined || kind === null)
  throw new Error("The parameter 'kind' must be defined.");
url_ = url_.replace("{kind}", encodeURIComponent("" + kind));
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (name === undefined || name === null)
  throw new Error("The parameter 'name' must be defined.");
url_ = url_.replace("{name}", encodeURIComponent("" + name));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
if (deleteNow !== undefined && deleteNow !== null)
    url_ += "deleteNow=" + encodeURIComponent("" + deleteNow) + "&";
if (propagation !== undefined && propagation !== null)
    url_ += "propagation=" + encodeURIComponent("" + propagation) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function handleDeleteResource2MutationKey(kind: string, namespace: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, deleteNow: string | null | undefined, propagation: string | null | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'handleDeleteResource2',
      kind as any,
      namespace as any,
      name as any,
      filterBy as any,
      sortBy as any,
      itemsPerPage as any,
      page as any,
      metricNames as any,
      aggregations as any,
      deleteNow as any,
      propagation as any,
    ]);
}

/**
 * deletes a resource from a namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param kind kind of the resource
 * @param namespace namespace of the resource
 * @param name name of the resource
 * @param deleteNow (optional) override graceful delete options and enforce immediate deletion
 * @param propagation (optional) override default delete propagation policy
 */
export function useHandleDeleteResource2Mutation<TContext>(kind: string, namespace: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, deleteNow: string | null | undefined, propagation: string | null | undefined, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = handleDeleteResource2MutationKey(kind, namespace, name, filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, deleteNow, propagation);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client().handleDeleteResource2(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, kind, namespace, name, deleteNow, propagation),
    mutationKey: key,
  });
}
  
type HandleDeleteResource2__MutationParameters = HandleDeleteResource2QueryParameters

/**
 * deletes a resource from a namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param kind kind of the resource
 * @param namespace namespace of the resource
 * @param name name of the resource
 * @param deleteNow (optional) override graceful delete options and enforce immediate deletion
 * @param propagation (optional) override default delete propagation policy
 */
export function useHandleDeleteResource2MutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, HandleDeleteResource2__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: HandleDeleteResource2QueryParameters}): UseMutationResult<void, unknown, HandleDeleteResource2__MutationParameters, TContext> {
  const key = handleDeleteResource2MutationKey(options?.parameters?.kind!, options?.parameters?.namespace!, options?.parameters?.name!, options?.parameters?.filterBy!, options?.parameters?.sortBy!, options?.parameters?.itemsPerPage!, options?.parameters?.page!, options?.parameters?.metricNames!, options?.parameters?.aggregations!, options?.parameters?.deleteNow!, options?.parameters?.propagation!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: HandleDeleteResource2__MutationParameters) => Client().handleDeleteResource2(data.filterBy ?? options?.parameters?.filterBy!, data.sortBy ?? options?.parameters?.sortBy!, data.itemsPerPage ?? options?.parameters?.itemsPerPage!, data.page ?? options?.parameters?.page!, data.metricNames ?? options?.parameters?.metricNames!, data.aggregations ?? options?.parameters?.aggregations!, data.kind ?? options?.parameters?.kind!, data.namespace ?? options?.parameters?.namespace!, data.name ?? options?.parameters?.name!, data.deleteNow ?? options?.parameters?.deleteNow!, data.propagation ?? options?.parameters?.propagation!),
  mutationKey: key,
});
}
  
export function handleDeployUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/appdeployment?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function handleDeployMutationKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'handleDeploy',
      filterBy as any,
      sortBy as any,
      itemsPerPage as any,
      page as any,
      metricNames as any,
      aggregations as any,
    ]);
}

/**
 * creates an application based on provided deployment.AppDeploymentSpec
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleDeployMutation<TContext>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseMutationOptions<Types.AppDeploymentSpec, unknown, Types.AppDeploymentSpec, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AppDeploymentSpec, unknown, Types.AppDeploymentSpec, TContext> {
  const key = handleDeployMutationKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.AppDeploymentSpec) => Client().handleDeploy(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, body),
    mutationKey: key,
  });
}
  
type HandleDeploy__MutationParameters = HandleDeployQueryParameters & {
  body: Types.AppDeploymentSpec;
}

/**
 * creates an application based on provided deployment.AppDeploymentSpec
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleDeployMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.AppDeploymentSpec, unknown, HandleDeploy__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: HandleDeployQueryParameters}): UseMutationResult<Types.AppDeploymentSpec, unknown, HandleDeploy__MutationParameters, TContext> {
  const key = handleDeployMutationKey(options?.parameters?.filterBy!, options?.parameters?.sortBy!, options?.parameters?.itemsPerPage!, options?.parameters?.page!, options?.parameters?.metricNames!, options?.parameters?.aggregations!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: HandleDeploy__MutationParameters) => Client().handleDeploy(data.filterBy ?? options?.parameters?.filterBy!, data.sortBy ?? options?.parameters?.sortBy!, data.itemsPerPage ?? options?.parameters?.itemsPerPage!, data.page ?? options?.parameters?.page!, data.metricNames ?? options?.parameters?.metricNames!, data.aggregations ?? options?.parameters?.aggregations!, data.body),
  mutationKey: key,
});
}
  
export function handleGetAvailableProtocolsUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/appdeployment/protocols?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetAvailableProtocolsDefaultOptions: Omit<UseQueryOptions<Types.Protocols, unknown, Types.Protocols>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.Protocols, unknown, Types.Protocols>, 'queryFn'>> = {
};
export function getHandleGetAvailableProtocolsDefaultOptions() {
  return handleGetAvailableProtocolsDefaultOptions;
};
export function setHandleGetAvailableProtocolsDefaultOptions(options: typeof handleGetAvailableProtocolsDefaultOptions) {
  handleGetAvailableProtocolsDefaultOptions = options;
}

export function handleGetAvailableProtocolsQueryKey(dto: HandleGetAvailableProtocolsQueryParameters): QueryKey;
export function handleGetAvailableProtocolsQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): QueryKey;
export function handleGetAvailableProtocolsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetAvailableProtocolsQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetAvailableProtocols',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetAvailableProtocols',
        ...params
      ]);
  }
}
export function __handleGetAvailableProtocols(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetAvailableProtocols(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined);
}

export function useHandleGetAvailableProtocolsQuery<TSelectData = Types.Protocols, TError = unknown>(dto: HandleGetAvailableProtocolsQueryParameters, options?: Omit<UseQueryOptions<Types.Protocols, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of available protocols for the service
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleGetAvailableProtocolsQuery<TSelectData = Types.Protocols, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseQueryOptions<Types.Protocols, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetAvailableProtocolsQuery<TSelectData = Types.Protocols, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Protocols, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetAvailableProtocolsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Protocols, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetAvailableProtocols(context, axiosConfig) : __handleGetAvailableProtocols,
    queryKey: handleGetAvailableProtocolsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    ...handleGetAvailableProtocolsDefaultOptions as unknown as Omit<UseQueryOptions<Types.Protocols, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of available protocols for the service
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetAvailableProtocolsData(queryClient: QueryClient, updater: (data: Types.Protocols | undefined) => Types.Protocols, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined) {
  queryClient.setQueryData(handleGetAvailableProtocolsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    updater
  );
}

/**
 * returns a list of available protocols for the service
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetAvailableProtocolsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Protocols | undefined) => Types.Protocols) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleImageReferenceValidityUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/appdeployment/validate/imagereference?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function handleImageReferenceValidityMutationKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'handleImageReferenceValidity',
      filterBy as any,
      sortBy as any,
      itemsPerPage as any,
      page as any,
      metricNames as any,
      aggregations as any,
    ]);
}

/**
 * checks if provided image is valid
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleImageReferenceValidityMutation<TContext>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseMutationOptions<Types.ImageReferenceValidity, unknown, Types.ImageReferenceValiditySpec, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ImageReferenceValidity, unknown, Types.ImageReferenceValiditySpec, TContext> {
  const key = handleImageReferenceValidityMutationKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.ImageReferenceValiditySpec) => Client().handleImageReferenceValidity(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, body),
    mutationKey: key,
  });
}
  
type HandleImageReferenceValidity__MutationParameters = HandleImageReferenceValidityQueryParameters & {
  body: Types.ImageReferenceValiditySpec;
}

/**
 * checks if provided image is valid
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleImageReferenceValidityMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.ImageReferenceValidity, unknown, HandleImageReferenceValidity__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: HandleImageReferenceValidityQueryParameters}): UseMutationResult<Types.ImageReferenceValidity, unknown, HandleImageReferenceValidity__MutationParameters, TContext> {
  const key = handleImageReferenceValidityMutationKey(options?.parameters?.filterBy!, options?.parameters?.sortBy!, options?.parameters?.itemsPerPage!, options?.parameters?.page!, options?.parameters?.metricNames!, options?.parameters?.aggregations!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: HandleImageReferenceValidity__MutationParameters) => Client().handleImageReferenceValidity(data.filterBy ?? options?.parameters?.filterBy!, data.sortBy ?? options?.parameters?.sortBy!, data.itemsPerPage ?? options?.parameters?.itemsPerPage!, data.page ?? options?.parameters?.page!, data.metricNames ?? options?.parameters?.metricNames!, data.aggregations ?? options?.parameters?.aggregations!, data.body),
  mutationKey: key,
});
}
  
export function handleNameValidityUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/appdeployment/validate/name?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function handleNameValidityMutationKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'handleNameValidity',
      filterBy as any,
      sortBy as any,
      itemsPerPage as any,
      page as any,
      metricNames as any,
      aggregations as any,
    ]);
}

/**
 * checks if provided name is valid
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleNameValidityMutation<TContext>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseMutationOptions<Types.AppNameValidity, unknown, Types.AppNameValiditySpec, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AppNameValidity, unknown, Types.AppNameValiditySpec, TContext> {
  const key = handleNameValidityMutationKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.AppNameValiditySpec) => Client().handleNameValidity(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, body),
    mutationKey: key,
  });
}
  
type HandleNameValidity__MutationParameters = HandleNameValidityQueryParameters & {
  body: Types.AppNameValiditySpec;
}

/**
 * checks if provided name is valid
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleNameValidityMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.AppNameValidity, unknown, HandleNameValidity__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: HandleNameValidityQueryParameters}): UseMutationResult<Types.AppNameValidity, unknown, HandleNameValidity__MutationParameters, TContext> {
  const key = handleNameValidityMutationKey(options?.parameters?.filterBy!, options?.parameters?.sortBy!, options?.parameters?.itemsPerPage!, options?.parameters?.page!, options?.parameters?.metricNames!, options?.parameters?.aggregations!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: HandleNameValidity__MutationParameters) => Client().handleNameValidity(data.filterBy ?? options?.parameters?.filterBy!, data.sortBy ?? options?.parameters?.sortBy!, data.itemsPerPage ?? options?.parameters?.itemsPerPage!, data.page ?? options?.parameters?.page!, data.metricNames ?? options?.parameters?.metricNames!, data.aggregations ?? options?.parameters?.aggregations!, data.body),
  mutationKey: key,
});
}
  
export function handleProtocolValidityUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/appdeployment/validate/protocol?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function handleProtocolValidityMutationKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'handleProtocolValidity',
      filterBy as any,
      sortBy as any,
      itemsPerPage as any,
      page as any,
      metricNames as any,
      aggregations as any,
    ]);
}

/**
 * checks if provided service protocol is valid
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleProtocolValidityMutation<TContext>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseMutationOptions<Types.ProtocolValidity, unknown, Types.ProtocolValiditySpec, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ProtocolValidity, unknown, Types.ProtocolValiditySpec, TContext> {
  const key = handleProtocolValidityMutationKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.ProtocolValiditySpec) => Client().handleProtocolValidity(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, body),
    mutationKey: key,
  });
}
  
type HandleProtocolValidity__MutationParameters = HandleProtocolValidityQueryParameters & {
  body: Types.ProtocolValiditySpec;
}

/**
 * checks if provided service protocol is valid
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleProtocolValidityMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.ProtocolValidity, unknown, HandleProtocolValidity__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: HandleProtocolValidityQueryParameters}): UseMutationResult<Types.ProtocolValidity, unknown, HandleProtocolValidity__MutationParameters, TContext> {
  const key = handleProtocolValidityMutationKey(options?.parameters?.filterBy!, options?.parameters?.sortBy!, options?.parameters?.itemsPerPage!, options?.parameters?.page!, options?.parameters?.metricNames!, options?.parameters?.aggregations!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: HandleProtocolValidity__MutationParameters) => Client().handleProtocolValidity(data.filterBy ?? options?.parameters?.filterBy!, data.sortBy ?? options?.parameters?.sortBy!, data.itemsPerPage ?? options?.parameters?.itemsPerPage!, data.page ?? options?.parameters?.page!, data.metricNames ?? options?.parameters?.metricNames!, data.aggregations ?? options?.parameters?.aggregations!, data.body),
  mutationKey: key,
});
}
  
export function handleDeployFromFileUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/appdeploymentfromfile?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function handleDeployFromFileMutationKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'handleDeployFromFile',
      filterBy as any,
      sortBy as any,
      itemsPerPage as any,
      page as any,
      metricNames as any,
      aggregations as any,
    ]);
}

/**
 * create an application from file
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleDeployFromFileMutation<TContext>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseMutationOptions<Types.AppDeploymentFromFileResponse, unknown, Types.AppDeploymentFromFileSpec, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AppDeploymentFromFileResponse, unknown, Types.AppDeploymentFromFileSpec, TContext> {
  const key = handleDeployFromFileMutationKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.AppDeploymentFromFileSpec) => Client().handleDeployFromFile(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, body),
    mutationKey: key,
  });
}
  
type HandleDeployFromFile__MutationParameters = HandleDeployFromFileQueryParameters & {
  body: Types.AppDeploymentFromFileSpec;
}

/**
 * create an application from file
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleDeployFromFileMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.AppDeploymentFromFileResponse, unknown, HandleDeployFromFile__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: HandleDeployFromFileQueryParameters}): UseMutationResult<Types.AppDeploymentFromFileResponse, unknown, HandleDeployFromFile__MutationParameters, TContext> {
  const key = handleDeployFromFileMutationKey(options?.parameters?.filterBy!, options?.parameters?.sortBy!, options?.parameters?.itemsPerPage!, options?.parameters?.page!, options?.parameters?.metricNames!, options?.parameters?.aggregations!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: HandleDeployFromFile__MutationParameters) => Client().handleDeployFromFile(data.filterBy ?? options?.parameters?.filterBy!, data.sortBy ?? options?.parameters?.sortBy!, data.itemsPerPage ?? options?.parameters?.itemsPerPage!, data.page ?? options?.parameters?.page!, data.metricNames ?? options?.parameters?.metricNames!, data.aggregations ?? options?.parameters?.aggregations!, data.body),
  mutationKey: key,
});
}
  
export function handleGetClusterRoleListUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/clusterrole?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetClusterRoleListDefaultOptions: Omit<UseQueryOptions<Types.ClusterRoleList, unknown, Types.ClusterRoleList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ClusterRoleList, unknown, Types.ClusterRoleList>, 'queryFn'>> = {
};
export function getHandleGetClusterRoleListDefaultOptions() {
  return handleGetClusterRoleListDefaultOptions;
};
export function setHandleGetClusterRoleListDefaultOptions(options: typeof handleGetClusterRoleListDefaultOptions) {
  handleGetClusterRoleListDefaultOptions = options;
}

export function handleGetClusterRoleListQueryKey(dto: HandleGetClusterRoleListQueryParameters): QueryKey;
export function handleGetClusterRoleListQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): QueryKey;
export function handleGetClusterRoleListQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetClusterRoleListQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetClusterRoleList',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetClusterRoleList',
        ...params
      ]);
  }
}
export function __handleGetClusterRoleList(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetClusterRoleList(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined);
}

export function useHandleGetClusterRoleListQuery<TSelectData = Types.ClusterRoleList, TError = unknown>(dto: HandleGetClusterRoleListQueryParameters, options?: Omit<UseQueryOptions<Types.ClusterRoleList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of ClusterRoles
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleGetClusterRoleListQuery<TSelectData = Types.ClusterRoleList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseQueryOptions<Types.ClusterRoleList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetClusterRoleListQuery<TSelectData = Types.ClusterRoleList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ClusterRoleList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetClusterRoleListQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ClusterRoleList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetClusterRoleList(context, axiosConfig) : __handleGetClusterRoleList,
    queryKey: handleGetClusterRoleListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    ...handleGetClusterRoleListDefaultOptions as unknown as Omit<UseQueryOptions<Types.ClusterRoleList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of ClusterRoles
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetClusterRoleListData(queryClient: QueryClient, updater: (data: Types.ClusterRoleList | undefined) => Types.ClusterRoleList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined) {
  queryClient.setQueryData(handleGetClusterRoleListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    updater
  );
}

/**
 * returns a list of ClusterRoles
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetClusterRoleListDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ClusterRoleList | undefined) => Types.ClusterRoleList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetClusterRoleDetailUrl(name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/clusterrole/{name}?";
if (name === undefined || name === null)
  throw new Error("The parameter 'name' must be defined.");
url_ = url_.replace("{name}", encodeURIComponent("" + name));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetClusterRoleDetailDefaultOptions: Omit<UseQueryOptions<Types.ClusterRoleDetail, unknown, Types.ClusterRoleDetail>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ClusterRoleDetail, unknown, Types.ClusterRoleDetail>, 'queryFn'>> = {
};
export function getHandleGetClusterRoleDetailDefaultOptions() {
  return handleGetClusterRoleDetailDefaultOptions;
};
export function setHandleGetClusterRoleDetailDefaultOptions(options: typeof handleGetClusterRoleDetailDefaultOptions) {
  handleGetClusterRoleDetailDefaultOptions = options;
}

export function handleGetClusterRoleDetailQueryKey(dto: HandleGetClusterRoleDetailQueryParameters): QueryKey;
export function handleGetClusterRoleDetailQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, name: string): QueryKey;
export function handleGetClusterRoleDetailQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name,  } = params[0] as HandleGetClusterRoleDetailQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetClusterRoleDetail',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        name as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetClusterRoleDetail',
        ...params
      ]);
  }
}
export function __handleGetClusterRoleDetail(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetClusterRoleDetail(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetClusterRoleDetailQuery<TSelectData = Types.ClusterRoleDetail, TError = unknown>(dto: HandleGetClusterRoleDetailQueryParameters, options?: Omit<UseQueryOptions<Types.ClusterRoleDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns detailed information about ClusterRole
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param name name of the ClusterRole
 * @return OK
 */
export function useHandleGetClusterRoleDetailQuery<TSelectData = Types.ClusterRoleDetail, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, name: string, options?: Omit<UseQueryOptions<Types.ClusterRoleDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetClusterRoleDetailQuery<TSelectData = Types.ClusterRoleDetail, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ClusterRoleDetail, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let name: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name,  } = params[0] as HandleGetClusterRoleDetailQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ClusterRoleDetail, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetClusterRoleDetail(context, axiosConfig) : __handleGetClusterRoleDetail,
    queryKey: handleGetClusterRoleDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name),
    ...handleGetClusterRoleDetailDefaultOptions as unknown as Omit<UseQueryOptions<Types.ClusterRoleDetail, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns detailed information about ClusterRole
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param name name of the ClusterRole
 * @return OK
 */
export function setHandleGetClusterRoleDetailData(queryClient: QueryClient, updater: (data: Types.ClusterRoleDetail | undefined) => Types.ClusterRoleDetail, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, name: string) {
  queryClient.setQueryData(handleGetClusterRoleDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name),
    updater
  );
}

/**
 * returns detailed information about ClusterRole
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param name name of the ClusterRole
 * @return OK
 */
export function setHandleGetClusterRoleDetailDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ClusterRoleDetail | undefined) => Types.ClusterRoleDetail) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetClusterRoleBindingListUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/clusterrolebinding?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetClusterRoleBindingListDefaultOptions: Omit<UseQueryOptions<Types.ClusterRoleBindingList, unknown, Types.ClusterRoleBindingList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ClusterRoleBindingList, unknown, Types.ClusterRoleBindingList>, 'queryFn'>> = {
};
export function getHandleGetClusterRoleBindingListDefaultOptions() {
  return handleGetClusterRoleBindingListDefaultOptions;
};
export function setHandleGetClusterRoleBindingListDefaultOptions(options: typeof handleGetClusterRoleBindingListDefaultOptions) {
  handleGetClusterRoleBindingListDefaultOptions = options;
}

export function handleGetClusterRoleBindingListQueryKey(dto: HandleGetClusterRoleBindingListQueryParameters): QueryKey;
export function handleGetClusterRoleBindingListQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): QueryKey;
export function handleGetClusterRoleBindingListQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetClusterRoleBindingListQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetClusterRoleBindingList',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetClusterRoleBindingList',
        ...params
      ]);
  }
}
export function __handleGetClusterRoleBindingList(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetClusterRoleBindingList(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined);
}

export function useHandleGetClusterRoleBindingListQuery<TSelectData = Types.ClusterRoleBindingList, TError = unknown>(dto: HandleGetClusterRoleBindingListQueryParameters, options?: Omit<UseQueryOptions<Types.ClusterRoleBindingList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of ClusterRoleBindings
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleGetClusterRoleBindingListQuery<TSelectData = Types.ClusterRoleBindingList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseQueryOptions<Types.ClusterRoleBindingList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetClusterRoleBindingListQuery<TSelectData = Types.ClusterRoleBindingList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ClusterRoleBindingList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetClusterRoleBindingListQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ClusterRoleBindingList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetClusterRoleBindingList(context, axiosConfig) : __handleGetClusterRoleBindingList,
    queryKey: handleGetClusterRoleBindingListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    ...handleGetClusterRoleBindingListDefaultOptions as unknown as Omit<UseQueryOptions<Types.ClusterRoleBindingList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of ClusterRoleBindings
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetClusterRoleBindingListData(queryClient: QueryClient, updater: (data: Types.ClusterRoleBindingList | undefined) => Types.ClusterRoleBindingList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined) {
  queryClient.setQueryData(handleGetClusterRoleBindingListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    updater
  );
}

/**
 * returns a list of ClusterRoleBindings
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetClusterRoleBindingListDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ClusterRoleBindingList | undefined) => Types.ClusterRoleBindingList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetClusterRoleBindingDetailUrl(name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/clusterrolebinding/{name}?";
if (name === undefined || name === null)
  throw new Error("The parameter 'name' must be defined.");
url_ = url_.replace("{name}", encodeURIComponent("" + name));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetClusterRoleBindingDetailDefaultOptions: Omit<UseQueryOptions<Types.ClusterRoleBindingDetail, unknown, Types.ClusterRoleBindingDetail>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ClusterRoleBindingDetail, unknown, Types.ClusterRoleBindingDetail>, 'queryFn'>> = {
};
export function getHandleGetClusterRoleBindingDetailDefaultOptions() {
  return handleGetClusterRoleBindingDetailDefaultOptions;
};
export function setHandleGetClusterRoleBindingDetailDefaultOptions(options: typeof handleGetClusterRoleBindingDetailDefaultOptions) {
  handleGetClusterRoleBindingDetailDefaultOptions = options;
}

export function handleGetClusterRoleBindingDetailQueryKey(dto: HandleGetClusterRoleBindingDetailQueryParameters): QueryKey;
export function handleGetClusterRoleBindingDetailQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, name: string): QueryKey;
export function handleGetClusterRoleBindingDetailQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name,  } = params[0] as HandleGetClusterRoleBindingDetailQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetClusterRoleBindingDetail',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        name as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetClusterRoleBindingDetail',
        ...params
      ]);
  }
}
export function __handleGetClusterRoleBindingDetail(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetClusterRoleBindingDetail(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetClusterRoleBindingDetailQuery<TSelectData = Types.ClusterRoleBindingDetail, TError = unknown>(dto: HandleGetClusterRoleBindingDetailQueryParameters, options?: Omit<UseQueryOptions<Types.ClusterRoleBindingDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns detailed information about ClusterRoleBinding
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param name name of the ClusterRoleBinding
 * @return OK
 */
export function useHandleGetClusterRoleBindingDetailQuery<TSelectData = Types.ClusterRoleBindingDetail, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, name: string, options?: Omit<UseQueryOptions<Types.ClusterRoleBindingDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetClusterRoleBindingDetailQuery<TSelectData = Types.ClusterRoleBindingDetail, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ClusterRoleBindingDetail, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let name: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name,  } = params[0] as HandleGetClusterRoleBindingDetailQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ClusterRoleBindingDetail, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetClusterRoleBindingDetail(context, axiosConfig) : __handleGetClusterRoleBindingDetail,
    queryKey: handleGetClusterRoleBindingDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name),
    ...handleGetClusterRoleBindingDetailDefaultOptions as unknown as Omit<UseQueryOptions<Types.ClusterRoleBindingDetail, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns detailed information about ClusterRoleBinding
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param name name of the ClusterRoleBinding
 * @return OK
 */
export function setHandleGetClusterRoleBindingDetailData(queryClient: QueryClient, updater: (data: Types.ClusterRoleBindingDetail | undefined) => Types.ClusterRoleBindingDetail, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, name: string) {
  queryClient.setQueryData(handleGetClusterRoleBindingDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name),
    updater
  );
}

/**
 * returns detailed information about ClusterRoleBinding
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param name name of the ClusterRoleBinding
 * @return OK
 */
export function setHandleGetClusterRoleBindingDetailDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ClusterRoleBindingDetail | undefined) => Types.ClusterRoleBindingDetail) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetConfigMapListUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/configmap?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetConfigMapListDefaultOptions: Omit<UseQueryOptions<Types.ConfigMapList, unknown, Types.ConfigMapList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ConfigMapList, unknown, Types.ConfigMapList>, 'queryFn'>> = {
};
export function getHandleGetConfigMapListDefaultOptions() {
  return handleGetConfigMapListDefaultOptions;
};
export function setHandleGetConfigMapListDefaultOptions(options: typeof handleGetConfigMapListDefaultOptions) {
  handleGetConfigMapListDefaultOptions = options;
}

export function handleGetConfigMapListQueryKey(dto: HandleGetConfigMapListQueryParameters): QueryKey;
export function handleGetConfigMapListQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): QueryKey;
export function handleGetConfigMapListQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetConfigMapListQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetConfigMapList',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetConfigMapList',
        ...params
      ]);
  }
}
export function __handleGetConfigMapList(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetConfigMapList(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined);
}

export function useHandleGetConfigMapListQuery<TSelectData = Types.ConfigMapList, TError = unknown>(dto: HandleGetConfigMapListQueryParameters, options?: Omit<UseQueryOptions<Types.ConfigMapList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of ConfigMaps from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleGetConfigMapListQuery<TSelectData = Types.ConfigMapList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseQueryOptions<Types.ConfigMapList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetConfigMapListQuery<TSelectData = Types.ConfigMapList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ConfigMapList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetConfigMapListQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ConfigMapList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetConfigMapList(context, axiosConfig) : __handleGetConfigMapList,
    queryKey: handleGetConfigMapListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    ...handleGetConfigMapListDefaultOptions as unknown as Omit<UseQueryOptions<Types.ConfigMapList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of ConfigMaps from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetConfigMapListData(queryClient: QueryClient, updater: (data: Types.ConfigMapList | undefined) => Types.ConfigMapList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined) {
  queryClient.setQueryData(handleGetConfigMapListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    updater
  );
}

/**
 * returns a list of ConfigMaps from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetConfigMapListDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ConfigMapList | undefined) => Types.ConfigMapList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetConfigMapList2Url(namespace: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/configmap/{namespace}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetConfigMapList2DefaultOptions: Omit<UseQueryOptions<Types.ConfigMapList, unknown, Types.ConfigMapList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ConfigMapList, unknown, Types.ConfigMapList>, 'queryFn'>> = {
};
export function getHandleGetConfigMapList2DefaultOptions() {
  return handleGetConfigMapList2DefaultOptions;
};
export function setHandleGetConfigMapList2DefaultOptions(options: typeof handleGetConfigMapList2DefaultOptions) {
  handleGetConfigMapList2DefaultOptions = options;
}

export function handleGetConfigMapList2QueryKey(dto: HandleGetConfigMapList2QueryParameters): QueryKey;
export function handleGetConfigMapList2QueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string): QueryKey;
export function handleGetConfigMapList2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetConfigMapList2QueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetConfigMapList2',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetConfigMapList2',
        ...params
      ]);
  }
}
export function __handleGetConfigMapList2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetConfigMapList2(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetConfigMapList2Query<TSelectData = Types.ConfigMapList, TError = unknown>(dto: HandleGetConfigMapList2QueryParameters, options?: Omit<UseQueryOptions<Types.ConfigMapList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of ConfigMaps in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ConfigMap
 * @return OK
 */
export function useHandleGetConfigMapList2Query<TSelectData = Types.ConfigMapList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, options?: Omit<UseQueryOptions<Types.ConfigMapList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetConfigMapList2Query<TSelectData = Types.ConfigMapList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ConfigMapList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetConfigMapList2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ConfigMapList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetConfigMapList2(context, axiosConfig) : __handleGetConfigMapList2,
    queryKey: handleGetConfigMapList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    ...handleGetConfigMapList2DefaultOptions as unknown as Omit<UseQueryOptions<Types.ConfigMapList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of ConfigMaps in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ConfigMap
 * @return OK
 */
export function setHandleGetConfigMapList2Data(queryClient: QueryClient, updater: (data: Types.ConfigMapList | undefined) => Types.ConfigMapList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string) {
  queryClient.setQueryData(handleGetConfigMapList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    updater
  );
}

/**
 * returns a list of ConfigMaps in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ConfigMap
 * @return OK
 */
export function setHandleGetConfigMapList2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ConfigMapList | undefined) => Types.ConfigMapList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetConfigMapDetailUrl(namespace: string, configmap: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/configmap/{namespace}/{configmap}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (configmap === undefined || configmap === null)
  throw new Error("The parameter 'configmap' must be defined.");
url_ = url_.replace("{configmap}", encodeURIComponent("" + configmap));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetConfigMapDetailDefaultOptions: Omit<UseQueryOptions<Types.ConfigMapDetail, unknown, Types.ConfigMapDetail>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ConfigMapDetail, unknown, Types.ConfigMapDetail>, 'queryFn'>> = {
};
export function getHandleGetConfigMapDetailDefaultOptions() {
  return handleGetConfigMapDetailDefaultOptions;
};
export function setHandleGetConfigMapDetailDefaultOptions(options: typeof handleGetConfigMapDetailDefaultOptions) {
  handleGetConfigMapDetailDefaultOptions = options;
}

export function handleGetConfigMapDetailQueryKey(dto: HandleGetConfigMapDetailQueryParameters): QueryKey;
export function handleGetConfigMapDetailQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, configmap: string): QueryKey;
export function handleGetConfigMapDetailQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, configmap,  } = params[0] as HandleGetConfigMapDetailQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetConfigMapDetail',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        configmap as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetConfigMapDetail',
        ...params
      ]);
  }
}
export function __handleGetConfigMapDetail(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetConfigMapDetail(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetConfigMapDetailQuery<TSelectData = Types.ConfigMapDetail, TError = unknown>(dto: HandleGetConfigMapDetailQueryParameters, options?: Omit<UseQueryOptions<Types.ConfigMapDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns detailed information about ConfigMap
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ConfigMap
 * @param configmap name of the ConfigMap
 * @return OK
 */
export function useHandleGetConfigMapDetailQuery<TSelectData = Types.ConfigMapDetail, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, configmap: string, options?: Omit<UseQueryOptions<Types.ConfigMapDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetConfigMapDetailQuery<TSelectData = Types.ConfigMapDetail, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ConfigMapDetail, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let configmap: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, configmap,  } = params[0] as HandleGetConfigMapDetailQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, configmap, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ConfigMapDetail, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetConfigMapDetail(context, axiosConfig) : __handleGetConfigMapDetail,
    queryKey: handleGetConfigMapDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, configmap),
    ...handleGetConfigMapDetailDefaultOptions as unknown as Omit<UseQueryOptions<Types.ConfigMapDetail, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns detailed information about ConfigMap
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ConfigMap
 * @param configmap name of the ConfigMap
 * @return OK
 */
export function setHandleGetConfigMapDetailData(queryClient: QueryClient, updater: (data: Types.ConfigMapDetail | undefined) => Types.ConfigMapDetail, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, configmap: string) {
  queryClient.setQueryData(handleGetConfigMapDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, configmap),
    updater
  );
}

/**
 * returns detailed information about ConfigMap
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ConfigMap
 * @param configmap name of the ConfigMap
 * @return OK
 */
export function setHandleGetConfigMapDetailDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ConfigMapDetail | undefined) => Types.ConfigMapDetail) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetCustomResourceDefinitionListUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/crd?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetCustomResourceDefinitionListDefaultOptions: Omit<UseQueryOptions<Types.CustomResourceDefinitionList, unknown, Types.CustomResourceDefinitionList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.CustomResourceDefinitionList, unknown, Types.CustomResourceDefinitionList>, 'queryFn'>> = {
};
export function getHandleGetCustomResourceDefinitionListDefaultOptions() {
  return handleGetCustomResourceDefinitionListDefaultOptions;
};
export function setHandleGetCustomResourceDefinitionListDefaultOptions(options: typeof handleGetCustomResourceDefinitionListDefaultOptions) {
  handleGetCustomResourceDefinitionListDefaultOptions = options;
}

export function handleGetCustomResourceDefinitionListQueryKey(dto: HandleGetCustomResourceDefinitionListQueryParameters): QueryKey;
export function handleGetCustomResourceDefinitionListQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): QueryKey;
export function handleGetCustomResourceDefinitionListQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetCustomResourceDefinitionListQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetCustomResourceDefinitionList',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetCustomResourceDefinitionList',
        ...params
      ]);
  }
}
export function __handleGetCustomResourceDefinitionList(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetCustomResourceDefinitionList(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined);
}

export function useHandleGetCustomResourceDefinitionListQuery<TSelectData = Types.CustomResourceDefinitionList, TError = unknown>(dto: HandleGetCustomResourceDefinitionListQueryParameters, options?: Omit<UseQueryOptions<Types.CustomResourceDefinitionList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of CustomResourceDefinition
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleGetCustomResourceDefinitionListQuery<TSelectData = Types.CustomResourceDefinitionList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseQueryOptions<Types.CustomResourceDefinitionList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetCustomResourceDefinitionListQuery<TSelectData = Types.CustomResourceDefinitionList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.CustomResourceDefinitionList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetCustomResourceDefinitionListQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.CustomResourceDefinitionList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetCustomResourceDefinitionList(context, axiosConfig) : __handleGetCustomResourceDefinitionList,
    queryKey: handleGetCustomResourceDefinitionListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    ...handleGetCustomResourceDefinitionListDefaultOptions as unknown as Omit<UseQueryOptions<Types.CustomResourceDefinitionList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of CustomResourceDefinition
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetCustomResourceDefinitionListData(queryClient: QueryClient, updater: (data: Types.CustomResourceDefinitionList | undefined) => Types.CustomResourceDefinitionList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined) {
  queryClient.setQueryData(handleGetCustomResourceDefinitionListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    updater
  );
}

/**
 * returns a list of CustomResourceDefinition
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetCustomResourceDefinitionListDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.CustomResourceDefinitionList | undefined) => Types.CustomResourceDefinitionList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetCustomResourceDefinitionDetailUrl(crd: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/crd/{crd}?";
if (crd === undefined || crd === null)
  throw new Error("The parameter 'crd' must be defined.");
url_ = url_.replace("{crd}", encodeURIComponent("" + crd));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetCustomResourceDefinitionDetailDefaultOptions: Omit<UseQueryOptions<Types.CustomResourceDefinitionDetail, unknown, Types.CustomResourceDefinitionDetail>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.CustomResourceDefinitionDetail, unknown, Types.CustomResourceDefinitionDetail>, 'queryFn'>> = {
};
export function getHandleGetCustomResourceDefinitionDetailDefaultOptions() {
  return handleGetCustomResourceDefinitionDetailDefaultOptions;
};
export function setHandleGetCustomResourceDefinitionDetailDefaultOptions(options: typeof handleGetCustomResourceDefinitionDetailDefaultOptions) {
  handleGetCustomResourceDefinitionDetailDefaultOptions = options;
}

export function handleGetCustomResourceDefinitionDetailQueryKey(dto: HandleGetCustomResourceDefinitionDetailQueryParameters): QueryKey;
export function handleGetCustomResourceDefinitionDetailQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, crd: string): QueryKey;
export function handleGetCustomResourceDefinitionDetailQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, crd,  } = params[0] as HandleGetCustomResourceDefinitionDetailQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetCustomResourceDefinitionDetail',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        crd as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetCustomResourceDefinitionDetail',
        ...params
      ]);
  }
}
export function __handleGetCustomResourceDefinitionDetail(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetCustomResourceDefinitionDetail(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetCustomResourceDefinitionDetailQuery<TSelectData = Types.CustomResourceDefinitionDetail, TError = unknown>(dto: HandleGetCustomResourceDefinitionDetailQueryParameters, options?: Omit<UseQueryOptions<Types.CustomResourceDefinitionDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns detailed information about CustomResourceDefinition
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param crd name of the CustomResourceDefinition
 * @return OK
 */
export function useHandleGetCustomResourceDefinitionDetailQuery<TSelectData = Types.CustomResourceDefinitionDetail, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, crd: string, options?: Omit<UseQueryOptions<Types.CustomResourceDefinitionDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetCustomResourceDefinitionDetailQuery<TSelectData = Types.CustomResourceDefinitionDetail, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.CustomResourceDefinitionDetail, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let crd: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, crd,  } = params[0] as HandleGetCustomResourceDefinitionDetailQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, crd, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.CustomResourceDefinitionDetail, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetCustomResourceDefinitionDetail(context, axiosConfig) : __handleGetCustomResourceDefinitionDetail,
    queryKey: handleGetCustomResourceDefinitionDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, crd),
    ...handleGetCustomResourceDefinitionDetailDefaultOptions as unknown as Omit<UseQueryOptions<Types.CustomResourceDefinitionDetail, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns detailed information about CustomResourceDefinition
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param crd name of the CustomResourceDefinition
 * @return OK
 */
export function setHandleGetCustomResourceDefinitionDetailData(queryClient: QueryClient, updater: (data: Types.CustomResourceDefinitionDetail | undefined) => Types.CustomResourceDefinitionDetail, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, crd: string) {
  queryClient.setQueryData(handleGetCustomResourceDefinitionDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, crd),
    updater
  );
}

/**
 * returns detailed information about CustomResourceDefinition
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param crd name of the CustomResourceDefinition
 * @return OK
 */
export function setHandleGetCustomResourceDefinitionDetailDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.CustomResourceDefinitionDetail | undefined) => Types.CustomResourceDefinitionDetail) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetCustomResourceObjectListUrl(namespace: string, crd: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/crd/{namespace}/{crd}/object?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (crd === undefined || crd === null)
  throw new Error("The parameter 'crd' must be defined.");
url_ = url_.replace("{crd}", encodeURIComponent("" + crd));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetCustomResourceObjectListDefaultOptions: Omit<UseQueryOptions<Types.CustomResourceObjectList, unknown, Types.CustomResourceObjectList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.CustomResourceObjectList, unknown, Types.CustomResourceObjectList>, 'queryFn'>> = {
};
export function getHandleGetCustomResourceObjectListDefaultOptions() {
  return handleGetCustomResourceObjectListDefaultOptions;
};
export function setHandleGetCustomResourceObjectListDefaultOptions(options: typeof handleGetCustomResourceObjectListDefaultOptions) {
  handleGetCustomResourceObjectListDefaultOptions = options;
}

export function handleGetCustomResourceObjectListQueryKey(dto: HandleGetCustomResourceObjectListQueryParameters): QueryKey;
export function handleGetCustomResourceObjectListQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, crd: string): QueryKey;
export function handleGetCustomResourceObjectListQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, crd,  } = params[0] as HandleGetCustomResourceObjectListQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetCustomResourceObjectList',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        crd as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetCustomResourceObjectList',
        ...params
      ]);
  }
}
export function __handleGetCustomResourceObjectList(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetCustomResourceObjectList(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetCustomResourceObjectListQuery<TSelectData = Types.CustomResourceObjectList, TError = unknown>(dto: HandleGetCustomResourceObjectListQueryParameters, options?: Omit<UseQueryOptions<Types.CustomResourceObjectList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of objects of CustomResourceDefinition
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the custom resource
 * @param crd name of the CustomResourceDefinition
 * @return OK
 */
export function useHandleGetCustomResourceObjectListQuery<TSelectData = Types.CustomResourceObjectList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, crd: string, options?: Omit<UseQueryOptions<Types.CustomResourceObjectList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetCustomResourceObjectListQuery<TSelectData = Types.CustomResourceObjectList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.CustomResourceObjectList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let crd: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, crd,  } = params[0] as HandleGetCustomResourceObjectListQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, crd, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.CustomResourceObjectList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetCustomResourceObjectList(context, axiosConfig) : __handleGetCustomResourceObjectList,
    queryKey: handleGetCustomResourceObjectListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, crd),
    ...handleGetCustomResourceObjectListDefaultOptions as unknown as Omit<UseQueryOptions<Types.CustomResourceObjectList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of objects of CustomResourceDefinition
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the custom resource
 * @param crd name of the CustomResourceDefinition
 * @return OK
 */
export function setHandleGetCustomResourceObjectListData(queryClient: QueryClient, updater: (data: Types.CustomResourceObjectList | undefined) => Types.CustomResourceObjectList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, crd: string) {
  queryClient.setQueryData(handleGetCustomResourceObjectListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, crd),
    updater
  );
}

/**
 * returns a list of objects of CustomResourceDefinition
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the custom resource
 * @param crd name of the CustomResourceDefinition
 * @return OK
 */
export function setHandleGetCustomResourceObjectListDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.CustomResourceObjectList | undefined) => Types.CustomResourceObjectList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetCustomResourceObjectDetailUrl(namespace: string, crd: string, object: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/crd/{namespace}/{crd}/{object}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (crd === undefined || crd === null)
  throw new Error("The parameter 'crd' must be defined.");
url_ = url_.replace("{crd}", encodeURIComponent("" + crd));
if (object === undefined || object === null)
  throw new Error("The parameter 'object' must be defined.");
url_ = url_.replace("{object}", encodeURIComponent("" + object));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetCustomResourceObjectDetailDefaultOptions: Omit<UseQueryOptions<Types.CustomResourceObjectDetail, unknown, Types.CustomResourceObjectDetail>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.CustomResourceObjectDetail, unknown, Types.CustomResourceObjectDetail>, 'queryFn'>> = {
};
export function getHandleGetCustomResourceObjectDetailDefaultOptions() {
  return handleGetCustomResourceObjectDetailDefaultOptions;
};
export function setHandleGetCustomResourceObjectDetailDefaultOptions(options: typeof handleGetCustomResourceObjectDetailDefaultOptions) {
  handleGetCustomResourceObjectDetailDefaultOptions = options;
}

export function handleGetCustomResourceObjectDetailQueryKey(dto: HandleGetCustomResourceObjectDetailQueryParameters): QueryKey;
export function handleGetCustomResourceObjectDetailQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, crd: string, object: string): QueryKey;
export function handleGetCustomResourceObjectDetailQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, crd, object,  } = params[0] as HandleGetCustomResourceObjectDetailQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetCustomResourceObjectDetail',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        crd as any,
        object as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetCustomResourceObjectDetail',
        ...params
      ]);
  }
}
export function __handleGetCustomResourceObjectDetail(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetCustomResourceObjectDetail(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string,       context.queryKey[10] as string);
}

export function useHandleGetCustomResourceObjectDetailQuery<TSelectData = Types.CustomResourceObjectDetail, TError = unknown>(dto: HandleGetCustomResourceObjectDetailQueryParameters, options?: Omit<UseQueryOptions<Types.CustomResourceObjectDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns detailed information about custom resource object
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the custom resource
 * @param crd name of the CustomResourceDefinition
 * @param object name of the custom resource object
 * @return OK
 */
export function useHandleGetCustomResourceObjectDetailQuery<TSelectData = Types.CustomResourceObjectDetail, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, crd: string, object: string, options?: Omit<UseQueryOptions<Types.CustomResourceObjectDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetCustomResourceObjectDetailQuery<TSelectData = Types.CustomResourceObjectDetail, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.CustomResourceObjectDetail, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let crd: any = undefined;
  let object: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, crd, object,  } = params[0] as HandleGetCustomResourceObjectDetailQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, crd, object, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.CustomResourceObjectDetail, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetCustomResourceObjectDetail(context, axiosConfig) : __handleGetCustomResourceObjectDetail,
    queryKey: handleGetCustomResourceObjectDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, crd, object),
    ...handleGetCustomResourceObjectDetailDefaultOptions as unknown as Omit<UseQueryOptions<Types.CustomResourceObjectDetail, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns detailed information about custom resource object
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the custom resource
 * @param crd name of the CustomResourceDefinition
 * @param object name of the custom resource object
 * @return OK
 */
export function setHandleGetCustomResourceObjectDetailData(queryClient: QueryClient, updater: (data: Types.CustomResourceObjectDetail | undefined) => Types.CustomResourceObjectDetail, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, crd: string, object: string) {
  queryClient.setQueryData(handleGetCustomResourceObjectDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, crd, object),
    updater
  );
}

/**
 * returns detailed information about custom resource object
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the custom resource
 * @param crd name of the CustomResourceDefinition
 * @param object name of the custom resource object
 * @return OK
 */
export function setHandleGetCustomResourceObjectDetailDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.CustomResourceObjectDetail | undefined) => Types.CustomResourceObjectDetail) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetCustomResourceObjectEventsUrl(namespace: string, crd: string, object: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/crd/{namespace}/{crd}/{object}/event?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (crd === undefined || crd === null)
  throw new Error("The parameter 'crd' must be defined.");
url_ = url_.replace("{crd}", encodeURIComponent("" + crd));
if (object === undefined || object === null)
  throw new Error("The parameter 'object' must be defined.");
url_ = url_.replace("{object}", encodeURIComponent("" + object));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetCustomResourceObjectEventsDefaultOptions: Omit<UseQueryOptions<Types.EventList, unknown, Types.EventList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.EventList, unknown, Types.EventList>, 'queryFn'>> = {
};
export function getHandleGetCustomResourceObjectEventsDefaultOptions() {
  return handleGetCustomResourceObjectEventsDefaultOptions;
};
export function setHandleGetCustomResourceObjectEventsDefaultOptions(options: typeof handleGetCustomResourceObjectEventsDefaultOptions) {
  handleGetCustomResourceObjectEventsDefaultOptions = options;
}

export function handleGetCustomResourceObjectEventsQueryKey(dto: HandleGetCustomResourceObjectEventsQueryParameters): QueryKey;
export function handleGetCustomResourceObjectEventsQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, crd: string, object: string): QueryKey;
export function handleGetCustomResourceObjectEventsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, crd, object,  } = params[0] as HandleGetCustomResourceObjectEventsQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetCustomResourceObjectEvents',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        crd as any,
        object as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetCustomResourceObjectEvents',
        ...params
      ]);
  }
}
export function __handleGetCustomResourceObjectEvents(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetCustomResourceObjectEvents(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string,       context.queryKey[10] as string);
}

export function useHandleGetCustomResourceObjectEventsQuery<TSelectData = Types.EventList, TError = unknown>(dto: HandleGetCustomResourceObjectEventsQueryParameters, options?: Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns Events for custom resource object
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the custom resource
 * @param crd name of the CustomResourceDefinition
 * @param object name of the custom resource object
 * @return OK
 */
export function useHandleGetCustomResourceObjectEventsQuery<TSelectData = Types.EventList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, crd: string, object: string, options?: Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetCustomResourceObjectEventsQuery<TSelectData = Types.EventList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.EventList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let crd: any = undefined;
  let object: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, crd, object,  } = params[0] as HandleGetCustomResourceObjectEventsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, crd, object, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.EventList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetCustomResourceObjectEvents(context, axiosConfig) : __handleGetCustomResourceObjectEvents,
    queryKey: handleGetCustomResourceObjectEventsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, crd, object),
    ...handleGetCustomResourceObjectEventsDefaultOptions as unknown as Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns Events for custom resource object
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the custom resource
 * @param crd name of the CustomResourceDefinition
 * @param object name of the custom resource object
 * @return OK
 */
export function setHandleGetCustomResourceObjectEventsData(queryClient: QueryClient, updater: (data: Types.EventList | undefined) => Types.EventList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, crd: string, object: string) {
  queryClient.setQueryData(handleGetCustomResourceObjectEventsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, crd, object),
    updater
  );
}

/**
 * returns Events for custom resource object
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the custom resource
 * @param crd name of the CustomResourceDefinition
 * @param object name of the custom resource object
 * @return OK
 */
export function setHandleGetCustomResourceObjectEventsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.EventList | undefined) => Types.EventList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetCronJobListUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/cronjob?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetCronJobListDefaultOptions: Omit<UseQueryOptions<Types.CronJobList, unknown, Types.CronJobList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.CronJobList, unknown, Types.CronJobList>, 'queryFn'>> = {
};
export function getHandleGetCronJobListDefaultOptions() {
  return handleGetCronJobListDefaultOptions;
};
export function setHandleGetCronJobListDefaultOptions(options: typeof handleGetCronJobListDefaultOptions) {
  handleGetCronJobListDefaultOptions = options;
}

export function handleGetCronJobListQueryKey(dto: HandleGetCronJobListQueryParameters): QueryKey;
export function handleGetCronJobListQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): QueryKey;
export function handleGetCronJobListQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetCronJobListQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetCronJobList',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetCronJobList',
        ...params
      ]);
  }
}
export function __handleGetCronJobList(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetCronJobList(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined);
}

export function useHandleGetCronJobListQuery<TSelectData = Types.CronJobList, TError = unknown>(dto: HandleGetCronJobListQueryParameters, options?: Omit<UseQueryOptions<Types.CronJobList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of CronJobs from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleGetCronJobListQuery<TSelectData = Types.CronJobList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseQueryOptions<Types.CronJobList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetCronJobListQuery<TSelectData = Types.CronJobList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.CronJobList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetCronJobListQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.CronJobList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetCronJobList(context, axiosConfig) : __handleGetCronJobList,
    queryKey: handleGetCronJobListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    ...handleGetCronJobListDefaultOptions as unknown as Omit<UseQueryOptions<Types.CronJobList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of CronJobs from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetCronJobListData(queryClient: QueryClient, updater: (data: Types.CronJobList | undefined) => Types.CronJobList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined) {
  queryClient.setQueryData(handleGetCronJobListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    updater
  );
}

/**
 * returns a list of CronJobs from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetCronJobListDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.CronJobList | undefined) => Types.CronJobList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetCronJobList2Url(namespace: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/cronjob/{namespace}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetCronJobList2DefaultOptions: Omit<UseQueryOptions<Types.CronJobList, unknown, Types.CronJobList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.CronJobList, unknown, Types.CronJobList>, 'queryFn'>> = {
};
export function getHandleGetCronJobList2DefaultOptions() {
  return handleGetCronJobList2DefaultOptions;
};
export function setHandleGetCronJobList2DefaultOptions(options: typeof handleGetCronJobList2DefaultOptions) {
  handleGetCronJobList2DefaultOptions = options;
}

export function handleGetCronJobList2QueryKey(dto: HandleGetCronJobList2QueryParameters): QueryKey;
export function handleGetCronJobList2QueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string): QueryKey;
export function handleGetCronJobList2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetCronJobList2QueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetCronJobList2',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetCronJobList2',
        ...params
      ]);
  }
}
export function __handleGetCronJobList2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetCronJobList2(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetCronJobList2Query<TSelectData = Types.CronJobList, TError = unknown>(dto: HandleGetCronJobList2QueryParameters, options?: Omit<UseQueryOptions<Types.CronJobList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of CronJobs in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the CronJob
 * @return OK
 */
export function useHandleGetCronJobList2Query<TSelectData = Types.CronJobList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, options?: Omit<UseQueryOptions<Types.CronJobList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetCronJobList2Query<TSelectData = Types.CronJobList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.CronJobList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetCronJobList2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.CronJobList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetCronJobList2(context, axiosConfig) : __handleGetCronJobList2,
    queryKey: handleGetCronJobList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    ...handleGetCronJobList2DefaultOptions as unknown as Omit<UseQueryOptions<Types.CronJobList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of CronJobs in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the CronJob
 * @return OK
 */
export function setHandleGetCronJobList2Data(queryClient: QueryClient, updater: (data: Types.CronJobList | undefined) => Types.CronJobList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string) {
  queryClient.setQueryData(handleGetCronJobList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    updater
  );
}

/**
 * returns a list of CronJobs in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the CronJob
 * @return OK
 */
export function setHandleGetCronJobList2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.CronJobList | undefined) => Types.CronJobList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetCronJobDetailUrl(namespace: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/cronjob/{namespace}/{name}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (name === undefined || name === null)
  throw new Error("The parameter 'name' must be defined.");
url_ = url_.replace("{name}", encodeURIComponent("" + name));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetCronJobDetailDefaultOptions: Omit<UseQueryOptions<Types.CronJobDetail, unknown, Types.CronJobDetail>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.CronJobDetail, unknown, Types.CronJobDetail>, 'queryFn'>> = {
};
export function getHandleGetCronJobDetailDefaultOptions() {
  return handleGetCronJobDetailDefaultOptions;
};
export function setHandleGetCronJobDetailDefaultOptions(options: typeof handleGetCronJobDetailDefaultOptions) {
  handleGetCronJobDetailDefaultOptions = options;
}

export function handleGetCronJobDetailQueryKey(dto: HandleGetCronJobDetailQueryParameters): QueryKey;
export function handleGetCronJobDetailQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, name: string): QueryKey;
export function handleGetCronJobDetailQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name,  } = params[0] as HandleGetCronJobDetailQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetCronJobDetail',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        name as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetCronJobDetail',
        ...params
      ]);
  }
}
export function __handleGetCronJobDetail(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetCronJobDetail(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetCronJobDetailQuery<TSelectData = Types.CronJobDetail, TError = unknown>(dto: HandleGetCronJobDetailQueryParameters, options?: Omit<UseQueryOptions<Types.CronJobDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns detailed information about CronJob
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the CronJob
 * @param name name of the CronJob
 * @return OK
 */
export function useHandleGetCronJobDetailQuery<TSelectData = Types.CronJobDetail, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, name: string, options?: Omit<UseQueryOptions<Types.CronJobDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetCronJobDetailQuery<TSelectData = Types.CronJobDetail, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.CronJobDetail, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let name: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name,  } = params[0] as HandleGetCronJobDetailQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.CronJobDetail, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetCronJobDetail(context, axiosConfig) : __handleGetCronJobDetail,
    queryKey: handleGetCronJobDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name),
    ...handleGetCronJobDetailDefaultOptions as unknown as Omit<UseQueryOptions<Types.CronJobDetail, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns detailed information about CronJob
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the CronJob
 * @param name name of the CronJob
 * @return OK
 */
export function setHandleGetCronJobDetailData(queryClient: QueryClient, updater: (data: Types.CronJobDetail | undefined) => Types.CronJobDetail, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, name: string) {
  queryClient.setQueryData(handleGetCronJobDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name),
    updater
  );
}

/**
 * returns detailed information about CronJob
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the CronJob
 * @param name name of the CronJob
 * @return OK
 */
export function setHandleGetCronJobDetailDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.CronJobDetail | undefined) => Types.CronJobDetail) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetCronJobEventsUrl(namespace: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/cronjob/{namespace}/{name}/event?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (name === undefined || name === null)
  throw new Error("The parameter 'name' must be defined.");
url_ = url_.replace("{name}", encodeURIComponent("" + name));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetCronJobEventsDefaultOptions: Omit<UseQueryOptions<Types.EventList, unknown, Types.EventList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.EventList, unknown, Types.EventList>, 'queryFn'>> = {
};
export function getHandleGetCronJobEventsDefaultOptions() {
  return handleGetCronJobEventsDefaultOptions;
};
export function setHandleGetCronJobEventsDefaultOptions(options: typeof handleGetCronJobEventsDefaultOptions) {
  handleGetCronJobEventsDefaultOptions = options;
}

export function handleGetCronJobEventsQueryKey(dto: HandleGetCronJobEventsQueryParameters): QueryKey;
export function handleGetCronJobEventsQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, name: string): QueryKey;
export function handleGetCronJobEventsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name,  } = params[0] as HandleGetCronJobEventsQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetCronJobEvents',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        name as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetCronJobEvents',
        ...params
      ]);
  }
}
export function __handleGetCronJobEvents(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetCronJobEvents(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetCronJobEventsQuery<TSelectData = Types.EventList, TError = unknown>(dto: HandleGetCronJobEventsQueryParameters, options?: Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Events for CronJob
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the CronJob
 * @param name name of the CronJob
 * @return OK
 */
export function useHandleGetCronJobEventsQuery<TSelectData = Types.EventList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, name: string, options?: Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetCronJobEventsQuery<TSelectData = Types.EventList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.EventList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let name: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name,  } = params[0] as HandleGetCronJobEventsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.EventList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetCronJobEvents(context, axiosConfig) : __handleGetCronJobEvents,
    queryKey: handleGetCronJobEventsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name),
    ...handleGetCronJobEventsDefaultOptions as unknown as Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Events for CronJob
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the CronJob
 * @param name name of the CronJob
 * @return OK
 */
export function setHandleGetCronJobEventsData(queryClient: QueryClient, updater: (data: Types.EventList | undefined) => Types.EventList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, name: string) {
  queryClient.setQueryData(handleGetCronJobEventsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name),
    updater
  );
}

/**
 * returns a list of Events for CronJob
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the CronJob
 * @param name name of the CronJob
 * @return OK
 */
export function setHandleGetCronJobEventsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.EventList | undefined) => Types.EventList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetCronJobJobsUrl(namespace: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, active: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/cronjob/{namespace}/{name}/job?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (name === undefined || name === null)
  throw new Error("The parameter 'name' must be defined.");
url_ = url_.replace("{name}", encodeURIComponent("" + name));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
if (active !== undefined && active !== null)
    url_ += "active=" + encodeURIComponent("" + active) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetCronJobJobsDefaultOptions: Omit<UseQueryOptions<Types.JobList, unknown, Types.JobList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.JobList, unknown, Types.JobList>, 'queryFn'>> = {
};
export function getHandleGetCronJobJobsDefaultOptions() {
  return handleGetCronJobJobsDefaultOptions;
};
export function setHandleGetCronJobJobsDefaultOptions(options: typeof handleGetCronJobJobsDefaultOptions) {
  handleGetCronJobJobsDefaultOptions = options;
}

export function handleGetCronJobJobsQueryKey(dto: HandleGetCronJobJobsQueryParameters): QueryKey;
export function handleGetCronJobJobsQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, name: string, active: string | null | undefined): QueryKey;
export function handleGetCronJobJobsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name, active,  } = params[0] as HandleGetCronJobJobsQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetCronJobJobs',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        name as any,
        active as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetCronJobJobs',
        ...params
      ]);
  }
}
export function __handleGetCronJobJobs(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetCronJobJobs(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string,       context.queryKey[10] as string | null | undefined);
}

export function useHandleGetCronJobJobsQuery<TSelectData = Types.JobList, TError = unknown>(dto: HandleGetCronJobJobsQueryParameters, options?: Omit<UseQueryOptions<Types.JobList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Jobs for CronJob
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the CronJob
 * @param name name of the CronJob
 * @param active (optional) filter related Jobs by active status
 * @return OK
 */
export function useHandleGetCronJobJobsQuery<TSelectData = Types.JobList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, name: string, active: string | null | undefined, options?: Omit<UseQueryOptions<Types.JobList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetCronJobJobsQuery<TSelectData = Types.JobList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.JobList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let name: any = undefined;
  let active: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name, active,  } = params[0] as HandleGetCronJobJobsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name, active, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.JobList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetCronJobJobs(context, axiosConfig) : __handleGetCronJobJobs,
    queryKey: handleGetCronJobJobsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name, active),
    ...handleGetCronJobJobsDefaultOptions as unknown as Omit<UseQueryOptions<Types.JobList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Jobs for CronJob
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the CronJob
 * @param name name of the CronJob
 * @param active (optional) filter related Jobs by active status
 * @return OK
 */
export function setHandleGetCronJobJobsData(queryClient: QueryClient, updater: (data: Types.JobList | undefined) => Types.JobList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, name: string, active: string | null | undefined) {
  queryClient.setQueryData(handleGetCronJobJobsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name, active),
    updater
  );
}

/**
 * returns a list of Jobs for CronJob
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the CronJob
 * @param name name of the CronJob
 * @param active (optional) filter related Jobs by active status
 * @return OK
 */
export function setHandleGetCronJobJobsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.JobList | undefined) => Types.JobList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleTriggerCronJobUrl(namespace: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/cronjob/{namespace}/{name}/trigger?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (name === undefined || name === null)
  throw new Error("The parameter 'name' must be defined.");
url_ = url_.replace("{name}", encodeURIComponent("" + name));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function handleTriggerCronJobMutationKey(namespace: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'handleTriggerCronJob',
      namespace as any,
      name as any,
      filterBy as any,
      sortBy as any,
      itemsPerPage as any,
      page as any,
      metricNames as any,
      aggregations as any,
    ]);
}

/**
 * triggers a Job based on CronJob
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the CronJob
 * @param name name of the CronJob
 * @return OK
 */
export function useHandleTriggerCronJobMutation<TContext>(namespace: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = handleTriggerCronJobMutationKey(namespace, name, filterBy, sortBy, itemsPerPage, page, metricNames, aggregations);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client().handleTriggerCronJob(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name),
    mutationKey: key,
  });
}
  
type HandleTriggerCronJob__MutationParameters = HandleTriggerCronJobQueryParameters

/**
 * triggers a Job based on CronJob
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the CronJob
 * @param name name of the CronJob
 * @return OK
 */
export function useHandleTriggerCronJobMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, HandleTriggerCronJob__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: HandleTriggerCronJobQueryParameters}): UseMutationResult<void, unknown, HandleTriggerCronJob__MutationParameters, TContext> {
  const key = handleTriggerCronJobMutationKey(options?.parameters?.namespace!, options?.parameters?.name!, options?.parameters?.filterBy!, options?.parameters?.sortBy!, options?.parameters?.itemsPerPage!, options?.parameters?.page!, options?.parameters?.metricNames!, options?.parameters?.aggregations!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: HandleTriggerCronJob__MutationParameters) => Client().handleTriggerCronJob(data.filterBy ?? options?.parameters?.filterBy!, data.sortBy ?? options?.parameters?.sortBy!, data.itemsPerPage ?? options?.parameters?.itemsPerPage!, data.page ?? options?.parameters?.page!, data.metricNames ?? options?.parameters?.metricNames!, data.aggregations ?? options?.parameters?.aggregations!, data.namespace ?? options?.parameters?.namespace!, data.name ?? options?.parameters?.name!),
  mutationKey: key,
});
}
  
export function handleGetCsrfTokenUrl(action: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/csrftoken/{action}?";
if (action === undefined || action === null)
  throw new Error("The parameter 'action' must be defined.");
url_ = url_.replace("{action}", encodeURIComponent("" + action));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetCsrfTokenDefaultOptions: Omit<UseQueryOptions<Types.Response, unknown, Types.Response>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.Response, unknown, Types.Response>, 'queryFn'>> = {
};
export function getHandleGetCsrfTokenDefaultOptions() {
  return handleGetCsrfTokenDefaultOptions;
};
export function setHandleGetCsrfTokenDefaultOptions(options: typeof handleGetCsrfTokenDefaultOptions) {
  handleGetCsrfTokenDefaultOptions = options;
}

export function handleGetCsrfTokenQueryKey(dto: HandleGetCsrfTokenQueryParameters): QueryKey;
export function handleGetCsrfTokenQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, action: string): QueryKey;
export function handleGetCsrfTokenQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, action,  } = params[0] as HandleGetCsrfTokenQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetCsrfToken',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        action as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetCsrfToken',
        ...params
      ]);
  }
}
export function __handleGetCsrfToken(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetCsrfToken(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetCsrfTokenQuery<TSelectData = Types.Response, TError = unknown>(dto: HandleGetCsrfTokenQueryParameters, options?: Omit<UseQueryOptions<Types.Response, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * generates a one-time CSRF token that can be used by POST request
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param action action name to generate CSRF token for
 * @return OK
 */
export function useHandleGetCsrfTokenQuery<TSelectData = Types.Response, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, action: string, options?: Omit<UseQueryOptions<Types.Response, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetCsrfTokenQuery<TSelectData = Types.Response, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Response, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let action: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, action,  } = params[0] as HandleGetCsrfTokenQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, action, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Response, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetCsrfToken(context, axiosConfig) : __handleGetCsrfToken,
    queryKey: handleGetCsrfTokenQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, action),
    ...handleGetCsrfTokenDefaultOptions as unknown as Omit<UseQueryOptions<Types.Response, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * generates a one-time CSRF token that can be used by POST request
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param action action name to generate CSRF token for
 * @return OK
 */
export function setHandleGetCsrfTokenData(queryClient: QueryClient, updater: (data: Types.Response | undefined) => Types.Response, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, action: string) {
  queryClient.setQueryData(handleGetCsrfTokenQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, action),
    updater
  );
}

/**
 * generates a one-time CSRF token that can be used by POST request
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param action action name to generate CSRF token for
 * @return OK
 */
export function setHandleGetCsrfTokenDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Response | undefined) => Types.Response) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetDaemonSetListUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/daemonset?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetDaemonSetListDefaultOptions: Omit<UseQueryOptions<Types.DaemonSetList, unknown, Types.DaemonSetList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.DaemonSetList, unknown, Types.DaemonSetList>, 'queryFn'>> = {
};
export function getHandleGetDaemonSetListDefaultOptions() {
  return handleGetDaemonSetListDefaultOptions;
};
export function setHandleGetDaemonSetListDefaultOptions(options: typeof handleGetDaemonSetListDefaultOptions) {
  handleGetDaemonSetListDefaultOptions = options;
}

export function handleGetDaemonSetListQueryKey(dto: HandleGetDaemonSetListQueryParameters): QueryKey;
export function handleGetDaemonSetListQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): QueryKey;
export function handleGetDaemonSetListQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetDaemonSetListQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetDaemonSetList',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetDaemonSetList',
        ...params
      ]);
  }
}
export function __handleGetDaemonSetList(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetDaemonSetList(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined);
}

export function useHandleGetDaemonSetListQuery<TSelectData = Types.DaemonSetList, TError = unknown>(dto: HandleGetDaemonSetListQueryParameters, options?: Omit<UseQueryOptions<Types.DaemonSetList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of DaemonSets from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleGetDaemonSetListQuery<TSelectData = Types.DaemonSetList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseQueryOptions<Types.DaemonSetList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetDaemonSetListQuery<TSelectData = Types.DaemonSetList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.DaemonSetList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetDaemonSetListQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.DaemonSetList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetDaemonSetList(context, axiosConfig) : __handleGetDaemonSetList,
    queryKey: handleGetDaemonSetListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    ...handleGetDaemonSetListDefaultOptions as unknown as Omit<UseQueryOptions<Types.DaemonSetList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of DaemonSets from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetDaemonSetListData(queryClient: QueryClient, updater: (data: Types.DaemonSetList | undefined) => Types.DaemonSetList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined) {
  queryClient.setQueryData(handleGetDaemonSetListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    updater
  );
}

/**
 * returns a list of DaemonSets from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetDaemonSetListDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.DaemonSetList | undefined) => Types.DaemonSetList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetDaemonSetList2Url(namespace: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/daemonset/{namespace}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetDaemonSetList2DefaultOptions: Omit<UseQueryOptions<Types.DaemonSetList, unknown, Types.DaemonSetList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.DaemonSetList, unknown, Types.DaemonSetList>, 'queryFn'>> = {
};
export function getHandleGetDaemonSetList2DefaultOptions() {
  return handleGetDaemonSetList2DefaultOptions;
};
export function setHandleGetDaemonSetList2DefaultOptions(options: typeof handleGetDaemonSetList2DefaultOptions) {
  handleGetDaemonSetList2DefaultOptions = options;
}

export function handleGetDaemonSetList2QueryKey(dto: HandleGetDaemonSetList2QueryParameters): QueryKey;
export function handleGetDaemonSetList2QueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string): QueryKey;
export function handleGetDaemonSetList2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetDaemonSetList2QueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetDaemonSetList2',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetDaemonSetList2',
        ...params
      ]);
  }
}
export function __handleGetDaemonSetList2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetDaemonSetList2(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetDaemonSetList2Query<TSelectData = Types.DaemonSetList, TError = unknown>(dto: HandleGetDaemonSetList2QueryParameters, options?: Omit<UseQueryOptions<Types.DaemonSetList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of DaemonSets in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the DaemonSet
 * @return OK
 */
export function useHandleGetDaemonSetList2Query<TSelectData = Types.DaemonSetList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, options?: Omit<UseQueryOptions<Types.DaemonSetList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetDaemonSetList2Query<TSelectData = Types.DaemonSetList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.DaemonSetList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetDaemonSetList2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.DaemonSetList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetDaemonSetList2(context, axiosConfig) : __handleGetDaemonSetList2,
    queryKey: handleGetDaemonSetList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    ...handleGetDaemonSetList2DefaultOptions as unknown as Omit<UseQueryOptions<Types.DaemonSetList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of DaemonSets in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the DaemonSet
 * @return OK
 */
export function setHandleGetDaemonSetList2Data(queryClient: QueryClient, updater: (data: Types.DaemonSetList | undefined) => Types.DaemonSetList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string) {
  queryClient.setQueryData(handleGetDaemonSetList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    updater
  );
}

/**
 * returns a list of DaemonSets in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the DaemonSet
 * @return OK
 */
export function setHandleGetDaemonSetList2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.DaemonSetList | undefined) => Types.DaemonSetList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetDaemonSetDetailUrl(namespace: string, daemonSet: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/daemonset/{namespace}/{daemonSet}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (daemonSet === undefined || daemonSet === null)
  throw new Error("The parameter 'daemonSet' must be defined.");
url_ = url_.replace("{daemonSet}", encodeURIComponent("" + daemonSet));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetDaemonSetDetailDefaultOptions: Omit<UseQueryOptions<Types.DaemonSetDetail, unknown, Types.DaemonSetDetail>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.DaemonSetDetail, unknown, Types.DaemonSetDetail>, 'queryFn'>> = {
};
export function getHandleGetDaemonSetDetailDefaultOptions() {
  return handleGetDaemonSetDetailDefaultOptions;
};
export function setHandleGetDaemonSetDetailDefaultOptions(options: typeof handleGetDaemonSetDetailDefaultOptions) {
  handleGetDaemonSetDetailDefaultOptions = options;
}

export function handleGetDaemonSetDetailQueryKey(dto: HandleGetDaemonSetDetailQueryParameters): QueryKey;
export function handleGetDaemonSetDetailQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, daemonSet: string): QueryKey;
export function handleGetDaemonSetDetailQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, daemonSet,  } = params[0] as HandleGetDaemonSetDetailQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetDaemonSetDetail',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        daemonSet as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetDaemonSetDetail',
        ...params
      ]);
  }
}
export function __handleGetDaemonSetDetail(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetDaemonSetDetail(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetDaemonSetDetailQuery<TSelectData = Types.DaemonSetDetail, TError = unknown>(dto: HandleGetDaemonSetDetailQueryParameters, options?: Omit<UseQueryOptions<Types.DaemonSetDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns detailed information about DaemonSet
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the DaemonSet
 * @param daemonSet name of the DaemonSet
 * @return OK
 */
export function useHandleGetDaemonSetDetailQuery<TSelectData = Types.DaemonSetDetail, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, daemonSet: string, options?: Omit<UseQueryOptions<Types.DaemonSetDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetDaemonSetDetailQuery<TSelectData = Types.DaemonSetDetail, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.DaemonSetDetail, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let daemonSet: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, daemonSet,  } = params[0] as HandleGetDaemonSetDetailQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, daemonSet, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.DaemonSetDetail, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetDaemonSetDetail(context, axiosConfig) : __handleGetDaemonSetDetail,
    queryKey: handleGetDaemonSetDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, daemonSet),
    ...handleGetDaemonSetDetailDefaultOptions as unknown as Omit<UseQueryOptions<Types.DaemonSetDetail, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns detailed information about DaemonSet
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the DaemonSet
 * @param daemonSet name of the DaemonSet
 * @return OK
 */
export function setHandleGetDaemonSetDetailData(queryClient: QueryClient, updater: (data: Types.DaemonSetDetail | undefined) => Types.DaemonSetDetail, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, daemonSet: string) {
  queryClient.setQueryData(handleGetDaemonSetDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, daemonSet),
    updater
  );
}

/**
 * returns detailed information about DaemonSet
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the DaemonSet
 * @param daemonSet name of the DaemonSet
 * @return OK
 */
export function setHandleGetDaemonSetDetailDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.DaemonSetDetail | undefined) => Types.DaemonSetDetail) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetDaemonSetEventsUrl(namespace: string, daemonSet: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/daemonset/{namespace}/{daemonSet}/event?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (daemonSet === undefined || daemonSet === null)
  throw new Error("The parameter 'daemonSet' must be defined.");
url_ = url_.replace("{daemonSet}", encodeURIComponent("" + daemonSet));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetDaemonSetEventsDefaultOptions: Omit<UseQueryOptions<Types.EventList, unknown, Types.EventList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.EventList, unknown, Types.EventList>, 'queryFn'>> = {
};
export function getHandleGetDaemonSetEventsDefaultOptions() {
  return handleGetDaemonSetEventsDefaultOptions;
};
export function setHandleGetDaemonSetEventsDefaultOptions(options: typeof handleGetDaemonSetEventsDefaultOptions) {
  handleGetDaemonSetEventsDefaultOptions = options;
}

export function handleGetDaemonSetEventsQueryKey(dto: HandleGetDaemonSetEventsQueryParameters): QueryKey;
export function handleGetDaemonSetEventsQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, daemonSet: string): QueryKey;
export function handleGetDaemonSetEventsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, daemonSet,  } = params[0] as HandleGetDaemonSetEventsQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetDaemonSetEvents',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        daemonSet as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetDaemonSetEvents',
        ...params
      ]);
  }
}
export function __handleGetDaemonSetEvents(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetDaemonSetEvents(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetDaemonSetEventsQuery<TSelectData = Types.EventList, TError = unknown>(dto: HandleGetDaemonSetEventsQueryParameters, options?: Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Events for DaemonSet
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the DaemonSet
 * @param daemonSet name of the DaemonSet
 * @return OK
 */
export function useHandleGetDaemonSetEventsQuery<TSelectData = Types.EventList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, daemonSet: string, options?: Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetDaemonSetEventsQuery<TSelectData = Types.EventList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.EventList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let daemonSet: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, daemonSet,  } = params[0] as HandleGetDaemonSetEventsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, daemonSet, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.EventList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetDaemonSetEvents(context, axiosConfig) : __handleGetDaemonSetEvents,
    queryKey: handleGetDaemonSetEventsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, daemonSet),
    ...handleGetDaemonSetEventsDefaultOptions as unknown as Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Events for DaemonSet
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the DaemonSet
 * @param daemonSet name of the DaemonSet
 * @return OK
 */
export function setHandleGetDaemonSetEventsData(queryClient: QueryClient, updater: (data: Types.EventList | undefined) => Types.EventList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, daemonSet: string) {
  queryClient.setQueryData(handleGetDaemonSetEventsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, daemonSet),
    updater
  );
}

/**
 * returns a list of Events for DaemonSet
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the DaemonSet
 * @param daemonSet name of the DaemonSet
 * @return OK
 */
export function setHandleGetDaemonSetEventsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.EventList | undefined) => Types.EventList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetDaemonSetPodsUrl(namespace: string, daemonSet: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/daemonset/{namespace}/{daemonSet}/pod?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (daemonSet === undefined || daemonSet === null)
  throw new Error("The parameter 'daemonSet' must be defined.");
url_ = url_.replace("{daemonSet}", encodeURIComponent("" + daemonSet));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetDaemonSetPodsDefaultOptions: Omit<UseQueryOptions<Types.PodList, unknown, Types.PodList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PodList, unknown, Types.PodList>, 'queryFn'>> = {
};
export function getHandleGetDaemonSetPodsDefaultOptions() {
  return handleGetDaemonSetPodsDefaultOptions;
};
export function setHandleGetDaemonSetPodsDefaultOptions(options: typeof handleGetDaemonSetPodsDefaultOptions) {
  handleGetDaemonSetPodsDefaultOptions = options;
}

export function handleGetDaemonSetPodsQueryKey(dto: HandleGetDaemonSetPodsQueryParameters): QueryKey;
export function handleGetDaemonSetPodsQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, daemonSet: string): QueryKey;
export function handleGetDaemonSetPodsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, daemonSet,  } = params[0] as HandleGetDaemonSetPodsQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetDaemonSetPods',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        daemonSet as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetDaemonSetPods',
        ...params
      ]);
  }
}
export function __handleGetDaemonSetPods(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetDaemonSetPods(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetDaemonSetPodsQuery<TSelectData = Types.PodList, TError = unknown>(dto: HandleGetDaemonSetPodsQueryParameters, options?: Omit<UseQueryOptions<Types.PodList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Pods for DaemonSet
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the DaemonSet
 * @param daemonSet name of the DaemonSet
 * @return OK
 */
export function useHandleGetDaemonSetPodsQuery<TSelectData = Types.PodList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, daemonSet: string, options?: Omit<UseQueryOptions<Types.PodList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetDaemonSetPodsQuery<TSelectData = Types.PodList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PodList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let daemonSet: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, daemonSet,  } = params[0] as HandleGetDaemonSetPodsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, daemonSet, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PodList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetDaemonSetPods(context, axiosConfig) : __handleGetDaemonSetPods,
    queryKey: handleGetDaemonSetPodsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, daemonSet),
    ...handleGetDaemonSetPodsDefaultOptions as unknown as Omit<UseQueryOptions<Types.PodList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Pods for DaemonSet
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the DaemonSet
 * @param daemonSet name of the DaemonSet
 * @return OK
 */
export function setHandleGetDaemonSetPodsData(queryClient: QueryClient, updater: (data: Types.PodList | undefined) => Types.PodList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, daemonSet: string) {
  queryClient.setQueryData(handleGetDaemonSetPodsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, daemonSet),
    updater
  );
}

/**
 * returns a list of Pods for DaemonSet
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the DaemonSet
 * @param daemonSet name of the DaemonSet
 * @return OK
 */
export function setHandleGetDaemonSetPodsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PodList | undefined) => Types.PodList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleDaemonSetRestartUrl(namespace: string, daemonSet: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/daemonset/{namespace}/{daemonSet}/restart?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (daemonSet === undefined || daemonSet === null)
  throw new Error("The parameter 'daemonSet' must be defined.");
url_ = url_.replace("{daemonSet}", encodeURIComponent("" + daemonSet));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function handleDaemonSetRestartMutationKey(namespace: string, daemonSet: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'handleDaemonSetRestart',
      namespace as any,
      daemonSet as any,
      filterBy as any,
      sortBy as any,
      itemsPerPage as any,
      page as any,
      metricNames as any,
      aggregations as any,
    ]);
}

/**
 * rollout restart of the Daemon Set
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Daemon Set
 * @param daemonSet name of the Daemon Set
 * @return OK
 */
export function useHandleDaemonSetRestartMutation<TContext>(namespace: string, daemonSet: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseMutationOptions<Types.DaemonSetDetail, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DaemonSetDetail, unknown, void, TContext> {
  const key = handleDaemonSetRestartMutationKey(namespace, daemonSet, filterBy, sortBy, itemsPerPage, page, metricNames, aggregations);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client().handleDaemonSetRestart(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, daemonSet),
    mutationKey: key,
  });
}
  
type HandleDaemonSetRestart__MutationParameters = HandleDaemonSetRestartQueryParameters

/**
 * rollout restart of the Daemon Set
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Daemon Set
 * @param daemonSet name of the Daemon Set
 * @return OK
 */
export function useHandleDaemonSetRestartMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.DaemonSetDetail, unknown, HandleDaemonSetRestart__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: HandleDaemonSetRestartQueryParameters}): UseMutationResult<Types.DaemonSetDetail, unknown, HandleDaemonSetRestart__MutationParameters, TContext> {
  const key = handleDaemonSetRestartMutationKey(options?.parameters?.namespace!, options?.parameters?.daemonSet!, options?.parameters?.filterBy!, options?.parameters?.sortBy!, options?.parameters?.itemsPerPage!, options?.parameters?.page!, options?.parameters?.metricNames!, options?.parameters?.aggregations!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: HandleDaemonSetRestart__MutationParameters) => Client().handleDaemonSetRestart(data.filterBy ?? options?.parameters?.filterBy!, data.sortBy ?? options?.parameters?.sortBy!, data.itemsPerPage ?? options?.parameters?.itemsPerPage!, data.page ?? options?.parameters?.page!, data.metricNames ?? options?.parameters?.metricNames!, data.aggregations ?? options?.parameters?.aggregations!, data.namespace ?? options?.parameters?.namespace!, data.daemonSet ?? options?.parameters?.daemonSet!),
  mutationKey: key,
});
}
  
export function handleGetDaemonSetServicesUrl(namespace: string, daemonSet: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/daemonset/{namespace}/{daemonSet}/service?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (daemonSet === undefined || daemonSet === null)
  throw new Error("The parameter 'daemonSet' must be defined.");
url_ = url_.replace("{daemonSet}", encodeURIComponent("" + daemonSet));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetDaemonSetServicesDefaultOptions: Omit<UseQueryOptions<Types.ServiceList, unknown, Types.ServiceList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ServiceList, unknown, Types.ServiceList>, 'queryFn'>> = {
};
export function getHandleGetDaemonSetServicesDefaultOptions() {
  return handleGetDaemonSetServicesDefaultOptions;
};
export function setHandleGetDaemonSetServicesDefaultOptions(options: typeof handleGetDaemonSetServicesDefaultOptions) {
  handleGetDaemonSetServicesDefaultOptions = options;
}

export function handleGetDaemonSetServicesQueryKey(dto: HandleGetDaemonSetServicesQueryParameters): QueryKey;
export function handleGetDaemonSetServicesQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, daemonSet: string): QueryKey;
export function handleGetDaemonSetServicesQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, daemonSet,  } = params[0] as HandleGetDaemonSetServicesQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetDaemonSetServices',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        daemonSet as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetDaemonSetServices',
        ...params
      ]);
  }
}
export function __handleGetDaemonSetServices(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetDaemonSetServices(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetDaemonSetServicesQuery<TSelectData = Types.ServiceList, TError = unknown>(dto: HandleGetDaemonSetServicesQueryParameters, options?: Omit<UseQueryOptions<Types.ServiceList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Services for DaemonSet
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the DaemonSet
 * @param daemonSet name of the DaemonSet
 * @return OK
 */
export function useHandleGetDaemonSetServicesQuery<TSelectData = Types.ServiceList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, daemonSet: string, options?: Omit<UseQueryOptions<Types.ServiceList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetDaemonSetServicesQuery<TSelectData = Types.ServiceList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ServiceList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let daemonSet: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, daemonSet,  } = params[0] as HandleGetDaemonSetServicesQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, daemonSet, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ServiceList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetDaemonSetServices(context, axiosConfig) : __handleGetDaemonSetServices,
    queryKey: handleGetDaemonSetServicesQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, daemonSet),
    ...handleGetDaemonSetServicesDefaultOptions as unknown as Omit<UseQueryOptions<Types.ServiceList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Services for DaemonSet
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the DaemonSet
 * @param daemonSet name of the DaemonSet
 * @return OK
 */
export function setHandleGetDaemonSetServicesData(queryClient: QueryClient, updater: (data: Types.ServiceList | undefined) => Types.ServiceList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, daemonSet: string) {
  queryClient.setQueryData(handleGetDaemonSetServicesQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, daemonSet),
    updater
  );
}

/**
 * returns a list of Services for DaemonSet
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the DaemonSet
 * @param daemonSet name of the DaemonSet
 * @return OK
 */
export function setHandleGetDaemonSetServicesDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ServiceList | undefined) => Types.ServiceList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetDeploymentsUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/deployment?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetDeploymentsDefaultOptions: Omit<UseQueryOptions<Types.DeploymentList, unknown, Types.DeploymentList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.DeploymentList, unknown, Types.DeploymentList>, 'queryFn'>> = {
};
export function getHandleGetDeploymentsDefaultOptions() {
  return handleGetDeploymentsDefaultOptions;
};
export function setHandleGetDeploymentsDefaultOptions(options: typeof handleGetDeploymentsDefaultOptions) {
  handleGetDeploymentsDefaultOptions = options;
}

export function handleGetDeploymentsQueryKey(dto: HandleGetDeploymentsQueryParameters): QueryKey;
export function handleGetDeploymentsQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): QueryKey;
export function handleGetDeploymentsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetDeploymentsQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetDeployments',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetDeployments',
        ...params
      ]);
  }
}
export function __handleGetDeployments(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetDeployments(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined);
}

export function useHandleGetDeploymentsQuery<TSelectData = Types.DeploymentList, TError = unknown>(dto: HandleGetDeploymentsQueryParameters, options?: Omit<UseQueryOptions<Types.DeploymentList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Deployments from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleGetDeploymentsQuery<TSelectData = Types.DeploymentList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseQueryOptions<Types.DeploymentList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetDeploymentsQuery<TSelectData = Types.DeploymentList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.DeploymentList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetDeploymentsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.DeploymentList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetDeployments(context, axiosConfig) : __handleGetDeployments,
    queryKey: handleGetDeploymentsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    ...handleGetDeploymentsDefaultOptions as unknown as Omit<UseQueryOptions<Types.DeploymentList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Deployments from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetDeploymentsData(queryClient: QueryClient, updater: (data: Types.DeploymentList | undefined) => Types.DeploymentList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined) {
  queryClient.setQueryData(handleGetDeploymentsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    updater
  );
}

/**
 * returns a list of Deployments from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetDeploymentsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.DeploymentList | undefined) => Types.DeploymentList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetDeployments2Url(namespace: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/deployment/{namespace}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetDeployments2DefaultOptions: Omit<UseQueryOptions<Types.DeploymentList, unknown, Types.DeploymentList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.DeploymentList, unknown, Types.DeploymentList>, 'queryFn'>> = {
};
export function getHandleGetDeployments2DefaultOptions() {
  return handleGetDeployments2DefaultOptions;
};
export function setHandleGetDeployments2DefaultOptions(options: typeof handleGetDeployments2DefaultOptions) {
  handleGetDeployments2DefaultOptions = options;
}

export function handleGetDeployments2QueryKey(dto: HandleGetDeployments2QueryParameters): QueryKey;
export function handleGetDeployments2QueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string): QueryKey;
export function handleGetDeployments2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetDeployments2QueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetDeployments2',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetDeployments2',
        ...params
      ]);
  }
}
export function __handleGetDeployments2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetDeployments2(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetDeployments2Query<TSelectData = Types.DeploymentList, TError = unknown>(dto: HandleGetDeployments2QueryParameters, options?: Omit<UseQueryOptions<Types.DeploymentList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Deployments in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Deployment
 * @return OK
 */
export function useHandleGetDeployments2Query<TSelectData = Types.DeploymentList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, options?: Omit<UseQueryOptions<Types.DeploymentList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetDeployments2Query<TSelectData = Types.DeploymentList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.DeploymentList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetDeployments2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.DeploymentList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetDeployments2(context, axiosConfig) : __handleGetDeployments2,
    queryKey: handleGetDeployments2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    ...handleGetDeployments2DefaultOptions as unknown as Omit<UseQueryOptions<Types.DeploymentList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Deployments in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Deployment
 * @return OK
 */
export function setHandleGetDeployments2Data(queryClient: QueryClient, updater: (data: Types.DeploymentList | undefined) => Types.DeploymentList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string) {
  queryClient.setQueryData(handleGetDeployments2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    updater
  );
}

/**
 * returns a list of Deployments in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Deployment
 * @return OK
 */
export function setHandleGetDeployments2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.DeploymentList | undefined) => Types.DeploymentList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetDeploymentDetailUrl(namespace: string, deployment: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/deployment/{namespace}/{deployment}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (deployment === undefined || deployment === null)
  throw new Error("The parameter 'deployment' must be defined.");
url_ = url_.replace("{deployment}", encodeURIComponent("" + deployment));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetDeploymentDetailDefaultOptions: Omit<UseQueryOptions<Types.DeploymentDetail, unknown, Types.DeploymentDetail>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.DeploymentDetail, unknown, Types.DeploymentDetail>, 'queryFn'>> = {
};
export function getHandleGetDeploymentDetailDefaultOptions() {
  return handleGetDeploymentDetailDefaultOptions;
};
export function setHandleGetDeploymentDetailDefaultOptions(options: typeof handleGetDeploymentDetailDefaultOptions) {
  handleGetDeploymentDetailDefaultOptions = options;
}

export function handleGetDeploymentDetailQueryKey(dto: HandleGetDeploymentDetailQueryParameters): QueryKey;
export function handleGetDeploymentDetailQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, deployment: string): QueryKey;
export function handleGetDeploymentDetailQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, deployment,  } = params[0] as HandleGetDeploymentDetailQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetDeploymentDetail',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        deployment as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetDeploymentDetail',
        ...params
      ]);
  }
}
export function __handleGetDeploymentDetail(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetDeploymentDetail(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetDeploymentDetailQuery<TSelectData = Types.DeploymentDetail, TError = unknown>(dto: HandleGetDeploymentDetailQueryParameters, options?: Omit<UseQueryOptions<Types.DeploymentDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns detailed information about Deployment
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Deployment
 * @param deployment name of the Deployment
 * @return OK
 */
export function useHandleGetDeploymentDetailQuery<TSelectData = Types.DeploymentDetail, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, deployment: string, options?: Omit<UseQueryOptions<Types.DeploymentDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetDeploymentDetailQuery<TSelectData = Types.DeploymentDetail, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.DeploymentDetail, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let deployment: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, deployment,  } = params[0] as HandleGetDeploymentDetailQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, deployment, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.DeploymentDetail, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetDeploymentDetail(context, axiosConfig) : __handleGetDeploymentDetail,
    queryKey: handleGetDeploymentDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, deployment),
    ...handleGetDeploymentDetailDefaultOptions as unknown as Omit<UseQueryOptions<Types.DeploymentDetail, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns detailed information about Deployment
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Deployment
 * @param deployment name of the Deployment
 * @return OK
 */
export function setHandleGetDeploymentDetailData(queryClient: QueryClient, updater: (data: Types.DeploymentDetail | undefined) => Types.DeploymentDetail, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, deployment: string) {
  queryClient.setQueryData(handleGetDeploymentDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, deployment),
    updater
  );
}

/**
 * returns detailed information about Deployment
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Deployment
 * @param deployment name of the Deployment
 * @return OK
 */
export function setHandleGetDeploymentDetailDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.DeploymentDetail | undefined) => Types.DeploymentDetail) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetDeploymentEventsUrl(namespace: string, deployment: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/deployment/{namespace}/{deployment}/event?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (deployment === undefined || deployment === null)
  throw new Error("The parameter 'deployment' must be defined.");
url_ = url_.replace("{deployment}", encodeURIComponent("" + deployment));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetDeploymentEventsDefaultOptions: Omit<UseQueryOptions<Types.EventList, unknown, Types.EventList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.EventList, unknown, Types.EventList>, 'queryFn'>> = {
};
export function getHandleGetDeploymentEventsDefaultOptions() {
  return handleGetDeploymentEventsDefaultOptions;
};
export function setHandleGetDeploymentEventsDefaultOptions(options: typeof handleGetDeploymentEventsDefaultOptions) {
  handleGetDeploymentEventsDefaultOptions = options;
}

export function handleGetDeploymentEventsQueryKey(dto: HandleGetDeploymentEventsQueryParameters): QueryKey;
export function handleGetDeploymentEventsQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, deployment: string): QueryKey;
export function handleGetDeploymentEventsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, deployment,  } = params[0] as HandleGetDeploymentEventsQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetDeploymentEvents',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        deployment as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetDeploymentEvents',
        ...params
      ]);
  }
}
export function __handleGetDeploymentEvents(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetDeploymentEvents(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetDeploymentEventsQuery<TSelectData = Types.EventList, TError = unknown>(dto: HandleGetDeploymentEventsQueryParameters, options?: Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Events for Deployment
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Deployment
 * @param deployment name of the Deployment
 * @return OK
 */
export function useHandleGetDeploymentEventsQuery<TSelectData = Types.EventList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, deployment: string, options?: Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetDeploymentEventsQuery<TSelectData = Types.EventList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.EventList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let deployment: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, deployment,  } = params[0] as HandleGetDeploymentEventsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, deployment, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.EventList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetDeploymentEvents(context, axiosConfig) : __handleGetDeploymentEvents,
    queryKey: handleGetDeploymentEventsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, deployment),
    ...handleGetDeploymentEventsDefaultOptions as unknown as Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Events for Deployment
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Deployment
 * @param deployment name of the Deployment
 * @return OK
 */
export function setHandleGetDeploymentEventsData(queryClient: QueryClient, updater: (data: Types.EventList | undefined) => Types.EventList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, deployment: string) {
  queryClient.setQueryData(handleGetDeploymentEventsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, deployment),
    updater
  );
}

/**
 * returns a list of Events for Deployment
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Deployment
 * @param deployment name of the Deployment
 * @return OK
 */
export function setHandleGetDeploymentEventsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.EventList | undefined) => Types.EventList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetDeploymentNewReplicaSetUrl(namespace: string, deployment: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/deployment/{namespace}/{deployment}/newreplicaset?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (deployment === undefined || deployment === null)
  throw new Error("The parameter 'deployment' must be defined.");
url_ = url_.replace("{deployment}", encodeURIComponent("" + deployment));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetDeploymentNewReplicaSetDefaultOptions: Omit<UseQueryOptions<Types.ReplicaSet, unknown, Types.ReplicaSet>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ReplicaSet, unknown, Types.ReplicaSet>, 'queryFn'>> = {
};
export function getHandleGetDeploymentNewReplicaSetDefaultOptions() {
  return handleGetDeploymentNewReplicaSetDefaultOptions;
};
export function setHandleGetDeploymentNewReplicaSetDefaultOptions(options: typeof handleGetDeploymentNewReplicaSetDefaultOptions) {
  handleGetDeploymentNewReplicaSetDefaultOptions = options;
}

export function handleGetDeploymentNewReplicaSetQueryKey(dto: HandleGetDeploymentNewReplicaSetQueryParameters): QueryKey;
export function handleGetDeploymentNewReplicaSetQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, deployment: string): QueryKey;
export function handleGetDeploymentNewReplicaSetQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, deployment,  } = params[0] as HandleGetDeploymentNewReplicaSetQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetDeploymentNewReplicaSet',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        deployment as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetDeploymentNewReplicaSet',
        ...params
      ]);
  }
}
export function __handleGetDeploymentNewReplicaSet(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetDeploymentNewReplicaSet(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetDeploymentNewReplicaSetQuery<TSelectData = Types.ReplicaSet, TError = unknown>(dto: HandleGetDeploymentNewReplicaSetQueryParameters, options?: Omit<UseQueryOptions<Types.ReplicaSet, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of new ReplicaSets for Deployment
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Deployment
 * @param deployment name of the Deployment
 * @return OK
 */
export function useHandleGetDeploymentNewReplicaSetQuery<TSelectData = Types.ReplicaSet, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, deployment: string, options?: Omit<UseQueryOptions<Types.ReplicaSet, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetDeploymentNewReplicaSetQuery<TSelectData = Types.ReplicaSet, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ReplicaSet, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let deployment: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, deployment,  } = params[0] as HandleGetDeploymentNewReplicaSetQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, deployment, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ReplicaSet, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetDeploymentNewReplicaSet(context, axiosConfig) : __handleGetDeploymentNewReplicaSet,
    queryKey: handleGetDeploymentNewReplicaSetQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, deployment),
    ...handleGetDeploymentNewReplicaSetDefaultOptions as unknown as Omit<UseQueryOptions<Types.ReplicaSet, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of new ReplicaSets for Deployment
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Deployment
 * @param deployment name of the Deployment
 * @return OK
 */
export function setHandleGetDeploymentNewReplicaSetData(queryClient: QueryClient, updater: (data: Types.ReplicaSet | undefined) => Types.ReplicaSet, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, deployment: string) {
  queryClient.setQueryData(handleGetDeploymentNewReplicaSetQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, deployment),
    updater
  );
}

/**
 * returns a list of new ReplicaSets for Deployment
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Deployment
 * @param deployment name of the Deployment
 * @return OK
 */
export function setHandleGetDeploymentNewReplicaSetDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ReplicaSet | undefined) => Types.ReplicaSet) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetDeploymentOldReplicaSetsUrl(namespace: string, deployment: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/deployment/{namespace}/{deployment}/oldreplicaset?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (deployment === undefined || deployment === null)
  throw new Error("The parameter 'deployment' must be defined.");
url_ = url_.replace("{deployment}", encodeURIComponent("" + deployment));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetDeploymentOldReplicaSetsDefaultOptions: Omit<UseQueryOptions<Types.ReplicaSetList, unknown, Types.ReplicaSetList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ReplicaSetList, unknown, Types.ReplicaSetList>, 'queryFn'>> = {
};
export function getHandleGetDeploymentOldReplicaSetsDefaultOptions() {
  return handleGetDeploymentOldReplicaSetsDefaultOptions;
};
export function setHandleGetDeploymentOldReplicaSetsDefaultOptions(options: typeof handleGetDeploymentOldReplicaSetsDefaultOptions) {
  handleGetDeploymentOldReplicaSetsDefaultOptions = options;
}

export function handleGetDeploymentOldReplicaSetsQueryKey(dto: HandleGetDeploymentOldReplicaSetsQueryParameters): QueryKey;
export function handleGetDeploymentOldReplicaSetsQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, deployment: string): QueryKey;
export function handleGetDeploymentOldReplicaSetsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, deployment,  } = params[0] as HandleGetDeploymentOldReplicaSetsQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetDeploymentOldReplicaSets',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        deployment as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetDeploymentOldReplicaSets',
        ...params
      ]);
  }
}
export function __handleGetDeploymentOldReplicaSets(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetDeploymentOldReplicaSets(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetDeploymentOldReplicaSetsQuery<TSelectData = Types.ReplicaSetList, TError = unknown>(dto: HandleGetDeploymentOldReplicaSetsQueryParameters, options?: Omit<UseQueryOptions<Types.ReplicaSetList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of old ReplicaSets for Deployment
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Deployment
 * @param deployment name of the Deployment
 * @return OK
 */
export function useHandleGetDeploymentOldReplicaSetsQuery<TSelectData = Types.ReplicaSetList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, deployment: string, options?: Omit<UseQueryOptions<Types.ReplicaSetList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetDeploymentOldReplicaSetsQuery<TSelectData = Types.ReplicaSetList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ReplicaSetList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let deployment: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, deployment,  } = params[0] as HandleGetDeploymentOldReplicaSetsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, deployment, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ReplicaSetList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetDeploymentOldReplicaSets(context, axiosConfig) : __handleGetDeploymentOldReplicaSets,
    queryKey: handleGetDeploymentOldReplicaSetsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, deployment),
    ...handleGetDeploymentOldReplicaSetsDefaultOptions as unknown as Omit<UseQueryOptions<Types.ReplicaSetList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of old ReplicaSets for Deployment
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Deployment
 * @param deployment name of the Deployment
 * @return OK
 */
export function setHandleGetDeploymentOldReplicaSetsData(queryClient: QueryClient, updater: (data: Types.ReplicaSetList | undefined) => Types.ReplicaSetList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, deployment: string) {
  queryClient.setQueryData(handleGetDeploymentOldReplicaSetsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, deployment),
    updater
  );
}

/**
 * returns a list of old ReplicaSets for Deployment
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Deployment
 * @param deployment name of the Deployment
 * @return OK
 */
export function setHandleGetDeploymentOldReplicaSetsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ReplicaSetList | undefined) => Types.ReplicaSetList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleDeploymentPauseUrl(namespace: string, deployment: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/deployment/{namespace}/{deployment}/pause?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (deployment === undefined || deployment === null)
  throw new Error("The parameter 'deployment' must be defined.");
url_ = url_.replace("{deployment}", encodeURIComponent("" + deployment));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function handleDeploymentPauseMutationKey(namespace: string, deployment: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'handleDeploymentPause',
      namespace as any,
      deployment as any,
      filterBy as any,
      sortBy as any,
      itemsPerPage as any,
      page as any,
      metricNames as any,
      aggregations as any,
    ]);
}

/**
 * pauses the Deployment
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Deployment
 * @param deployment name of the Deployment
 * @return OK
 */
export function useHandleDeploymentPauseMutation<TContext>(namespace: string, deployment: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseMutationOptions<Types.DeploymentDetail, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DeploymentDetail, unknown, void, TContext> {
  const key = handleDeploymentPauseMutationKey(namespace, deployment, filterBy, sortBy, itemsPerPage, page, metricNames, aggregations);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client().handleDeploymentPause(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, deployment),
    mutationKey: key,
  });
}
  
type HandleDeploymentPause__MutationParameters = HandleDeploymentPauseQueryParameters

/**
 * pauses the Deployment
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Deployment
 * @param deployment name of the Deployment
 * @return OK
 */
export function useHandleDeploymentPauseMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.DeploymentDetail, unknown, HandleDeploymentPause__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: HandleDeploymentPauseQueryParameters}): UseMutationResult<Types.DeploymentDetail, unknown, HandleDeploymentPause__MutationParameters, TContext> {
  const key = handleDeploymentPauseMutationKey(options?.parameters?.namespace!, options?.parameters?.deployment!, options?.parameters?.filterBy!, options?.parameters?.sortBy!, options?.parameters?.itemsPerPage!, options?.parameters?.page!, options?.parameters?.metricNames!, options?.parameters?.aggregations!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: HandleDeploymentPause__MutationParameters) => Client().handleDeploymentPause(data.filterBy ?? options?.parameters?.filterBy!, data.sortBy ?? options?.parameters?.sortBy!, data.itemsPerPage ?? options?.parameters?.itemsPerPage!, data.page ?? options?.parameters?.page!, data.metricNames ?? options?.parameters?.metricNames!, data.aggregations ?? options?.parameters?.aggregations!, data.namespace ?? options?.parameters?.namespace!, data.deployment ?? options?.parameters?.deployment!),
  mutationKey: key,
});
}
  
export function handleDeploymentRestartUrl(namespace: string, deployment: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/deployment/{namespace}/{deployment}/restart?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (deployment === undefined || deployment === null)
  throw new Error("The parameter 'deployment' must be defined.");
url_ = url_.replace("{deployment}", encodeURIComponent("" + deployment));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function handleDeploymentRestartMutationKey(namespace: string, deployment: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'handleDeploymentRestart',
      namespace as any,
      deployment as any,
      filterBy as any,
      sortBy as any,
      itemsPerPage as any,
      page as any,
      metricNames as any,
      aggregations as any,
    ]);
}

/**
 * rollout restart of the Deployment
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Deployment
 * @param deployment name of the Deployment
 * @return OK
 */
export function useHandleDeploymentRestartMutation<TContext>(namespace: string, deployment: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseMutationOptions<Types.RolloutSpec, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.RolloutSpec, unknown, void, TContext> {
  const key = handleDeploymentRestartMutationKey(namespace, deployment, filterBy, sortBy, itemsPerPage, page, metricNames, aggregations);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client().handleDeploymentRestart(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, deployment),
    mutationKey: key,
  });
}
  
type HandleDeploymentRestart__MutationParameters = HandleDeploymentRestartQueryParameters

/**
 * rollout restart of the Deployment
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Deployment
 * @param deployment name of the Deployment
 * @return OK
 */
export function useHandleDeploymentRestartMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.RolloutSpec, unknown, HandleDeploymentRestart__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: HandleDeploymentRestartQueryParameters}): UseMutationResult<Types.RolloutSpec, unknown, HandleDeploymentRestart__MutationParameters, TContext> {
  const key = handleDeploymentRestartMutationKey(options?.parameters?.namespace!, options?.parameters?.deployment!, options?.parameters?.filterBy!, options?.parameters?.sortBy!, options?.parameters?.itemsPerPage!, options?.parameters?.page!, options?.parameters?.metricNames!, options?.parameters?.aggregations!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: HandleDeploymentRestart__MutationParameters) => Client().handleDeploymentRestart(data.filterBy ?? options?.parameters?.filterBy!, data.sortBy ?? options?.parameters?.sortBy!, data.itemsPerPage ?? options?.parameters?.itemsPerPage!, data.page ?? options?.parameters?.page!, data.metricNames ?? options?.parameters?.metricNames!, data.aggregations ?? options?.parameters?.aggregations!, data.namespace ?? options?.parameters?.namespace!, data.deployment ?? options?.parameters?.deployment!),
  mutationKey: key,
});
}
  
export function handleDeploymentResumeUrl(namespace: string, deployment: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/deployment/{namespace}/{deployment}/resume?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (deployment === undefined || deployment === null)
  throw new Error("The parameter 'deployment' must be defined.");
url_ = url_.replace("{deployment}", encodeURIComponent("" + deployment));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function handleDeploymentResumeMutationKey(namespace: string, deployment: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'handleDeploymentResume',
      namespace as any,
      deployment as any,
      filterBy as any,
      sortBy as any,
      itemsPerPage as any,
      page as any,
      metricNames as any,
      aggregations as any,
    ]);
}

/**
 * resumes the Deployment
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Deployment
 * @param deployment name of the Deployment
 * @return OK
 */
export function useHandleDeploymentResumeMutation<TContext>(namespace: string, deployment: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseMutationOptions<Types.DeploymentDetail, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DeploymentDetail, unknown, void, TContext> {
  const key = handleDeploymentResumeMutationKey(namespace, deployment, filterBy, sortBy, itemsPerPage, page, metricNames, aggregations);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client().handleDeploymentResume(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, deployment),
    mutationKey: key,
  });
}
  
type HandleDeploymentResume__MutationParameters = HandleDeploymentResumeQueryParameters

/**
 * resumes the Deployment
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Deployment
 * @param deployment name of the Deployment
 * @return OK
 */
export function useHandleDeploymentResumeMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.DeploymentDetail, unknown, HandleDeploymentResume__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: HandleDeploymentResumeQueryParameters}): UseMutationResult<Types.DeploymentDetail, unknown, HandleDeploymentResume__MutationParameters, TContext> {
  const key = handleDeploymentResumeMutationKey(options?.parameters?.namespace!, options?.parameters?.deployment!, options?.parameters?.filterBy!, options?.parameters?.sortBy!, options?.parameters?.itemsPerPage!, options?.parameters?.page!, options?.parameters?.metricNames!, options?.parameters?.aggregations!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: HandleDeploymentResume__MutationParameters) => Client().handleDeploymentResume(data.filterBy ?? options?.parameters?.filterBy!, data.sortBy ?? options?.parameters?.sortBy!, data.itemsPerPage ?? options?.parameters?.itemsPerPage!, data.page ?? options?.parameters?.page!, data.metricNames ?? options?.parameters?.metricNames!, data.aggregations ?? options?.parameters?.aggregations!, data.namespace ?? options?.parameters?.namespace!, data.deployment ?? options?.parameters?.deployment!),
  mutationKey: key,
});
}
  
export function handleDeploymentRollbackUrl(namespace: string, deployment: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/deployment/{namespace}/{deployment}/rollback?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (deployment === undefined || deployment === null)
  throw new Error("The parameter 'deployment' must be defined.");
url_ = url_.replace("{deployment}", encodeURIComponent("" + deployment));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function handleDeploymentRollbackMutationKey(namespace: string, deployment: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'handleDeploymentRollback',
      namespace as any,
      deployment as any,
      filterBy as any,
      sortBy as any,
      itemsPerPage as any,
      page as any,
      metricNames as any,
      aggregations as any,
    ]);
}

/**
 * rolls back the Deployment to the target revision
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Deployment
 * @param deployment name of the Deployment
 * @return OK
 */
export function useHandleDeploymentRollbackMutation<TContext>(namespace: string, deployment: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseMutationOptions<Types.RolloutSpec, unknown, Types.RolloutSpec, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.RolloutSpec, unknown, Types.RolloutSpec, TContext> {
  const key = handleDeploymentRollbackMutationKey(namespace, deployment, filterBy, sortBy, itemsPerPage, page, metricNames, aggregations);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.RolloutSpec) => Client().handleDeploymentRollback(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, deployment, body),
    mutationKey: key,
  });
}
  
type HandleDeploymentRollback__MutationParameters = HandleDeploymentRollbackQueryParameters & {
  body: Types.RolloutSpec;
}

/**
 * rolls back the Deployment to the target revision
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Deployment
 * @param deployment name of the Deployment
 * @return OK
 */
export function useHandleDeploymentRollbackMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.RolloutSpec, unknown, HandleDeploymentRollback__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: HandleDeploymentRollbackQueryParameters}): UseMutationResult<Types.RolloutSpec, unknown, HandleDeploymentRollback__MutationParameters, TContext> {
  const key = handleDeploymentRollbackMutationKey(options?.parameters?.namespace!, options?.parameters?.deployment!, options?.parameters?.filterBy!, options?.parameters?.sortBy!, options?.parameters?.itemsPerPage!, options?.parameters?.page!, options?.parameters?.metricNames!, options?.parameters?.aggregations!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: HandleDeploymentRollback__MutationParameters) => Client().handleDeploymentRollback(data.filterBy ?? options?.parameters?.filterBy!, data.sortBy ?? options?.parameters?.sortBy!, data.itemsPerPage ?? options?.parameters?.itemsPerPage!, data.page ?? options?.parameters?.page!, data.metricNames ?? options?.parameters?.metricNames!, data.aggregations ?? options?.parameters?.aggregations!, data.namespace ?? options?.parameters?.namespace!, data.deployment ?? options?.parameters?.deployment!, data.body),
  mutationKey: key,
});
}
  
export function handleGetEventListUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/event?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetEventListDefaultOptions: Omit<UseQueryOptions<Types.EventList, unknown, Types.EventList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.EventList, unknown, Types.EventList>, 'queryFn'>> = {
};
export function getHandleGetEventListDefaultOptions() {
  return handleGetEventListDefaultOptions;
};
export function setHandleGetEventListDefaultOptions(options: typeof handleGetEventListDefaultOptions) {
  handleGetEventListDefaultOptions = options;
}

export function handleGetEventListQueryKey(dto: HandleGetEventListQueryParameters): QueryKey;
export function handleGetEventListQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): QueryKey;
export function handleGetEventListQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetEventListQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetEventList',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetEventList',
        ...params
      ]);
  }
}
export function __handleGetEventList(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetEventList(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined);
}

export function useHandleGetEventListQuery<TSelectData = Types.EventList, TError = unknown>(dto: HandleGetEventListQueryParameters, options?: Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Events from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleGetEventListQuery<TSelectData = Types.EventList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetEventListQuery<TSelectData = Types.EventList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.EventList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetEventListQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.EventList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetEventList(context, axiosConfig) : __handleGetEventList,
    queryKey: handleGetEventListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    ...handleGetEventListDefaultOptions as unknown as Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Events from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetEventListData(queryClient: QueryClient, updater: (data: Types.EventList | undefined) => Types.EventList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined) {
  queryClient.setQueryData(handleGetEventListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    updater
  );
}

/**
 * returns a list of Events from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetEventListDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.EventList | undefined) => Types.EventList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetEventList2Url(namespace: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/event/{namespace}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetEventList2DefaultOptions: Omit<UseQueryOptions<Types.EventList, unknown, Types.EventList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.EventList, unknown, Types.EventList>, 'queryFn'>> = {
};
export function getHandleGetEventList2DefaultOptions() {
  return handleGetEventList2DefaultOptions;
};
export function setHandleGetEventList2DefaultOptions(options: typeof handleGetEventList2DefaultOptions) {
  handleGetEventList2DefaultOptions = options;
}

export function handleGetEventList2QueryKey(dto: HandleGetEventList2QueryParameters): QueryKey;
export function handleGetEventList2QueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string): QueryKey;
export function handleGetEventList2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetEventList2QueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetEventList2',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetEventList2',
        ...params
      ]);
  }
}
export function __handleGetEventList2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetEventList2(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetEventList2Query<TSelectData = Types.EventList, TError = unknown>(dto: HandleGetEventList2QueryParameters, options?: Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Events in a namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace to get Events from
 * @return OK
 */
export function useHandleGetEventList2Query<TSelectData = Types.EventList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, options?: Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetEventList2Query<TSelectData = Types.EventList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.EventList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetEventList2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.EventList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetEventList2(context, axiosConfig) : __handleGetEventList2,
    queryKey: handleGetEventList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    ...handleGetEventList2DefaultOptions as unknown as Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Events in a namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace to get Events from
 * @return OK
 */
export function setHandleGetEventList2Data(queryClient: QueryClient, updater: (data: Types.EventList | undefined) => Types.EventList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string) {
  queryClient.setQueryData(handleGetEventList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    updater
  );
}

/**
 * returns a list of Events in a namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace to get Events from
 * @return OK
 */
export function setHandleGetEventList2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.EventList | undefined) => Types.EventList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetHorizontalPodAutoscalerListUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/horizontalpodautoscaler?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetHorizontalPodAutoscalerListDefaultOptions: Omit<UseQueryOptions<Types.HorizontalPodAutoscalerList, unknown, Types.HorizontalPodAutoscalerList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.HorizontalPodAutoscalerList, unknown, Types.HorizontalPodAutoscalerList>, 'queryFn'>> = {
};
export function getHandleGetHorizontalPodAutoscalerListDefaultOptions() {
  return handleGetHorizontalPodAutoscalerListDefaultOptions;
};
export function setHandleGetHorizontalPodAutoscalerListDefaultOptions(options: typeof handleGetHorizontalPodAutoscalerListDefaultOptions) {
  handleGetHorizontalPodAutoscalerListDefaultOptions = options;
}

export function handleGetHorizontalPodAutoscalerListQueryKey(dto: HandleGetHorizontalPodAutoscalerListQueryParameters): QueryKey;
export function handleGetHorizontalPodAutoscalerListQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): QueryKey;
export function handleGetHorizontalPodAutoscalerListQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetHorizontalPodAutoscalerListQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetHorizontalPodAutoscalerList',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetHorizontalPodAutoscalerList',
        ...params
      ]);
  }
}
export function __handleGetHorizontalPodAutoscalerList(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetHorizontalPodAutoscalerList(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined);
}

export function useHandleGetHorizontalPodAutoscalerListQuery<TSelectData = Types.HorizontalPodAutoscalerList, TError = unknown>(dto: HandleGetHorizontalPodAutoscalerListQueryParameters, options?: Omit<UseQueryOptions<Types.HorizontalPodAutoscalerList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of HorizontalPodAutoscalers from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleGetHorizontalPodAutoscalerListQuery<TSelectData = Types.HorizontalPodAutoscalerList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseQueryOptions<Types.HorizontalPodAutoscalerList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetHorizontalPodAutoscalerListQuery<TSelectData = Types.HorizontalPodAutoscalerList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.HorizontalPodAutoscalerList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetHorizontalPodAutoscalerListQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.HorizontalPodAutoscalerList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetHorizontalPodAutoscalerList(context, axiosConfig) : __handleGetHorizontalPodAutoscalerList,
    queryKey: handleGetHorizontalPodAutoscalerListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    ...handleGetHorizontalPodAutoscalerListDefaultOptions as unknown as Omit<UseQueryOptions<Types.HorizontalPodAutoscalerList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of HorizontalPodAutoscalers from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetHorizontalPodAutoscalerListData(queryClient: QueryClient, updater: (data: Types.HorizontalPodAutoscalerList | undefined) => Types.HorizontalPodAutoscalerList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined) {
  queryClient.setQueryData(handleGetHorizontalPodAutoscalerListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    updater
  );
}

/**
 * returns a list of HorizontalPodAutoscalers from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetHorizontalPodAutoscalerListDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.HorizontalPodAutoscalerList | undefined) => Types.HorizontalPodAutoscalerList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetHorizontalPodAutoscalerList2Url(namespace: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/horizontalpodautoscaler/{namespace}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetHorizontalPodAutoscalerList2DefaultOptions: Omit<UseQueryOptions<Types.HorizontalPodAutoscalerList, unknown, Types.HorizontalPodAutoscalerList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.HorizontalPodAutoscalerList, unknown, Types.HorizontalPodAutoscalerList>, 'queryFn'>> = {
};
export function getHandleGetHorizontalPodAutoscalerList2DefaultOptions() {
  return handleGetHorizontalPodAutoscalerList2DefaultOptions;
};
export function setHandleGetHorizontalPodAutoscalerList2DefaultOptions(options: typeof handleGetHorizontalPodAutoscalerList2DefaultOptions) {
  handleGetHorizontalPodAutoscalerList2DefaultOptions = options;
}

export function handleGetHorizontalPodAutoscalerList2QueryKey(dto: HandleGetHorizontalPodAutoscalerList2QueryParameters): QueryKey;
export function handleGetHorizontalPodAutoscalerList2QueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string): QueryKey;
export function handleGetHorizontalPodAutoscalerList2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetHorizontalPodAutoscalerList2QueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetHorizontalPodAutoscalerList2',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetHorizontalPodAutoscalerList2',
        ...params
      ]);
  }
}
export function __handleGetHorizontalPodAutoscalerList2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetHorizontalPodAutoscalerList2(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetHorizontalPodAutoscalerList2Query<TSelectData = Types.HorizontalPodAutoscalerList, TError = unknown>(dto: HandleGetHorizontalPodAutoscalerList2QueryParameters, options?: Omit<UseQueryOptions<Types.HorizontalPodAutoscalerList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of HorizontalPodAutoscalers in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the HorizontalPodAutoscaler
 * @return OK
 */
export function useHandleGetHorizontalPodAutoscalerList2Query<TSelectData = Types.HorizontalPodAutoscalerList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, options?: Omit<UseQueryOptions<Types.HorizontalPodAutoscalerList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetHorizontalPodAutoscalerList2Query<TSelectData = Types.HorizontalPodAutoscalerList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.HorizontalPodAutoscalerList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetHorizontalPodAutoscalerList2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.HorizontalPodAutoscalerList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetHorizontalPodAutoscalerList2(context, axiosConfig) : __handleGetHorizontalPodAutoscalerList2,
    queryKey: handleGetHorizontalPodAutoscalerList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    ...handleGetHorizontalPodAutoscalerList2DefaultOptions as unknown as Omit<UseQueryOptions<Types.HorizontalPodAutoscalerList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of HorizontalPodAutoscalers in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the HorizontalPodAutoscaler
 * @return OK
 */
export function setHandleGetHorizontalPodAutoscalerList2Data(queryClient: QueryClient, updater: (data: Types.HorizontalPodAutoscalerList | undefined) => Types.HorizontalPodAutoscalerList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string) {
  queryClient.setQueryData(handleGetHorizontalPodAutoscalerList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    updater
  );
}

/**
 * returns a list of HorizontalPodAutoscalers in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the HorizontalPodAutoscaler
 * @return OK
 */
export function setHandleGetHorizontalPodAutoscalerList2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.HorizontalPodAutoscalerList | undefined) => Types.HorizontalPodAutoscalerList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetHorizontalPodAutoscalerDetailUrl(namespace: string, horizontalpodautoscaler: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/horizontalpodautoscaler/{namespace}/{horizontalpodautoscaler}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (horizontalpodautoscaler === undefined || horizontalpodautoscaler === null)
  throw new Error("The parameter 'horizontalpodautoscaler' must be defined.");
url_ = url_.replace("{horizontalpodautoscaler}", encodeURIComponent("" + horizontalpodautoscaler));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetHorizontalPodAutoscalerDetailDefaultOptions: Omit<UseQueryOptions<Types.HorizontalPodAutoscalerDetail, unknown, Types.HorizontalPodAutoscalerDetail>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.HorizontalPodAutoscalerDetail, unknown, Types.HorizontalPodAutoscalerDetail>, 'queryFn'>> = {
};
export function getHandleGetHorizontalPodAutoscalerDetailDefaultOptions() {
  return handleGetHorizontalPodAutoscalerDetailDefaultOptions;
};
export function setHandleGetHorizontalPodAutoscalerDetailDefaultOptions(options: typeof handleGetHorizontalPodAutoscalerDetailDefaultOptions) {
  handleGetHorizontalPodAutoscalerDetailDefaultOptions = options;
}

export function handleGetHorizontalPodAutoscalerDetailQueryKey(dto: HandleGetHorizontalPodAutoscalerDetailQueryParameters): QueryKey;
export function handleGetHorizontalPodAutoscalerDetailQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, horizontalpodautoscaler: string): QueryKey;
export function handleGetHorizontalPodAutoscalerDetailQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, horizontalpodautoscaler,  } = params[0] as HandleGetHorizontalPodAutoscalerDetailQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetHorizontalPodAutoscalerDetail',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        horizontalpodautoscaler as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetHorizontalPodAutoscalerDetail',
        ...params
      ]);
  }
}
export function __handleGetHorizontalPodAutoscalerDetail(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetHorizontalPodAutoscalerDetail(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetHorizontalPodAutoscalerDetailQuery<TSelectData = Types.HorizontalPodAutoscalerDetail, TError = unknown>(dto: HandleGetHorizontalPodAutoscalerDetailQueryParameters, options?: Omit<UseQueryOptions<Types.HorizontalPodAutoscalerDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns detailed information about HorizontalPodAutoscaler
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the HorizontalPodAutoscaler
 * @param horizontalpodautoscaler name of the HorizontalPodAutoscaler
 * @return OK
 */
export function useHandleGetHorizontalPodAutoscalerDetailQuery<TSelectData = Types.HorizontalPodAutoscalerDetail, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, horizontalpodautoscaler: string, options?: Omit<UseQueryOptions<Types.HorizontalPodAutoscalerDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetHorizontalPodAutoscalerDetailQuery<TSelectData = Types.HorizontalPodAutoscalerDetail, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.HorizontalPodAutoscalerDetail, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let horizontalpodautoscaler: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, horizontalpodautoscaler,  } = params[0] as HandleGetHorizontalPodAutoscalerDetailQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, horizontalpodautoscaler, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.HorizontalPodAutoscalerDetail, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetHorizontalPodAutoscalerDetail(context, axiosConfig) : __handleGetHorizontalPodAutoscalerDetail,
    queryKey: handleGetHorizontalPodAutoscalerDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, horizontalpodautoscaler),
    ...handleGetHorizontalPodAutoscalerDetailDefaultOptions as unknown as Omit<UseQueryOptions<Types.HorizontalPodAutoscalerDetail, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns detailed information about HorizontalPodAutoscaler
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the HorizontalPodAutoscaler
 * @param horizontalpodautoscaler name of the HorizontalPodAutoscaler
 * @return OK
 */
export function setHandleGetHorizontalPodAutoscalerDetailData(queryClient: QueryClient, updater: (data: Types.HorizontalPodAutoscalerDetail | undefined) => Types.HorizontalPodAutoscalerDetail, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, horizontalpodautoscaler: string) {
  queryClient.setQueryData(handleGetHorizontalPodAutoscalerDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, horizontalpodautoscaler),
    updater
  );
}

/**
 * returns detailed information about HorizontalPodAutoscaler
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the HorizontalPodAutoscaler
 * @param horizontalpodautoscaler name of the HorizontalPodAutoscaler
 * @return OK
 */
export function setHandleGetHorizontalPodAutoscalerDetailDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.HorizontalPodAutoscalerDetail | undefined) => Types.HorizontalPodAutoscalerDetail) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetIngressListUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/ingress?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetIngressListDefaultOptions: Omit<UseQueryOptions<Types.IngressList, unknown, Types.IngressList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.IngressList, unknown, Types.IngressList>, 'queryFn'>> = {
};
export function getHandleGetIngressListDefaultOptions() {
  return handleGetIngressListDefaultOptions;
};
export function setHandleGetIngressListDefaultOptions(options: typeof handleGetIngressListDefaultOptions) {
  handleGetIngressListDefaultOptions = options;
}

export function handleGetIngressListQueryKey(dto: HandleGetIngressListQueryParameters): QueryKey;
export function handleGetIngressListQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): QueryKey;
export function handleGetIngressListQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetIngressListQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetIngressList',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetIngressList',
        ...params
      ]);
  }
}
export function __handleGetIngressList(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetIngressList(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined);
}

export function useHandleGetIngressListQuery<TSelectData = Types.IngressList, TError = unknown>(dto: HandleGetIngressListQueryParameters, options?: Omit<UseQueryOptions<Types.IngressList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Ingresses from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleGetIngressListQuery<TSelectData = Types.IngressList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseQueryOptions<Types.IngressList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetIngressListQuery<TSelectData = Types.IngressList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.IngressList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetIngressListQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.IngressList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetIngressList(context, axiosConfig) : __handleGetIngressList,
    queryKey: handleGetIngressListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    ...handleGetIngressListDefaultOptions as unknown as Omit<UseQueryOptions<Types.IngressList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Ingresses from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetIngressListData(queryClient: QueryClient, updater: (data: Types.IngressList | undefined) => Types.IngressList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined) {
  queryClient.setQueryData(handleGetIngressListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    updater
  );
}

/**
 * returns a list of Ingresses from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetIngressListDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.IngressList | undefined) => Types.IngressList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetIngressList2Url(namespace: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/ingress/{namespace}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetIngressList2DefaultOptions: Omit<UseQueryOptions<Types.IngressList, unknown, Types.IngressList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.IngressList, unknown, Types.IngressList>, 'queryFn'>> = {
};
export function getHandleGetIngressList2DefaultOptions() {
  return handleGetIngressList2DefaultOptions;
};
export function setHandleGetIngressList2DefaultOptions(options: typeof handleGetIngressList2DefaultOptions) {
  handleGetIngressList2DefaultOptions = options;
}

export function handleGetIngressList2QueryKey(dto: HandleGetIngressList2QueryParameters): QueryKey;
export function handleGetIngressList2QueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string): QueryKey;
export function handleGetIngressList2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetIngressList2QueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetIngressList2',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetIngressList2',
        ...params
      ]);
  }
}
export function __handleGetIngressList2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetIngressList2(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetIngressList2Query<TSelectData = Types.IngressList, TError = unknown>(dto: HandleGetIngressList2QueryParameters, options?: Omit<UseQueryOptions<Types.IngressList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Ingresses in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Ingress
 * @return OK
 */
export function useHandleGetIngressList2Query<TSelectData = Types.IngressList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, options?: Omit<UseQueryOptions<Types.IngressList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetIngressList2Query<TSelectData = Types.IngressList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.IngressList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetIngressList2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.IngressList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetIngressList2(context, axiosConfig) : __handleGetIngressList2,
    queryKey: handleGetIngressList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    ...handleGetIngressList2DefaultOptions as unknown as Omit<UseQueryOptions<Types.IngressList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Ingresses in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Ingress
 * @return OK
 */
export function setHandleGetIngressList2Data(queryClient: QueryClient, updater: (data: Types.IngressList | undefined) => Types.IngressList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string) {
  queryClient.setQueryData(handleGetIngressList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    updater
  );
}

/**
 * returns a list of Ingresses in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Ingress
 * @return OK
 */
export function setHandleGetIngressList2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.IngressList | undefined) => Types.IngressList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetIngressEventUrl(namespace: string, ingress: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/ingress/{namespace}/{ingress}/event?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (ingress === undefined || ingress === null)
  throw new Error("The parameter 'ingress' must be defined.");
url_ = url_.replace("{ingress}", encodeURIComponent("" + ingress));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetIngressEventDefaultOptions: Omit<UseQueryOptions<Types.EventList, unknown, Types.EventList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.EventList, unknown, Types.EventList>, 'queryFn'>> = {
};
export function getHandleGetIngressEventDefaultOptions() {
  return handleGetIngressEventDefaultOptions;
};
export function setHandleGetIngressEventDefaultOptions(options: typeof handleGetIngressEventDefaultOptions) {
  handleGetIngressEventDefaultOptions = options;
}

export function handleGetIngressEventQueryKey(dto: HandleGetIngressEventQueryParameters): QueryKey;
export function handleGetIngressEventQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, ingress: string): QueryKey;
export function handleGetIngressEventQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, ingress,  } = params[0] as HandleGetIngressEventQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetIngressEvent',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        ingress as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetIngressEvent',
        ...params
      ]);
  }
}
export function __handleGetIngressEvent(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetIngressEvent(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetIngressEventQuery<TSelectData = Types.EventList, TError = unknown>(dto: HandleGetIngressEventQueryParameters, options?: Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Events for Ingress
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Ingress
 * @param ingress name of the Ingress
 * @return OK
 */
export function useHandleGetIngressEventQuery<TSelectData = Types.EventList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, ingress: string, options?: Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetIngressEventQuery<TSelectData = Types.EventList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.EventList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let ingress: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, ingress,  } = params[0] as HandleGetIngressEventQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, ingress, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.EventList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetIngressEvent(context, axiosConfig) : __handleGetIngressEvent,
    queryKey: handleGetIngressEventQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, ingress),
    ...handleGetIngressEventDefaultOptions as unknown as Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Events for Ingress
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Ingress
 * @param ingress name of the Ingress
 * @return OK
 */
export function setHandleGetIngressEventData(queryClient: QueryClient, updater: (data: Types.EventList | undefined) => Types.EventList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, ingress: string) {
  queryClient.setQueryData(handleGetIngressEventQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, ingress),
    updater
  );
}

/**
 * returns a list of Events for Ingress
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Ingress
 * @param ingress name of the Ingress
 * @return OK
 */
export function setHandleGetIngressEventDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.EventList | undefined) => Types.EventList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetIngressDetailUrl(namespace: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/ingress/{namespace}/{name}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (name === undefined || name === null)
  throw new Error("The parameter 'name' must be defined.");
url_ = url_.replace("{name}", encodeURIComponent("" + name));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetIngressDetailDefaultOptions: Omit<UseQueryOptions<Types.IngressDetail, unknown, Types.IngressDetail>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.IngressDetail, unknown, Types.IngressDetail>, 'queryFn'>> = {
};
export function getHandleGetIngressDetailDefaultOptions() {
  return handleGetIngressDetailDefaultOptions;
};
export function setHandleGetIngressDetailDefaultOptions(options: typeof handleGetIngressDetailDefaultOptions) {
  handleGetIngressDetailDefaultOptions = options;
}

export function handleGetIngressDetailQueryKey(dto: HandleGetIngressDetailQueryParameters): QueryKey;
export function handleGetIngressDetailQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, name: string): QueryKey;
export function handleGetIngressDetailQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name,  } = params[0] as HandleGetIngressDetailQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetIngressDetail',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        name as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetIngressDetail',
        ...params
      ]);
  }
}
export function __handleGetIngressDetail(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetIngressDetail(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetIngressDetailQuery<TSelectData = Types.IngressDetail, TError = unknown>(dto: HandleGetIngressDetailQueryParameters, options?: Omit<UseQueryOptions<Types.IngressDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns detailed information about Ingress
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Ingress
 * @param name name of the Ingress
 * @return OK
 */
export function useHandleGetIngressDetailQuery<TSelectData = Types.IngressDetail, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, name: string, options?: Omit<UseQueryOptions<Types.IngressDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetIngressDetailQuery<TSelectData = Types.IngressDetail, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.IngressDetail, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let name: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name,  } = params[0] as HandleGetIngressDetailQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.IngressDetail, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetIngressDetail(context, axiosConfig) : __handleGetIngressDetail,
    queryKey: handleGetIngressDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name),
    ...handleGetIngressDetailDefaultOptions as unknown as Omit<UseQueryOptions<Types.IngressDetail, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns detailed information about Ingress
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Ingress
 * @param name name of the Ingress
 * @return OK
 */
export function setHandleGetIngressDetailData(queryClient: QueryClient, updater: (data: Types.IngressDetail | undefined) => Types.IngressDetail, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, name: string) {
  queryClient.setQueryData(handleGetIngressDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name),
    updater
  );
}

/**
 * returns detailed information about Ingress
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Ingress
 * @param name name of the Ingress
 * @return OK
 */
export function setHandleGetIngressDetailDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.IngressDetail | undefined) => Types.IngressDetail) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetIngressClassListUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/ingressclass?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetIngressClassListDefaultOptions: Omit<UseQueryOptions<Types.IngressClassList, unknown, Types.IngressClassList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.IngressClassList, unknown, Types.IngressClassList>, 'queryFn'>> = {
};
export function getHandleGetIngressClassListDefaultOptions() {
  return handleGetIngressClassListDefaultOptions;
};
export function setHandleGetIngressClassListDefaultOptions(options: typeof handleGetIngressClassListDefaultOptions) {
  handleGetIngressClassListDefaultOptions = options;
}

export function handleGetIngressClassListQueryKey(dto: HandleGetIngressClassListQueryParameters): QueryKey;
export function handleGetIngressClassListQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): QueryKey;
export function handleGetIngressClassListQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetIngressClassListQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetIngressClassList',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetIngressClassList',
        ...params
      ]);
  }
}
export function __handleGetIngressClassList(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetIngressClassList(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined);
}

export function useHandleGetIngressClassListQuery<TSelectData = Types.IngressClassList, TError = unknown>(dto: HandleGetIngressClassListQueryParameters, options?: Omit<UseQueryOptions<Types.IngressClassList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of IngressClasses
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleGetIngressClassListQuery<TSelectData = Types.IngressClassList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseQueryOptions<Types.IngressClassList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetIngressClassListQuery<TSelectData = Types.IngressClassList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.IngressClassList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetIngressClassListQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.IngressClassList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetIngressClassList(context, axiosConfig) : __handleGetIngressClassList,
    queryKey: handleGetIngressClassListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    ...handleGetIngressClassListDefaultOptions as unknown as Omit<UseQueryOptions<Types.IngressClassList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of IngressClasses
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetIngressClassListData(queryClient: QueryClient, updater: (data: Types.IngressClassList | undefined) => Types.IngressClassList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined) {
  queryClient.setQueryData(handleGetIngressClassListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    updater
  );
}

/**
 * returns a list of IngressClasses
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetIngressClassListDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.IngressClassList | undefined) => Types.IngressClassList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetIngressClassUrl(ingressclass: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/ingressclass/{ingressclass}?";
if (ingressclass === undefined || ingressclass === null)
  throw new Error("The parameter 'ingressclass' must be defined.");
url_ = url_.replace("{ingressclass}", encodeURIComponent("" + ingressclass));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetIngressClassDefaultOptions: Omit<UseQueryOptions<Types.IngressClass, unknown, Types.IngressClass>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.IngressClass, unknown, Types.IngressClass>, 'queryFn'>> = {
};
export function getHandleGetIngressClassDefaultOptions() {
  return handleGetIngressClassDefaultOptions;
};
export function setHandleGetIngressClassDefaultOptions(options: typeof handleGetIngressClassDefaultOptions) {
  handleGetIngressClassDefaultOptions = options;
}

export function handleGetIngressClassQueryKey(dto: HandleGetIngressClassQueryParameters): QueryKey;
export function handleGetIngressClassQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, ingressclass: string): QueryKey;
export function handleGetIngressClassQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, ingressclass,  } = params[0] as HandleGetIngressClassQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetIngressClass',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        ingressclass as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetIngressClass',
        ...params
      ]);
  }
}
export function __handleGetIngressClass(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetIngressClass(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetIngressClassQuery<TSelectData = Types.IngressClass, TError = unknown>(dto: HandleGetIngressClassQueryParameters, options?: Omit<UseQueryOptions<Types.IngressClass, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns detailed information about IngressClass
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param ingressclass name of the IngressClass
 * @return OK
 */
export function useHandleGetIngressClassQuery<TSelectData = Types.IngressClass, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, ingressclass: string, options?: Omit<UseQueryOptions<Types.IngressClass, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetIngressClassQuery<TSelectData = Types.IngressClass, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.IngressClass, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let ingressclass: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, ingressclass,  } = params[0] as HandleGetIngressClassQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, ingressclass, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.IngressClass, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetIngressClass(context, axiosConfig) : __handleGetIngressClass,
    queryKey: handleGetIngressClassQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, ingressclass),
    ...handleGetIngressClassDefaultOptions as unknown as Omit<UseQueryOptions<Types.IngressClass, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns detailed information about IngressClass
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param ingressclass name of the IngressClass
 * @return OK
 */
export function setHandleGetIngressClassData(queryClient: QueryClient, updater: (data: Types.IngressClass | undefined) => Types.IngressClass, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, ingressclass: string) {
  queryClient.setQueryData(handleGetIngressClassQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, ingressclass),
    updater
  );
}

/**
 * returns detailed information about IngressClass
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param ingressclass name of the IngressClass
 * @return OK
 */
export function setHandleGetIngressClassDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.IngressClass | undefined) => Types.IngressClass) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetStateUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/integration/{name}/state?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetStateDefaultOptions: Omit<UseQueryOptions<void, unknown, void>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<void, unknown, void>, 'queryFn'>> = {
};
export function getHandleGetStateDefaultOptions() {
  return handleGetStateDefaultOptions;
};
export function setHandleGetStateDefaultOptions(options: typeof handleGetStateDefaultOptions) {
  handleGetStateDefaultOptions = options;
}

export function handleGetStateQueryKey(dto: HandleGetStateQueryParameters): QueryKey;
export function handleGetStateQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): QueryKey;
export function handleGetStateQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetStateQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetState',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetState',
        ...params
      ]);
  }
}
export function __handleGetState(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetState(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined);
}

export function useHandleGetStateQuery<TSelectData = void, TError = unknown>(dto: HandleGetStateQueryParameters, options?: Omit<UseQueryOptions<void, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleGetStateQuery<TSelectData = void, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseQueryOptions<void, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetStateQuery<TSelectData = void, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<void, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetStateQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<void, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetState(context, axiosConfig) : __handleGetState,
    queryKey: handleGetStateQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    ...handleGetStateDefaultOptions as unknown as Omit<UseQueryOptions<void, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetStateData(queryClient: QueryClient, updater: (data: void | undefined) => void, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined) {
  queryClient.setQueryData(handleGetStateQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    updater
  );
}

/**
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetStateDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: void | undefined) => void) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetJobListUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/job?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetJobListDefaultOptions: Omit<UseQueryOptions<Types.JobList, unknown, Types.JobList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.JobList, unknown, Types.JobList>, 'queryFn'>> = {
};
export function getHandleGetJobListDefaultOptions() {
  return handleGetJobListDefaultOptions;
};
export function setHandleGetJobListDefaultOptions(options: typeof handleGetJobListDefaultOptions) {
  handleGetJobListDefaultOptions = options;
}

export function handleGetJobListQueryKey(dto: HandleGetJobListQueryParameters): QueryKey;
export function handleGetJobListQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): QueryKey;
export function handleGetJobListQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetJobListQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetJobList',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetJobList',
        ...params
      ]);
  }
}
export function __handleGetJobList(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetJobList(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined);
}

export function useHandleGetJobListQuery<TSelectData = Types.JobList, TError = unknown>(dto: HandleGetJobListQueryParameters, options?: Omit<UseQueryOptions<Types.JobList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Jobs from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleGetJobListQuery<TSelectData = Types.JobList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseQueryOptions<Types.JobList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetJobListQuery<TSelectData = Types.JobList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.JobList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetJobListQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.JobList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetJobList(context, axiosConfig) : __handleGetJobList,
    queryKey: handleGetJobListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    ...handleGetJobListDefaultOptions as unknown as Omit<UseQueryOptions<Types.JobList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Jobs from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetJobListData(queryClient: QueryClient, updater: (data: Types.JobList | undefined) => Types.JobList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined) {
  queryClient.setQueryData(handleGetJobListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    updater
  );
}

/**
 * returns a list of Jobs from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetJobListDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.JobList | undefined) => Types.JobList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetJobList2Url(namespace: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/job/{namespace}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetJobList2DefaultOptions: Omit<UseQueryOptions<Types.JobList, unknown, Types.JobList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.JobList, unknown, Types.JobList>, 'queryFn'>> = {
};
export function getHandleGetJobList2DefaultOptions() {
  return handleGetJobList2DefaultOptions;
};
export function setHandleGetJobList2DefaultOptions(options: typeof handleGetJobList2DefaultOptions) {
  handleGetJobList2DefaultOptions = options;
}

export function handleGetJobList2QueryKey(dto: HandleGetJobList2QueryParameters): QueryKey;
export function handleGetJobList2QueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string): QueryKey;
export function handleGetJobList2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetJobList2QueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetJobList2',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetJobList2',
        ...params
      ]);
  }
}
export function __handleGetJobList2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetJobList2(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetJobList2Query<TSelectData = Types.JobList, TError = unknown>(dto: HandleGetJobList2QueryParameters, options?: Omit<UseQueryOptions<Types.JobList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Jobs in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Job
 * @return OK
 */
export function useHandleGetJobList2Query<TSelectData = Types.JobList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, options?: Omit<UseQueryOptions<Types.JobList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetJobList2Query<TSelectData = Types.JobList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.JobList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetJobList2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.JobList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetJobList2(context, axiosConfig) : __handleGetJobList2,
    queryKey: handleGetJobList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    ...handleGetJobList2DefaultOptions as unknown as Omit<UseQueryOptions<Types.JobList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Jobs in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Job
 * @return OK
 */
export function setHandleGetJobList2Data(queryClient: QueryClient, updater: (data: Types.JobList | undefined) => Types.JobList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string) {
  queryClient.setQueryData(handleGetJobList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    updater
  );
}

/**
 * returns a list of Jobs in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Job
 * @return OK
 */
export function setHandleGetJobList2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.JobList | undefined) => Types.JobList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetJobDetailUrl(namespace: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/job/{namespace}/{name}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (name === undefined || name === null)
  throw new Error("The parameter 'name' must be defined.");
url_ = url_.replace("{name}", encodeURIComponent("" + name));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetJobDetailDefaultOptions: Omit<UseQueryOptions<Types.JobDetail, unknown, Types.JobDetail>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.JobDetail, unknown, Types.JobDetail>, 'queryFn'>> = {
};
export function getHandleGetJobDetailDefaultOptions() {
  return handleGetJobDetailDefaultOptions;
};
export function setHandleGetJobDetailDefaultOptions(options: typeof handleGetJobDetailDefaultOptions) {
  handleGetJobDetailDefaultOptions = options;
}

export function handleGetJobDetailQueryKey(dto: HandleGetJobDetailQueryParameters): QueryKey;
export function handleGetJobDetailQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, name: string): QueryKey;
export function handleGetJobDetailQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name,  } = params[0] as HandleGetJobDetailQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetJobDetail',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        name as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetJobDetail',
        ...params
      ]);
  }
}
export function __handleGetJobDetail(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetJobDetail(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetJobDetailQuery<TSelectData = Types.JobDetail, TError = unknown>(dto: HandleGetJobDetailQueryParameters, options?: Omit<UseQueryOptions<Types.JobDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns detailed information about Job
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Job
 * @param name name of the Job
 * @return OK
 */
export function useHandleGetJobDetailQuery<TSelectData = Types.JobDetail, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, name: string, options?: Omit<UseQueryOptions<Types.JobDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetJobDetailQuery<TSelectData = Types.JobDetail, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.JobDetail, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let name: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name,  } = params[0] as HandleGetJobDetailQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.JobDetail, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetJobDetail(context, axiosConfig) : __handleGetJobDetail,
    queryKey: handleGetJobDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name),
    ...handleGetJobDetailDefaultOptions as unknown as Omit<UseQueryOptions<Types.JobDetail, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns detailed information about Job
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Job
 * @param name name of the Job
 * @return OK
 */
export function setHandleGetJobDetailData(queryClient: QueryClient, updater: (data: Types.JobDetail | undefined) => Types.JobDetail, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, name: string) {
  queryClient.setQueryData(handleGetJobDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name),
    updater
  );
}

/**
 * returns detailed information about Job
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Job
 * @param name name of the Job
 * @return OK
 */
export function setHandleGetJobDetailDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.JobDetail | undefined) => Types.JobDetail) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetJobEventsUrl(namespace: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/job/{namespace}/{name}/event?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (name === undefined || name === null)
  throw new Error("The parameter 'name' must be defined.");
url_ = url_.replace("{name}", encodeURIComponent("" + name));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetJobEventsDefaultOptions: Omit<UseQueryOptions<Types.EventList, unknown, Types.EventList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.EventList, unknown, Types.EventList>, 'queryFn'>> = {
};
export function getHandleGetJobEventsDefaultOptions() {
  return handleGetJobEventsDefaultOptions;
};
export function setHandleGetJobEventsDefaultOptions(options: typeof handleGetJobEventsDefaultOptions) {
  handleGetJobEventsDefaultOptions = options;
}

export function handleGetJobEventsQueryKey(dto: HandleGetJobEventsQueryParameters): QueryKey;
export function handleGetJobEventsQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, name: string): QueryKey;
export function handleGetJobEventsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name,  } = params[0] as HandleGetJobEventsQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetJobEvents',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        name as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetJobEvents',
        ...params
      ]);
  }
}
export function __handleGetJobEvents(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetJobEvents(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetJobEventsQuery<TSelectData = Types.EventList, TError = unknown>(dto: HandleGetJobEventsQueryParameters, options?: Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Events for Job
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Job
 * @param name name of the Job
 * @return OK
 */
export function useHandleGetJobEventsQuery<TSelectData = Types.EventList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, name: string, options?: Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetJobEventsQuery<TSelectData = Types.EventList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.EventList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let name: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name,  } = params[0] as HandleGetJobEventsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.EventList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetJobEvents(context, axiosConfig) : __handleGetJobEvents,
    queryKey: handleGetJobEventsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name),
    ...handleGetJobEventsDefaultOptions as unknown as Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Events for Job
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Job
 * @param name name of the Job
 * @return OK
 */
export function setHandleGetJobEventsData(queryClient: QueryClient, updater: (data: Types.EventList | undefined) => Types.EventList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, name: string) {
  queryClient.setQueryData(handleGetJobEventsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name),
    updater
  );
}

/**
 * returns a list of Events for Job
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Job
 * @param name name of the Job
 * @return OK
 */
export function setHandleGetJobEventsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.EventList | undefined) => Types.EventList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetJobPodsUrl(namespace: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/job/{namespace}/{name}/pod?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (name === undefined || name === null)
  throw new Error("The parameter 'name' must be defined.");
url_ = url_.replace("{name}", encodeURIComponent("" + name));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetJobPodsDefaultOptions: Omit<UseQueryOptions<Types.PodList, unknown, Types.PodList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PodList, unknown, Types.PodList>, 'queryFn'>> = {
};
export function getHandleGetJobPodsDefaultOptions() {
  return handleGetJobPodsDefaultOptions;
};
export function setHandleGetJobPodsDefaultOptions(options: typeof handleGetJobPodsDefaultOptions) {
  handleGetJobPodsDefaultOptions = options;
}

export function handleGetJobPodsQueryKey(dto: HandleGetJobPodsQueryParameters): QueryKey;
export function handleGetJobPodsQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, name: string): QueryKey;
export function handleGetJobPodsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name,  } = params[0] as HandleGetJobPodsQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetJobPods',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        name as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetJobPods',
        ...params
      ]);
  }
}
export function __handleGetJobPods(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetJobPods(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetJobPodsQuery<TSelectData = Types.PodList, TError = unknown>(dto: HandleGetJobPodsQueryParameters, options?: Omit<UseQueryOptions<Types.PodList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Pods for Job
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Job
 * @param name name of the Job
 * @return OK
 */
export function useHandleGetJobPodsQuery<TSelectData = Types.PodList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, name: string, options?: Omit<UseQueryOptions<Types.PodList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetJobPodsQuery<TSelectData = Types.PodList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PodList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let name: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name,  } = params[0] as HandleGetJobPodsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PodList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetJobPods(context, axiosConfig) : __handleGetJobPods,
    queryKey: handleGetJobPodsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name),
    ...handleGetJobPodsDefaultOptions as unknown as Omit<UseQueryOptions<Types.PodList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Pods for Job
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Job
 * @param name name of the Job
 * @return OK
 */
export function setHandleGetJobPodsData(queryClient: QueryClient, updater: (data: Types.PodList | undefined) => Types.PodList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, name: string) {
  queryClient.setQueryData(handleGetJobPodsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name),
    updater
  );
}

/**
 * returns a list of Pods for Job
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Job
 * @param name name of the Job
 * @return OK
 */
export function setHandleGetJobPodsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PodList | undefined) => Types.PodList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleLogFileUrl(namespace: string, pod: string, container: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/log/file/{namespace}/{pod}/{container}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (pod === undefined || pod === null)
  throw new Error("The parameter 'pod' must be defined.");
url_ = url_.replace("{pod}", encodeURIComponent("" + pod));
if (container === undefined || container === null)
  throw new Error("The parameter 'container' must be defined.");
url_ = url_.replace("{container}", encodeURIComponent("" + container));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleLogFileDefaultOptions: Omit<UseQueryOptions<number[], unknown, number[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<number[], unknown, number[]>, 'queryFn'>> = {
};
export function getHandleLogFileDefaultOptions() {
  return handleLogFileDefaultOptions;
};
export function setHandleLogFileDefaultOptions(options: typeof handleLogFileDefaultOptions) {
  handleLogFileDefaultOptions = options;
}

export function handleLogFileQueryKey(dto: HandleLogFileQueryParameters): QueryKey;
export function handleLogFileQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, pod: string, container: string): QueryKey;
export function handleLogFileQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod, container,  } = params[0] as HandleLogFileQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleLogFile',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        pod as any,
        container as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleLogFile',
        ...params
      ]);
  }
}
export function __handleLogFile(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleLogFile(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string,       context.queryKey[10] as string);
}

export function useHandleLogFileQuery<TSelectData = number[], TError = unknown>(dto: HandleLogFileQueryParameters, options?: Omit<UseQueryOptions<number[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a text file with logs from a Container
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Pod
 * @param pod name of the Pod
 * @param container name of container in the Pod
 * @return OK
 */
export function useHandleLogFileQuery<TSelectData = number[], TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, pod: string, container: string, options?: Omit<UseQueryOptions<number[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleLogFileQuery<TSelectData = number[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<number[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let pod: any = undefined;
  let container: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod, container,  } = params[0] as HandleLogFileQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod, container, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<number[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleLogFile(context, axiosConfig) : __handleLogFile,
    queryKey: handleLogFileQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod, container),
    ...handleLogFileDefaultOptions as unknown as Omit<UseQueryOptions<number[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a text file with logs from a Container
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Pod
 * @param pod name of the Pod
 * @param container name of container in the Pod
 * @return OK
 */
export function setHandleLogFileData(queryClient: QueryClient, updater: (data: number[] | undefined) => number[], filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, pod: string, container: string) {
  queryClient.setQueryData(handleLogFileQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod, container),
    updater
  );
}

/**
 * returns a text file with logs from a Container
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Pod
 * @param pod name of the Pod
 * @param container name of container in the Pod
 * @return OK
 */
export function setHandleLogFileDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: number[] | undefined) => number[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleLogSourceUrl(namespace: string, resourceName: string, resourceType: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/log/source/{namespace}/{resourceName}/{resourceType}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (resourceName === undefined || resourceName === null)
  throw new Error("The parameter 'resourceName' must be defined.");
url_ = url_.replace("{resourceName}", encodeURIComponent("" + resourceName));
if (resourceType === undefined || resourceType === null)
  throw new Error("The parameter 'resourceType' must be defined.");
url_ = url_.replace("{resourceType}", encodeURIComponent("" + resourceType));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleLogSourceDefaultOptions: Omit<UseQueryOptions<Types.LogSources, unknown, Types.LogSources>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.LogSources, unknown, Types.LogSources>, 'queryFn'>> = {
};
export function getHandleLogSourceDefaultOptions() {
  return handleLogSourceDefaultOptions;
};
export function setHandleLogSourceDefaultOptions(options: typeof handleLogSourceDefaultOptions) {
  handleLogSourceDefaultOptions = options;
}

export function handleLogSourceQueryKey(dto: HandleLogSourceQueryParameters): QueryKey;
export function handleLogSourceQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, resourceName: string, resourceType: string): QueryKey;
export function handleLogSourceQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, resourceName, resourceType,  } = params[0] as HandleLogSourceQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleLogSource',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        resourceName as any,
        resourceType as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleLogSource',
        ...params
      ]);
  }
}
export function __handleLogSource(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleLogSource(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string,       context.queryKey[10] as string);
}

export function useHandleLogSourceQuery<TSelectData = Types.LogSources, TError = unknown>(dto: HandleLogSourceQueryParameters, options?: Omit<UseQueryOptions<Types.LogSources, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns log sources for a resource
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the resource
 * @param resourceName name of the resource
 * @param resourceType type of the resource
 * @return OK
 */
export function useHandleLogSourceQuery<TSelectData = Types.LogSources, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, resourceName: string, resourceType: string, options?: Omit<UseQueryOptions<Types.LogSources, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleLogSourceQuery<TSelectData = Types.LogSources, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.LogSources, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let resourceName: any = undefined;
  let resourceType: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, resourceName, resourceType,  } = params[0] as HandleLogSourceQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, resourceName, resourceType, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.LogSources, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleLogSource(context, axiosConfig) : __handleLogSource,
    queryKey: handleLogSourceQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, resourceName, resourceType),
    ...handleLogSourceDefaultOptions as unknown as Omit<UseQueryOptions<Types.LogSources, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns log sources for a resource
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the resource
 * @param resourceName name of the resource
 * @param resourceType type of the resource
 * @return OK
 */
export function setHandleLogSourceData(queryClient: QueryClient, updater: (data: Types.LogSources | undefined) => Types.LogSources, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, resourceName: string, resourceType: string) {
  queryClient.setQueryData(handleLogSourceQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, resourceName, resourceType),
    updater
  );
}

/**
 * returns log sources for a resource
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the resource
 * @param resourceName name of the resource
 * @param resourceType type of the resource
 * @return OK
 */
export function setHandleLogSourceDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.LogSources | undefined) => Types.LogSources) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleLogsUrl(namespace: string, pod: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/log/{namespace}/{pod}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (pod === undefined || pod === null)
  throw new Error("The parameter 'pod' must be defined.");
url_ = url_.replace("{pod}", encodeURIComponent("" + pod));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleLogsDefaultOptions: Omit<UseQueryOptions<Types.LogDetails, unknown, Types.LogDetails>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.LogDetails, unknown, Types.LogDetails>, 'queryFn'>> = {
};
export function getHandleLogsDefaultOptions() {
  return handleLogsDefaultOptions;
};
export function setHandleLogsDefaultOptions(options: typeof handleLogsDefaultOptions) {
  handleLogsDefaultOptions = options;
}

export function handleLogsQueryKey(dto: HandleLogsQueryParameters): QueryKey;
export function handleLogsQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, pod: string): QueryKey;
export function handleLogsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod,  } = params[0] as HandleLogsQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleLogs',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        pod as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleLogs',
        ...params
      ]);
  }
}
export function __handleLogs(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleLogs(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleLogsQuery<TSelectData = Types.LogDetails, TError = unknown>(dto: HandleLogsQueryParameters, options?: Omit<UseQueryOptions<Types.LogDetails, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns logs from a Pod
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Pod
 * @param pod name of the Pod
 * @return OK
 */
export function useHandleLogsQuery<TSelectData = Types.LogDetails, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, pod: string, options?: Omit<UseQueryOptions<Types.LogDetails, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleLogsQuery<TSelectData = Types.LogDetails, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.LogDetails, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let pod: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod,  } = params[0] as HandleLogsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.LogDetails, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleLogs(context, axiosConfig) : __handleLogs,
    queryKey: handleLogsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod),
    ...handleLogsDefaultOptions as unknown as Omit<UseQueryOptions<Types.LogDetails, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns logs from a Pod
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Pod
 * @param pod name of the Pod
 * @return OK
 */
export function setHandleLogsData(queryClient: QueryClient, updater: (data: Types.LogDetails | undefined) => Types.LogDetails, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, pod: string) {
  queryClient.setQueryData(handleLogsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod),
    updater
  );
}

/**
 * returns logs from a Pod
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Pod
 * @param pod name of the Pod
 * @return OK
 */
export function setHandleLogsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.LogDetails | undefined) => Types.LogDetails) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleLogs2Url(namespace: string, pod: string, container: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/log/{namespace}/{pod}/{container}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (pod === undefined || pod === null)
  throw new Error("The parameter 'pod' must be defined.");
url_ = url_.replace("{pod}", encodeURIComponent("" + pod));
if (container === undefined || container === null)
  throw new Error("The parameter 'container' must be defined.");
url_ = url_.replace("{container}", encodeURIComponent("" + container));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleLogs2DefaultOptions: Omit<UseQueryOptions<Types.LogDetails, unknown, Types.LogDetails>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.LogDetails, unknown, Types.LogDetails>, 'queryFn'>> = {
};
export function getHandleLogs2DefaultOptions() {
  return handleLogs2DefaultOptions;
};
export function setHandleLogs2DefaultOptions(options: typeof handleLogs2DefaultOptions) {
  handleLogs2DefaultOptions = options;
}

export function handleLogs2QueryKey(dto: HandleLogs2QueryParameters): QueryKey;
export function handleLogs2QueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, pod: string, container: string): QueryKey;
export function handleLogs2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod, container,  } = params[0] as HandleLogs2QueryParameters;

    return trimArrayEnd([
        'Client',
        'handleLogs2',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        pod as any,
        container as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleLogs2',
        ...params
      ]);
  }
}
export function __handleLogs2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleLogs2(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string,       context.queryKey[10] as string);
}

export function useHandleLogs2Query<TSelectData = Types.LogDetails, TError = unknown>(dto: HandleLogs2QueryParameters, options?: Omit<UseQueryOptions<Types.LogDetails, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns logs from a Container
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Pod
 * @param pod name of the Pod
 * @param container name of container in the Pod
 * @return OK
 */
export function useHandleLogs2Query<TSelectData = Types.LogDetails, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, pod: string, container: string, options?: Omit<UseQueryOptions<Types.LogDetails, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleLogs2Query<TSelectData = Types.LogDetails, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.LogDetails, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let pod: any = undefined;
  let container: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod, container,  } = params[0] as HandleLogs2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod, container, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.LogDetails, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleLogs2(context, axiosConfig) : __handleLogs2,
    queryKey: handleLogs2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod, container),
    ...handleLogs2DefaultOptions as unknown as Omit<UseQueryOptions<Types.LogDetails, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns logs from a Container
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Pod
 * @param pod name of the Pod
 * @param container name of container in the Pod
 * @return OK
 */
export function setHandleLogs2Data(queryClient: QueryClient, updater: (data: Types.LogDetails | undefined) => Types.LogDetails, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, pod: string, container: string) {
  queryClient.setQueryData(handleLogs2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod, container),
    updater
  );
}

/**
 * returns logs from a Container
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Pod
 * @param pod name of the Pod
 * @param container name of container in the Pod
 * @return OK
 */
export function setHandleLogs2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.LogDetails | undefined) => Types.LogDetails) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetNamespacesUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/namespace?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetNamespacesDefaultOptions: Omit<UseQueryOptions<Types.NamespaceList, unknown, Types.NamespaceList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.NamespaceList, unknown, Types.NamespaceList>, 'queryFn'>> = {
};
export function getHandleGetNamespacesDefaultOptions() {
  return handleGetNamespacesDefaultOptions;
};
export function setHandleGetNamespacesDefaultOptions(options: typeof handleGetNamespacesDefaultOptions) {
  handleGetNamespacesDefaultOptions = options;
}

export function handleGetNamespacesQueryKey(dto: HandleGetNamespacesQueryParameters): QueryKey;
export function handleGetNamespacesQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): QueryKey;
export function handleGetNamespacesQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetNamespacesQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetNamespaces',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetNamespaces',
        ...params
      ]);
  }
}
export function __handleGetNamespaces(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetNamespaces(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined);
}

export function useHandleGetNamespacesQuery<TSelectData = Types.NamespaceList, TError = unknown>(dto: HandleGetNamespacesQueryParameters, options?: Omit<UseQueryOptions<Types.NamespaceList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleGetNamespacesQuery<TSelectData = Types.NamespaceList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseQueryOptions<Types.NamespaceList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetNamespacesQuery<TSelectData = Types.NamespaceList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.NamespaceList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetNamespacesQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.NamespaceList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetNamespaces(context, axiosConfig) : __handleGetNamespaces,
    queryKey: handleGetNamespacesQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    ...handleGetNamespacesDefaultOptions as unknown as Omit<UseQueryOptions<Types.NamespaceList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetNamespacesData(queryClient: QueryClient, updater: (data: Types.NamespaceList | undefined) => Types.NamespaceList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined) {
  queryClient.setQueryData(handleGetNamespacesQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    updater
  );
}

/**
 * returns a list of Namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetNamespacesDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.NamespaceList | undefined) => Types.NamespaceList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleCreateNamespaceUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/namespace?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function handleCreateNamespaceMutationKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'handleCreateNamespace',
      filterBy as any,
      sortBy as any,
      itemsPerPage as any,
      page as any,
      metricNames as any,
      aggregations as any,
    ]);
}

/**
 * create a Namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleCreateNamespaceMutation<TContext>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseMutationOptions<Types.NamespaceSpec, unknown, Types.NamespaceSpec, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.NamespaceSpec, unknown, Types.NamespaceSpec, TContext> {
  const key = handleCreateNamespaceMutationKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.NamespaceSpec) => Client().handleCreateNamespace(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, body),
    mutationKey: key,
  });
}
  
type HandleCreateNamespace__MutationParameters = HandleCreateNamespaceQueryParameters & {
  body: Types.NamespaceSpec;
}

/**
 * create a Namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleCreateNamespaceMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.NamespaceSpec, unknown, HandleCreateNamespace__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: HandleCreateNamespaceQueryParameters}): UseMutationResult<Types.NamespaceSpec, unknown, HandleCreateNamespace__MutationParameters, TContext> {
  const key = handleCreateNamespaceMutationKey(options?.parameters?.filterBy!, options?.parameters?.sortBy!, options?.parameters?.itemsPerPage!, options?.parameters?.page!, options?.parameters?.metricNames!, options?.parameters?.aggregations!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: HandleCreateNamespace__MutationParameters) => Client().handleCreateNamespace(data.filterBy ?? options?.parameters?.filterBy!, data.sortBy ?? options?.parameters?.sortBy!, data.itemsPerPage ?? options?.parameters?.itemsPerPage!, data.page ?? options?.parameters?.page!, data.metricNames ?? options?.parameters?.metricNames!, data.aggregations ?? options?.parameters?.aggregations!, data.body),
  mutationKey: key,
});
}
  
export function handleGetNamespaceDetailUrl(name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/namespace/{name}?";
if (name === undefined || name === null)
  throw new Error("The parameter 'name' must be defined.");
url_ = url_.replace("{name}", encodeURIComponent("" + name));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetNamespaceDetailDefaultOptions: Omit<UseQueryOptions<Types.NamespaceDetail, unknown, Types.NamespaceDetail>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.NamespaceDetail, unknown, Types.NamespaceDetail>, 'queryFn'>> = {
};
export function getHandleGetNamespaceDetailDefaultOptions() {
  return handleGetNamespaceDetailDefaultOptions;
};
export function setHandleGetNamespaceDetailDefaultOptions(options: typeof handleGetNamespaceDetailDefaultOptions) {
  handleGetNamespaceDetailDefaultOptions = options;
}

export function handleGetNamespaceDetailQueryKey(dto: HandleGetNamespaceDetailQueryParameters): QueryKey;
export function handleGetNamespaceDetailQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, name: string): QueryKey;
export function handleGetNamespaceDetailQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name,  } = params[0] as HandleGetNamespaceDetailQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetNamespaceDetail',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        name as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetNamespaceDetail',
        ...params
      ]);
  }
}
export function __handleGetNamespaceDetail(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetNamespaceDetail(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetNamespaceDetailQuery<TSelectData = Types.NamespaceDetail, TError = unknown>(dto: HandleGetNamespaceDetailQueryParameters, options?: Omit<UseQueryOptions<Types.NamespaceDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns detailed information about Namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param name name of the Namespace
 * @return OK
 */
export function useHandleGetNamespaceDetailQuery<TSelectData = Types.NamespaceDetail, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, name: string, options?: Omit<UseQueryOptions<Types.NamespaceDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetNamespaceDetailQuery<TSelectData = Types.NamespaceDetail, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.NamespaceDetail, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let name: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name,  } = params[0] as HandleGetNamespaceDetailQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.NamespaceDetail, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetNamespaceDetail(context, axiosConfig) : __handleGetNamespaceDetail,
    queryKey: handleGetNamespaceDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name),
    ...handleGetNamespaceDetailDefaultOptions as unknown as Omit<UseQueryOptions<Types.NamespaceDetail, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns detailed information about Namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param name name of the Namespace
 * @return OK
 */
export function setHandleGetNamespaceDetailData(queryClient: QueryClient, updater: (data: Types.NamespaceDetail | undefined) => Types.NamespaceDetail, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, name: string) {
  queryClient.setQueryData(handleGetNamespaceDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name),
    updater
  );
}

/**
 * returns detailed information about Namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param name name of the Namespace
 * @return OK
 */
export function setHandleGetNamespaceDetailDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.NamespaceDetail | undefined) => Types.NamespaceDetail) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetNamespaceEventsUrl(name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/namespace/{name}/event?";
if (name === undefined || name === null)
  throw new Error("The parameter 'name' must be defined.");
url_ = url_.replace("{name}", encodeURIComponent("" + name));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetNamespaceEventsDefaultOptions: Omit<UseQueryOptions<Types.EventList, unknown, Types.EventList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.EventList, unknown, Types.EventList>, 'queryFn'>> = {
};
export function getHandleGetNamespaceEventsDefaultOptions() {
  return handleGetNamespaceEventsDefaultOptions;
};
export function setHandleGetNamespaceEventsDefaultOptions(options: typeof handleGetNamespaceEventsDefaultOptions) {
  handleGetNamespaceEventsDefaultOptions = options;
}

export function handleGetNamespaceEventsQueryKey(dto: HandleGetNamespaceEventsQueryParameters): QueryKey;
export function handleGetNamespaceEventsQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, name: string): QueryKey;
export function handleGetNamespaceEventsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name,  } = params[0] as HandleGetNamespaceEventsQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetNamespaceEvents',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        name as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetNamespaceEvents',
        ...params
      ]);
  }
}
export function __handleGetNamespaceEvents(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetNamespaceEvents(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetNamespaceEventsQuery<TSelectData = Types.EventList, TError = unknown>(dto: HandleGetNamespaceEventsQueryParameters, options?: Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Events for Namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param name name of the Namespace
 * @return OK
 */
export function useHandleGetNamespaceEventsQuery<TSelectData = Types.EventList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, name: string, options?: Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetNamespaceEventsQuery<TSelectData = Types.EventList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.EventList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let name: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name,  } = params[0] as HandleGetNamespaceEventsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.EventList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetNamespaceEvents(context, axiosConfig) : __handleGetNamespaceEvents,
    queryKey: handleGetNamespaceEventsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name),
    ...handleGetNamespaceEventsDefaultOptions as unknown as Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Events for Namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param name name of the Namespace
 * @return OK
 */
export function setHandleGetNamespaceEventsData(queryClient: QueryClient, updater: (data: Types.EventList | undefined) => Types.EventList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, name: string) {
  queryClient.setQueryData(handleGetNamespaceEventsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name),
    updater
  );
}

/**
 * returns a list of Events for Namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param name name of the Namespace
 * @return OK
 */
export function setHandleGetNamespaceEventsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.EventList | undefined) => Types.EventList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetNetworkPolicyListUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/networkpolicy?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetNetworkPolicyListDefaultOptions: Omit<UseQueryOptions<Types.NetworkPolicyList, unknown, Types.NetworkPolicyList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.NetworkPolicyList, unknown, Types.NetworkPolicyList>, 'queryFn'>> = {
};
export function getHandleGetNetworkPolicyListDefaultOptions() {
  return handleGetNetworkPolicyListDefaultOptions;
};
export function setHandleGetNetworkPolicyListDefaultOptions(options: typeof handleGetNetworkPolicyListDefaultOptions) {
  handleGetNetworkPolicyListDefaultOptions = options;
}

export function handleGetNetworkPolicyListQueryKey(dto: HandleGetNetworkPolicyListQueryParameters): QueryKey;
export function handleGetNetworkPolicyListQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): QueryKey;
export function handleGetNetworkPolicyListQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetNetworkPolicyListQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetNetworkPolicyList',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetNetworkPolicyList',
        ...params
      ]);
  }
}
export function __handleGetNetworkPolicyList(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetNetworkPolicyList(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined);
}

export function useHandleGetNetworkPolicyListQuery<TSelectData = Types.NetworkPolicyList, TError = unknown>(dto: HandleGetNetworkPolicyListQueryParameters, options?: Omit<UseQueryOptions<Types.NetworkPolicyList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of NetworkPolicies from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleGetNetworkPolicyListQuery<TSelectData = Types.NetworkPolicyList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseQueryOptions<Types.NetworkPolicyList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetNetworkPolicyListQuery<TSelectData = Types.NetworkPolicyList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.NetworkPolicyList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetNetworkPolicyListQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.NetworkPolicyList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetNetworkPolicyList(context, axiosConfig) : __handleGetNetworkPolicyList,
    queryKey: handleGetNetworkPolicyListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    ...handleGetNetworkPolicyListDefaultOptions as unknown as Omit<UseQueryOptions<Types.NetworkPolicyList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of NetworkPolicies from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetNetworkPolicyListData(queryClient: QueryClient, updater: (data: Types.NetworkPolicyList | undefined) => Types.NetworkPolicyList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined) {
  queryClient.setQueryData(handleGetNetworkPolicyListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    updater
  );
}

/**
 * returns a list of NetworkPolicies from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetNetworkPolicyListDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.NetworkPolicyList | undefined) => Types.NetworkPolicyList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetNetworkPolicyList2Url(namespace: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/networkpolicy/{namespace}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetNetworkPolicyList2DefaultOptions: Omit<UseQueryOptions<Types.NetworkPolicyList, unknown, Types.NetworkPolicyList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.NetworkPolicyList, unknown, Types.NetworkPolicyList>, 'queryFn'>> = {
};
export function getHandleGetNetworkPolicyList2DefaultOptions() {
  return handleGetNetworkPolicyList2DefaultOptions;
};
export function setHandleGetNetworkPolicyList2DefaultOptions(options: typeof handleGetNetworkPolicyList2DefaultOptions) {
  handleGetNetworkPolicyList2DefaultOptions = options;
}

export function handleGetNetworkPolicyList2QueryKey(dto: HandleGetNetworkPolicyList2QueryParameters): QueryKey;
export function handleGetNetworkPolicyList2QueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string): QueryKey;
export function handleGetNetworkPolicyList2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetNetworkPolicyList2QueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetNetworkPolicyList2',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetNetworkPolicyList2',
        ...params
      ]);
  }
}
export function __handleGetNetworkPolicyList2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetNetworkPolicyList2(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetNetworkPolicyList2Query<TSelectData = Types.NetworkPolicyList, TError = unknown>(dto: HandleGetNetworkPolicyList2QueryParameters, options?: Omit<UseQueryOptions<Types.NetworkPolicyList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of NetworkPolicies in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the NetworkPolicy
 * @return OK
 */
export function useHandleGetNetworkPolicyList2Query<TSelectData = Types.NetworkPolicyList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, options?: Omit<UseQueryOptions<Types.NetworkPolicyList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetNetworkPolicyList2Query<TSelectData = Types.NetworkPolicyList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.NetworkPolicyList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetNetworkPolicyList2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.NetworkPolicyList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetNetworkPolicyList2(context, axiosConfig) : __handleGetNetworkPolicyList2,
    queryKey: handleGetNetworkPolicyList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    ...handleGetNetworkPolicyList2DefaultOptions as unknown as Omit<UseQueryOptions<Types.NetworkPolicyList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of NetworkPolicies in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the NetworkPolicy
 * @return OK
 */
export function setHandleGetNetworkPolicyList2Data(queryClient: QueryClient, updater: (data: Types.NetworkPolicyList | undefined) => Types.NetworkPolicyList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string) {
  queryClient.setQueryData(handleGetNetworkPolicyList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    updater
  );
}

/**
 * returns a list of NetworkPolicies in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the NetworkPolicy
 * @return OK
 */
export function setHandleGetNetworkPolicyList2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.NetworkPolicyList | undefined) => Types.NetworkPolicyList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetNetworkPolicyDetailUrl(namespace: string, networkpolicy: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/networkpolicy/{namespace}/{networkpolicy}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (networkpolicy === undefined || networkpolicy === null)
  throw new Error("The parameter 'networkpolicy' must be defined.");
url_ = url_.replace("{networkpolicy}", encodeURIComponent("" + networkpolicy));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetNetworkPolicyDetailDefaultOptions: Omit<UseQueryOptions<Types.NetworkPolicyDetail, unknown, Types.NetworkPolicyDetail>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.NetworkPolicyDetail, unknown, Types.NetworkPolicyDetail>, 'queryFn'>> = {
};
export function getHandleGetNetworkPolicyDetailDefaultOptions() {
  return handleGetNetworkPolicyDetailDefaultOptions;
};
export function setHandleGetNetworkPolicyDetailDefaultOptions(options: typeof handleGetNetworkPolicyDetailDefaultOptions) {
  handleGetNetworkPolicyDetailDefaultOptions = options;
}

export function handleGetNetworkPolicyDetailQueryKey(dto: HandleGetNetworkPolicyDetailQueryParameters): QueryKey;
export function handleGetNetworkPolicyDetailQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, networkpolicy: string): QueryKey;
export function handleGetNetworkPolicyDetailQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, networkpolicy,  } = params[0] as HandleGetNetworkPolicyDetailQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetNetworkPolicyDetail',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        networkpolicy as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetNetworkPolicyDetail',
        ...params
      ]);
  }
}
export function __handleGetNetworkPolicyDetail(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetNetworkPolicyDetail(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetNetworkPolicyDetailQuery<TSelectData = Types.NetworkPolicyDetail, TError = unknown>(dto: HandleGetNetworkPolicyDetailQueryParameters, options?: Omit<UseQueryOptions<Types.NetworkPolicyDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns detailed information about NetworkPolicy
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the NetworkPolicy
 * @param networkpolicy name of the NetworkPolicy
 * @return OK
 */
export function useHandleGetNetworkPolicyDetailQuery<TSelectData = Types.NetworkPolicyDetail, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, networkpolicy: string, options?: Omit<UseQueryOptions<Types.NetworkPolicyDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetNetworkPolicyDetailQuery<TSelectData = Types.NetworkPolicyDetail, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.NetworkPolicyDetail, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let networkpolicy: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, networkpolicy,  } = params[0] as HandleGetNetworkPolicyDetailQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, networkpolicy, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.NetworkPolicyDetail, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetNetworkPolicyDetail(context, axiosConfig) : __handleGetNetworkPolicyDetail,
    queryKey: handleGetNetworkPolicyDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, networkpolicy),
    ...handleGetNetworkPolicyDetailDefaultOptions as unknown as Omit<UseQueryOptions<Types.NetworkPolicyDetail, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns detailed information about NetworkPolicy
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the NetworkPolicy
 * @param networkpolicy name of the NetworkPolicy
 * @return OK
 */
export function setHandleGetNetworkPolicyDetailData(queryClient: QueryClient, updater: (data: Types.NetworkPolicyDetail | undefined) => Types.NetworkPolicyDetail, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, networkpolicy: string) {
  queryClient.setQueryData(handleGetNetworkPolicyDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, networkpolicy),
    updater
  );
}

/**
 * returns detailed information about NetworkPolicy
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the NetworkPolicy
 * @param networkpolicy name of the NetworkPolicy
 * @return OK
 */
export function setHandleGetNetworkPolicyDetailDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.NetworkPolicyDetail | undefined) => Types.NetworkPolicyDetail) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetNodeListUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/node?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetNodeListDefaultOptions: Omit<UseQueryOptions<Types.NodeList, unknown, Types.NodeList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.NodeList, unknown, Types.NodeList>, 'queryFn'>> = {
};
export function getHandleGetNodeListDefaultOptions() {
  return handleGetNodeListDefaultOptions;
};
export function setHandleGetNodeListDefaultOptions(options: typeof handleGetNodeListDefaultOptions) {
  handleGetNodeListDefaultOptions = options;
}

export function handleGetNodeListQueryKey(dto: HandleGetNodeListQueryParameters): QueryKey;
export function handleGetNodeListQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): QueryKey;
export function handleGetNodeListQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetNodeListQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetNodeList',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetNodeList',
        ...params
      ]);
  }
}
export function __handleGetNodeList(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetNodeList(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined);
}

export function useHandleGetNodeListQuery<TSelectData = Types.NodeList, TError = unknown>(dto: HandleGetNodeListQueryParameters, options?: Omit<UseQueryOptions<Types.NodeList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Nodes
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleGetNodeListQuery<TSelectData = Types.NodeList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseQueryOptions<Types.NodeList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetNodeListQuery<TSelectData = Types.NodeList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.NodeList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetNodeListQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.NodeList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetNodeList(context, axiosConfig) : __handleGetNodeList,
    queryKey: handleGetNodeListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    ...handleGetNodeListDefaultOptions as unknown as Omit<UseQueryOptions<Types.NodeList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Nodes
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetNodeListData(queryClient: QueryClient, updater: (data: Types.NodeList | undefined) => Types.NodeList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined) {
  queryClient.setQueryData(handleGetNodeListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    updater
  );
}

/**
 * returns a list of Nodes
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetNodeListDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.NodeList | undefined) => Types.NodeList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetNodeDetailUrl(name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/node/{name}?";
if (name === undefined || name === null)
  throw new Error("The parameter 'name' must be defined.");
url_ = url_.replace("{name}", encodeURIComponent("" + name));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetNodeDetailDefaultOptions: Omit<UseQueryOptions<Types.NodeDetail, unknown, Types.NodeDetail>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.NodeDetail, unknown, Types.NodeDetail>, 'queryFn'>> = {
};
export function getHandleGetNodeDetailDefaultOptions() {
  return handleGetNodeDetailDefaultOptions;
};
export function setHandleGetNodeDetailDefaultOptions(options: typeof handleGetNodeDetailDefaultOptions) {
  handleGetNodeDetailDefaultOptions = options;
}

export function handleGetNodeDetailQueryKey(dto: HandleGetNodeDetailQueryParameters): QueryKey;
export function handleGetNodeDetailQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, name: string): QueryKey;
export function handleGetNodeDetailQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name,  } = params[0] as HandleGetNodeDetailQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetNodeDetail',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        name as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetNodeDetail',
        ...params
      ]);
  }
}
export function __handleGetNodeDetail(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetNodeDetail(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetNodeDetailQuery<TSelectData = Types.NodeDetail, TError = unknown>(dto: HandleGetNodeDetailQueryParameters, options?: Omit<UseQueryOptions<Types.NodeDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns detailed information about Node
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param name name of the Node
 * @return OK
 */
export function useHandleGetNodeDetailQuery<TSelectData = Types.NodeDetail, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, name: string, options?: Omit<UseQueryOptions<Types.NodeDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetNodeDetailQuery<TSelectData = Types.NodeDetail, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.NodeDetail, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let name: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name,  } = params[0] as HandleGetNodeDetailQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.NodeDetail, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetNodeDetail(context, axiosConfig) : __handleGetNodeDetail,
    queryKey: handleGetNodeDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name),
    ...handleGetNodeDetailDefaultOptions as unknown as Omit<UseQueryOptions<Types.NodeDetail, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns detailed information about Node
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param name name of the Node
 * @return OK
 */
export function setHandleGetNodeDetailData(queryClient: QueryClient, updater: (data: Types.NodeDetail | undefined) => Types.NodeDetail, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, name: string) {
  queryClient.setQueryData(handleGetNodeDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name),
    updater
  );
}

/**
 * returns detailed information about Node
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param name name of the Node
 * @return OK
 */
export function setHandleGetNodeDetailDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.NodeDetail | undefined) => Types.NodeDetail) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleNodeDrainUrl(name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/node/{name}/drain?";
if (name === undefined || name === null)
  throw new Error("The parameter 'name' must be defined.");
url_ = url_.replace("{name}", encodeURIComponent("" + name));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function handleNodeDrainMutationKey(name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'handleNodeDrain',
      name as any,
      filterBy as any,
      sortBy as any,
      itemsPerPage as any,
      page as any,
      metricNames as any,
      aggregations as any,
    ]);
}

/**
 * drains Node
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param name name of the Node
 * @return OK
 */
export function useHandleNodeDrainMutation<TContext>(name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseMutationOptions<void, unknown, Types.NodeDrainSpec, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.NodeDrainSpec, TContext> {
  const key = handleNodeDrainMutationKey(name, filterBy, sortBy, itemsPerPage, page, metricNames, aggregations);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.NodeDrainSpec) => Client().handleNodeDrain(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name, body),
    mutationKey: key,
  });
}
  
type HandleNodeDrain__MutationParameters = HandleNodeDrainQueryParameters & {
  body: Types.NodeDrainSpec;
}

/**
 * drains Node
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param name name of the Node
 * @return OK
 */
export function useHandleNodeDrainMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, HandleNodeDrain__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: HandleNodeDrainQueryParameters}): UseMutationResult<void, unknown, HandleNodeDrain__MutationParameters, TContext> {
  const key = handleNodeDrainMutationKey(options?.parameters?.name!, options?.parameters?.filterBy!, options?.parameters?.sortBy!, options?.parameters?.itemsPerPage!, options?.parameters?.page!, options?.parameters?.metricNames!, options?.parameters?.aggregations!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: HandleNodeDrain__MutationParameters) => Client().handleNodeDrain(data.filterBy ?? options?.parameters?.filterBy!, data.sortBy ?? options?.parameters?.sortBy!, data.itemsPerPage ?? options?.parameters?.itemsPerPage!, data.page ?? options?.parameters?.page!, data.metricNames ?? options?.parameters?.metricNames!, data.aggregations ?? options?.parameters?.aggregations!, data.name ?? options?.parameters?.name!, data.body),
  mutationKey: key,
});
}
  
export function handleGetNodeEventsUrl(name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/node/{name}/event?";
if (name === undefined || name === null)
  throw new Error("The parameter 'name' must be defined.");
url_ = url_.replace("{name}", encodeURIComponent("" + name));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetNodeEventsDefaultOptions: Omit<UseQueryOptions<Types.EventList, unknown, Types.EventList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.EventList, unknown, Types.EventList>, 'queryFn'>> = {
};
export function getHandleGetNodeEventsDefaultOptions() {
  return handleGetNodeEventsDefaultOptions;
};
export function setHandleGetNodeEventsDefaultOptions(options: typeof handleGetNodeEventsDefaultOptions) {
  handleGetNodeEventsDefaultOptions = options;
}

export function handleGetNodeEventsQueryKey(dto: HandleGetNodeEventsQueryParameters): QueryKey;
export function handleGetNodeEventsQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, name: string): QueryKey;
export function handleGetNodeEventsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name,  } = params[0] as HandleGetNodeEventsQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetNodeEvents',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        name as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetNodeEvents',
        ...params
      ]);
  }
}
export function __handleGetNodeEvents(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetNodeEvents(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetNodeEventsQuery<TSelectData = Types.EventList, TError = unknown>(dto: HandleGetNodeEventsQueryParameters, options?: Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Events for Node
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param name name of the Node
 * @return OK
 */
export function useHandleGetNodeEventsQuery<TSelectData = Types.EventList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, name: string, options?: Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetNodeEventsQuery<TSelectData = Types.EventList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.EventList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let name: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name,  } = params[0] as HandleGetNodeEventsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.EventList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetNodeEvents(context, axiosConfig) : __handleGetNodeEvents,
    queryKey: handleGetNodeEventsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name),
    ...handleGetNodeEventsDefaultOptions as unknown as Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Events for Node
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param name name of the Node
 * @return OK
 */
export function setHandleGetNodeEventsData(queryClient: QueryClient, updater: (data: Types.EventList | undefined) => Types.EventList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, name: string) {
  queryClient.setQueryData(handleGetNodeEventsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name),
    updater
  );
}

/**
 * returns a list of Events for Node
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param name name of the Node
 * @return OK
 */
export function setHandleGetNodeEventsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.EventList | undefined) => Types.EventList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetNodePodsUrl(name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/node/{name}/pod?";
if (name === undefined || name === null)
  throw new Error("The parameter 'name' must be defined.");
url_ = url_.replace("{name}", encodeURIComponent("" + name));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetNodePodsDefaultOptions: Omit<UseQueryOptions<Types.PodList, unknown, Types.PodList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PodList, unknown, Types.PodList>, 'queryFn'>> = {
};
export function getHandleGetNodePodsDefaultOptions() {
  return handleGetNodePodsDefaultOptions;
};
export function setHandleGetNodePodsDefaultOptions(options: typeof handleGetNodePodsDefaultOptions) {
  handleGetNodePodsDefaultOptions = options;
}

export function handleGetNodePodsQueryKey(dto: HandleGetNodePodsQueryParameters): QueryKey;
export function handleGetNodePodsQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, name: string): QueryKey;
export function handleGetNodePodsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name,  } = params[0] as HandleGetNodePodsQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetNodePods',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        name as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetNodePods',
        ...params
      ]);
  }
}
export function __handleGetNodePods(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetNodePods(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetNodePodsQuery<TSelectData = Types.PodList, TError = unknown>(dto: HandleGetNodePodsQueryParameters, options?: Omit<UseQueryOptions<Types.PodList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Pods for Node
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param name name of the Node
 * @return OK
 */
export function useHandleGetNodePodsQuery<TSelectData = Types.PodList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, name: string, options?: Omit<UseQueryOptions<Types.PodList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetNodePodsQuery<TSelectData = Types.PodList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PodList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let name: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name,  } = params[0] as HandleGetNodePodsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PodList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetNodePods(context, axiosConfig) : __handleGetNodePods,
    queryKey: handleGetNodePodsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name),
    ...handleGetNodePodsDefaultOptions as unknown as Omit<UseQueryOptions<Types.PodList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Pods for Node
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param name name of the Node
 * @return OK
 */
export function setHandleGetNodePodsData(queryClient: QueryClient, updater: (data: Types.PodList | undefined) => Types.PodList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, name: string) {
  queryClient.setQueryData(handleGetNodePodsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name),
    updater
  );
}

/**
 * returns a list of Pods for Node
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param name name of the Node
 * @return OK
 */
export function setHandleGetNodePodsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PodList | undefined) => Types.PodList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetPersistentVolumeListUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/persistentvolume?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetPersistentVolumeListDefaultOptions: Omit<UseQueryOptions<Types.PersistentVolumeList, unknown, Types.PersistentVolumeList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PersistentVolumeList, unknown, Types.PersistentVolumeList>, 'queryFn'>> = {
};
export function getHandleGetPersistentVolumeListDefaultOptions() {
  return handleGetPersistentVolumeListDefaultOptions;
};
export function setHandleGetPersistentVolumeListDefaultOptions(options: typeof handleGetPersistentVolumeListDefaultOptions) {
  handleGetPersistentVolumeListDefaultOptions = options;
}

export function handleGetPersistentVolumeListQueryKey(dto: HandleGetPersistentVolumeListQueryParameters): QueryKey;
export function handleGetPersistentVolumeListQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): QueryKey;
export function handleGetPersistentVolumeListQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetPersistentVolumeListQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetPersistentVolumeList',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetPersistentVolumeList',
        ...params
      ]);
  }
}
export function __handleGetPersistentVolumeList(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetPersistentVolumeList(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined);
}

export function useHandleGetPersistentVolumeListQuery<TSelectData = Types.PersistentVolumeList, TError = unknown>(dto: HandleGetPersistentVolumeListQueryParameters, options?: Omit<UseQueryOptions<Types.PersistentVolumeList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of PersistentVolumes from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleGetPersistentVolumeListQuery<TSelectData = Types.PersistentVolumeList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseQueryOptions<Types.PersistentVolumeList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetPersistentVolumeListQuery<TSelectData = Types.PersistentVolumeList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PersistentVolumeList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetPersistentVolumeListQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PersistentVolumeList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetPersistentVolumeList(context, axiosConfig) : __handleGetPersistentVolumeList,
    queryKey: handleGetPersistentVolumeListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    ...handleGetPersistentVolumeListDefaultOptions as unknown as Omit<UseQueryOptions<Types.PersistentVolumeList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of PersistentVolumes from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetPersistentVolumeListData(queryClient: QueryClient, updater: (data: Types.PersistentVolumeList | undefined) => Types.PersistentVolumeList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined) {
  queryClient.setQueryData(handleGetPersistentVolumeListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    updater
  );
}

/**
 * returns a list of PersistentVolumes from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetPersistentVolumeListDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PersistentVolumeList | undefined) => Types.PersistentVolumeList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetPersistentVolumeDetailUrl(persistentvolume: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/persistentvolume/namespace/{namespace}/name/{persistentvolume}?";
if (persistentvolume === undefined || persistentvolume === null)
  throw new Error("The parameter 'persistentvolume' must be defined.");
url_ = url_.replace("{persistentvolume}", encodeURIComponent("" + persistentvolume));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetPersistentVolumeDetailDefaultOptions: Omit<UseQueryOptions<Types.PersistentVolumeDetail, unknown, Types.PersistentVolumeDetail>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PersistentVolumeDetail, unknown, Types.PersistentVolumeDetail>, 'queryFn'>> = {
};
export function getHandleGetPersistentVolumeDetailDefaultOptions() {
  return handleGetPersistentVolumeDetailDefaultOptions;
};
export function setHandleGetPersistentVolumeDetailDefaultOptions(options: typeof handleGetPersistentVolumeDetailDefaultOptions) {
  handleGetPersistentVolumeDetailDefaultOptions = options;
}

export function handleGetPersistentVolumeDetailQueryKey(dto: HandleGetPersistentVolumeDetailQueryParameters): QueryKey;
export function handleGetPersistentVolumeDetailQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, persistentvolume: string): QueryKey;
export function handleGetPersistentVolumeDetailQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, persistentvolume,  } = params[0] as HandleGetPersistentVolumeDetailQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetPersistentVolumeDetail',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        persistentvolume as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetPersistentVolumeDetail',
        ...params
      ]);
  }
}
export function __handleGetPersistentVolumeDetail(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetPersistentVolumeDetail(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetPersistentVolumeDetailQuery<TSelectData = Types.PersistentVolumeDetail, TError = unknown>(dto: HandleGetPersistentVolumeDetailQueryParameters, options?: Omit<UseQueryOptions<Types.PersistentVolumeDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns detailed information about PersistentVolume
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param persistentvolume name of the PersistentVolume
 * @return OK
 */
export function useHandleGetPersistentVolumeDetailQuery<TSelectData = Types.PersistentVolumeDetail, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, persistentvolume: string, options?: Omit<UseQueryOptions<Types.PersistentVolumeDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetPersistentVolumeDetailQuery<TSelectData = Types.PersistentVolumeDetail, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PersistentVolumeDetail, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let persistentvolume: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, persistentvolume,  } = params[0] as HandleGetPersistentVolumeDetailQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, persistentvolume, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PersistentVolumeDetail, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetPersistentVolumeDetail(context, axiosConfig) : __handleGetPersistentVolumeDetail,
    queryKey: handleGetPersistentVolumeDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, persistentvolume),
    ...handleGetPersistentVolumeDetailDefaultOptions as unknown as Omit<UseQueryOptions<Types.PersistentVolumeDetail, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns detailed information about PersistentVolume
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param persistentvolume name of the PersistentVolume
 * @return OK
 */
export function setHandleGetPersistentVolumeDetailData(queryClient: QueryClient, updater: (data: Types.PersistentVolumeDetail | undefined) => Types.PersistentVolumeDetail, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, persistentvolume: string) {
  queryClient.setQueryData(handleGetPersistentVolumeDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, persistentvolume),
    updater
  );
}

/**
 * returns detailed information about PersistentVolume
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param persistentvolume name of the PersistentVolume
 * @return OK
 */
export function setHandleGetPersistentVolumeDetailDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PersistentVolumeDetail | undefined) => Types.PersistentVolumeDetail) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetPersistentVolumeDetail2Url(persistentvolume: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/persistentvolume/{persistentvolume}?";
if (persistentvolume === undefined || persistentvolume === null)
  throw new Error("The parameter 'persistentvolume' must be defined.");
url_ = url_.replace("{persistentvolume}", encodeURIComponent("" + persistentvolume));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetPersistentVolumeDetail2DefaultOptions: Omit<UseQueryOptions<Types.PersistentVolumeDetail, unknown, Types.PersistentVolumeDetail>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PersistentVolumeDetail, unknown, Types.PersistentVolumeDetail>, 'queryFn'>> = {
};
export function getHandleGetPersistentVolumeDetail2DefaultOptions() {
  return handleGetPersistentVolumeDetail2DefaultOptions;
};
export function setHandleGetPersistentVolumeDetail2DefaultOptions(options: typeof handleGetPersistentVolumeDetail2DefaultOptions) {
  handleGetPersistentVolumeDetail2DefaultOptions = options;
}

export function handleGetPersistentVolumeDetail2QueryKey(dto: HandleGetPersistentVolumeDetail2QueryParameters): QueryKey;
export function handleGetPersistentVolumeDetail2QueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, persistentvolume: string): QueryKey;
export function handleGetPersistentVolumeDetail2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, persistentvolume,  } = params[0] as HandleGetPersistentVolumeDetail2QueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetPersistentVolumeDetail2',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        persistentvolume as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetPersistentVolumeDetail2',
        ...params
      ]);
  }
}
export function __handleGetPersistentVolumeDetail2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetPersistentVolumeDetail2(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetPersistentVolumeDetail2Query<TSelectData = Types.PersistentVolumeDetail, TError = unknown>(dto: HandleGetPersistentVolumeDetail2QueryParameters, options?: Omit<UseQueryOptions<Types.PersistentVolumeDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns detailed information about PersistentVolume
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param persistentvolume name of the PersistentVolume
 * @return OK
 */
export function useHandleGetPersistentVolumeDetail2Query<TSelectData = Types.PersistentVolumeDetail, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, persistentvolume: string, options?: Omit<UseQueryOptions<Types.PersistentVolumeDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetPersistentVolumeDetail2Query<TSelectData = Types.PersistentVolumeDetail, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PersistentVolumeDetail, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let persistentvolume: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, persistentvolume,  } = params[0] as HandleGetPersistentVolumeDetail2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, persistentvolume, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PersistentVolumeDetail, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetPersistentVolumeDetail2(context, axiosConfig) : __handleGetPersistentVolumeDetail2,
    queryKey: handleGetPersistentVolumeDetail2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, persistentvolume),
    ...handleGetPersistentVolumeDetail2DefaultOptions as unknown as Omit<UseQueryOptions<Types.PersistentVolumeDetail, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns detailed information about PersistentVolume
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param persistentvolume name of the PersistentVolume
 * @return OK
 */
export function setHandleGetPersistentVolumeDetail2Data(queryClient: QueryClient, updater: (data: Types.PersistentVolumeDetail | undefined) => Types.PersistentVolumeDetail, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, persistentvolume: string) {
  queryClient.setQueryData(handleGetPersistentVolumeDetail2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, persistentvolume),
    updater
  );
}

/**
 * returns detailed information about PersistentVolume
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param persistentvolume name of the PersistentVolume
 * @return OK
 */
export function setHandleGetPersistentVolumeDetail2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PersistentVolumeDetail | undefined) => Types.PersistentVolumeDetail) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetPersistentVolumeClaimListUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/persistentvolumeclaim?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetPersistentVolumeClaimListDefaultOptions: Omit<UseQueryOptions<Types.PersistentVolumeClaimList, unknown, Types.PersistentVolumeClaimList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PersistentVolumeClaimList, unknown, Types.PersistentVolumeClaimList>, 'queryFn'>> = {
};
export function getHandleGetPersistentVolumeClaimListDefaultOptions() {
  return handleGetPersistentVolumeClaimListDefaultOptions;
};
export function setHandleGetPersistentVolumeClaimListDefaultOptions(options: typeof handleGetPersistentVolumeClaimListDefaultOptions) {
  handleGetPersistentVolumeClaimListDefaultOptions = options;
}

export function handleGetPersistentVolumeClaimListQueryKey(dto: HandleGetPersistentVolumeClaimListQueryParameters): QueryKey;
export function handleGetPersistentVolumeClaimListQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): QueryKey;
export function handleGetPersistentVolumeClaimListQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetPersistentVolumeClaimListQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetPersistentVolumeClaimList',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetPersistentVolumeClaimList',
        ...params
      ]);
  }
}
export function __handleGetPersistentVolumeClaimList(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetPersistentVolumeClaimList(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined);
}

export function useHandleGetPersistentVolumeClaimListQuery<TSelectData = Types.PersistentVolumeClaimList, TError = unknown>(dto: HandleGetPersistentVolumeClaimListQueryParameters, options?: Omit<UseQueryOptions<Types.PersistentVolumeClaimList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of PersistentVolumeClaim
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleGetPersistentVolumeClaimListQuery<TSelectData = Types.PersistentVolumeClaimList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseQueryOptions<Types.PersistentVolumeClaimList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetPersistentVolumeClaimListQuery<TSelectData = Types.PersistentVolumeClaimList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PersistentVolumeClaimList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetPersistentVolumeClaimListQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PersistentVolumeClaimList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetPersistentVolumeClaimList(context, axiosConfig) : __handleGetPersistentVolumeClaimList,
    queryKey: handleGetPersistentVolumeClaimListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    ...handleGetPersistentVolumeClaimListDefaultOptions as unknown as Omit<UseQueryOptions<Types.PersistentVolumeClaimList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of PersistentVolumeClaim
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetPersistentVolumeClaimListData(queryClient: QueryClient, updater: (data: Types.PersistentVolumeClaimList | undefined) => Types.PersistentVolumeClaimList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined) {
  queryClient.setQueryData(handleGetPersistentVolumeClaimListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    updater
  );
}

/**
 * returns a list of PersistentVolumeClaim
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetPersistentVolumeClaimListDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PersistentVolumeClaimList | undefined) => Types.PersistentVolumeClaimList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetPersistentVolumeClaimList2Url(namespace: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/persistentvolumeclaim/{namespace}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetPersistentVolumeClaimList2DefaultOptions: Omit<UseQueryOptions<Types.PersistentVolumeClaimList, unknown, Types.PersistentVolumeClaimList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PersistentVolumeClaimList, unknown, Types.PersistentVolumeClaimList>, 'queryFn'>> = {
};
export function getHandleGetPersistentVolumeClaimList2DefaultOptions() {
  return handleGetPersistentVolumeClaimList2DefaultOptions;
};
export function setHandleGetPersistentVolumeClaimList2DefaultOptions(options: typeof handleGetPersistentVolumeClaimList2DefaultOptions) {
  handleGetPersistentVolumeClaimList2DefaultOptions = options;
}

export function handleGetPersistentVolumeClaimList2QueryKey(dto: HandleGetPersistentVolumeClaimList2QueryParameters): QueryKey;
export function handleGetPersistentVolumeClaimList2QueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string): QueryKey;
export function handleGetPersistentVolumeClaimList2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetPersistentVolumeClaimList2QueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetPersistentVolumeClaimList2',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetPersistentVolumeClaimList2',
        ...params
      ]);
  }
}
export function __handleGetPersistentVolumeClaimList2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetPersistentVolumeClaimList2(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetPersistentVolumeClaimList2Query<TSelectData = Types.PersistentVolumeClaimList, TError = unknown>(dto: HandleGetPersistentVolumeClaimList2QueryParameters, options?: Omit<UseQueryOptions<Types.PersistentVolumeClaimList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of PersistentVolumeClaim from specified namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the PersistentVolumeClaim
 * @return OK
 */
export function useHandleGetPersistentVolumeClaimList2Query<TSelectData = Types.PersistentVolumeClaimList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, options?: Omit<UseQueryOptions<Types.PersistentVolumeClaimList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetPersistentVolumeClaimList2Query<TSelectData = Types.PersistentVolumeClaimList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PersistentVolumeClaimList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetPersistentVolumeClaimList2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PersistentVolumeClaimList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetPersistentVolumeClaimList2(context, axiosConfig) : __handleGetPersistentVolumeClaimList2,
    queryKey: handleGetPersistentVolumeClaimList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    ...handleGetPersistentVolumeClaimList2DefaultOptions as unknown as Omit<UseQueryOptions<Types.PersistentVolumeClaimList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of PersistentVolumeClaim from specified namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the PersistentVolumeClaim
 * @return OK
 */
export function setHandleGetPersistentVolumeClaimList2Data(queryClient: QueryClient, updater: (data: Types.PersistentVolumeClaimList | undefined) => Types.PersistentVolumeClaimList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string) {
  queryClient.setQueryData(handleGetPersistentVolumeClaimList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    updater
  );
}

/**
 * returns a list of PersistentVolumeClaim from specified namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the PersistentVolumeClaim
 * @return OK
 */
export function setHandleGetPersistentVolumeClaimList2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PersistentVolumeClaimList | undefined) => Types.PersistentVolumeClaimList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetPersistentVolumeClaimDetailUrl(name: string, namespace: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/persistentvolumeclaim/{namespace}/{name}?";
if (name === undefined || name === null)
  throw new Error("The parameter 'name' must be defined.");
url_ = url_.replace("{name}", encodeURIComponent("" + name));
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetPersistentVolumeClaimDetailDefaultOptions: Omit<UseQueryOptions<Types.PersistentVolumeClaimDetail, unknown, Types.PersistentVolumeClaimDetail>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PersistentVolumeClaimDetail, unknown, Types.PersistentVolumeClaimDetail>, 'queryFn'>> = {
};
export function getHandleGetPersistentVolumeClaimDetailDefaultOptions() {
  return handleGetPersistentVolumeClaimDetailDefaultOptions;
};
export function setHandleGetPersistentVolumeClaimDetailDefaultOptions(options: typeof handleGetPersistentVolumeClaimDetailDefaultOptions) {
  handleGetPersistentVolumeClaimDetailDefaultOptions = options;
}

export function handleGetPersistentVolumeClaimDetailQueryKey(dto: HandleGetPersistentVolumeClaimDetailQueryParameters): QueryKey;
export function handleGetPersistentVolumeClaimDetailQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, name: string, namespace: string): QueryKey;
export function handleGetPersistentVolumeClaimDetailQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name, namespace,  } = params[0] as HandleGetPersistentVolumeClaimDetailQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetPersistentVolumeClaimDetail',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        name as any,
        namespace as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetPersistentVolumeClaimDetail',
        ...params
      ]);
  }
}
export function __handleGetPersistentVolumeClaimDetail(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetPersistentVolumeClaimDetail(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetPersistentVolumeClaimDetailQuery<TSelectData = Types.PersistentVolumeClaimDetail, TError = unknown>(dto: HandleGetPersistentVolumeClaimDetailQueryParameters, options?: Omit<UseQueryOptions<Types.PersistentVolumeClaimDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns detailed information about PersistentVolumeClaim
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param name name of the PersistentVolumeClaim
 * @param namespace namespace of the PersistentVolumeClaim
 * @return OK
 */
export function useHandleGetPersistentVolumeClaimDetailQuery<TSelectData = Types.PersistentVolumeClaimDetail, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, name: string, namespace: string, options?: Omit<UseQueryOptions<Types.PersistentVolumeClaimDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetPersistentVolumeClaimDetailQuery<TSelectData = Types.PersistentVolumeClaimDetail, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PersistentVolumeClaimDetail, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let name: any = undefined;
  let namespace: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name, namespace,  } = params[0] as HandleGetPersistentVolumeClaimDetailQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name, namespace, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PersistentVolumeClaimDetail, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetPersistentVolumeClaimDetail(context, axiosConfig) : __handleGetPersistentVolumeClaimDetail,
    queryKey: handleGetPersistentVolumeClaimDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name, namespace),
    ...handleGetPersistentVolumeClaimDetailDefaultOptions as unknown as Omit<UseQueryOptions<Types.PersistentVolumeClaimDetail, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns detailed information about PersistentVolumeClaim
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param name name of the PersistentVolumeClaim
 * @param namespace namespace of the PersistentVolumeClaim
 * @return OK
 */
export function setHandleGetPersistentVolumeClaimDetailData(queryClient: QueryClient, updater: (data: Types.PersistentVolumeClaimDetail | undefined) => Types.PersistentVolumeClaimDetail, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, name: string, namespace: string) {
  queryClient.setQueryData(handleGetPersistentVolumeClaimDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name, namespace),
    updater
  );
}

/**
 * returns detailed information about PersistentVolumeClaim
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param name name of the PersistentVolumeClaim
 * @param namespace namespace of the PersistentVolumeClaim
 * @return OK
 */
export function setHandleGetPersistentVolumeClaimDetailDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PersistentVolumeClaimDetail | undefined) => Types.PersistentVolumeClaimDetail) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetPodsUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/pod?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetPodsDefaultOptions: Omit<UseQueryOptions<Types.PodList, unknown, Types.PodList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PodList, unknown, Types.PodList>, 'queryFn'>> = {
};
export function getHandleGetPodsDefaultOptions() {
  return handleGetPodsDefaultOptions;
};
export function setHandleGetPodsDefaultOptions(options: typeof handleGetPodsDefaultOptions) {
  handleGetPodsDefaultOptions = options;
}

export function handleGetPodsQueryKey(dto: HandleGetPodsQueryParameters): QueryKey;
export function handleGetPodsQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): QueryKey;
export function handleGetPodsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetPodsQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetPods',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetPods',
        ...params
      ]);
  }
}
export function __handleGetPods(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetPods(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined);
}

export function useHandleGetPodsQuery<TSelectData = Types.PodList, TError = unknown>(dto: HandleGetPodsQueryParameters, options?: Omit<UseQueryOptions<Types.PodList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Pods from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleGetPodsQuery<TSelectData = Types.PodList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseQueryOptions<Types.PodList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetPodsQuery<TSelectData = Types.PodList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PodList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetPodsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PodList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetPods(context, axiosConfig) : __handleGetPods,
    queryKey: handleGetPodsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    ...handleGetPodsDefaultOptions as unknown as Omit<UseQueryOptions<Types.PodList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Pods from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetPodsData(queryClient: QueryClient, updater: (data: Types.PodList | undefined) => Types.PodList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined) {
  queryClient.setQueryData(handleGetPodsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    updater
  );
}

/**
 * returns a list of Pods from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetPodsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PodList | undefined) => Types.PodList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetPods2Url(namespace: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/pod/{namespace}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetPods2DefaultOptions: Omit<UseQueryOptions<Types.PodList, unknown, Types.PodList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PodList, unknown, Types.PodList>, 'queryFn'>> = {
};
export function getHandleGetPods2DefaultOptions() {
  return handleGetPods2DefaultOptions;
};
export function setHandleGetPods2DefaultOptions(options: typeof handleGetPods2DefaultOptions) {
  handleGetPods2DefaultOptions = options;
}

export function handleGetPods2QueryKey(dto: HandleGetPods2QueryParameters): QueryKey;
export function handleGetPods2QueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string): QueryKey;
export function handleGetPods2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetPods2QueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetPods2',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetPods2',
        ...params
      ]);
  }
}
export function __handleGetPods2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetPods2(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetPods2Query<TSelectData = Types.PodList, TError = unknown>(dto: HandleGetPods2QueryParameters, options?: Omit<UseQueryOptions<Types.PodList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Pods in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Pod
 * @return OK
 */
export function useHandleGetPods2Query<TSelectData = Types.PodList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, options?: Omit<UseQueryOptions<Types.PodList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetPods2Query<TSelectData = Types.PodList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PodList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetPods2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PodList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetPods2(context, axiosConfig) : __handleGetPods2,
    queryKey: handleGetPods2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    ...handleGetPods2DefaultOptions as unknown as Omit<UseQueryOptions<Types.PodList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Pods in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Pod
 * @return OK
 */
export function setHandleGetPods2Data(queryClient: QueryClient, updater: (data: Types.PodList | undefined) => Types.PodList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string) {
  queryClient.setQueryData(handleGetPods2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    updater
  );
}

/**
 * returns a list of Pods in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Pod
 * @return OK
 */
export function setHandleGetPods2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PodList | undefined) => Types.PodList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetPodDetailUrl(namespace: string, pod: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/pod/{namespace}/{pod}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (pod === undefined || pod === null)
  throw new Error("The parameter 'pod' must be defined.");
url_ = url_.replace("{pod}", encodeURIComponent("" + pod));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetPodDetailDefaultOptions: Omit<UseQueryOptions<Types.PodDetail, unknown, Types.PodDetail>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PodDetail, unknown, Types.PodDetail>, 'queryFn'>> = {
};
export function getHandleGetPodDetailDefaultOptions() {
  return handleGetPodDetailDefaultOptions;
};
export function setHandleGetPodDetailDefaultOptions(options: typeof handleGetPodDetailDefaultOptions) {
  handleGetPodDetailDefaultOptions = options;
}

export function handleGetPodDetailQueryKey(dto: HandleGetPodDetailQueryParameters): QueryKey;
export function handleGetPodDetailQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, pod: string): QueryKey;
export function handleGetPodDetailQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod,  } = params[0] as HandleGetPodDetailQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetPodDetail',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        pod as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetPodDetail',
        ...params
      ]);
  }
}
export function __handleGetPodDetail(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetPodDetail(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetPodDetailQuery<TSelectData = Types.PodDetail, TError = unknown>(dto: HandleGetPodDetailQueryParameters, options?: Omit<UseQueryOptions<Types.PodDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns detailed information about Pod
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Pod
 * @param pod name of the Pod
 * @return OK
 */
export function useHandleGetPodDetailQuery<TSelectData = Types.PodDetail, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, pod: string, options?: Omit<UseQueryOptions<Types.PodDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetPodDetailQuery<TSelectData = Types.PodDetail, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PodDetail, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let pod: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod,  } = params[0] as HandleGetPodDetailQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PodDetail, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetPodDetail(context, axiosConfig) : __handleGetPodDetail,
    queryKey: handleGetPodDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod),
    ...handleGetPodDetailDefaultOptions as unknown as Omit<UseQueryOptions<Types.PodDetail, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns detailed information about Pod
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Pod
 * @param pod name of the Pod
 * @return OK
 */
export function setHandleGetPodDetailData(queryClient: QueryClient, updater: (data: Types.PodDetail | undefined) => Types.PodDetail, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, pod: string) {
  queryClient.setQueryData(handleGetPodDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod),
    updater
  );
}

/**
 * returns detailed information about Pod
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Pod
 * @param pod name of the Pod
 * @return OK
 */
export function setHandleGetPodDetailDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PodDetail | undefined) => Types.PodDetail) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetPodContainersUrl(namespace: string, pod: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/pod/{namespace}/{pod}/container?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (pod === undefined || pod === null)
  throw new Error("The parameter 'pod' must be defined.");
url_ = url_.replace("{pod}", encodeURIComponent("" + pod));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetPodContainersDefaultOptions: Omit<UseQueryOptions<Types.PodDetail, unknown, Types.PodDetail>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PodDetail, unknown, Types.PodDetail>, 'queryFn'>> = {
};
export function getHandleGetPodContainersDefaultOptions() {
  return handleGetPodContainersDefaultOptions;
};
export function setHandleGetPodContainersDefaultOptions(options: typeof handleGetPodContainersDefaultOptions) {
  handleGetPodContainersDefaultOptions = options;
}

export function handleGetPodContainersQueryKey(dto: HandleGetPodContainersQueryParameters): QueryKey;
export function handleGetPodContainersQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, pod: string): QueryKey;
export function handleGetPodContainersQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod,  } = params[0] as HandleGetPodContainersQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetPodContainers',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        pod as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetPodContainers',
        ...params
      ]);
  }
}
export function __handleGetPodContainers(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetPodContainers(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetPodContainersQuery<TSelectData = Types.PodDetail, TError = unknown>(dto: HandleGetPodContainersQueryParameters, options?: Omit<UseQueryOptions<Types.PodDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of containers for Pod
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Pod
 * @param pod name of the Pod
 * @return OK
 */
export function useHandleGetPodContainersQuery<TSelectData = Types.PodDetail, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, pod: string, options?: Omit<UseQueryOptions<Types.PodDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetPodContainersQuery<TSelectData = Types.PodDetail, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PodDetail, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let pod: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod,  } = params[0] as HandleGetPodContainersQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PodDetail, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetPodContainers(context, axiosConfig) : __handleGetPodContainers,
    queryKey: handleGetPodContainersQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod),
    ...handleGetPodContainersDefaultOptions as unknown as Omit<UseQueryOptions<Types.PodDetail, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of containers for Pod
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Pod
 * @param pod name of the Pod
 * @return OK
 */
export function setHandleGetPodContainersData(queryClient: QueryClient, updater: (data: Types.PodDetail | undefined) => Types.PodDetail, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, pod: string) {
  queryClient.setQueryData(handleGetPodContainersQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod),
    updater
  );
}

/**
 * returns a list of containers for Pod
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Pod
 * @param pod name of the Pod
 * @return OK
 */
export function setHandleGetPodContainersDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PodDetail | undefined) => Types.PodDetail) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetPodEventsUrl(namespace: string, pod: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/pod/{namespace}/{pod}/event?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (pod === undefined || pod === null)
  throw new Error("The parameter 'pod' must be defined.");
url_ = url_.replace("{pod}", encodeURIComponent("" + pod));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetPodEventsDefaultOptions: Omit<UseQueryOptions<Types.EventList, unknown, Types.EventList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.EventList, unknown, Types.EventList>, 'queryFn'>> = {
};
export function getHandleGetPodEventsDefaultOptions() {
  return handleGetPodEventsDefaultOptions;
};
export function setHandleGetPodEventsDefaultOptions(options: typeof handleGetPodEventsDefaultOptions) {
  handleGetPodEventsDefaultOptions = options;
}

export function handleGetPodEventsQueryKey(dto: HandleGetPodEventsQueryParameters): QueryKey;
export function handleGetPodEventsQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, pod: string): QueryKey;
export function handleGetPodEventsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod,  } = params[0] as HandleGetPodEventsQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetPodEvents',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        pod as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetPodEvents',
        ...params
      ]);
  }
}
export function __handleGetPodEvents(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetPodEvents(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetPodEventsQuery<TSelectData = Types.EventList, TError = unknown>(dto: HandleGetPodEventsQueryParameters, options?: Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Events for Pod
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Pod
 * @param pod name of the Pod
 * @return OK
 */
export function useHandleGetPodEventsQuery<TSelectData = Types.EventList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, pod: string, options?: Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetPodEventsQuery<TSelectData = Types.EventList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.EventList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let pod: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod,  } = params[0] as HandleGetPodEventsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.EventList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetPodEvents(context, axiosConfig) : __handleGetPodEvents,
    queryKey: handleGetPodEventsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod),
    ...handleGetPodEventsDefaultOptions as unknown as Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Events for Pod
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Pod
 * @param pod name of the Pod
 * @return OK
 */
export function setHandleGetPodEventsData(queryClient: QueryClient, updater: (data: Types.EventList | undefined) => Types.EventList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, pod: string) {
  queryClient.setQueryData(handleGetPodEventsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod),
    updater
  );
}

/**
 * returns a list of Events for Pod
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Pod
 * @param pod name of the Pod
 * @return OK
 */
export function setHandleGetPodEventsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.EventList | undefined) => Types.EventList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetPodPersistentVolumeClaimsUrl(namespace: string, pod: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/pod/{namespace}/{pod}/persistentvolumeclaim?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (pod === undefined || pod === null)
  throw new Error("The parameter 'pod' must be defined.");
url_ = url_.replace("{pod}", encodeURIComponent("" + pod));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetPodPersistentVolumeClaimsDefaultOptions: Omit<UseQueryOptions<Types.PersistentVolumeClaimList, unknown, Types.PersistentVolumeClaimList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PersistentVolumeClaimList, unknown, Types.PersistentVolumeClaimList>, 'queryFn'>> = {
};
export function getHandleGetPodPersistentVolumeClaimsDefaultOptions() {
  return handleGetPodPersistentVolumeClaimsDefaultOptions;
};
export function setHandleGetPodPersistentVolumeClaimsDefaultOptions(options: typeof handleGetPodPersistentVolumeClaimsDefaultOptions) {
  handleGetPodPersistentVolumeClaimsDefaultOptions = options;
}

export function handleGetPodPersistentVolumeClaimsQueryKey(dto: HandleGetPodPersistentVolumeClaimsQueryParameters): QueryKey;
export function handleGetPodPersistentVolumeClaimsQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, pod: string): QueryKey;
export function handleGetPodPersistentVolumeClaimsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod,  } = params[0] as HandleGetPodPersistentVolumeClaimsQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetPodPersistentVolumeClaims',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        pod as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetPodPersistentVolumeClaims',
        ...params
      ]);
  }
}
export function __handleGetPodPersistentVolumeClaims(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetPodPersistentVolumeClaims(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetPodPersistentVolumeClaimsQuery<TSelectData = Types.PersistentVolumeClaimList, TError = unknown>(dto: HandleGetPodPersistentVolumeClaimsQueryParameters, options?: Omit<UseQueryOptions<Types.PersistentVolumeClaimList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of containers for Pod
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Pod
 * @param pod name of the Pod
 * @return OK
 */
export function useHandleGetPodPersistentVolumeClaimsQuery<TSelectData = Types.PersistentVolumeClaimList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, pod: string, options?: Omit<UseQueryOptions<Types.PersistentVolumeClaimList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetPodPersistentVolumeClaimsQuery<TSelectData = Types.PersistentVolumeClaimList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PersistentVolumeClaimList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let pod: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod,  } = params[0] as HandleGetPodPersistentVolumeClaimsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PersistentVolumeClaimList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetPodPersistentVolumeClaims(context, axiosConfig) : __handleGetPodPersistentVolumeClaims,
    queryKey: handleGetPodPersistentVolumeClaimsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod),
    ...handleGetPodPersistentVolumeClaimsDefaultOptions as unknown as Omit<UseQueryOptions<Types.PersistentVolumeClaimList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of containers for Pod
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Pod
 * @param pod name of the Pod
 * @return OK
 */
export function setHandleGetPodPersistentVolumeClaimsData(queryClient: QueryClient, updater: (data: Types.PersistentVolumeClaimList | undefined) => Types.PersistentVolumeClaimList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, pod: string) {
  queryClient.setQueryData(handleGetPodPersistentVolumeClaimsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod),
    updater
  );
}

/**
 * returns a list of containers for Pod
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Pod
 * @param pod name of the Pod
 * @return OK
 */
export function setHandleGetPodPersistentVolumeClaimsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PersistentVolumeClaimList | undefined) => Types.PersistentVolumeClaimList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleExecShellUrl(namespace: string, pod: string, container: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/pod/{namespace}/{pod}/shell/{container}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (pod === undefined || pod === null)
  throw new Error("The parameter 'pod' must be defined.");
url_ = url_.replace("{pod}", encodeURIComponent("" + pod));
if (container === undefined || container === null)
  throw new Error("The parameter 'container' must be defined.");
url_ = url_.replace("{container}", encodeURIComponent("" + container));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleExecShellDefaultOptions: Omit<UseQueryOptions<Types.TerminalResponse, unknown, Types.TerminalResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.TerminalResponse, unknown, Types.TerminalResponse>, 'queryFn'>> = {
};
export function getHandleExecShellDefaultOptions() {
  return handleExecShellDefaultOptions;
};
export function setHandleExecShellDefaultOptions(options: typeof handleExecShellDefaultOptions) {
  handleExecShellDefaultOptions = options;
}

export function handleExecShellQueryKey(dto: HandleExecShellQueryParameters): QueryKey;
export function handleExecShellQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, pod: string, container: string): QueryKey;
export function handleExecShellQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod, container,  } = params[0] as HandleExecShellQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleExecShell',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        pod as any,
        container as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleExecShell',
        ...params
      ]);
  }
}
export function __handleExecShell(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleExecShell(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string,       context.queryKey[10] as string);
}

export function useHandleExecShellQuery<TSelectData = Types.TerminalResponse, TError = unknown>(dto: HandleExecShellQueryParameters, options?: Omit<UseQueryOptions<Types.TerminalResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * handles exec into pod
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Pod
 * @param pod name of the Pod
 * @param container name of container in the Pod
 * @return OK
 */
export function useHandleExecShellQuery<TSelectData = Types.TerminalResponse, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, pod: string, container: string, options?: Omit<UseQueryOptions<Types.TerminalResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleExecShellQuery<TSelectData = Types.TerminalResponse, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.TerminalResponse, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let pod: any = undefined;
  let container: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod, container,  } = params[0] as HandleExecShellQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod, container, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.TerminalResponse, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleExecShell(context, axiosConfig) : __handleExecShell,
    queryKey: handleExecShellQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod, container),
    ...handleExecShellDefaultOptions as unknown as Omit<UseQueryOptions<Types.TerminalResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * handles exec into pod
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Pod
 * @param pod name of the Pod
 * @param container name of container in the Pod
 * @return OK
 */
export function setHandleExecShellData(queryClient: QueryClient, updater: (data: Types.TerminalResponse | undefined) => Types.TerminalResponse, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, pod: string, container: string) {
  queryClient.setQueryData(handleExecShellQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, pod, container),
    updater
  );
}

/**
 * handles exec into pod
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Pod
 * @param pod name of the Pod
 * @param container name of container in the Pod
 * @return OK
 */
export function setHandleExecShellDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.TerminalResponse | undefined) => Types.TerminalResponse) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetPodDisruptionBudgetListUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/poddisruptionbudget?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetPodDisruptionBudgetListDefaultOptions: Omit<UseQueryOptions<Types.PodDisruptionBudgetList, unknown, Types.PodDisruptionBudgetList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PodDisruptionBudgetList, unknown, Types.PodDisruptionBudgetList>, 'queryFn'>> = {
};
export function getHandleGetPodDisruptionBudgetListDefaultOptions() {
  return handleGetPodDisruptionBudgetListDefaultOptions;
};
export function setHandleGetPodDisruptionBudgetListDefaultOptions(options: typeof handleGetPodDisruptionBudgetListDefaultOptions) {
  handleGetPodDisruptionBudgetListDefaultOptions = options;
}

export function handleGetPodDisruptionBudgetListQueryKey(dto: HandleGetPodDisruptionBudgetListQueryParameters): QueryKey;
export function handleGetPodDisruptionBudgetListQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): QueryKey;
export function handleGetPodDisruptionBudgetListQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetPodDisruptionBudgetListQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetPodDisruptionBudgetList',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetPodDisruptionBudgetList',
        ...params
      ]);
  }
}
export function __handleGetPodDisruptionBudgetList(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetPodDisruptionBudgetList(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined);
}

export function useHandleGetPodDisruptionBudgetListQuery<TSelectData = Types.PodDisruptionBudgetList, TError = unknown>(dto: HandleGetPodDisruptionBudgetListQueryParameters, options?: Omit<UseQueryOptions<Types.PodDisruptionBudgetList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of PodDisruptionBudget
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleGetPodDisruptionBudgetListQuery<TSelectData = Types.PodDisruptionBudgetList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseQueryOptions<Types.PodDisruptionBudgetList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetPodDisruptionBudgetListQuery<TSelectData = Types.PodDisruptionBudgetList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PodDisruptionBudgetList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetPodDisruptionBudgetListQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PodDisruptionBudgetList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetPodDisruptionBudgetList(context, axiosConfig) : __handleGetPodDisruptionBudgetList,
    queryKey: handleGetPodDisruptionBudgetListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    ...handleGetPodDisruptionBudgetListDefaultOptions as unknown as Omit<UseQueryOptions<Types.PodDisruptionBudgetList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of PodDisruptionBudget
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetPodDisruptionBudgetListData(queryClient: QueryClient, updater: (data: Types.PodDisruptionBudgetList | undefined) => Types.PodDisruptionBudgetList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined) {
  queryClient.setQueryData(handleGetPodDisruptionBudgetListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    updater
  );
}

/**
 * returns a list of PodDisruptionBudget
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetPodDisruptionBudgetListDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PodDisruptionBudgetList | undefined) => Types.PodDisruptionBudgetList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetPodDisruptionBudgetList2Url(namespace: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/poddisruptionbudget/{namespace}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetPodDisruptionBudgetList2DefaultOptions: Omit<UseQueryOptions<Types.PodDisruptionBudgetList, unknown, Types.PodDisruptionBudgetList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PodDisruptionBudgetList, unknown, Types.PodDisruptionBudgetList>, 'queryFn'>> = {
};
export function getHandleGetPodDisruptionBudgetList2DefaultOptions() {
  return handleGetPodDisruptionBudgetList2DefaultOptions;
};
export function setHandleGetPodDisruptionBudgetList2DefaultOptions(options: typeof handleGetPodDisruptionBudgetList2DefaultOptions) {
  handleGetPodDisruptionBudgetList2DefaultOptions = options;
}

export function handleGetPodDisruptionBudgetList2QueryKey(dto: HandleGetPodDisruptionBudgetList2QueryParameters): QueryKey;
export function handleGetPodDisruptionBudgetList2QueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string): QueryKey;
export function handleGetPodDisruptionBudgetList2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetPodDisruptionBudgetList2QueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetPodDisruptionBudgetList2',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetPodDisruptionBudgetList2',
        ...params
      ]);
  }
}
export function __handleGetPodDisruptionBudgetList2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetPodDisruptionBudgetList2(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetPodDisruptionBudgetList2Query<TSelectData = Types.PodDisruptionBudgetList, TError = unknown>(dto: HandleGetPodDisruptionBudgetList2QueryParameters, options?: Omit<UseQueryOptions<Types.PodDisruptionBudgetList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of PodDisruptionBudget from specified namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the PodDisruptionBudget
 * @return OK
 */
export function useHandleGetPodDisruptionBudgetList2Query<TSelectData = Types.PodDisruptionBudgetList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, options?: Omit<UseQueryOptions<Types.PodDisruptionBudgetList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetPodDisruptionBudgetList2Query<TSelectData = Types.PodDisruptionBudgetList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PodDisruptionBudgetList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetPodDisruptionBudgetList2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PodDisruptionBudgetList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetPodDisruptionBudgetList2(context, axiosConfig) : __handleGetPodDisruptionBudgetList2,
    queryKey: handleGetPodDisruptionBudgetList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    ...handleGetPodDisruptionBudgetList2DefaultOptions as unknown as Omit<UseQueryOptions<Types.PodDisruptionBudgetList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of PodDisruptionBudget from specified namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the PodDisruptionBudget
 * @return OK
 */
export function setHandleGetPodDisruptionBudgetList2Data(queryClient: QueryClient, updater: (data: Types.PodDisruptionBudgetList | undefined) => Types.PodDisruptionBudgetList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string) {
  queryClient.setQueryData(handleGetPodDisruptionBudgetList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    updater
  );
}

/**
 * returns a list of PodDisruptionBudget from specified namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the PodDisruptionBudget
 * @return OK
 */
export function setHandleGetPodDisruptionBudgetList2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PodDisruptionBudgetList | undefined) => Types.PodDisruptionBudgetList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetPodDisruptionBudgetDetailUrl(name: string, namespace: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/poddisruptionbudget/{namespace}/{name}?";
if (name === undefined || name === null)
  throw new Error("The parameter 'name' must be defined.");
url_ = url_.replace("{name}", encodeURIComponent("" + name));
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetPodDisruptionBudgetDetailDefaultOptions: Omit<UseQueryOptions<Types.PodDisruptionBudgetDetail, unknown, Types.PodDisruptionBudgetDetail>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PodDisruptionBudgetDetail, unknown, Types.PodDisruptionBudgetDetail>, 'queryFn'>> = {
};
export function getHandleGetPodDisruptionBudgetDetailDefaultOptions() {
  return handleGetPodDisruptionBudgetDetailDefaultOptions;
};
export function setHandleGetPodDisruptionBudgetDetailDefaultOptions(options: typeof handleGetPodDisruptionBudgetDetailDefaultOptions) {
  handleGetPodDisruptionBudgetDetailDefaultOptions = options;
}

export function handleGetPodDisruptionBudgetDetailQueryKey(dto: HandleGetPodDisruptionBudgetDetailQueryParameters): QueryKey;
export function handleGetPodDisruptionBudgetDetailQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, name: string, namespace: string): QueryKey;
export function handleGetPodDisruptionBudgetDetailQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name, namespace,  } = params[0] as HandleGetPodDisruptionBudgetDetailQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetPodDisruptionBudgetDetail',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        name as any,
        namespace as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetPodDisruptionBudgetDetail',
        ...params
      ]);
  }
}
export function __handleGetPodDisruptionBudgetDetail(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetPodDisruptionBudgetDetail(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetPodDisruptionBudgetDetailQuery<TSelectData = Types.PodDisruptionBudgetDetail, TError = unknown>(dto: HandleGetPodDisruptionBudgetDetailQueryParameters, options?: Omit<UseQueryOptions<Types.PodDisruptionBudgetDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns detailed information about PodDisruptionBudget
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param name name of the PodDisruptionBudget
 * @param namespace namespace of the PodDisruptionBudget
 * @return OK
 */
export function useHandleGetPodDisruptionBudgetDetailQuery<TSelectData = Types.PodDisruptionBudgetDetail, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, name: string, namespace: string, options?: Omit<UseQueryOptions<Types.PodDisruptionBudgetDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetPodDisruptionBudgetDetailQuery<TSelectData = Types.PodDisruptionBudgetDetail, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PodDisruptionBudgetDetail, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let name: any = undefined;
  let namespace: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name, namespace,  } = params[0] as HandleGetPodDisruptionBudgetDetailQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name, namespace, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PodDisruptionBudgetDetail, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetPodDisruptionBudgetDetail(context, axiosConfig) : __handleGetPodDisruptionBudgetDetail,
    queryKey: handleGetPodDisruptionBudgetDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name, namespace),
    ...handleGetPodDisruptionBudgetDetailDefaultOptions as unknown as Omit<UseQueryOptions<Types.PodDisruptionBudgetDetail, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns detailed information about PodDisruptionBudget
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param name name of the PodDisruptionBudget
 * @param namespace namespace of the PodDisruptionBudget
 * @return OK
 */
export function setHandleGetPodDisruptionBudgetDetailData(queryClient: QueryClient, updater: (data: Types.PodDisruptionBudgetDetail | undefined) => Types.PodDisruptionBudgetDetail, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, name: string, namespace: string) {
  queryClient.setQueryData(handleGetPodDisruptionBudgetDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, name, namespace),
    updater
  );
}

/**
 * returns detailed information about PodDisruptionBudget
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param name name of the PodDisruptionBudget
 * @param namespace namespace of the PodDisruptionBudget
 * @return OK
 */
export function setHandleGetPodDisruptionBudgetDetailDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PodDisruptionBudgetDetail | undefined) => Types.PodDisruptionBudgetDetail) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetReplicaSetsUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/replicaset?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetReplicaSetsDefaultOptions: Omit<UseQueryOptions<Types.ReplicaSetList, unknown, Types.ReplicaSetList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ReplicaSetList, unknown, Types.ReplicaSetList>, 'queryFn'>> = {
};
export function getHandleGetReplicaSetsDefaultOptions() {
  return handleGetReplicaSetsDefaultOptions;
};
export function setHandleGetReplicaSetsDefaultOptions(options: typeof handleGetReplicaSetsDefaultOptions) {
  handleGetReplicaSetsDefaultOptions = options;
}

export function handleGetReplicaSetsQueryKey(dto: HandleGetReplicaSetsQueryParameters): QueryKey;
export function handleGetReplicaSetsQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): QueryKey;
export function handleGetReplicaSetsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetReplicaSetsQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetReplicaSets',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetReplicaSets',
        ...params
      ]);
  }
}
export function __handleGetReplicaSets(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetReplicaSets(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined);
}

export function useHandleGetReplicaSetsQuery<TSelectData = Types.ReplicaSetList, TError = unknown>(dto: HandleGetReplicaSetsQueryParameters, options?: Omit<UseQueryOptions<Types.ReplicaSetList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of ReplicaSets from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleGetReplicaSetsQuery<TSelectData = Types.ReplicaSetList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseQueryOptions<Types.ReplicaSetList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetReplicaSetsQuery<TSelectData = Types.ReplicaSetList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ReplicaSetList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetReplicaSetsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ReplicaSetList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetReplicaSets(context, axiosConfig) : __handleGetReplicaSets,
    queryKey: handleGetReplicaSetsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    ...handleGetReplicaSetsDefaultOptions as unknown as Omit<UseQueryOptions<Types.ReplicaSetList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of ReplicaSets from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetReplicaSetsData(queryClient: QueryClient, updater: (data: Types.ReplicaSetList | undefined) => Types.ReplicaSetList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined) {
  queryClient.setQueryData(handleGetReplicaSetsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    updater
  );
}

/**
 * returns a list of ReplicaSets from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetReplicaSetsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ReplicaSetList | undefined) => Types.ReplicaSetList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetReplicaSets2Url(namespace: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/replicaset/{namespace}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetReplicaSets2DefaultOptions: Omit<UseQueryOptions<Types.ReplicaSetList, unknown, Types.ReplicaSetList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ReplicaSetList, unknown, Types.ReplicaSetList>, 'queryFn'>> = {
};
export function getHandleGetReplicaSets2DefaultOptions() {
  return handleGetReplicaSets2DefaultOptions;
};
export function setHandleGetReplicaSets2DefaultOptions(options: typeof handleGetReplicaSets2DefaultOptions) {
  handleGetReplicaSets2DefaultOptions = options;
}

export function handleGetReplicaSets2QueryKey(dto: HandleGetReplicaSets2QueryParameters): QueryKey;
export function handleGetReplicaSets2QueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string): QueryKey;
export function handleGetReplicaSets2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetReplicaSets2QueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetReplicaSets2',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetReplicaSets2',
        ...params
      ]);
  }
}
export function __handleGetReplicaSets2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetReplicaSets2(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetReplicaSets2Query<TSelectData = Types.ReplicaSetList, TError = unknown>(dto: HandleGetReplicaSets2QueryParameters, options?: Omit<UseQueryOptions<Types.ReplicaSetList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of ReplicaSets in a namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ReplicaSets
 * @return OK
 */
export function useHandleGetReplicaSets2Query<TSelectData = Types.ReplicaSetList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, options?: Omit<UseQueryOptions<Types.ReplicaSetList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetReplicaSets2Query<TSelectData = Types.ReplicaSetList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ReplicaSetList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetReplicaSets2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ReplicaSetList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetReplicaSets2(context, axiosConfig) : __handleGetReplicaSets2,
    queryKey: handleGetReplicaSets2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    ...handleGetReplicaSets2DefaultOptions as unknown as Omit<UseQueryOptions<Types.ReplicaSetList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of ReplicaSets in a namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ReplicaSets
 * @return OK
 */
export function setHandleGetReplicaSets2Data(queryClient: QueryClient, updater: (data: Types.ReplicaSetList | undefined) => Types.ReplicaSetList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string) {
  queryClient.setQueryData(handleGetReplicaSets2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    updater
  );
}

/**
 * returns a list of ReplicaSets in a namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ReplicaSets
 * @return OK
 */
export function setHandleGetReplicaSets2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ReplicaSetList | undefined) => Types.ReplicaSetList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetReplicaSetDetailUrl(namespace: string, replicaSet: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/replicaset/{namespace}/{replicaSet}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (replicaSet === undefined || replicaSet === null)
  throw new Error("The parameter 'replicaSet' must be defined.");
url_ = url_.replace("{replicaSet}", encodeURIComponent("" + replicaSet));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetReplicaSetDetailDefaultOptions: Omit<UseQueryOptions<Types.ReplicaSetDetail, unknown, Types.ReplicaSetDetail>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ReplicaSetDetail, unknown, Types.ReplicaSetDetail>, 'queryFn'>> = {
};
export function getHandleGetReplicaSetDetailDefaultOptions() {
  return handleGetReplicaSetDetailDefaultOptions;
};
export function setHandleGetReplicaSetDetailDefaultOptions(options: typeof handleGetReplicaSetDetailDefaultOptions) {
  handleGetReplicaSetDetailDefaultOptions = options;
}

export function handleGetReplicaSetDetailQueryKey(dto: HandleGetReplicaSetDetailQueryParameters): QueryKey;
export function handleGetReplicaSetDetailQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, replicaSet: string): QueryKey;
export function handleGetReplicaSetDetailQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicaSet,  } = params[0] as HandleGetReplicaSetDetailQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetReplicaSetDetail',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        replicaSet as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetReplicaSetDetail',
        ...params
      ]);
  }
}
export function __handleGetReplicaSetDetail(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetReplicaSetDetail(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetReplicaSetDetailQuery<TSelectData = Types.ReplicaSetDetail, TError = unknown>(dto: HandleGetReplicaSetDetailQueryParameters, options?: Omit<UseQueryOptions<Types.ReplicaSetDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns detailed information about ReplicaSet
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ReplicaSet
 * @param replicaSet name of the ReplicaSets
 * @return OK
 */
export function useHandleGetReplicaSetDetailQuery<TSelectData = Types.ReplicaSetDetail, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, replicaSet: string, options?: Omit<UseQueryOptions<Types.ReplicaSetDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetReplicaSetDetailQuery<TSelectData = Types.ReplicaSetDetail, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ReplicaSetDetail, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let replicaSet: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicaSet,  } = params[0] as HandleGetReplicaSetDetailQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicaSet, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ReplicaSetDetail, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetReplicaSetDetail(context, axiosConfig) : __handleGetReplicaSetDetail,
    queryKey: handleGetReplicaSetDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicaSet),
    ...handleGetReplicaSetDetailDefaultOptions as unknown as Omit<UseQueryOptions<Types.ReplicaSetDetail, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns detailed information about ReplicaSet
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ReplicaSet
 * @param replicaSet name of the ReplicaSets
 * @return OK
 */
export function setHandleGetReplicaSetDetailData(queryClient: QueryClient, updater: (data: Types.ReplicaSetDetail | undefined) => Types.ReplicaSetDetail, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, replicaSet: string) {
  queryClient.setQueryData(handleGetReplicaSetDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicaSet),
    updater
  );
}

/**
 * returns detailed information about ReplicaSet
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ReplicaSet
 * @param replicaSet name of the ReplicaSets
 * @return OK
 */
export function setHandleGetReplicaSetDetailDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ReplicaSetDetail | undefined) => Types.ReplicaSetDetail) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetReplicaSetEventsUrl(namespace: string, replicaSet: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/replicaset/{namespace}/{replicaSet}/event?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (replicaSet === undefined || replicaSet === null)
  throw new Error("The parameter 'replicaSet' must be defined.");
url_ = url_.replace("{replicaSet}", encodeURIComponent("" + replicaSet));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetReplicaSetEventsDefaultOptions: Omit<UseQueryOptions<Types.EventList, unknown, Types.EventList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.EventList, unknown, Types.EventList>, 'queryFn'>> = {
};
export function getHandleGetReplicaSetEventsDefaultOptions() {
  return handleGetReplicaSetEventsDefaultOptions;
};
export function setHandleGetReplicaSetEventsDefaultOptions(options: typeof handleGetReplicaSetEventsDefaultOptions) {
  handleGetReplicaSetEventsDefaultOptions = options;
}

export function handleGetReplicaSetEventsQueryKey(dto: HandleGetReplicaSetEventsQueryParameters): QueryKey;
export function handleGetReplicaSetEventsQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, replicaSet: string): QueryKey;
export function handleGetReplicaSetEventsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicaSet,  } = params[0] as HandleGetReplicaSetEventsQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetReplicaSetEvents',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        replicaSet as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetReplicaSetEvents',
        ...params
      ]);
  }
}
export function __handleGetReplicaSetEvents(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetReplicaSetEvents(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetReplicaSetEventsQuery<TSelectData = Types.EventList, TError = unknown>(dto: HandleGetReplicaSetEventsQueryParameters, options?: Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Events for ReplicaSet
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ReplicaSet
 * @param replicaSet name of the ReplicaSets
 * @return OK
 */
export function useHandleGetReplicaSetEventsQuery<TSelectData = Types.EventList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, replicaSet: string, options?: Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetReplicaSetEventsQuery<TSelectData = Types.EventList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.EventList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let replicaSet: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicaSet,  } = params[0] as HandleGetReplicaSetEventsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicaSet, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.EventList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetReplicaSetEvents(context, axiosConfig) : __handleGetReplicaSetEvents,
    queryKey: handleGetReplicaSetEventsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicaSet),
    ...handleGetReplicaSetEventsDefaultOptions as unknown as Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Events for ReplicaSet
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ReplicaSet
 * @param replicaSet name of the ReplicaSets
 * @return OK
 */
export function setHandleGetReplicaSetEventsData(queryClient: QueryClient, updater: (data: Types.EventList | undefined) => Types.EventList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, replicaSet: string) {
  queryClient.setQueryData(handleGetReplicaSetEventsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicaSet),
    updater
  );
}

/**
 * returns a list of Events for ReplicaSet
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ReplicaSet
 * @param replicaSet name of the ReplicaSets
 * @return OK
 */
export function setHandleGetReplicaSetEventsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.EventList | undefined) => Types.EventList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetReplicaSetPodsUrl(namespace: string, replicaSet: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/replicaset/{namespace}/{replicaSet}/pod?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (replicaSet === undefined || replicaSet === null)
  throw new Error("The parameter 'replicaSet' must be defined.");
url_ = url_.replace("{replicaSet}", encodeURIComponent("" + replicaSet));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetReplicaSetPodsDefaultOptions: Omit<UseQueryOptions<Types.PodList, unknown, Types.PodList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PodList, unknown, Types.PodList>, 'queryFn'>> = {
};
export function getHandleGetReplicaSetPodsDefaultOptions() {
  return handleGetReplicaSetPodsDefaultOptions;
};
export function setHandleGetReplicaSetPodsDefaultOptions(options: typeof handleGetReplicaSetPodsDefaultOptions) {
  handleGetReplicaSetPodsDefaultOptions = options;
}

export function handleGetReplicaSetPodsQueryKey(dto: HandleGetReplicaSetPodsQueryParameters): QueryKey;
export function handleGetReplicaSetPodsQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, replicaSet: string): QueryKey;
export function handleGetReplicaSetPodsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicaSet,  } = params[0] as HandleGetReplicaSetPodsQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetReplicaSetPods',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        replicaSet as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetReplicaSetPods',
        ...params
      ]);
  }
}
export function __handleGetReplicaSetPods(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetReplicaSetPods(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetReplicaSetPodsQuery<TSelectData = Types.PodList, TError = unknown>(dto: HandleGetReplicaSetPodsQueryParameters, options?: Omit<UseQueryOptions<Types.PodList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Pods for ReplicaSet
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ReplicaSet
 * @param replicaSet name of the ReplicaSets
 * @return OK
 */
export function useHandleGetReplicaSetPodsQuery<TSelectData = Types.PodList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, replicaSet: string, options?: Omit<UseQueryOptions<Types.PodList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetReplicaSetPodsQuery<TSelectData = Types.PodList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PodList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let replicaSet: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicaSet,  } = params[0] as HandleGetReplicaSetPodsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicaSet, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PodList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetReplicaSetPods(context, axiosConfig) : __handleGetReplicaSetPods,
    queryKey: handleGetReplicaSetPodsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicaSet),
    ...handleGetReplicaSetPodsDefaultOptions as unknown as Omit<UseQueryOptions<Types.PodList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Pods for ReplicaSet
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ReplicaSet
 * @param replicaSet name of the ReplicaSets
 * @return OK
 */
export function setHandleGetReplicaSetPodsData(queryClient: QueryClient, updater: (data: Types.PodList | undefined) => Types.PodList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, replicaSet: string) {
  queryClient.setQueryData(handleGetReplicaSetPodsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicaSet),
    updater
  );
}

/**
 * returns a list of Pods for ReplicaSet
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ReplicaSet
 * @param replicaSet name of the ReplicaSets
 * @return OK
 */
export function setHandleGetReplicaSetPodsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PodList | undefined) => Types.PodList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetReplicaSetServicesUrl(namespace: string, replicaSet: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/replicaset/{namespace}/{replicaSet}/service?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (replicaSet === undefined || replicaSet === null)
  throw new Error("The parameter 'replicaSet' must be defined.");
url_ = url_.replace("{replicaSet}", encodeURIComponent("" + replicaSet));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetReplicaSetServicesDefaultOptions: Omit<UseQueryOptions<Types.ServiceList, unknown, Types.ServiceList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ServiceList, unknown, Types.ServiceList>, 'queryFn'>> = {
};
export function getHandleGetReplicaSetServicesDefaultOptions() {
  return handleGetReplicaSetServicesDefaultOptions;
};
export function setHandleGetReplicaSetServicesDefaultOptions(options: typeof handleGetReplicaSetServicesDefaultOptions) {
  handleGetReplicaSetServicesDefaultOptions = options;
}

export function handleGetReplicaSetServicesQueryKey(dto: HandleGetReplicaSetServicesQueryParameters): QueryKey;
export function handleGetReplicaSetServicesQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, replicaSet: string): QueryKey;
export function handleGetReplicaSetServicesQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicaSet,  } = params[0] as HandleGetReplicaSetServicesQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetReplicaSetServices',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        replicaSet as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetReplicaSetServices',
        ...params
      ]);
  }
}
export function __handleGetReplicaSetServices(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetReplicaSetServices(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetReplicaSetServicesQuery<TSelectData = Types.ServiceList, TError = unknown>(dto: HandleGetReplicaSetServicesQueryParameters, options?: Omit<UseQueryOptions<Types.ServiceList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Services for ReplicaSet
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ReplicaSet
 * @param replicaSet name of the ReplicaSets
 * @return OK
 */
export function useHandleGetReplicaSetServicesQuery<TSelectData = Types.ServiceList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, replicaSet: string, options?: Omit<UseQueryOptions<Types.ServiceList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetReplicaSetServicesQuery<TSelectData = Types.ServiceList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ServiceList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let replicaSet: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicaSet,  } = params[0] as HandleGetReplicaSetServicesQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicaSet, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ServiceList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetReplicaSetServices(context, axiosConfig) : __handleGetReplicaSetServices,
    queryKey: handleGetReplicaSetServicesQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicaSet),
    ...handleGetReplicaSetServicesDefaultOptions as unknown as Omit<UseQueryOptions<Types.ServiceList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Services for ReplicaSet
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ReplicaSet
 * @param replicaSet name of the ReplicaSets
 * @return OK
 */
export function setHandleGetReplicaSetServicesData(queryClient: QueryClient, updater: (data: Types.ServiceList | undefined) => Types.ServiceList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, replicaSet: string) {
  queryClient.setQueryData(handleGetReplicaSetServicesQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicaSet),
    updater
  );
}

/**
 * returns a list of Services for ReplicaSet
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ReplicaSet
 * @param replicaSet name of the ReplicaSets
 * @return OK
 */
export function setHandleGetReplicaSetServicesDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ServiceList | undefined) => Types.ServiceList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetReplicationControllerListUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/replicationcontroller?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetReplicationControllerListDefaultOptions: Omit<UseQueryOptions<Types.ReplicationControllerList, unknown, Types.ReplicationControllerList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ReplicationControllerList, unknown, Types.ReplicationControllerList>, 'queryFn'>> = {
};
export function getHandleGetReplicationControllerListDefaultOptions() {
  return handleGetReplicationControllerListDefaultOptions;
};
export function setHandleGetReplicationControllerListDefaultOptions(options: typeof handleGetReplicationControllerListDefaultOptions) {
  handleGetReplicationControllerListDefaultOptions = options;
}

export function handleGetReplicationControllerListQueryKey(dto: HandleGetReplicationControllerListQueryParameters): QueryKey;
export function handleGetReplicationControllerListQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): QueryKey;
export function handleGetReplicationControllerListQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetReplicationControllerListQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetReplicationControllerList',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetReplicationControllerList',
        ...params
      ]);
  }
}
export function __handleGetReplicationControllerList(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetReplicationControllerList(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined);
}

export function useHandleGetReplicationControllerListQuery<TSelectData = Types.ReplicationControllerList, TError = unknown>(dto: HandleGetReplicationControllerListQueryParameters, options?: Omit<UseQueryOptions<Types.ReplicationControllerList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of ReplicationControllers from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleGetReplicationControllerListQuery<TSelectData = Types.ReplicationControllerList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseQueryOptions<Types.ReplicationControllerList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetReplicationControllerListQuery<TSelectData = Types.ReplicationControllerList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ReplicationControllerList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetReplicationControllerListQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ReplicationControllerList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetReplicationControllerList(context, axiosConfig) : __handleGetReplicationControllerList,
    queryKey: handleGetReplicationControllerListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    ...handleGetReplicationControllerListDefaultOptions as unknown as Omit<UseQueryOptions<Types.ReplicationControllerList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of ReplicationControllers from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetReplicationControllerListData(queryClient: QueryClient, updater: (data: Types.ReplicationControllerList | undefined) => Types.ReplicationControllerList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined) {
  queryClient.setQueryData(handleGetReplicationControllerListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    updater
  );
}

/**
 * returns a list of ReplicationControllers from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetReplicationControllerListDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ReplicationControllerList | undefined) => Types.ReplicationControllerList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetReplicationControllerList2Url(namespace: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/replicationcontroller/{namespace}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetReplicationControllerList2DefaultOptions: Omit<UseQueryOptions<Types.ReplicationControllerList, unknown, Types.ReplicationControllerList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ReplicationControllerList, unknown, Types.ReplicationControllerList>, 'queryFn'>> = {
};
export function getHandleGetReplicationControllerList2DefaultOptions() {
  return handleGetReplicationControllerList2DefaultOptions;
};
export function setHandleGetReplicationControllerList2DefaultOptions(options: typeof handleGetReplicationControllerList2DefaultOptions) {
  handleGetReplicationControllerList2DefaultOptions = options;
}

export function handleGetReplicationControllerList2QueryKey(dto: HandleGetReplicationControllerList2QueryParameters): QueryKey;
export function handleGetReplicationControllerList2QueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string): QueryKey;
export function handleGetReplicationControllerList2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetReplicationControllerList2QueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetReplicationControllerList2',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetReplicationControllerList2',
        ...params
      ]);
  }
}
export function __handleGetReplicationControllerList2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetReplicationControllerList2(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetReplicationControllerList2Query<TSelectData = Types.ReplicationControllerList, TError = unknown>(dto: HandleGetReplicationControllerList2QueryParameters, options?: Omit<UseQueryOptions<Types.ReplicationControllerList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of ReplicationController in a namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace to get a list of ReplicationController from
 * @return OK
 */
export function useHandleGetReplicationControllerList2Query<TSelectData = Types.ReplicationControllerList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, options?: Omit<UseQueryOptions<Types.ReplicationControllerList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetReplicationControllerList2Query<TSelectData = Types.ReplicationControllerList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ReplicationControllerList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetReplicationControllerList2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ReplicationControllerList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetReplicationControllerList2(context, axiosConfig) : __handleGetReplicationControllerList2,
    queryKey: handleGetReplicationControllerList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    ...handleGetReplicationControllerList2DefaultOptions as unknown as Omit<UseQueryOptions<Types.ReplicationControllerList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of ReplicationController in a namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace to get a list of ReplicationController from
 * @return OK
 */
export function setHandleGetReplicationControllerList2Data(queryClient: QueryClient, updater: (data: Types.ReplicationControllerList | undefined) => Types.ReplicationControllerList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string) {
  queryClient.setQueryData(handleGetReplicationControllerList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    updater
  );
}

/**
 * returns a list of ReplicationController in a namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace to get a list of ReplicationController from
 * @return OK
 */
export function setHandleGetReplicationControllerList2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ReplicationControllerList | undefined) => Types.ReplicationControllerList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetReplicationControllerDetailUrl(namespace: string, replicationController: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/replicationcontroller/{namespace}/{replicationController}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (replicationController === undefined || replicationController === null)
  throw new Error("The parameter 'replicationController' must be defined.");
url_ = url_.replace("{replicationController}", encodeURIComponent("" + replicationController));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetReplicationControllerDetailDefaultOptions: Omit<UseQueryOptions<Types.ReplicationControllerDetail, unknown, Types.ReplicationControllerDetail>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ReplicationControllerDetail, unknown, Types.ReplicationControllerDetail>, 'queryFn'>> = {
};
export function getHandleGetReplicationControllerDetailDefaultOptions() {
  return handleGetReplicationControllerDetailDefaultOptions;
};
export function setHandleGetReplicationControllerDetailDefaultOptions(options: typeof handleGetReplicationControllerDetailDefaultOptions) {
  handleGetReplicationControllerDetailDefaultOptions = options;
}

export function handleGetReplicationControllerDetailQueryKey(dto: HandleGetReplicationControllerDetailQueryParameters): QueryKey;
export function handleGetReplicationControllerDetailQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, replicationController: string): QueryKey;
export function handleGetReplicationControllerDetailQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicationController,  } = params[0] as HandleGetReplicationControllerDetailQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetReplicationControllerDetail',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        replicationController as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetReplicationControllerDetail',
        ...params
      ]);
  }
}
export function __handleGetReplicationControllerDetail(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetReplicationControllerDetail(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetReplicationControllerDetailQuery<TSelectData = Types.ReplicationControllerDetail, TError = unknown>(dto: HandleGetReplicationControllerDetailQueryParameters, options?: Omit<UseQueryOptions<Types.ReplicationControllerDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns detailed information about ReplicationController
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ReplicationController
 * @param replicationController name of the ReplicationController
 * @return OK
 */
export function useHandleGetReplicationControllerDetailQuery<TSelectData = Types.ReplicationControllerDetail, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, replicationController: string, options?: Omit<UseQueryOptions<Types.ReplicationControllerDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetReplicationControllerDetailQuery<TSelectData = Types.ReplicationControllerDetail, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ReplicationControllerDetail, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let replicationController: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicationController,  } = params[0] as HandleGetReplicationControllerDetailQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicationController, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ReplicationControllerDetail, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetReplicationControllerDetail(context, axiosConfig) : __handleGetReplicationControllerDetail,
    queryKey: handleGetReplicationControllerDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicationController),
    ...handleGetReplicationControllerDetailDefaultOptions as unknown as Omit<UseQueryOptions<Types.ReplicationControllerDetail, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns detailed information about ReplicationController
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ReplicationController
 * @param replicationController name of the ReplicationController
 * @return OK
 */
export function setHandleGetReplicationControllerDetailData(queryClient: QueryClient, updater: (data: Types.ReplicationControllerDetail | undefined) => Types.ReplicationControllerDetail, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, replicationController: string) {
  queryClient.setQueryData(handleGetReplicationControllerDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicationController),
    updater
  );
}

/**
 * returns detailed information about ReplicationController
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ReplicationController
 * @param replicationController name of the ReplicationController
 * @return OK
 */
export function setHandleGetReplicationControllerDetailDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ReplicationControllerDetail | undefined) => Types.ReplicationControllerDetail) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetReplicationControllerEventsUrl(namespace: string, replicationController: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/replicationcontroller/{namespace}/{replicationController}/event?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (replicationController === undefined || replicationController === null)
  throw new Error("The parameter 'replicationController' must be defined.");
url_ = url_.replace("{replicationController}", encodeURIComponent("" + replicationController));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetReplicationControllerEventsDefaultOptions: Omit<UseQueryOptions<Types.EventList, unknown, Types.EventList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.EventList, unknown, Types.EventList>, 'queryFn'>> = {
};
export function getHandleGetReplicationControllerEventsDefaultOptions() {
  return handleGetReplicationControllerEventsDefaultOptions;
};
export function setHandleGetReplicationControllerEventsDefaultOptions(options: typeof handleGetReplicationControllerEventsDefaultOptions) {
  handleGetReplicationControllerEventsDefaultOptions = options;
}

export function handleGetReplicationControllerEventsQueryKey(dto: HandleGetReplicationControllerEventsQueryParameters): QueryKey;
export function handleGetReplicationControllerEventsQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, replicationController: string): QueryKey;
export function handleGetReplicationControllerEventsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicationController,  } = params[0] as HandleGetReplicationControllerEventsQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetReplicationControllerEvents',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        replicationController as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetReplicationControllerEvents',
        ...params
      ]);
  }
}
export function __handleGetReplicationControllerEvents(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetReplicationControllerEvents(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetReplicationControllerEventsQuery<TSelectData = Types.EventList, TError = unknown>(dto: HandleGetReplicationControllerEventsQueryParameters, options?: Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Events for ReplicationController
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ReplicationController
 * @param replicationController name of the ReplicationController
 * @return OK
 */
export function useHandleGetReplicationControllerEventsQuery<TSelectData = Types.EventList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, replicationController: string, options?: Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetReplicationControllerEventsQuery<TSelectData = Types.EventList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.EventList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let replicationController: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicationController,  } = params[0] as HandleGetReplicationControllerEventsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicationController, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.EventList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetReplicationControllerEvents(context, axiosConfig) : __handleGetReplicationControllerEvents,
    queryKey: handleGetReplicationControllerEventsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicationController),
    ...handleGetReplicationControllerEventsDefaultOptions as unknown as Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Events for ReplicationController
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ReplicationController
 * @param replicationController name of the ReplicationController
 * @return OK
 */
export function setHandleGetReplicationControllerEventsData(queryClient: QueryClient, updater: (data: Types.EventList | undefined) => Types.EventList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, replicationController: string) {
  queryClient.setQueryData(handleGetReplicationControllerEventsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicationController),
    updater
  );
}

/**
 * returns a list of Events for ReplicationController
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ReplicationController
 * @param replicationController name of the ReplicationController
 * @return OK
 */
export function setHandleGetReplicationControllerEventsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.EventList | undefined) => Types.EventList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetReplicationControllerPodsUrl(namespace: string, replicationController: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/replicationcontroller/{namespace}/{replicationController}/pod?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (replicationController === undefined || replicationController === null)
  throw new Error("The parameter 'replicationController' must be defined.");
url_ = url_.replace("{replicationController}", encodeURIComponent("" + replicationController));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetReplicationControllerPodsDefaultOptions: Omit<UseQueryOptions<Types.PodList, unknown, Types.PodList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PodList, unknown, Types.PodList>, 'queryFn'>> = {
};
export function getHandleGetReplicationControllerPodsDefaultOptions() {
  return handleGetReplicationControllerPodsDefaultOptions;
};
export function setHandleGetReplicationControllerPodsDefaultOptions(options: typeof handleGetReplicationControllerPodsDefaultOptions) {
  handleGetReplicationControllerPodsDefaultOptions = options;
}

export function handleGetReplicationControllerPodsQueryKey(dto: HandleGetReplicationControllerPodsQueryParameters): QueryKey;
export function handleGetReplicationControllerPodsQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, replicationController: string): QueryKey;
export function handleGetReplicationControllerPodsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicationController,  } = params[0] as HandleGetReplicationControllerPodsQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetReplicationControllerPods',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        replicationController as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetReplicationControllerPods',
        ...params
      ]);
  }
}
export function __handleGetReplicationControllerPods(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetReplicationControllerPods(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetReplicationControllerPodsQuery<TSelectData = Types.PodList, TError = unknown>(dto: HandleGetReplicationControllerPodsQueryParameters, options?: Omit<UseQueryOptions<Types.PodList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Pods for ReplicationController
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ReplicationController
 * @param replicationController name of the ReplicationController
 * @return OK
 */
export function useHandleGetReplicationControllerPodsQuery<TSelectData = Types.PodList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, replicationController: string, options?: Omit<UseQueryOptions<Types.PodList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetReplicationControllerPodsQuery<TSelectData = Types.PodList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PodList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let replicationController: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicationController,  } = params[0] as HandleGetReplicationControllerPodsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicationController, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PodList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetReplicationControllerPods(context, axiosConfig) : __handleGetReplicationControllerPods,
    queryKey: handleGetReplicationControllerPodsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicationController),
    ...handleGetReplicationControllerPodsDefaultOptions as unknown as Omit<UseQueryOptions<Types.PodList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Pods for ReplicationController
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ReplicationController
 * @param replicationController name of the ReplicationController
 * @return OK
 */
export function setHandleGetReplicationControllerPodsData(queryClient: QueryClient, updater: (data: Types.PodList | undefined) => Types.PodList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, replicationController: string) {
  queryClient.setQueryData(handleGetReplicationControllerPodsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicationController),
    updater
  );
}

/**
 * returns a list of Pods for ReplicationController
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ReplicationController
 * @param replicationController name of the ReplicationController
 * @return OK
 */
export function setHandleGetReplicationControllerPodsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PodList | undefined) => Types.PodList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetReplicationControllerServicesUrl(namespace: string, replicationController: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/replicationcontroller/{namespace}/{replicationController}/service?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (replicationController === undefined || replicationController === null)
  throw new Error("The parameter 'replicationController' must be defined.");
url_ = url_.replace("{replicationController}", encodeURIComponent("" + replicationController));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetReplicationControllerServicesDefaultOptions: Omit<UseQueryOptions<Types.ServiceList, unknown, Types.ServiceList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ServiceList, unknown, Types.ServiceList>, 'queryFn'>> = {
};
export function getHandleGetReplicationControllerServicesDefaultOptions() {
  return handleGetReplicationControllerServicesDefaultOptions;
};
export function setHandleGetReplicationControllerServicesDefaultOptions(options: typeof handleGetReplicationControllerServicesDefaultOptions) {
  handleGetReplicationControllerServicesDefaultOptions = options;
}

export function handleGetReplicationControllerServicesQueryKey(dto: HandleGetReplicationControllerServicesQueryParameters): QueryKey;
export function handleGetReplicationControllerServicesQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, replicationController: string): QueryKey;
export function handleGetReplicationControllerServicesQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicationController,  } = params[0] as HandleGetReplicationControllerServicesQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetReplicationControllerServices',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        replicationController as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetReplicationControllerServices',
        ...params
      ]);
  }
}
export function __handleGetReplicationControllerServices(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetReplicationControllerServices(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetReplicationControllerServicesQuery<TSelectData = Types.ServiceList, TError = unknown>(dto: HandleGetReplicationControllerServicesQueryParameters, options?: Omit<UseQueryOptions<Types.ServiceList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Services for ReplicationController
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ReplicationController
 * @param replicationController name of the ReplicationController
 * @return OK
 */
export function useHandleGetReplicationControllerServicesQuery<TSelectData = Types.ServiceList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, replicationController: string, options?: Omit<UseQueryOptions<Types.ServiceList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetReplicationControllerServicesQuery<TSelectData = Types.ServiceList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ServiceList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let replicationController: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicationController,  } = params[0] as HandleGetReplicationControllerServicesQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicationController, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ServiceList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetReplicationControllerServices(context, axiosConfig) : __handleGetReplicationControllerServices,
    queryKey: handleGetReplicationControllerServicesQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicationController),
    ...handleGetReplicationControllerServicesDefaultOptions as unknown as Omit<UseQueryOptions<Types.ServiceList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Services for ReplicationController
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ReplicationController
 * @param replicationController name of the ReplicationController
 * @return OK
 */
export function setHandleGetReplicationControllerServicesData(queryClient: QueryClient, updater: (data: Types.ServiceList | undefined) => Types.ServiceList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, replicationController: string) {
  queryClient.setQueryData(handleGetReplicationControllerServicesQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicationController),
    updater
  );
}

/**
 * returns a list of Services for ReplicationController
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ReplicationController
 * @param replicationController name of the ReplicationController
 * @return OK
 */
export function setHandleGetReplicationControllerServicesDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ServiceList | undefined) => Types.ServiceList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleUpdateReplicasCountUrl(namespace: string, replicationController: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/replicationcontroller/{namespace}/{replicationController}/update/pod?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (replicationController === undefined || replicationController === null)
  throw new Error("The parameter 'replicationController' must be defined.");
url_ = url_.replace("{replicationController}", encodeURIComponent("" + replicationController));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function handleUpdateReplicasCountMutationKey(namespace: string, replicationController: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'handleUpdateReplicasCount',
      namespace as any,
      replicationController as any,
      filterBy as any,
      sortBy as any,
      itemsPerPage as any,
      page as any,
      metricNames as any,
      aggregations as any,
    ]);
}

/**
 * scales ReplicationController to a number of replicas
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ReplicationController
 * @param replicationController name of the ReplicationController
 * @return OK
 */
export function useHandleUpdateReplicasCountMutation<TContext>(namespace: string, replicationController: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseMutationOptions<void, unknown, Types.ReplicationControllerSpec, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.ReplicationControllerSpec, TContext> {
  const key = handleUpdateReplicasCountMutationKey(namespace, replicationController, filterBy, sortBy, itemsPerPage, page, metricNames, aggregations);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.ReplicationControllerSpec) => Client().handleUpdateReplicasCount(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, replicationController, body),
    mutationKey: key,
  });
}
  
type HandleUpdateReplicasCount__MutationParameters = HandleUpdateReplicasCountQueryParameters & {
  body: Types.ReplicationControllerSpec;
}

/**
 * scales ReplicationController to a number of replicas
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ReplicationController
 * @param replicationController name of the ReplicationController
 * @return OK
 */
export function useHandleUpdateReplicasCountMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, HandleUpdateReplicasCount__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: HandleUpdateReplicasCountQueryParameters}): UseMutationResult<void, unknown, HandleUpdateReplicasCount__MutationParameters, TContext> {
  const key = handleUpdateReplicasCountMutationKey(options?.parameters?.namespace!, options?.parameters?.replicationController!, options?.parameters?.filterBy!, options?.parameters?.sortBy!, options?.parameters?.itemsPerPage!, options?.parameters?.page!, options?.parameters?.metricNames!, options?.parameters?.aggregations!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: HandleUpdateReplicasCount__MutationParameters) => Client().handleUpdateReplicasCount(data.filterBy ?? options?.parameters?.filterBy!, data.sortBy ?? options?.parameters?.sortBy!, data.itemsPerPage ?? options?.parameters?.itemsPerPage!, data.page ?? options?.parameters?.page!, data.metricNames ?? options?.parameters?.metricNames!, data.aggregations ?? options?.parameters?.aggregations!, data.namespace ?? options?.parameters?.namespace!, data.replicationController ?? options?.parameters?.replicationController!, data.body),
  mutationKey: key,
});
}
  
export function handleGetRoleListUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/role?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetRoleListDefaultOptions: Omit<UseQueryOptions<Types.RoleList, unknown, Types.RoleList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.RoleList, unknown, Types.RoleList>, 'queryFn'>> = {
};
export function getHandleGetRoleListDefaultOptions() {
  return handleGetRoleListDefaultOptions;
};
export function setHandleGetRoleListDefaultOptions(options: typeof handleGetRoleListDefaultOptions) {
  handleGetRoleListDefaultOptions = options;
}

export function handleGetRoleListQueryKey(dto: HandleGetRoleListQueryParameters): QueryKey;
export function handleGetRoleListQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): QueryKey;
export function handleGetRoleListQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetRoleListQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetRoleList',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetRoleList',
        ...params
      ]);
  }
}
export function __handleGetRoleList(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetRoleList(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined);
}

export function useHandleGetRoleListQuery<TSelectData = Types.RoleList, TError = unknown>(dto: HandleGetRoleListQueryParameters, options?: Omit<UseQueryOptions<Types.RoleList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Roles from all namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleGetRoleListQuery<TSelectData = Types.RoleList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseQueryOptions<Types.RoleList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetRoleListQuery<TSelectData = Types.RoleList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.RoleList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetRoleListQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.RoleList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetRoleList(context, axiosConfig) : __handleGetRoleList,
    queryKey: handleGetRoleListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    ...handleGetRoleListDefaultOptions as unknown as Omit<UseQueryOptions<Types.RoleList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Roles from all namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetRoleListData(queryClient: QueryClient, updater: (data: Types.RoleList | undefined) => Types.RoleList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined) {
  queryClient.setQueryData(handleGetRoleListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    updater
  );
}

/**
 * returns a list of Roles from all namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetRoleListDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.RoleList | undefined) => Types.RoleList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetRoleList2Url(namespace: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/role/{namespace}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetRoleList2DefaultOptions: Omit<UseQueryOptions<Types.RoleList, unknown, Types.RoleList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.RoleList, unknown, Types.RoleList>, 'queryFn'>> = {
};
export function getHandleGetRoleList2DefaultOptions() {
  return handleGetRoleList2DefaultOptions;
};
export function setHandleGetRoleList2DefaultOptions(options: typeof handleGetRoleList2DefaultOptions) {
  handleGetRoleList2DefaultOptions = options;
}

export function handleGetRoleList2QueryKey(dto: HandleGetRoleList2QueryParameters): QueryKey;
export function handleGetRoleList2QueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string): QueryKey;
export function handleGetRoleList2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetRoleList2QueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetRoleList2',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetRoleList2',
        ...params
      ]);
  }
}
export function __handleGetRoleList2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetRoleList2(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetRoleList2Query<TSelectData = Types.RoleList, TError = unknown>(dto: HandleGetRoleList2QueryParameters, options?: Omit<UseQueryOptions<Types.RoleList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Roles in a namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Role
 * @return OK
 */
export function useHandleGetRoleList2Query<TSelectData = Types.RoleList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, options?: Omit<UseQueryOptions<Types.RoleList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetRoleList2Query<TSelectData = Types.RoleList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.RoleList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetRoleList2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.RoleList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetRoleList2(context, axiosConfig) : __handleGetRoleList2,
    queryKey: handleGetRoleList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    ...handleGetRoleList2DefaultOptions as unknown as Omit<UseQueryOptions<Types.RoleList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Roles in a namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Role
 * @return OK
 */
export function setHandleGetRoleList2Data(queryClient: QueryClient, updater: (data: Types.RoleList | undefined) => Types.RoleList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string) {
  queryClient.setQueryData(handleGetRoleList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    updater
  );
}

/**
 * returns a list of Roles in a namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Role
 * @return OK
 */
export function setHandleGetRoleList2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.RoleList | undefined) => Types.RoleList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetRoleDetailUrl(namespace: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/role/{namespace}/{name}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (name === undefined || name === null)
  throw new Error("The parameter 'name' must be defined.");
url_ = url_.replace("{name}", encodeURIComponent("" + name));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetRoleDetailDefaultOptions: Omit<UseQueryOptions<Types.RoleDetail, unknown, Types.RoleDetail>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.RoleDetail, unknown, Types.RoleDetail>, 'queryFn'>> = {
};
export function getHandleGetRoleDetailDefaultOptions() {
  return handleGetRoleDetailDefaultOptions;
};
export function setHandleGetRoleDetailDefaultOptions(options: typeof handleGetRoleDetailDefaultOptions) {
  handleGetRoleDetailDefaultOptions = options;
}

export function handleGetRoleDetailQueryKey(dto: HandleGetRoleDetailQueryParameters): QueryKey;
export function handleGetRoleDetailQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, name: string): QueryKey;
export function handleGetRoleDetailQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name,  } = params[0] as HandleGetRoleDetailQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetRoleDetail',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        name as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetRoleDetail',
        ...params
      ]);
  }
}
export function __handleGetRoleDetail(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetRoleDetail(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetRoleDetailQuery<TSelectData = Types.RoleDetail, TError = unknown>(dto: HandleGetRoleDetailQueryParameters, options?: Omit<UseQueryOptions<Types.RoleDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns detailed information about Role
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Role
 * @param name name of the Role
 * @return OK
 */
export function useHandleGetRoleDetailQuery<TSelectData = Types.RoleDetail, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, name: string, options?: Omit<UseQueryOptions<Types.RoleDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetRoleDetailQuery<TSelectData = Types.RoleDetail, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.RoleDetail, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let name: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name,  } = params[0] as HandleGetRoleDetailQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.RoleDetail, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetRoleDetail(context, axiosConfig) : __handleGetRoleDetail,
    queryKey: handleGetRoleDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name),
    ...handleGetRoleDetailDefaultOptions as unknown as Omit<UseQueryOptions<Types.RoleDetail, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns detailed information about Role
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Role
 * @param name name of the Role
 * @return OK
 */
export function setHandleGetRoleDetailData(queryClient: QueryClient, updater: (data: Types.RoleDetail | undefined) => Types.RoleDetail, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, name: string) {
  queryClient.setQueryData(handleGetRoleDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name),
    updater
  );
}

/**
 * returns detailed information about Role
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Role
 * @param name name of the Role
 * @return OK
 */
export function setHandleGetRoleDetailDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.RoleDetail | undefined) => Types.RoleDetail) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetRoleBindingListUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/rolebinding?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetRoleBindingListDefaultOptions: Omit<UseQueryOptions<Types.RoleBindingList, unknown, Types.RoleBindingList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.RoleBindingList, unknown, Types.RoleBindingList>, 'queryFn'>> = {
};
export function getHandleGetRoleBindingListDefaultOptions() {
  return handleGetRoleBindingListDefaultOptions;
};
export function setHandleGetRoleBindingListDefaultOptions(options: typeof handleGetRoleBindingListDefaultOptions) {
  handleGetRoleBindingListDefaultOptions = options;
}

export function handleGetRoleBindingListQueryKey(dto: HandleGetRoleBindingListQueryParameters): QueryKey;
export function handleGetRoleBindingListQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): QueryKey;
export function handleGetRoleBindingListQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetRoleBindingListQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetRoleBindingList',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetRoleBindingList',
        ...params
      ]);
  }
}
export function __handleGetRoleBindingList(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetRoleBindingList(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined);
}

export function useHandleGetRoleBindingListQuery<TSelectData = Types.RoleBindingList, TError = unknown>(dto: HandleGetRoleBindingListQueryParameters, options?: Omit<UseQueryOptions<Types.RoleBindingList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of RoleBindings from all namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleGetRoleBindingListQuery<TSelectData = Types.RoleBindingList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseQueryOptions<Types.RoleBindingList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetRoleBindingListQuery<TSelectData = Types.RoleBindingList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.RoleBindingList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetRoleBindingListQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.RoleBindingList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetRoleBindingList(context, axiosConfig) : __handleGetRoleBindingList,
    queryKey: handleGetRoleBindingListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    ...handleGetRoleBindingListDefaultOptions as unknown as Omit<UseQueryOptions<Types.RoleBindingList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of RoleBindings from all namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetRoleBindingListData(queryClient: QueryClient, updater: (data: Types.RoleBindingList | undefined) => Types.RoleBindingList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined) {
  queryClient.setQueryData(handleGetRoleBindingListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    updater
  );
}

/**
 * returns a list of RoleBindings from all namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetRoleBindingListDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.RoleBindingList | undefined) => Types.RoleBindingList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetRoleBindingList2Url(namespace: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/rolebinding/{namespace}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetRoleBindingList2DefaultOptions: Omit<UseQueryOptions<Types.RoleBindingList, unknown, Types.RoleBindingList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.RoleBindingList, unknown, Types.RoleBindingList>, 'queryFn'>> = {
};
export function getHandleGetRoleBindingList2DefaultOptions() {
  return handleGetRoleBindingList2DefaultOptions;
};
export function setHandleGetRoleBindingList2DefaultOptions(options: typeof handleGetRoleBindingList2DefaultOptions) {
  handleGetRoleBindingList2DefaultOptions = options;
}

export function handleGetRoleBindingList2QueryKey(dto: HandleGetRoleBindingList2QueryParameters): QueryKey;
export function handleGetRoleBindingList2QueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string): QueryKey;
export function handleGetRoleBindingList2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetRoleBindingList2QueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetRoleBindingList2',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetRoleBindingList2',
        ...params
      ]);
  }
}
export function __handleGetRoleBindingList2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetRoleBindingList2(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetRoleBindingList2Query<TSelectData = Types.RoleBindingList, TError = unknown>(dto: HandleGetRoleBindingList2QueryParameters, options?: Omit<UseQueryOptions<Types.RoleBindingList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of RoleBindings in a namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the RoleBinding
 * @return OK
 */
export function useHandleGetRoleBindingList2Query<TSelectData = Types.RoleBindingList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, options?: Omit<UseQueryOptions<Types.RoleBindingList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetRoleBindingList2Query<TSelectData = Types.RoleBindingList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.RoleBindingList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetRoleBindingList2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.RoleBindingList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetRoleBindingList2(context, axiosConfig) : __handleGetRoleBindingList2,
    queryKey: handleGetRoleBindingList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    ...handleGetRoleBindingList2DefaultOptions as unknown as Omit<UseQueryOptions<Types.RoleBindingList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of RoleBindings in a namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the RoleBinding
 * @return OK
 */
export function setHandleGetRoleBindingList2Data(queryClient: QueryClient, updater: (data: Types.RoleBindingList | undefined) => Types.RoleBindingList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string) {
  queryClient.setQueryData(handleGetRoleBindingList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    updater
  );
}

/**
 * returns a list of RoleBindings in a namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the RoleBinding
 * @return OK
 */
export function setHandleGetRoleBindingList2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.RoleBindingList | undefined) => Types.RoleBindingList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetRoleBindingDetailUrl(namespace: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/rolebinding/{namespace}/{name}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (name === undefined || name === null)
  throw new Error("The parameter 'name' must be defined.");
url_ = url_.replace("{name}", encodeURIComponent("" + name));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetRoleBindingDetailDefaultOptions: Omit<UseQueryOptions<Types.RoleBindingDetail, unknown, Types.RoleBindingDetail>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.RoleBindingDetail, unknown, Types.RoleBindingDetail>, 'queryFn'>> = {
};
export function getHandleGetRoleBindingDetailDefaultOptions() {
  return handleGetRoleBindingDetailDefaultOptions;
};
export function setHandleGetRoleBindingDetailDefaultOptions(options: typeof handleGetRoleBindingDetailDefaultOptions) {
  handleGetRoleBindingDetailDefaultOptions = options;
}

export function handleGetRoleBindingDetailQueryKey(dto: HandleGetRoleBindingDetailQueryParameters): QueryKey;
export function handleGetRoleBindingDetailQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, name: string): QueryKey;
export function handleGetRoleBindingDetailQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name,  } = params[0] as HandleGetRoleBindingDetailQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetRoleBindingDetail',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        name as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetRoleBindingDetail',
        ...params
      ]);
  }
}
export function __handleGetRoleBindingDetail(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetRoleBindingDetail(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetRoleBindingDetailQuery<TSelectData = Types.RoleBindingDetail, TError = unknown>(dto: HandleGetRoleBindingDetailQueryParameters, options?: Omit<UseQueryOptions<Types.RoleBindingDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns detailed information about RoleBinding
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the RoleBinding
 * @param name name of the RoleBinding
 * @return OK
 */
export function useHandleGetRoleBindingDetailQuery<TSelectData = Types.RoleBindingDetail, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, name: string, options?: Omit<UseQueryOptions<Types.RoleBindingDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetRoleBindingDetailQuery<TSelectData = Types.RoleBindingDetail, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.RoleBindingDetail, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let name: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name,  } = params[0] as HandleGetRoleBindingDetailQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.RoleBindingDetail, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetRoleBindingDetail(context, axiosConfig) : __handleGetRoleBindingDetail,
    queryKey: handleGetRoleBindingDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name),
    ...handleGetRoleBindingDetailDefaultOptions as unknown as Omit<UseQueryOptions<Types.RoleBindingDetail, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns detailed information about RoleBinding
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the RoleBinding
 * @param name name of the RoleBinding
 * @return OK
 */
export function setHandleGetRoleBindingDetailData(queryClient: QueryClient, updater: (data: Types.RoleBindingDetail | undefined) => Types.RoleBindingDetail, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, name: string) {
  queryClient.setQueryData(handleGetRoleBindingDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name),
    updater
  );
}

/**
 * returns detailed information about RoleBinding
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the RoleBinding
 * @param name name of the RoleBinding
 * @return OK
 */
export function setHandleGetRoleBindingDetailDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.RoleBindingDetail | undefined) => Types.RoleBindingDetail) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetReplicaCountUrl(kind: string, namespace: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/scale/{kind}/{namespace}/{name}?";
if (kind === undefined || kind === null)
  throw new Error("The parameter 'kind' must be defined.");
url_ = url_.replace("{kind}", encodeURIComponent("" + kind));
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (name === undefined || name === null)
  throw new Error("The parameter 'name' must be defined.");
url_ = url_.replace("{name}", encodeURIComponent("" + name));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetReplicaCountDefaultOptions: Omit<UseQueryOptions<Types.ReplicaCounts, unknown, Types.ReplicaCounts>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ReplicaCounts, unknown, Types.ReplicaCounts>, 'queryFn'>> = {
};
export function getHandleGetReplicaCountDefaultOptions() {
  return handleGetReplicaCountDefaultOptions;
};
export function setHandleGetReplicaCountDefaultOptions(options: typeof handleGetReplicaCountDefaultOptions) {
  handleGetReplicaCountDefaultOptions = options;
}

export function handleGetReplicaCountQueryKey(dto: HandleGetReplicaCountQueryParameters): QueryKey;
export function handleGetReplicaCountQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, kind: string, namespace: string, name: string): QueryKey;
export function handleGetReplicaCountQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, kind, namespace, name,  } = params[0] as HandleGetReplicaCountQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetReplicaCount',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        kind as any,
        namespace as any,
        name as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetReplicaCount',
        ...params
      ]);
  }
}
export function __handleGetReplicaCount(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetReplicaCount(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string,       context.queryKey[10] as string);
}

export function useHandleGetReplicaCountQuery<TSelectData = Types.ReplicaCounts, TError = unknown>(dto: HandleGetReplicaCountQueryParameters, options?: Omit<UseQueryOptions<Types.ReplicaCounts, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a number of replicas of namespaced resource
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param kind kind of the resource
 * @param namespace namespace of the resource
 * @param name name of the resource
 * @return OK
 */
export function useHandleGetReplicaCountQuery<TSelectData = Types.ReplicaCounts, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, kind: string, namespace: string, name: string, options?: Omit<UseQueryOptions<Types.ReplicaCounts, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetReplicaCountQuery<TSelectData = Types.ReplicaCounts, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ReplicaCounts, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let kind: any = undefined;
  let namespace: any = undefined;
  let name: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, kind, namespace, name,  } = params[0] as HandleGetReplicaCountQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, kind, namespace, name, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ReplicaCounts, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetReplicaCount(context, axiosConfig) : __handleGetReplicaCount,
    queryKey: handleGetReplicaCountQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, kind, namespace, name),
    ...handleGetReplicaCountDefaultOptions as unknown as Omit<UseQueryOptions<Types.ReplicaCounts, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a number of replicas of namespaced resource
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param kind kind of the resource
 * @param namespace namespace of the resource
 * @param name name of the resource
 * @return OK
 */
export function setHandleGetReplicaCountData(queryClient: QueryClient, updater: (data: Types.ReplicaCounts | undefined) => Types.ReplicaCounts, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, kind: string, namespace: string, name: string) {
  queryClient.setQueryData(handleGetReplicaCountQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, kind, namespace, name),
    updater
  );
}

/**
 * returns a number of replicas of namespaced resource
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param kind kind of the resource
 * @param namespace namespace of the resource
 * @param name name of the resource
 * @return OK
 */
export function setHandleGetReplicaCountDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ReplicaCounts | undefined) => Types.ReplicaCounts) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleScaleResourceUrl(kind: string, namespace: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, scaleBy: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/scale/{kind}/{namespace}/{name}?";
if (kind === undefined || kind === null)
  throw new Error("The parameter 'kind' must be defined.");
url_ = url_.replace("{kind}", encodeURIComponent("" + kind));
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (name === undefined || name === null)
  throw new Error("The parameter 'name' must be defined.");
url_ = url_.replace("{name}", encodeURIComponent("" + name));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
if (scaleBy !== undefined && scaleBy !== null)
    url_ += "scaleBy=" + encodeURIComponent("" + scaleBy) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function handleScaleResourceMutationKey(kind: string, namespace: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, scaleBy: string | null | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'handleScaleResource',
      kind as any,
      namespace as any,
      name as any,
      filterBy as any,
      sortBy as any,
      itemsPerPage as any,
      page as any,
      metricNames as any,
      aggregations as any,
      scaleBy as any,
    ]);
}

/**
 * scales a namespaced resource
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param kind kind of the resource
 * @param namespace namespace of the resource
 * @param name name of the resource
 * @param scaleBy (optional) desired number of replicas
 * @return OK
 */
export function useHandleScaleResourceMutation<TContext>(kind: string, namespace: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, scaleBy: string | null | undefined, options?: Omit<UseMutationOptions<Types.ReplicaCounts, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ReplicaCounts, unknown, void, TContext> {
  const key = handleScaleResourceMutationKey(kind, namespace, name, filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, scaleBy);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client().handleScaleResource(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, kind, namespace, name, scaleBy),
    mutationKey: key,
  });
}
  
type HandleScaleResource__MutationParameters = HandleScaleResourceQueryParameters

/**
 * scales a namespaced resource
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param kind kind of the resource
 * @param namespace namespace of the resource
 * @param name name of the resource
 * @param scaleBy (optional) desired number of replicas
 * @return OK
 */
export function useHandleScaleResourceMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.ReplicaCounts, unknown, HandleScaleResource__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: HandleScaleResourceQueryParameters}): UseMutationResult<Types.ReplicaCounts, unknown, HandleScaleResource__MutationParameters, TContext> {
  const key = handleScaleResourceMutationKey(options?.parameters?.kind!, options?.parameters?.namespace!, options?.parameters?.name!, options?.parameters?.filterBy!, options?.parameters?.sortBy!, options?.parameters?.itemsPerPage!, options?.parameters?.page!, options?.parameters?.metricNames!, options?.parameters?.aggregations!, options?.parameters?.scaleBy!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: HandleScaleResource__MutationParameters) => Client().handleScaleResource(data.filterBy ?? options?.parameters?.filterBy!, data.sortBy ?? options?.parameters?.sortBy!, data.itemsPerPage ?? options?.parameters?.itemsPerPage!, data.page ?? options?.parameters?.page!, data.metricNames ?? options?.parameters?.metricNames!, data.aggregations ?? options?.parameters?.aggregations!, data.kind ?? options?.parameters?.kind!, data.namespace ?? options?.parameters?.namespace!, data.name ?? options?.parameters?.name!, data.scaleBy ?? options?.parameters?.scaleBy!),
  mutationKey: key,
});
}
  
export function handleGetReplicaCount2Url(kind: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/scale/{kind}/{name}?";
if (kind === undefined || kind === null)
  throw new Error("The parameter 'kind' must be defined.");
url_ = url_.replace("{kind}", encodeURIComponent("" + kind));
if (name === undefined || name === null)
  throw new Error("The parameter 'name' must be defined.");
url_ = url_.replace("{name}", encodeURIComponent("" + name));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetReplicaCount2DefaultOptions: Omit<UseQueryOptions<Types.ReplicaCounts, unknown, Types.ReplicaCounts>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ReplicaCounts, unknown, Types.ReplicaCounts>, 'queryFn'>> = {
};
export function getHandleGetReplicaCount2DefaultOptions() {
  return handleGetReplicaCount2DefaultOptions;
};
export function setHandleGetReplicaCount2DefaultOptions(options: typeof handleGetReplicaCount2DefaultOptions) {
  handleGetReplicaCount2DefaultOptions = options;
}

export function handleGetReplicaCount2QueryKey(dto: HandleGetReplicaCount2QueryParameters): QueryKey;
export function handleGetReplicaCount2QueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, kind: string, name: string): QueryKey;
export function handleGetReplicaCount2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, kind, name,  } = params[0] as HandleGetReplicaCount2QueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetReplicaCount2',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        kind as any,
        name as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetReplicaCount2',
        ...params
      ]);
  }
}
export function __handleGetReplicaCount2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetReplicaCount2(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetReplicaCount2Query<TSelectData = Types.ReplicaCounts, TError = unknown>(dto: HandleGetReplicaCount2QueryParameters, options?: Omit<UseQueryOptions<Types.ReplicaCounts, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a number of replicas of non-namespaced resource
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param kind kind of the resource
 * @param name name of the resource
 * @return OK
 */
export function useHandleGetReplicaCount2Query<TSelectData = Types.ReplicaCounts, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, kind: string, name: string, options?: Omit<UseQueryOptions<Types.ReplicaCounts, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetReplicaCount2Query<TSelectData = Types.ReplicaCounts, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ReplicaCounts, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let kind: any = undefined;
  let name: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, kind, name,  } = params[0] as HandleGetReplicaCount2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, kind, name, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ReplicaCounts, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetReplicaCount2(context, axiosConfig) : __handleGetReplicaCount2,
    queryKey: handleGetReplicaCount2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, kind, name),
    ...handleGetReplicaCount2DefaultOptions as unknown as Omit<UseQueryOptions<Types.ReplicaCounts, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a number of replicas of non-namespaced resource
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param kind kind of the resource
 * @param name name of the resource
 * @return OK
 */
export function setHandleGetReplicaCount2Data(queryClient: QueryClient, updater: (data: Types.ReplicaCounts | undefined) => Types.ReplicaCounts, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, kind: string, name: string) {
  queryClient.setQueryData(handleGetReplicaCount2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, kind, name),
    updater
  );
}

/**
 * returns a number of replicas of non-namespaced resource
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param kind kind of the resource
 * @param name name of the resource
 * @return OK
 */
export function setHandleGetReplicaCount2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ReplicaCounts | undefined) => Types.ReplicaCounts) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleScaleResource2Url(kind: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, scaleBy: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/scale/{kind}/{name}?";
if (kind === undefined || kind === null)
  throw new Error("The parameter 'kind' must be defined.");
url_ = url_.replace("{kind}", encodeURIComponent("" + kind));
if (name === undefined || name === null)
  throw new Error("The parameter 'name' must be defined.");
url_ = url_.replace("{name}", encodeURIComponent("" + name));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
if (scaleBy !== undefined && scaleBy !== null)
    url_ += "scaleBy=" + encodeURIComponent("" + scaleBy) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function handleScaleResource2MutationKey(kind: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, scaleBy: string | null | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'handleScaleResource2',
      kind as any,
      name as any,
      filterBy as any,
      sortBy as any,
      itemsPerPage as any,
      page as any,
      metricNames as any,
      aggregations as any,
      scaleBy as any,
    ]);
}

/**
 * scales a non-namespaced resource
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param kind kind of the resource
 * @param name name of the resource
 * @param scaleBy (optional) desired number of replicas
 * @return OK
 */
export function useHandleScaleResource2Mutation<TContext>(kind: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, scaleBy: string | null | undefined, options?: Omit<UseMutationOptions<Types.ReplicaCounts, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ReplicaCounts, unknown, void, TContext> {
  const key = handleScaleResource2MutationKey(kind, name, filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, scaleBy);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client().handleScaleResource2(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, kind, name, scaleBy),
    mutationKey: key,
  });
}
  
type HandleScaleResource2__MutationParameters = HandleScaleResource2QueryParameters

/**
 * scales a non-namespaced resource
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param kind kind of the resource
 * @param name name of the resource
 * @param scaleBy (optional) desired number of replicas
 * @return OK
 */
export function useHandleScaleResource2MutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.ReplicaCounts, unknown, HandleScaleResource2__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: HandleScaleResource2QueryParameters}): UseMutationResult<Types.ReplicaCounts, unknown, HandleScaleResource2__MutationParameters, TContext> {
  const key = handleScaleResource2MutationKey(options?.parameters?.kind!, options?.parameters?.name!, options?.parameters?.filterBy!, options?.parameters?.sortBy!, options?.parameters?.itemsPerPage!, options?.parameters?.page!, options?.parameters?.metricNames!, options?.parameters?.aggregations!, options?.parameters?.scaleBy!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: HandleScaleResource2__MutationParameters) => Client().handleScaleResource2(data.filterBy ?? options?.parameters?.filterBy!, data.sortBy ?? options?.parameters?.sortBy!, data.itemsPerPage ?? options?.parameters?.itemsPerPage!, data.page ?? options?.parameters?.page!, data.metricNames ?? options?.parameters?.metricNames!, data.aggregations ?? options?.parameters?.aggregations!, data.kind ?? options?.parameters?.kind!, data.name ?? options?.parameters?.name!, data.scaleBy ?? options?.parameters?.scaleBy!),
  mutationKey: key,
});
}
  
export function handleGetSecretListUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/secret?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetSecretListDefaultOptions: Omit<UseQueryOptions<Types.SecretList, unknown, Types.SecretList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.SecretList, unknown, Types.SecretList>, 'queryFn'>> = {
};
export function getHandleGetSecretListDefaultOptions() {
  return handleGetSecretListDefaultOptions;
};
export function setHandleGetSecretListDefaultOptions(options: typeof handleGetSecretListDefaultOptions) {
  handleGetSecretListDefaultOptions = options;
}

export function handleGetSecretListQueryKey(dto: HandleGetSecretListQueryParameters): QueryKey;
export function handleGetSecretListQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): QueryKey;
export function handleGetSecretListQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetSecretListQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetSecretList',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetSecretList',
        ...params
      ]);
  }
}
export function __handleGetSecretList(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetSecretList(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined);
}

export function useHandleGetSecretListQuery<TSelectData = Types.SecretList, TError = unknown>(dto: HandleGetSecretListQueryParameters, options?: Omit<UseQueryOptions<Types.SecretList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Secrets from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleGetSecretListQuery<TSelectData = Types.SecretList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseQueryOptions<Types.SecretList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetSecretListQuery<TSelectData = Types.SecretList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.SecretList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetSecretListQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.SecretList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetSecretList(context, axiosConfig) : __handleGetSecretList,
    queryKey: handleGetSecretListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    ...handleGetSecretListDefaultOptions as unknown as Omit<UseQueryOptions<Types.SecretList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Secrets from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetSecretListData(queryClient: QueryClient, updater: (data: Types.SecretList | undefined) => Types.SecretList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined) {
  queryClient.setQueryData(handleGetSecretListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    updater
  );
}

/**
 * returns a list of Secrets from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetSecretListDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.SecretList | undefined) => Types.SecretList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleCreateImagePullSecretUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/secret?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function handleCreateImagePullSecretMutationKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'handleCreateImagePullSecret',
      filterBy as any,
      sortBy as any,
      itemsPerPage as any,
      page as any,
      metricNames as any,
      aggregations as any,
    ]);
}

/**
 * stores ImagePullSecret in a Kubernetes Secret
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleCreateImagePullSecretMutation<TContext>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseMutationOptions<Types.Secret, unknown, Types.ImagePullSecretSpec, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.Secret, unknown, Types.ImagePullSecretSpec, TContext> {
  const key = handleCreateImagePullSecretMutationKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.ImagePullSecretSpec) => Client().handleCreateImagePullSecret(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, body),
    mutationKey: key,
  });
}
  
type HandleCreateImagePullSecret__MutationParameters = HandleCreateImagePullSecretQueryParameters & {
  body: Types.ImagePullSecretSpec;
}

/**
 * stores ImagePullSecret in a Kubernetes Secret
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleCreateImagePullSecretMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.Secret, unknown, HandleCreateImagePullSecret__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: HandleCreateImagePullSecretQueryParameters}): UseMutationResult<Types.Secret, unknown, HandleCreateImagePullSecret__MutationParameters, TContext> {
  const key = handleCreateImagePullSecretMutationKey(options?.parameters?.filterBy!, options?.parameters?.sortBy!, options?.parameters?.itemsPerPage!, options?.parameters?.page!, options?.parameters?.metricNames!, options?.parameters?.aggregations!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: HandleCreateImagePullSecret__MutationParameters) => Client().handleCreateImagePullSecret(data.filterBy ?? options?.parameters?.filterBy!, data.sortBy ?? options?.parameters?.sortBy!, data.itemsPerPage ?? options?.parameters?.itemsPerPage!, data.page ?? options?.parameters?.page!, data.metricNames ?? options?.parameters?.metricNames!, data.aggregations ?? options?.parameters?.aggregations!, data.body),
  mutationKey: key,
});
}
  
export function handleGetSecretList2Url(namespace: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/secret/{namespace}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetSecretList2DefaultOptions: Omit<UseQueryOptions<Types.SecretList, unknown, Types.SecretList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.SecretList, unknown, Types.SecretList>, 'queryFn'>> = {
};
export function getHandleGetSecretList2DefaultOptions() {
  return handleGetSecretList2DefaultOptions;
};
export function setHandleGetSecretList2DefaultOptions(options: typeof handleGetSecretList2DefaultOptions) {
  handleGetSecretList2DefaultOptions = options;
}

export function handleGetSecretList2QueryKey(dto: HandleGetSecretList2QueryParameters): QueryKey;
export function handleGetSecretList2QueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string): QueryKey;
export function handleGetSecretList2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetSecretList2QueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetSecretList2',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetSecretList2',
        ...params
      ]);
  }
}
export function __handleGetSecretList2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetSecretList2(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetSecretList2Query<TSelectData = Types.SecretList, TError = unknown>(dto: HandleGetSecretList2QueryParameters, options?: Omit<UseQueryOptions<Types.SecretList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Secrets in a namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Secret
 * @return OK
 */
export function useHandleGetSecretList2Query<TSelectData = Types.SecretList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, options?: Omit<UseQueryOptions<Types.SecretList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetSecretList2Query<TSelectData = Types.SecretList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.SecretList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetSecretList2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.SecretList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetSecretList2(context, axiosConfig) : __handleGetSecretList2,
    queryKey: handleGetSecretList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    ...handleGetSecretList2DefaultOptions as unknown as Omit<UseQueryOptions<Types.SecretList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Secrets in a namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Secret
 * @return OK
 */
export function setHandleGetSecretList2Data(queryClient: QueryClient, updater: (data: Types.SecretList | undefined) => Types.SecretList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string) {
  queryClient.setQueryData(handleGetSecretList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    updater
  );
}

/**
 * returns a list of Secrets in a namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Secret
 * @return OK
 */
export function setHandleGetSecretList2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.SecretList | undefined) => Types.SecretList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetSecretDetailUrl(namespace: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/secret/{namespace}/{name}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (name === undefined || name === null)
  throw new Error("The parameter 'name' must be defined.");
url_ = url_.replace("{name}", encodeURIComponent("" + name));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetSecretDetailDefaultOptions: Omit<UseQueryOptions<Types.SecretDetail, unknown, Types.SecretDetail>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.SecretDetail, unknown, Types.SecretDetail>, 'queryFn'>> = {
};
export function getHandleGetSecretDetailDefaultOptions() {
  return handleGetSecretDetailDefaultOptions;
};
export function setHandleGetSecretDetailDefaultOptions(options: typeof handleGetSecretDetailDefaultOptions) {
  handleGetSecretDetailDefaultOptions = options;
}

export function handleGetSecretDetailQueryKey(dto: HandleGetSecretDetailQueryParameters): QueryKey;
export function handleGetSecretDetailQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, name: string): QueryKey;
export function handleGetSecretDetailQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name,  } = params[0] as HandleGetSecretDetailQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetSecretDetail',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        name as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetSecretDetail',
        ...params
      ]);
  }
}
export function __handleGetSecretDetail(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetSecretDetail(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetSecretDetailQuery<TSelectData = Types.SecretDetail, TError = unknown>(dto: HandleGetSecretDetailQueryParameters, options?: Omit<UseQueryOptions<Types.SecretDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns detailed information about Secret
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Secret
 * @param name name of the Secret
 * @return OK
 */
export function useHandleGetSecretDetailQuery<TSelectData = Types.SecretDetail, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, name: string, options?: Omit<UseQueryOptions<Types.SecretDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetSecretDetailQuery<TSelectData = Types.SecretDetail, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.SecretDetail, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let name: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name,  } = params[0] as HandleGetSecretDetailQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.SecretDetail, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetSecretDetail(context, axiosConfig) : __handleGetSecretDetail,
    queryKey: handleGetSecretDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name),
    ...handleGetSecretDetailDefaultOptions as unknown as Omit<UseQueryOptions<Types.SecretDetail, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns detailed information about Secret
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Secret
 * @param name name of the Secret
 * @return OK
 */
export function setHandleGetSecretDetailData(queryClient: QueryClient, updater: (data: Types.SecretDetail | undefined) => Types.SecretDetail, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, name: string) {
  queryClient.setQueryData(handleGetSecretDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, name),
    updater
  );
}

/**
 * returns detailed information about Secret
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Secret
 * @param name name of the Secret
 * @return OK
 */
export function setHandleGetSecretDetailDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.SecretDetail | undefined) => Types.SecretDetail) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetServiceListUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/service?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetServiceListDefaultOptions: Omit<UseQueryOptions<Types.ServiceList, unknown, Types.ServiceList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ServiceList, unknown, Types.ServiceList>, 'queryFn'>> = {
};
export function getHandleGetServiceListDefaultOptions() {
  return handleGetServiceListDefaultOptions;
};
export function setHandleGetServiceListDefaultOptions(options: typeof handleGetServiceListDefaultOptions) {
  handleGetServiceListDefaultOptions = options;
}

export function handleGetServiceListQueryKey(dto: HandleGetServiceListQueryParameters): QueryKey;
export function handleGetServiceListQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): QueryKey;
export function handleGetServiceListQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetServiceListQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetServiceList',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetServiceList',
        ...params
      ]);
  }
}
export function __handleGetServiceList(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetServiceList(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined);
}

export function useHandleGetServiceListQuery<TSelectData = Types.ServiceList, TError = unknown>(dto: HandleGetServiceListQueryParameters, options?: Omit<UseQueryOptions<Types.ServiceList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Services from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleGetServiceListQuery<TSelectData = Types.ServiceList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseQueryOptions<Types.ServiceList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetServiceListQuery<TSelectData = Types.ServiceList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ServiceList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetServiceListQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ServiceList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetServiceList(context, axiosConfig) : __handleGetServiceList,
    queryKey: handleGetServiceListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    ...handleGetServiceListDefaultOptions as unknown as Omit<UseQueryOptions<Types.ServiceList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Services from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetServiceListData(queryClient: QueryClient, updater: (data: Types.ServiceList | undefined) => Types.ServiceList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined) {
  queryClient.setQueryData(handleGetServiceListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    updater
  );
}

/**
 * returns a list of Services from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetServiceListDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ServiceList | undefined) => Types.ServiceList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetServiceList2Url(namespace: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/service/{namespace}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetServiceList2DefaultOptions: Omit<UseQueryOptions<Types.ServiceList, unknown, Types.ServiceList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ServiceList, unknown, Types.ServiceList>, 'queryFn'>> = {
};
export function getHandleGetServiceList2DefaultOptions() {
  return handleGetServiceList2DefaultOptions;
};
export function setHandleGetServiceList2DefaultOptions(options: typeof handleGetServiceList2DefaultOptions) {
  handleGetServiceList2DefaultOptions = options;
}

export function handleGetServiceList2QueryKey(dto: HandleGetServiceList2QueryParameters): QueryKey;
export function handleGetServiceList2QueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string): QueryKey;
export function handleGetServiceList2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetServiceList2QueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetServiceList2',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetServiceList2',
        ...params
      ]);
  }
}
export function __handleGetServiceList2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetServiceList2(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetServiceList2Query<TSelectData = Types.ServiceList, TError = unknown>(dto: HandleGetServiceList2QueryParameters, options?: Omit<UseQueryOptions<Types.ServiceList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Services in a namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Service
 * @return OK
 */
export function useHandleGetServiceList2Query<TSelectData = Types.ServiceList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, options?: Omit<UseQueryOptions<Types.ServiceList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetServiceList2Query<TSelectData = Types.ServiceList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ServiceList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetServiceList2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ServiceList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetServiceList2(context, axiosConfig) : __handleGetServiceList2,
    queryKey: handleGetServiceList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    ...handleGetServiceList2DefaultOptions as unknown as Omit<UseQueryOptions<Types.ServiceList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Services in a namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Service
 * @return OK
 */
export function setHandleGetServiceList2Data(queryClient: QueryClient, updater: (data: Types.ServiceList | undefined) => Types.ServiceList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string) {
  queryClient.setQueryData(handleGetServiceList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    updater
  );
}

/**
 * returns a list of Services in a namespace
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Service
 * @return OK
 */
export function setHandleGetServiceList2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ServiceList | undefined) => Types.ServiceList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetServiceDetailUrl(namespace: string, service: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/service/{namespace}/{service}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (service === undefined || service === null)
  throw new Error("The parameter 'service' must be defined.");
url_ = url_.replace("{service}", encodeURIComponent("" + service));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetServiceDetailDefaultOptions: Omit<UseQueryOptions<Types.ServiceDetail, unknown, Types.ServiceDetail>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ServiceDetail, unknown, Types.ServiceDetail>, 'queryFn'>> = {
};
export function getHandleGetServiceDetailDefaultOptions() {
  return handleGetServiceDetailDefaultOptions;
};
export function setHandleGetServiceDetailDefaultOptions(options: typeof handleGetServiceDetailDefaultOptions) {
  handleGetServiceDetailDefaultOptions = options;
}

export function handleGetServiceDetailQueryKey(dto: HandleGetServiceDetailQueryParameters): QueryKey;
export function handleGetServiceDetailQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, service: string): QueryKey;
export function handleGetServiceDetailQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, service,  } = params[0] as HandleGetServiceDetailQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetServiceDetail',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        service as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetServiceDetail',
        ...params
      ]);
  }
}
export function __handleGetServiceDetail(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetServiceDetail(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetServiceDetailQuery<TSelectData = Types.ServiceDetail, TError = unknown>(dto: HandleGetServiceDetailQueryParameters, options?: Omit<UseQueryOptions<Types.ServiceDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns detailed information about Service
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Service
 * @param service name of the Service
 * @return OK
 */
export function useHandleGetServiceDetailQuery<TSelectData = Types.ServiceDetail, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, service: string, options?: Omit<UseQueryOptions<Types.ServiceDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetServiceDetailQuery<TSelectData = Types.ServiceDetail, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ServiceDetail, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let service: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, service,  } = params[0] as HandleGetServiceDetailQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, service, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ServiceDetail, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetServiceDetail(context, axiosConfig) : __handleGetServiceDetail,
    queryKey: handleGetServiceDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, service),
    ...handleGetServiceDetailDefaultOptions as unknown as Omit<UseQueryOptions<Types.ServiceDetail, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns detailed information about Service
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Service
 * @param service name of the Service
 * @return OK
 */
export function setHandleGetServiceDetailData(queryClient: QueryClient, updater: (data: Types.ServiceDetail | undefined) => Types.ServiceDetail, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, service: string) {
  queryClient.setQueryData(handleGetServiceDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, service),
    updater
  );
}

/**
 * returns detailed information about Service
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Service
 * @param service name of the Service
 * @return OK
 */
export function setHandleGetServiceDetailDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ServiceDetail | undefined) => Types.ServiceDetail) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetServiceEventUrl(namespace: string, service: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/service/{namespace}/{service}/event?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (service === undefined || service === null)
  throw new Error("The parameter 'service' must be defined.");
url_ = url_.replace("{service}", encodeURIComponent("" + service));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetServiceEventDefaultOptions: Omit<UseQueryOptions<Types.EventList, unknown, Types.EventList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.EventList, unknown, Types.EventList>, 'queryFn'>> = {
};
export function getHandleGetServiceEventDefaultOptions() {
  return handleGetServiceEventDefaultOptions;
};
export function setHandleGetServiceEventDefaultOptions(options: typeof handleGetServiceEventDefaultOptions) {
  handleGetServiceEventDefaultOptions = options;
}

export function handleGetServiceEventQueryKey(dto: HandleGetServiceEventQueryParameters): QueryKey;
export function handleGetServiceEventQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, service: string): QueryKey;
export function handleGetServiceEventQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, service,  } = params[0] as HandleGetServiceEventQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetServiceEvent',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        service as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetServiceEvent',
        ...params
      ]);
  }
}
export function __handleGetServiceEvent(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetServiceEvent(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetServiceEventQuery<TSelectData = Types.EventList, TError = unknown>(dto: HandleGetServiceEventQueryParameters, options?: Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Events for Service
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Service
 * @param service name of the Service
 * @return OK
 */
export function useHandleGetServiceEventQuery<TSelectData = Types.EventList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, service: string, options?: Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetServiceEventQuery<TSelectData = Types.EventList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.EventList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let service: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, service,  } = params[0] as HandleGetServiceEventQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, service, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.EventList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetServiceEvent(context, axiosConfig) : __handleGetServiceEvent,
    queryKey: handleGetServiceEventQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, service),
    ...handleGetServiceEventDefaultOptions as unknown as Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Events for Service
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Service
 * @param service name of the Service
 * @return OK
 */
export function setHandleGetServiceEventData(queryClient: QueryClient, updater: (data: Types.EventList | undefined) => Types.EventList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, service: string) {
  queryClient.setQueryData(handleGetServiceEventQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, service),
    updater
  );
}

/**
 * returns a list of Events for Service
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Service
 * @param service name of the Service
 * @return OK
 */
export function setHandleGetServiceEventDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.EventList | undefined) => Types.EventList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetServiceIngressListUrl(namespace: string, service: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/service/{namespace}/{service}/ingress?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (service === undefined || service === null)
  throw new Error("The parameter 'service' must be defined.");
url_ = url_.replace("{service}", encodeURIComponent("" + service));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetServiceIngressListDefaultOptions: Omit<UseQueryOptions<Types.IngressList, unknown, Types.IngressList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.IngressList, unknown, Types.IngressList>, 'queryFn'>> = {
};
export function getHandleGetServiceIngressListDefaultOptions() {
  return handleGetServiceIngressListDefaultOptions;
};
export function setHandleGetServiceIngressListDefaultOptions(options: typeof handleGetServiceIngressListDefaultOptions) {
  handleGetServiceIngressListDefaultOptions = options;
}

export function handleGetServiceIngressListQueryKey(dto: HandleGetServiceIngressListQueryParameters): QueryKey;
export function handleGetServiceIngressListQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, service: string): QueryKey;
export function handleGetServiceIngressListQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, service,  } = params[0] as HandleGetServiceIngressListQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetServiceIngressList',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        service as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetServiceIngressList',
        ...params
      ]);
  }
}
export function __handleGetServiceIngressList(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetServiceIngressList(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetServiceIngressListQuery<TSelectData = Types.IngressList, TError = unknown>(dto: HandleGetServiceIngressListQueryParameters, options?: Omit<UseQueryOptions<Types.IngressList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Ingresses for Service
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Service
 * @param service name of the Service
 * @return OK
 */
export function useHandleGetServiceIngressListQuery<TSelectData = Types.IngressList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, service: string, options?: Omit<UseQueryOptions<Types.IngressList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetServiceIngressListQuery<TSelectData = Types.IngressList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.IngressList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let service: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, service,  } = params[0] as HandleGetServiceIngressListQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, service, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.IngressList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetServiceIngressList(context, axiosConfig) : __handleGetServiceIngressList,
    queryKey: handleGetServiceIngressListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, service),
    ...handleGetServiceIngressListDefaultOptions as unknown as Omit<UseQueryOptions<Types.IngressList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Ingresses for Service
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Service
 * @param service name of the Service
 * @return OK
 */
export function setHandleGetServiceIngressListData(queryClient: QueryClient, updater: (data: Types.IngressList | undefined) => Types.IngressList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, service: string) {
  queryClient.setQueryData(handleGetServiceIngressListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, service),
    updater
  );
}

/**
 * returns a list of Ingresses for Service
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Service
 * @param service name of the Service
 * @return OK
 */
export function setHandleGetServiceIngressListDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.IngressList | undefined) => Types.IngressList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetServicePodsUrl(namespace: string, service: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/service/{namespace}/{service}/pod?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (service === undefined || service === null)
  throw new Error("The parameter 'service' must be defined.");
url_ = url_.replace("{service}", encodeURIComponent("" + service));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetServicePodsDefaultOptions: Omit<UseQueryOptions<Types.PodList, unknown, Types.PodList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PodList, unknown, Types.PodList>, 'queryFn'>> = {
};
export function getHandleGetServicePodsDefaultOptions() {
  return handleGetServicePodsDefaultOptions;
};
export function setHandleGetServicePodsDefaultOptions(options: typeof handleGetServicePodsDefaultOptions) {
  handleGetServicePodsDefaultOptions = options;
}

export function handleGetServicePodsQueryKey(dto: HandleGetServicePodsQueryParameters): QueryKey;
export function handleGetServicePodsQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, service: string): QueryKey;
export function handleGetServicePodsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, service,  } = params[0] as HandleGetServicePodsQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetServicePods',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        service as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetServicePods',
        ...params
      ]);
  }
}
export function __handleGetServicePods(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetServicePods(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetServicePodsQuery<TSelectData = Types.PodList, TError = unknown>(dto: HandleGetServicePodsQueryParameters, options?: Omit<UseQueryOptions<Types.PodList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Pods for Service
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Service
 * @param service name of the Service
 * @return OK
 */
export function useHandleGetServicePodsQuery<TSelectData = Types.PodList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, service: string, options?: Omit<UseQueryOptions<Types.PodList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetServicePodsQuery<TSelectData = Types.PodList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PodList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let service: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, service,  } = params[0] as HandleGetServicePodsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, service, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PodList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetServicePods(context, axiosConfig) : __handleGetServicePods,
    queryKey: handleGetServicePodsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, service),
    ...handleGetServicePodsDefaultOptions as unknown as Omit<UseQueryOptions<Types.PodList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Pods for Service
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Service
 * @param service name of the Service
 * @return OK
 */
export function setHandleGetServicePodsData(queryClient: QueryClient, updater: (data: Types.PodList | undefined) => Types.PodList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, service: string) {
  queryClient.setQueryData(handleGetServicePodsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, service),
    updater
  );
}

/**
 * returns a list of Pods for Service
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the Service
 * @param service name of the Service
 * @return OK
 */
export function setHandleGetServicePodsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PodList | undefined) => Types.PodList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetServiceAccountListUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/serviceaccount?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetServiceAccountListDefaultOptions: Omit<UseQueryOptions<Types.ServiceAccountList, unknown, Types.ServiceAccountList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ServiceAccountList, unknown, Types.ServiceAccountList>, 'queryFn'>> = {
};
export function getHandleGetServiceAccountListDefaultOptions() {
  return handleGetServiceAccountListDefaultOptions;
};
export function setHandleGetServiceAccountListDefaultOptions(options: typeof handleGetServiceAccountListDefaultOptions) {
  handleGetServiceAccountListDefaultOptions = options;
}

export function handleGetServiceAccountListQueryKey(dto: HandleGetServiceAccountListQueryParameters): QueryKey;
export function handleGetServiceAccountListQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): QueryKey;
export function handleGetServiceAccountListQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetServiceAccountListQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetServiceAccountList',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetServiceAccountList',
        ...params
      ]);
  }
}
export function __handleGetServiceAccountList(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetServiceAccountList(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined);
}

export function useHandleGetServiceAccountListQuery<TSelectData = Types.ServiceAccountList, TError = unknown>(dto: HandleGetServiceAccountListQueryParameters, options?: Omit<UseQueryOptions<Types.ServiceAccountList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of ServiceAccounts from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleGetServiceAccountListQuery<TSelectData = Types.ServiceAccountList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseQueryOptions<Types.ServiceAccountList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetServiceAccountListQuery<TSelectData = Types.ServiceAccountList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ServiceAccountList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetServiceAccountListQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ServiceAccountList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetServiceAccountList(context, axiosConfig) : __handleGetServiceAccountList,
    queryKey: handleGetServiceAccountListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    ...handleGetServiceAccountListDefaultOptions as unknown as Omit<UseQueryOptions<Types.ServiceAccountList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of ServiceAccounts from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetServiceAccountListData(queryClient: QueryClient, updater: (data: Types.ServiceAccountList | undefined) => Types.ServiceAccountList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined) {
  queryClient.setQueryData(handleGetServiceAccountListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    updater
  );
}

/**
 * returns a list of ServiceAccounts from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetServiceAccountListDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ServiceAccountList | undefined) => Types.ServiceAccountList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetServiceAccountList2Url(namespace: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/serviceaccount/{namespace}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetServiceAccountList2DefaultOptions: Omit<UseQueryOptions<Types.ServiceAccountList, unknown, Types.ServiceAccountList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ServiceAccountList, unknown, Types.ServiceAccountList>, 'queryFn'>> = {
};
export function getHandleGetServiceAccountList2DefaultOptions() {
  return handleGetServiceAccountList2DefaultOptions;
};
export function setHandleGetServiceAccountList2DefaultOptions(options: typeof handleGetServiceAccountList2DefaultOptions) {
  handleGetServiceAccountList2DefaultOptions = options;
}

export function handleGetServiceAccountList2QueryKey(dto: HandleGetServiceAccountList2QueryParameters): QueryKey;
export function handleGetServiceAccountList2QueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string): QueryKey;
export function handleGetServiceAccountList2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetServiceAccountList2QueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetServiceAccountList2',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetServiceAccountList2',
        ...params
      ]);
  }
}
export function __handleGetServiceAccountList2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetServiceAccountList2(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetServiceAccountList2Query<TSelectData = Types.ServiceAccountList, TError = unknown>(dto: HandleGetServiceAccountList2QueryParameters, options?: Omit<UseQueryOptions<Types.ServiceAccountList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of ServiceAccounts in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ServiceAccount
 * @return OK
 */
export function useHandleGetServiceAccountList2Query<TSelectData = Types.ServiceAccountList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, options?: Omit<UseQueryOptions<Types.ServiceAccountList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetServiceAccountList2Query<TSelectData = Types.ServiceAccountList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ServiceAccountList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetServiceAccountList2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ServiceAccountList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetServiceAccountList2(context, axiosConfig) : __handleGetServiceAccountList2,
    queryKey: handleGetServiceAccountList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    ...handleGetServiceAccountList2DefaultOptions as unknown as Omit<UseQueryOptions<Types.ServiceAccountList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of ServiceAccounts in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ServiceAccount
 * @return OK
 */
export function setHandleGetServiceAccountList2Data(queryClient: QueryClient, updater: (data: Types.ServiceAccountList | undefined) => Types.ServiceAccountList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string) {
  queryClient.setQueryData(handleGetServiceAccountList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    updater
  );
}

/**
 * returns a list of ServiceAccounts in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ServiceAccount
 * @return OK
 */
export function setHandleGetServiceAccountList2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ServiceAccountList | undefined) => Types.ServiceAccountList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetServiceAccountDetailUrl(namespace: string, serviceaccount: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/serviceaccount/{namespace}/{serviceaccount}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (serviceaccount === undefined || serviceaccount === null)
  throw new Error("The parameter 'serviceaccount' must be defined.");
url_ = url_.replace("{serviceaccount}", encodeURIComponent("" + serviceaccount));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetServiceAccountDetailDefaultOptions: Omit<UseQueryOptions<Types.ServiceAccountDetail, unknown, Types.ServiceAccountDetail>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ServiceAccountDetail, unknown, Types.ServiceAccountDetail>, 'queryFn'>> = {
};
export function getHandleGetServiceAccountDetailDefaultOptions() {
  return handleGetServiceAccountDetailDefaultOptions;
};
export function setHandleGetServiceAccountDetailDefaultOptions(options: typeof handleGetServiceAccountDetailDefaultOptions) {
  handleGetServiceAccountDetailDefaultOptions = options;
}

export function handleGetServiceAccountDetailQueryKey(dto: HandleGetServiceAccountDetailQueryParameters): QueryKey;
export function handleGetServiceAccountDetailQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, serviceaccount: string): QueryKey;
export function handleGetServiceAccountDetailQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, serviceaccount,  } = params[0] as HandleGetServiceAccountDetailQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetServiceAccountDetail',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        serviceaccount as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetServiceAccountDetail',
        ...params
      ]);
  }
}
export function __handleGetServiceAccountDetail(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetServiceAccountDetail(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetServiceAccountDetailQuery<TSelectData = Types.ServiceAccountDetail, TError = unknown>(dto: HandleGetServiceAccountDetailQueryParameters, options?: Omit<UseQueryOptions<Types.ServiceAccountDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns detailed information about ServiceAccount
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ServiceAccount
 * @param serviceaccount name of the ServiceAccount
 * @return OK
 */
export function useHandleGetServiceAccountDetailQuery<TSelectData = Types.ServiceAccountDetail, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, serviceaccount: string, options?: Omit<UseQueryOptions<Types.ServiceAccountDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetServiceAccountDetailQuery<TSelectData = Types.ServiceAccountDetail, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ServiceAccountDetail, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let serviceaccount: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, serviceaccount,  } = params[0] as HandleGetServiceAccountDetailQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, serviceaccount, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ServiceAccountDetail, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetServiceAccountDetail(context, axiosConfig) : __handleGetServiceAccountDetail,
    queryKey: handleGetServiceAccountDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, serviceaccount),
    ...handleGetServiceAccountDetailDefaultOptions as unknown as Omit<UseQueryOptions<Types.ServiceAccountDetail, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns detailed information about ServiceAccount
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ServiceAccount
 * @param serviceaccount name of the ServiceAccount
 * @return OK
 */
export function setHandleGetServiceAccountDetailData(queryClient: QueryClient, updater: (data: Types.ServiceAccountDetail | undefined) => Types.ServiceAccountDetail, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, serviceaccount: string) {
  queryClient.setQueryData(handleGetServiceAccountDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, serviceaccount),
    updater
  );
}

/**
 * returns detailed information about ServiceAccount
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ServiceAccount
 * @param serviceaccount name of the ServiceAccount
 * @return OK
 */
export function setHandleGetServiceAccountDetailDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ServiceAccountDetail | undefined) => Types.ServiceAccountDetail) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetServiceAccountImagePullSecretsUrl(namespace: string, serviceaccount: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/serviceaccount/{namespace}/{serviceaccount}/imagepullsecret?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (serviceaccount === undefined || serviceaccount === null)
  throw new Error("The parameter 'serviceaccount' must be defined.");
url_ = url_.replace("{serviceaccount}", encodeURIComponent("" + serviceaccount));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetServiceAccountImagePullSecretsDefaultOptions: Omit<UseQueryOptions<Types.SecretList, unknown, Types.SecretList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.SecretList, unknown, Types.SecretList>, 'queryFn'>> = {
};
export function getHandleGetServiceAccountImagePullSecretsDefaultOptions() {
  return handleGetServiceAccountImagePullSecretsDefaultOptions;
};
export function setHandleGetServiceAccountImagePullSecretsDefaultOptions(options: typeof handleGetServiceAccountImagePullSecretsDefaultOptions) {
  handleGetServiceAccountImagePullSecretsDefaultOptions = options;
}

export function handleGetServiceAccountImagePullSecretsQueryKey(dto: HandleGetServiceAccountImagePullSecretsQueryParameters): QueryKey;
export function handleGetServiceAccountImagePullSecretsQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, serviceaccount: string): QueryKey;
export function handleGetServiceAccountImagePullSecretsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, serviceaccount,  } = params[0] as HandleGetServiceAccountImagePullSecretsQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetServiceAccountImagePullSecrets',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        serviceaccount as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetServiceAccountImagePullSecrets',
        ...params
      ]);
  }
}
export function __handleGetServiceAccountImagePullSecrets(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetServiceAccountImagePullSecrets(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetServiceAccountImagePullSecretsQuery<TSelectData = Types.SecretList, TError = unknown>(dto: HandleGetServiceAccountImagePullSecretsQueryParameters, options?: Omit<UseQueryOptions<Types.SecretList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of ImagePullSecret Secrets for ServiceAccount
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ServiceAccount
 * @param serviceaccount name of the ServiceAccount
 * @return OK
 */
export function useHandleGetServiceAccountImagePullSecretsQuery<TSelectData = Types.SecretList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, serviceaccount: string, options?: Omit<UseQueryOptions<Types.SecretList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetServiceAccountImagePullSecretsQuery<TSelectData = Types.SecretList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.SecretList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let serviceaccount: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, serviceaccount,  } = params[0] as HandleGetServiceAccountImagePullSecretsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, serviceaccount, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.SecretList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetServiceAccountImagePullSecrets(context, axiosConfig) : __handleGetServiceAccountImagePullSecrets,
    queryKey: handleGetServiceAccountImagePullSecretsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, serviceaccount),
    ...handleGetServiceAccountImagePullSecretsDefaultOptions as unknown as Omit<UseQueryOptions<Types.SecretList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of ImagePullSecret Secrets for ServiceAccount
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ServiceAccount
 * @param serviceaccount name of the ServiceAccount
 * @return OK
 */
export function setHandleGetServiceAccountImagePullSecretsData(queryClient: QueryClient, updater: (data: Types.SecretList | undefined) => Types.SecretList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, serviceaccount: string) {
  queryClient.setQueryData(handleGetServiceAccountImagePullSecretsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, serviceaccount),
    updater
  );
}

/**
 * returns a list of ImagePullSecret Secrets for ServiceAccount
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ServiceAccount
 * @param serviceaccount name of the ServiceAccount
 * @return OK
 */
export function setHandleGetServiceAccountImagePullSecretsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.SecretList | undefined) => Types.SecretList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetServiceAccountSecretsUrl(namespace: string, serviceaccount: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/serviceaccount/{namespace}/{serviceaccount}/secret?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (serviceaccount === undefined || serviceaccount === null)
  throw new Error("The parameter 'serviceaccount' must be defined.");
url_ = url_.replace("{serviceaccount}", encodeURIComponent("" + serviceaccount));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetServiceAccountSecretsDefaultOptions: Omit<UseQueryOptions<Types.SecretList, unknown, Types.SecretList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.SecretList, unknown, Types.SecretList>, 'queryFn'>> = {
};
export function getHandleGetServiceAccountSecretsDefaultOptions() {
  return handleGetServiceAccountSecretsDefaultOptions;
};
export function setHandleGetServiceAccountSecretsDefaultOptions(options: typeof handleGetServiceAccountSecretsDefaultOptions) {
  handleGetServiceAccountSecretsDefaultOptions = options;
}

export function handleGetServiceAccountSecretsQueryKey(dto: HandleGetServiceAccountSecretsQueryParameters): QueryKey;
export function handleGetServiceAccountSecretsQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, serviceaccount: string): QueryKey;
export function handleGetServiceAccountSecretsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, serviceaccount,  } = params[0] as HandleGetServiceAccountSecretsQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetServiceAccountSecrets',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        serviceaccount as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetServiceAccountSecrets',
        ...params
      ]);
  }
}
export function __handleGetServiceAccountSecrets(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetServiceAccountSecrets(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetServiceAccountSecretsQuery<TSelectData = Types.SecretList, TError = unknown>(dto: HandleGetServiceAccountSecretsQueryParameters, options?: Omit<UseQueryOptions<Types.SecretList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Secrets for ServiceAccount
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ServiceAccount
 * @param serviceaccount name of the ServiceAccount
 * @return OK
 */
export function useHandleGetServiceAccountSecretsQuery<TSelectData = Types.SecretList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, serviceaccount: string, options?: Omit<UseQueryOptions<Types.SecretList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetServiceAccountSecretsQuery<TSelectData = Types.SecretList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.SecretList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let serviceaccount: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, serviceaccount,  } = params[0] as HandleGetServiceAccountSecretsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, serviceaccount, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.SecretList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetServiceAccountSecrets(context, axiosConfig) : __handleGetServiceAccountSecrets,
    queryKey: handleGetServiceAccountSecretsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, serviceaccount),
    ...handleGetServiceAccountSecretsDefaultOptions as unknown as Omit<UseQueryOptions<Types.SecretList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Secrets for ServiceAccount
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ServiceAccount
 * @param serviceaccount name of the ServiceAccount
 * @return OK
 */
export function setHandleGetServiceAccountSecretsData(queryClient: QueryClient, updater: (data: Types.SecretList | undefined) => Types.SecretList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, serviceaccount: string) {
  queryClient.setQueryData(handleGetServiceAccountSecretsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, serviceaccount),
    updater
  );
}

/**
 * returns a list of Secrets for ServiceAccount
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the ServiceAccount
 * @param serviceaccount name of the ServiceAccount
 * @return OK
 */
export function setHandleGetServiceAccountSecretsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.SecretList | undefined) => Types.SecretList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetStatefulSetListUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/statefulset?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetStatefulSetListDefaultOptions: Omit<UseQueryOptions<Types.StatefulSetList, unknown, Types.StatefulSetList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.StatefulSetList, unknown, Types.StatefulSetList>, 'queryFn'>> = {
};
export function getHandleGetStatefulSetListDefaultOptions() {
  return handleGetStatefulSetListDefaultOptions;
};
export function setHandleGetStatefulSetListDefaultOptions(options: typeof handleGetStatefulSetListDefaultOptions) {
  handleGetStatefulSetListDefaultOptions = options;
}

export function handleGetStatefulSetListQueryKey(dto: HandleGetStatefulSetListQueryParameters): QueryKey;
export function handleGetStatefulSetListQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): QueryKey;
export function handleGetStatefulSetListQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetStatefulSetListQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetStatefulSetList',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetStatefulSetList',
        ...params
      ]);
  }
}
export function __handleGetStatefulSetList(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetStatefulSetList(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined);
}

export function useHandleGetStatefulSetListQuery<TSelectData = Types.StatefulSetList, TError = unknown>(dto: HandleGetStatefulSetListQueryParameters, options?: Omit<UseQueryOptions<Types.StatefulSetList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of StatefulSets from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleGetStatefulSetListQuery<TSelectData = Types.StatefulSetList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseQueryOptions<Types.StatefulSetList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetStatefulSetListQuery<TSelectData = Types.StatefulSetList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.StatefulSetList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetStatefulSetListQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.StatefulSetList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetStatefulSetList(context, axiosConfig) : __handleGetStatefulSetList,
    queryKey: handleGetStatefulSetListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    ...handleGetStatefulSetListDefaultOptions as unknown as Omit<UseQueryOptions<Types.StatefulSetList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of StatefulSets from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetStatefulSetListData(queryClient: QueryClient, updater: (data: Types.StatefulSetList | undefined) => Types.StatefulSetList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined) {
  queryClient.setQueryData(handleGetStatefulSetListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    updater
  );
}

/**
 * returns a list of StatefulSets from all namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetStatefulSetListDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.StatefulSetList | undefined) => Types.StatefulSetList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetStatefulSetList2Url(namespace: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/statefulset/{namespace}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetStatefulSetList2DefaultOptions: Omit<UseQueryOptions<Types.StatefulSetList, unknown, Types.StatefulSetList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.StatefulSetList, unknown, Types.StatefulSetList>, 'queryFn'>> = {
};
export function getHandleGetStatefulSetList2DefaultOptions() {
  return handleGetStatefulSetList2DefaultOptions;
};
export function setHandleGetStatefulSetList2DefaultOptions(options: typeof handleGetStatefulSetList2DefaultOptions) {
  handleGetStatefulSetList2DefaultOptions = options;
}

export function handleGetStatefulSetList2QueryKey(dto: HandleGetStatefulSetList2QueryParameters): QueryKey;
export function handleGetStatefulSetList2QueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string): QueryKey;
export function handleGetStatefulSetList2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetStatefulSetList2QueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetStatefulSetList2',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetStatefulSetList2',
        ...params
      ]);
  }
}
export function __handleGetStatefulSetList2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetStatefulSetList2(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetStatefulSetList2Query<TSelectData = Types.StatefulSetList, TError = unknown>(dto: HandleGetStatefulSetList2QueryParameters, options?: Omit<UseQueryOptions<Types.StatefulSetList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of StatefulSets in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the StatefulSet
 * @return OK
 */
export function useHandleGetStatefulSetList2Query<TSelectData = Types.StatefulSetList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, options?: Omit<UseQueryOptions<Types.StatefulSetList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetStatefulSetList2Query<TSelectData = Types.StatefulSetList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.StatefulSetList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace,  } = params[0] as HandleGetStatefulSetList2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.StatefulSetList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetStatefulSetList2(context, axiosConfig) : __handleGetStatefulSetList2,
    queryKey: handleGetStatefulSetList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    ...handleGetStatefulSetList2DefaultOptions as unknown as Omit<UseQueryOptions<Types.StatefulSetList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of StatefulSets in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the StatefulSet
 * @return OK
 */
export function setHandleGetStatefulSetList2Data(queryClient: QueryClient, updater: (data: Types.StatefulSetList | undefined) => Types.StatefulSetList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string) {
  queryClient.setQueryData(handleGetStatefulSetList2QueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace),
    updater
  );
}

/**
 * returns a list of StatefulSets in a namespaces
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the StatefulSet
 * @return OK
 */
export function setHandleGetStatefulSetList2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.StatefulSetList | undefined) => Types.StatefulSetList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetStatefulSetDetailUrl(namespace: string, statefulset: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/statefulset/{namespace}/{statefulset}?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (statefulset === undefined || statefulset === null)
  throw new Error("The parameter 'statefulset' must be defined.");
url_ = url_.replace("{statefulset}", encodeURIComponent("" + statefulset));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetStatefulSetDetailDefaultOptions: Omit<UseQueryOptions<Types.StatefulSetDetail, unknown, Types.StatefulSetDetail>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.StatefulSetDetail, unknown, Types.StatefulSetDetail>, 'queryFn'>> = {
};
export function getHandleGetStatefulSetDetailDefaultOptions() {
  return handleGetStatefulSetDetailDefaultOptions;
};
export function setHandleGetStatefulSetDetailDefaultOptions(options: typeof handleGetStatefulSetDetailDefaultOptions) {
  handleGetStatefulSetDetailDefaultOptions = options;
}

export function handleGetStatefulSetDetailQueryKey(dto: HandleGetStatefulSetDetailQueryParameters): QueryKey;
export function handleGetStatefulSetDetailQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, statefulset: string): QueryKey;
export function handleGetStatefulSetDetailQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, statefulset,  } = params[0] as HandleGetStatefulSetDetailQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetStatefulSetDetail',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        statefulset as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetStatefulSetDetail',
        ...params
      ]);
  }
}
export function __handleGetStatefulSetDetail(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetStatefulSetDetail(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetStatefulSetDetailQuery<TSelectData = Types.StatefulSetDetail, TError = unknown>(dto: HandleGetStatefulSetDetailQueryParameters, options?: Omit<UseQueryOptions<Types.StatefulSetDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns detailed information about StatefulSets
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the StatefulSet
 * @param statefulset name of the StatefulSet
 * @return OK
 */
export function useHandleGetStatefulSetDetailQuery<TSelectData = Types.StatefulSetDetail, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, statefulset: string, options?: Omit<UseQueryOptions<Types.StatefulSetDetail, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetStatefulSetDetailQuery<TSelectData = Types.StatefulSetDetail, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.StatefulSetDetail, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let statefulset: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, statefulset,  } = params[0] as HandleGetStatefulSetDetailQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, statefulset, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.StatefulSetDetail, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetStatefulSetDetail(context, axiosConfig) : __handleGetStatefulSetDetail,
    queryKey: handleGetStatefulSetDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, statefulset),
    ...handleGetStatefulSetDetailDefaultOptions as unknown as Omit<UseQueryOptions<Types.StatefulSetDetail, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns detailed information about StatefulSets
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the StatefulSet
 * @param statefulset name of the StatefulSet
 * @return OK
 */
export function setHandleGetStatefulSetDetailData(queryClient: QueryClient, updater: (data: Types.StatefulSetDetail | undefined) => Types.StatefulSetDetail, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, statefulset: string) {
  queryClient.setQueryData(handleGetStatefulSetDetailQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, statefulset),
    updater
  );
}

/**
 * returns detailed information about StatefulSets
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the StatefulSet
 * @param statefulset name of the StatefulSet
 * @return OK
 */
export function setHandleGetStatefulSetDetailDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.StatefulSetDetail | undefined) => Types.StatefulSetDetail) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetStatefulSetEventsUrl(namespace: string, statefulset: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/statefulset/{namespace}/{statefulset}/event?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (statefulset === undefined || statefulset === null)
  throw new Error("The parameter 'statefulset' must be defined.");
url_ = url_.replace("{statefulset}", encodeURIComponent("" + statefulset));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetStatefulSetEventsDefaultOptions: Omit<UseQueryOptions<Types.EventList, unknown, Types.EventList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.EventList, unknown, Types.EventList>, 'queryFn'>> = {
};
export function getHandleGetStatefulSetEventsDefaultOptions() {
  return handleGetStatefulSetEventsDefaultOptions;
};
export function setHandleGetStatefulSetEventsDefaultOptions(options: typeof handleGetStatefulSetEventsDefaultOptions) {
  handleGetStatefulSetEventsDefaultOptions = options;
}

export function handleGetStatefulSetEventsQueryKey(dto: HandleGetStatefulSetEventsQueryParameters): QueryKey;
export function handleGetStatefulSetEventsQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, statefulset: string): QueryKey;
export function handleGetStatefulSetEventsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, statefulset,  } = params[0] as HandleGetStatefulSetEventsQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetStatefulSetEvents',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        statefulset as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetStatefulSetEvents',
        ...params
      ]);
  }
}
export function __handleGetStatefulSetEvents(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetStatefulSetEvents(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetStatefulSetEventsQuery<TSelectData = Types.EventList, TError = unknown>(dto: HandleGetStatefulSetEventsQueryParameters, options?: Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of Events for StatefulSets
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the StatefulSet
 * @param statefulset name of the StatefulSet
 * @return OK
 */
export function useHandleGetStatefulSetEventsQuery<TSelectData = Types.EventList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, statefulset: string, options?: Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetStatefulSetEventsQuery<TSelectData = Types.EventList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.EventList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let statefulset: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, statefulset,  } = params[0] as HandleGetStatefulSetEventsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, statefulset, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.EventList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetStatefulSetEvents(context, axiosConfig) : __handleGetStatefulSetEvents,
    queryKey: handleGetStatefulSetEventsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, statefulset),
    ...handleGetStatefulSetEventsDefaultOptions as unknown as Omit<UseQueryOptions<Types.EventList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of Events for StatefulSets
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the StatefulSet
 * @param statefulset name of the StatefulSet
 * @return OK
 */
export function setHandleGetStatefulSetEventsData(queryClient: QueryClient, updater: (data: Types.EventList | undefined) => Types.EventList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, statefulset: string) {
  queryClient.setQueryData(handleGetStatefulSetEventsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, statefulset),
    updater
  );
}

/**
 * returns a list of Events for StatefulSets
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the StatefulSet
 * @param statefulset name of the StatefulSet
 * @return OK
 */
export function setHandleGetStatefulSetEventsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.EventList | undefined) => Types.EventList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetStatefulSetPodsUrl(namespace: string, statefulset: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/statefulset/{namespace}/{statefulset}/pod?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (statefulset === undefined || statefulset === null)
  throw new Error("The parameter 'statefulset' must be defined.");
url_ = url_.replace("{statefulset}", encodeURIComponent("" + statefulset));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetStatefulSetPodsDefaultOptions: Omit<UseQueryOptions<Types.PodList, unknown, Types.PodList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PodList, unknown, Types.PodList>, 'queryFn'>> = {
};
export function getHandleGetStatefulSetPodsDefaultOptions() {
  return handleGetStatefulSetPodsDefaultOptions;
};
export function setHandleGetStatefulSetPodsDefaultOptions(options: typeof handleGetStatefulSetPodsDefaultOptions) {
  handleGetStatefulSetPodsDefaultOptions = options;
}

export function handleGetStatefulSetPodsQueryKey(dto: HandleGetStatefulSetPodsQueryParameters): QueryKey;
export function handleGetStatefulSetPodsQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, statefulset: string): QueryKey;
export function handleGetStatefulSetPodsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, statefulset,  } = params[0] as HandleGetStatefulSetPodsQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetStatefulSetPods',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        namespace as any,
        statefulset as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetStatefulSetPods',
        ...params
      ]);
  }
}
export function __handleGetStatefulSetPods(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetStatefulSetPods(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string);
}

export function useHandleGetStatefulSetPodsQuery<TSelectData = Types.PodList, TError = unknown>(dto: HandleGetStatefulSetPodsQueryParameters, options?: Omit<UseQueryOptions<Types.PodList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns  a list of Pods for StatefulSets
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the StatefulSet
 * @param statefulset name of the StatefulSet
 * @return OK
 */
export function useHandleGetStatefulSetPodsQuery<TSelectData = Types.PodList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, statefulset: string, options?: Omit<UseQueryOptions<Types.PodList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetStatefulSetPodsQuery<TSelectData = Types.PodList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PodList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let namespace: any = undefined;
  let statefulset: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, statefulset,  } = params[0] as HandleGetStatefulSetPodsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, statefulset, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PodList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetStatefulSetPods(context, axiosConfig) : __handleGetStatefulSetPods,
    queryKey: handleGetStatefulSetPodsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, statefulset),
    ...handleGetStatefulSetPodsDefaultOptions as unknown as Omit<UseQueryOptions<Types.PodList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns  a list of Pods for StatefulSets
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the StatefulSet
 * @param statefulset name of the StatefulSet
 * @return OK
 */
export function setHandleGetStatefulSetPodsData(queryClient: QueryClient, updater: (data: Types.PodList | undefined) => Types.PodList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, namespace: string, statefulset: string) {
  queryClient.setQueryData(handleGetStatefulSetPodsQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, statefulset),
    updater
  );
}

/**
 * returns  a list of Pods for StatefulSets
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the StatefulSet
 * @param statefulset name of the StatefulSet
 * @return OK
 */
export function setHandleGetStatefulSetPodsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PodList | undefined) => Types.PodList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleStatefulSetRestartUrl(namespace: string, statefulset: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/statefulset/{namespace}/{statefulset}/restart?";
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (statefulset === undefined || statefulset === null)
  throw new Error("The parameter 'statefulset' must be defined.");
url_ = url_.replace("{statefulset}", encodeURIComponent("" + statefulset));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function handleStatefulSetRestartMutationKey(namespace: string, statefulset: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'handleStatefulSetRestart',
      namespace as any,
      statefulset as any,
      filterBy as any,
      sortBy as any,
      itemsPerPage as any,
      page as any,
      metricNames as any,
      aggregations as any,
    ]);
}

/**
 * rollout restart of the Daemon Set
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the StatefulSet
 * @param statefulset name of the StatefulSet
 * @return OK
 */
export function useHandleStatefulSetRestartMutation<TContext>(namespace: string, statefulset: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseMutationOptions<Types.StatefulSetDetail, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.StatefulSetDetail, unknown, void, TContext> {
  const key = handleStatefulSetRestartMutationKey(namespace, statefulset, filterBy, sortBy, itemsPerPage, page, metricNames, aggregations);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client().handleStatefulSetRestart(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, namespace, statefulset),
    mutationKey: key,
  });
}
  
type HandleStatefulSetRestart__MutationParameters = HandleStatefulSetRestartQueryParameters

/**
 * rollout restart of the Daemon Set
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param namespace namespace of the StatefulSet
 * @param statefulset name of the StatefulSet
 * @return OK
 */
export function useHandleStatefulSetRestartMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.StatefulSetDetail, unknown, HandleStatefulSetRestart__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: HandleStatefulSetRestartQueryParameters}): UseMutationResult<Types.StatefulSetDetail, unknown, HandleStatefulSetRestart__MutationParameters, TContext> {
  const key = handleStatefulSetRestartMutationKey(options?.parameters?.namespace!, options?.parameters?.statefulset!, options?.parameters?.filterBy!, options?.parameters?.sortBy!, options?.parameters?.itemsPerPage!, options?.parameters?.page!, options?.parameters?.metricNames!, options?.parameters?.aggregations!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: HandleStatefulSetRestart__MutationParameters) => Client().handleStatefulSetRestart(data.filterBy ?? options?.parameters?.filterBy!, data.sortBy ?? options?.parameters?.sortBy!, data.itemsPerPage ?? options?.parameters?.itemsPerPage!, data.page ?? options?.parameters?.page!, data.metricNames ?? options?.parameters?.metricNames!, data.aggregations ?? options?.parameters?.aggregations!, data.namespace ?? options?.parameters?.namespace!, data.statefulset ?? options?.parameters?.statefulset!),
  mutationKey: key,
});
}
  
export function handleGetStorageClassListUrl(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/storageclass?";
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetStorageClassListDefaultOptions: Omit<UseQueryOptions<Types.StorageClassList, unknown, Types.StorageClassList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.StorageClassList, unknown, Types.StorageClassList>, 'queryFn'>> = {
};
export function getHandleGetStorageClassListDefaultOptions() {
  return handleGetStorageClassListDefaultOptions;
};
export function setHandleGetStorageClassListDefaultOptions(options: typeof handleGetStorageClassListDefaultOptions) {
  handleGetStorageClassListDefaultOptions = options;
}

export function handleGetStorageClassListQueryKey(dto: HandleGetStorageClassListQueryParameters): QueryKey;
export function handleGetStorageClassListQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): QueryKey;
export function handleGetStorageClassListQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetStorageClassListQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetStorageClassList',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetStorageClassList',
        ...params
      ]);
  }
}
export function __handleGetStorageClassList(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetStorageClassList(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined);
}

export function useHandleGetStorageClassListQuery<TSelectData = Types.StorageClassList, TError = unknown>(dto: HandleGetStorageClassListQueryParameters, options?: Omit<UseQueryOptions<Types.StorageClassList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of StorageClasses
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function useHandleGetStorageClassListQuery<TSelectData = Types.StorageClassList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, options?: Omit<UseQueryOptions<Types.StorageClassList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetStorageClassListQuery<TSelectData = Types.StorageClassList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.StorageClassList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations,  } = params[0] as HandleGetStorageClassListQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.StorageClassList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetStorageClassList(context, axiosConfig) : __handleGetStorageClassList,
    queryKey: handleGetStorageClassListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    ...handleGetStorageClassListDefaultOptions as unknown as Omit<UseQueryOptions<Types.StorageClassList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of StorageClasses
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetStorageClassListData(queryClient: QueryClient, updater: (data: Types.StorageClassList | undefined) => Types.StorageClassList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined) {
  queryClient.setQueryData(handleGetStorageClassListQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations),
    updater
  );
}

/**
 * returns a list of StorageClasses
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @return OK
 */
export function setHandleGetStorageClassListDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.StorageClassList | undefined) => Types.StorageClassList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetStorageClassUrl(storageclass: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/storageclass/{storageclass}?";
if (storageclass === undefined || storageclass === null)
  throw new Error("The parameter 'storageclass' must be defined.");
url_ = url_.replace("{storageclass}", encodeURIComponent("" + storageclass));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetStorageClassDefaultOptions: Omit<UseQueryOptions<Types.StorageClass, unknown, Types.StorageClass>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.StorageClass, unknown, Types.StorageClass>, 'queryFn'>> = {
};
export function getHandleGetStorageClassDefaultOptions() {
  return handleGetStorageClassDefaultOptions;
};
export function setHandleGetStorageClassDefaultOptions(options: typeof handleGetStorageClassDefaultOptions) {
  handleGetStorageClassDefaultOptions = options;
}

export function handleGetStorageClassQueryKey(dto: HandleGetStorageClassQueryParameters): QueryKey;
export function handleGetStorageClassQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, storageclass: string): QueryKey;
export function handleGetStorageClassQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, storageclass,  } = params[0] as HandleGetStorageClassQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetStorageClass',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        storageclass as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetStorageClass',
        ...params
      ]);
  }
}
export function __handleGetStorageClass(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetStorageClass(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetStorageClassQuery<TSelectData = Types.StorageClass, TError = unknown>(dto: HandleGetStorageClassQueryParameters, options?: Omit<UseQueryOptions<Types.StorageClass, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns detailed information about StorageClass
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param storageclass name of the StorageClass
 * @return OK
 */
export function useHandleGetStorageClassQuery<TSelectData = Types.StorageClass, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, storageclass: string, options?: Omit<UseQueryOptions<Types.StorageClass, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetStorageClassQuery<TSelectData = Types.StorageClass, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.StorageClass, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let storageclass: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, storageclass,  } = params[0] as HandleGetStorageClassQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, storageclass, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.StorageClass, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetStorageClass(context, axiosConfig) : __handleGetStorageClass,
    queryKey: handleGetStorageClassQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, storageclass),
    ...handleGetStorageClassDefaultOptions as unknown as Omit<UseQueryOptions<Types.StorageClass, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns detailed information about StorageClass
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param storageclass name of the StorageClass
 * @return OK
 */
export function setHandleGetStorageClassData(queryClient: QueryClient, updater: (data: Types.StorageClass | undefined) => Types.StorageClass, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, storageclass: string) {
  queryClient.setQueryData(handleGetStorageClassQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, storageclass),
    updater
  );
}

/**
 * returns detailed information about StorageClass
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param storageclass name of the StorageClass
 * @return OK
 */
export function setHandleGetStorageClassDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.StorageClass | undefined) => Types.StorageClass) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetStorageClassPersistentVolumesUrl(storageclass: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/storageclass/{storageclass}/persistentvolume?";
if (storageclass === undefined || storageclass === null)
  throw new Error("The parameter 'storageclass' must be defined.");
url_ = url_.replace("{storageclass}", encodeURIComponent("" + storageclass));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetStorageClassPersistentVolumesDefaultOptions: Omit<UseQueryOptions<Types.PersistentVolumeList, unknown, Types.PersistentVolumeList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PersistentVolumeList, unknown, Types.PersistentVolumeList>, 'queryFn'>> = {
};
export function getHandleGetStorageClassPersistentVolumesDefaultOptions() {
  return handleGetStorageClassPersistentVolumesDefaultOptions;
};
export function setHandleGetStorageClassPersistentVolumesDefaultOptions(options: typeof handleGetStorageClassPersistentVolumesDefaultOptions) {
  handleGetStorageClassPersistentVolumesDefaultOptions = options;
}

export function handleGetStorageClassPersistentVolumesQueryKey(dto: HandleGetStorageClassPersistentVolumesQueryParameters): QueryKey;
export function handleGetStorageClassPersistentVolumesQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, storageclass: string): QueryKey;
export function handleGetStorageClassPersistentVolumesQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, storageclass,  } = params[0] as HandleGetStorageClassPersistentVolumesQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetStorageClassPersistentVolumes',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        storageclass as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetStorageClassPersistentVolumes',
        ...params
      ]);
  }
}
export function __handleGetStorageClassPersistentVolumes(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetStorageClassPersistentVolumes(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string);
}

export function useHandleGetStorageClassPersistentVolumesQuery<TSelectData = Types.PersistentVolumeList, TError = unknown>(dto: HandleGetStorageClassPersistentVolumesQueryParameters, options?: Omit<UseQueryOptions<Types.PersistentVolumeList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of PersistentVolumes assigned to StorageClass
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param storageclass name of the StorageClass
 * @return OK
 */
export function useHandleGetStorageClassPersistentVolumesQuery<TSelectData = Types.PersistentVolumeList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, storageclass: string, options?: Omit<UseQueryOptions<Types.PersistentVolumeList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetStorageClassPersistentVolumesQuery<TSelectData = Types.PersistentVolumeList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PersistentVolumeList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let storageclass: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, storageclass,  } = params[0] as HandleGetStorageClassPersistentVolumesQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, storageclass, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PersistentVolumeList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetStorageClassPersistentVolumes(context, axiosConfig) : __handleGetStorageClassPersistentVolumes,
    queryKey: handleGetStorageClassPersistentVolumesQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, storageclass),
    ...handleGetStorageClassPersistentVolumesDefaultOptions as unknown as Omit<UseQueryOptions<Types.PersistentVolumeList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of PersistentVolumes assigned to StorageClass
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param storageclass name of the StorageClass
 * @return OK
 */
export function setHandleGetStorageClassPersistentVolumesData(queryClient: QueryClient, updater: (data: Types.PersistentVolumeList | undefined) => Types.PersistentVolumeList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, storageclass: string) {
  queryClient.setQueryData(handleGetStorageClassPersistentVolumesQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, storageclass),
    updater
  );
}

/**
 * returns a list of PersistentVolumes assigned to StorageClass
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param storageclass name of the StorageClass
 * @return OK
 */
export function setHandleGetStorageClassPersistentVolumesDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PersistentVolumeList | undefined) => Types.PersistentVolumeList) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function handleGetHorizontalPodAutoscalerListForResourceUrl(kind: string, namespace: string, name: string, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined): string {
  let url_ = getBaseUrl() + "/api/v1/{kind}/{namespace}/{name}/horizontalpodautoscaler?";
if (kind === undefined || kind === null)
  throw new Error("The parameter 'kind' must be defined.");
url_ = url_.replace("{kind}", encodeURIComponent("" + kind));
if (namespace === undefined || namespace === null)
  throw new Error("The parameter 'namespace' must be defined.");
url_ = url_.replace("{namespace}", encodeURIComponent("" + namespace));
if (name === undefined || name === null)
  throw new Error("The parameter 'name' must be defined.");
url_ = url_.replace("{name}", encodeURIComponent("" + name));
if (filterBy !== undefined && filterBy !== null)
    url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
if (itemsPerPage !== undefined && itemsPerPage !== null)
    url_ += "itemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
if (page !== undefined && page !== null)
    url_ += "page=" + encodeURIComponent("" + page) + "&";
if (metricNames !== undefined && metricNames !== null)
    url_ += "metricNames=" + encodeURIComponent("" + metricNames) + "&";
if (aggregations !== undefined && aggregations !== null)
    url_ += "aggregations=" + encodeURIComponent("" + aggregations) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let handleGetHorizontalPodAutoscalerListForResourceDefaultOptions: Omit<UseQueryOptions<Types.HorizontalPodAutoscalerList, unknown, Types.HorizontalPodAutoscalerList>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.HorizontalPodAutoscalerList, unknown, Types.HorizontalPodAutoscalerList>, 'queryFn'>> = {
};
export function getHandleGetHorizontalPodAutoscalerListForResourceDefaultOptions() {
  return handleGetHorizontalPodAutoscalerListForResourceDefaultOptions;
};
export function setHandleGetHorizontalPodAutoscalerListForResourceDefaultOptions(options: typeof handleGetHorizontalPodAutoscalerListForResourceDefaultOptions) {
  handleGetHorizontalPodAutoscalerListForResourceDefaultOptions = options;
}

export function handleGetHorizontalPodAutoscalerListForResourceQueryKey(dto: HandleGetHorizontalPodAutoscalerListForResourceQueryParameters): QueryKey;
export function handleGetHorizontalPodAutoscalerListForResourceQueryKey(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, kind: string, namespace: string, name: string): QueryKey;
export function handleGetHorizontalPodAutoscalerListForResourceQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, kind, namespace, name,  } = params[0] as HandleGetHorizontalPodAutoscalerListForResourceQueryParameters;

    return trimArrayEnd([
        'Client',
        'handleGetHorizontalPodAutoscalerListForResource',
        filterBy as any,
        sortBy as any,
        itemsPerPage as any,
        page as any,
        metricNames as any,
        aggregations as any,
        kind as any,
        namespace as any,
        name as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'handleGetHorizontalPodAutoscalerListForResource',
        ...params
      ]);
  }
}
export function __handleGetHorizontalPodAutoscalerListForResource(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().handleGetHorizontalPodAutoscalerListForResource(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined,       context.queryKey[5] as string | null | undefined,       context.queryKey[6] as string | null | undefined,       context.queryKey[7] as string | null | undefined,       context.queryKey[8] as string,       context.queryKey[9] as string,       context.queryKey[10] as string);
}

export function useHandleGetHorizontalPodAutoscalerListForResourceQuery<TSelectData = Types.HorizontalPodAutoscalerList, TError = unknown>(dto: HandleGetHorizontalPodAutoscalerListForResourceQueryParameters, options?: Omit<UseQueryOptions<Types.HorizontalPodAutoscalerList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * returns a list of HorizontalPodAutoscalers for resource
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param kind kind of the resource to get HorizontalPodAutoscalers for
 * @param namespace namespace of the resource to get HorizontalPodAutoscalers for
 * @param name name of the resource to get HorizontalPodAutoscalers for
 * @return OK
 */
export function useHandleGetHorizontalPodAutoscalerListForResourceQuery<TSelectData = Types.HorizontalPodAutoscalerList, TError = unknown>(filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, kind: string, namespace: string, name: string, options?: Omit<UseQueryOptions<Types.HorizontalPodAutoscalerList, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHandleGetHorizontalPodAutoscalerListForResourceQuery<TSelectData = Types.HorizontalPodAutoscalerList, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.HorizontalPodAutoscalerList, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let filterBy: any = undefined;
  let sortBy: any = undefined;
  let itemsPerPage: any = undefined;
  let page: any = undefined;
  let metricNames: any = undefined;
  let aggregations: any = undefined;
  let kind: any = undefined;
  let namespace: any = undefined;
  let name: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, kind, namespace, name,  } = params[0] as HandleGetHorizontalPodAutoscalerListForResourceQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, kind, namespace, name, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.HorizontalPodAutoscalerList, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __handleGetHorizontalPodAutoscalerListForResource(context, axiosConfig) : __handleGetHorizontalPodAutoscalerListForResource,
    queryKey: handleGetHorizontalPodAutoscalerListForResourceQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, kind, namespace, name),
    ...handleGetHorizontalPodAutoscalerListForResourceDefaultOptions as unknown as Omit<UseQueryOptions<Types.HorizontalPodAutoscalerList, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * returns a list of HorizontalPodAutoscalers for resource
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param kind kind of the resource to get HorizontalPodAutoscalers for
 * @param namespace namespace of the resource to get HorizontalPodAutoscalers for
 * @param name name of the resource to get HorizontalPodAutoscalers for
 * @return OK
 */
export function setHandleGetHorizontalPodAutoscalerListForResourceData(queryClient: QueryClient, updater: (data: Types.HorizontalPodAutoscalerList | undefined) => Types.HorizontalPodAutoscalerList, filterBy: string | null | undefined, sortBy: string | null | undefined, itemsPerPage: string | null | undefined, page: string | null | undefined, metricNames: string | null | undefined, aggregations: string | null | undefined, kind: string, namespace: string, name: string) {
  queryClient.setQueryData(handleGetHorizontalPodAutoscalerListForResourceQueryKey(filterBy, sortBy, itemsPerPage, page, metricNames, aggregations, kind, namespace, name),
    updater
  );
}

/**
 * returns a list of HorizontalPodAutoscalers for resource
 * @param filterBy (optional) Comma delimited string used to apply filtering: 'propertyName,filterValue'
 * @param sortBy (optional) Name of the column to sort by
 * @param itemsPerPage (optional) Number of items to return when pagination is applied
 * @param page (optional) Page number to return items from
 * @param metricNames (optional) Metric names to download
 * @param aggregations (optional) Aggregations to be performed for each metric (default: sum)
 * @param kind kind of the resource to get HorizontalPodAutoscalers for
 * @param namespace namespace of the resource to get HorizontalPodAutoscalers for
 * @param name name of the resource to get HorizontalPodAutoscalers for
 * @return OK
 */
export function setHandleGetHorizontalPodAutoscalerListForResourceDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.HorizontalPodAutoscalerList | undefined) => Types.HorizontalPodAutoscalerList) {
  queryClient.setQueryData(queryKey, updater);
}