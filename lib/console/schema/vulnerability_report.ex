defmodule Console.Schema.VulnerabilityReport do
  use Piazza.Ecto.Schema

  alias Console.Schema.{Cluster, Vulnerability, ServiceVuln, NamespaceVuln}

  defenum Grade, a: 0, b: 1, c: 2, d: 3, f: 4

  schema "vulnerability_reports" do
    field :artifact_url, :string
    field :grade,        Grade

    embeds_one :os, OS, on_replace: :update do
      field :eosl,   :boolean, default: false
      field :family, :string
      field :name,   :string
    end

    embeds_one :summary, Summary, on_replace: :update do
      field :critical_count, :integer
      field :high_count,     :integer
      field :medium_count,   :integer
      field :low_count,      :integer
      field :unknown_count,  :integer
      field :none_count,     :integer
    end

    embeds_one :artifact, Artifact, on_replace: :update do
      field :registry,   :string
      field :repository, :string
      field :digest,     :string
      field :tag,        :string
      field :mime,       :string
    end

    belongs_to :cluster, Cluster

    has_many :vulnerabilities, Vulnerability, on_replace: :delete, foreign_key: :report_id
    has_many :services,        ServiceVuln,   on_replace: :delete, foreign_key: :report_id
    has_many :namespaces,      NamespaceVuln, on_replace: :delete, foreign_key: :report_id

    timestamps()
  end

  def aggregate(user, grade) do
    clusters = Cluster.for_user(user)
    from(c in clusters,
      left_join: p in __MODULE__,
        on: c.id == p.cluster_id,
      group_by: c.id,
      select: %{
        cluster_id: c.id,
        count: sum(fragment("case when ? >= ? or ? is null then 1 else 0 end", p.grade, type(^grade, Grade), p.grade))
      }
    )
  end

  def for_user(query \\ __MODULE__, user) do
    clusters = Cluster.for_user(user)
    from(p in query,
      join: c in subquery(clusters),
        as: :clusters,
        on: c.id == p.cluster_id
    )
  end

  def search(query \\ __MODULE__, q) do
    from(vr in query, where: ilike(vr.artifact_url, ^"%#{q}%"))
  end

  def for_grade(query \\ __MODULE__, grade) do
    from(vr in query, where: vr.grade == ^grade)
  end

  def for_namespaces(query \\ __MODULE__, namespaces) do
    from(vr in query,
      join: ns in assoc(vr, :namespaces),
      where: ns.namespace in ^namespaces
    )
  end

  def for_clusters(query \\ __MODULE__, ids) do
    from(vr in query, where: vr.cluster_id in ^ids)
  end

  def for_cluster(query \\ __MODULE__, id) do
    from(vr in query, where: vr.cluster_id == ^id)
  end

  def for_flow(query \\ __MODULE__, id) do
    from(vr in query,
      join: sv in assoc(vr, :services),
      join: s in assoc(sv, :service),
      where: s.flow_id == ^id
    )
  end

  def ordered(query \\ __MODULE__, order \\ [asc: :artifact_url]) do
    from(vr in query, order_by: ^order)
  end

  def expired(query \\ __MODULE__) do
    expired_at = DateTime.add(DateTime.utc_now(), -120, :minute)
    from(vr in query, where: vr.updated_at < ^expired_at)
  end

  def stream(query \\ __MODULE__), do: ordered(query, asc: :id)

  def grades(query \\ __MODULE__) do
    from(s in query, group_by: s.grade, select: %{grade: s.grade, count: count(s.id, :distinct)})
  end

  def preloaded(query \\ __MODULE__, preloads \\ []) do
    from(vr in query, preload: ^preloads)
  end

  def distinct(query), do: from(p in query, distinct: true)

  @valid ~w(artifact_url grade cluster_id)a

  def changeset(model, attrs \\ %{}) do
    model
    |> cast(attrs, @valid)
    |> validate_length(:artifact_url, max: 255)
    |> cast_assoc(:vulnerabilities)
    |> cast_assoc(:services)
    |> cast_assoc(:namespaces)
    |> foreign_key_constraint(:cluster_id)
    |> unique_constraint([:cluster_id, :artifact_url])
    |> cast_embed(:os, with: &os_changeset/2)
    |> cast_embed(:summary, with: &summary_changeset/2)
    |> cast_embed(:artifact, with: &artifact_changeset/2)
    |> put_change(:updated_at, DateTime.utc_now())
    |> add_grade()
  end

  defp os_changeset(model, attrs) do
    model
    |> cast(attrs, ~w(eosl family name)a)
  end

  defp summary_changeset(model, attrs) do
    model
    |> cast(attrs, ~w(none_count low_count medium_count high_count critical_count)a)
  end

  defp artifact_changeset(model, attrs) do
    model
    |> cast(attrs, ~w(registry repository digest tag mime)a)
    |> validate_required([:repository])
  end

  defp add_grade(cs) do
    case get_field(cs, :summary) do
      %__MODULE__.Summary{critical_count: c} when c > 0 -> put_change(cs, :grade, :f)
      %__MODULE__.Summary{high_count: c} when c > 0 -> put_change(cs, :grade, :d)
      %__MODULE__.Summary{medium_count: c} when c > 0 -> put_change(cs, :grade, :c)
      %__MODULE__.Summary{low_count: c} when c > 0 -> put_change(cs, :grade, :b)
      _ -> put_change(cs, :grade, :a)
    end
  end
end
