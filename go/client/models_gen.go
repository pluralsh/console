// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package client

import (
	"fmt"
	"io"
	"strconv"
)

// supported kubernetes objects fetchable in runbooks
type KubernetesData interface {
	IsKubernetesData()
}

type AccessToken struct {
	ID         *string                     `json:"id,omitempty"`
	Token      *string                     `json:"token,omitempty"`
	Scopes     []*AccessTokenScope         `json:"scopes,omitempty"`
	Audits     *AccessTokenAuditConnection `json:"audits,omitempty"`
	InsertedAt *string                     `json:"insertedAt,omitempty"`
	UpdatedAt  *string                     `json:"updatedAt,omitempty"`
}

type AccessTokenAudit struct {
	ID         *string `json:"id,omitempty"`
	IP         *string `json:"ip,omitempty"`
	Timestamp  *string `json:"timestamp,omitempty"`
	Count      *int64  `json:"count,omitempty"`
	City       *string `json:"city,omitempty"`
	Country    *string `json:"country,omitempty"`
	Latitude   *string `json:"latitude,omitempty"`
	Longitude  *string `json:"longitude,omitempty"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

type AccessTokenAuditConnection struct {
	PageInfo PageInfo                `json:"pageInfo"`
	Edges    []*AccessTokenAuditEdge `json:"edges,omitempty"`
}

type AccessTokenAuditEdge struct {
	Node   *AccessTokenAudit `json:"node,omitempty"`
	Cursor *string           `json:"cursor,omitempty"`
}

type AccessTokenConnection struct {
	PageInfo PageInfo           `json:"pageInfo"`
	Edges    []*AccessTokenEdge `json:"edges,omitempty"`
}

type AccessTokenEdge struct {
	Node   *AccessToken `json:"node,omitempty"`
	Cursor *string      `json:"cursor,omitempty"`
}

type AccessTokenScope struct {
	API        *string  `json:"api,omitempty"`
	Apis       []string `json:"apis,omitempty"`
	Identifier *string  `json:"identifier,omitempty"`
	Ids        []string `json:"ids,omitempty"`
}

type Account struct {
	DelinquentAt       *string             `json:"delinquentAt,omitempty"`
	GrandfatheredUntil *string             `json:"grandfatheredUntil,omitempty"`
	AvailableFeatures  *AvailableFeatures  `json:"availableFeatures,omitempty"`
	Subscription       *PluralSubscription `json:"subscription,omitempty"`
}

// a condition that determines whether its configuration is viewable
type AddOnConfigCondition struct {
	// the operation for this condition, eg EQ, LT, GT
	Operation *string `json:"operation,omitempty"`
	// the field this condition applies to
	Field *string `json:"field,omitempty"`
	// the value to apply the condition with, for binary operators like LT/GT
	Value *string `json:"value,omitempty"`
}

// Input configuration for an add-on you can install
type AddOnConfiguration struct {
	// name for this configuration
	Name *string `json:"name,omitempty"`
	// a docstring explaining this configuration
	Documentation *string `json:"documentation,omitempty"`
	// a type for the configuration (should eventually be coerced back to string)
	Type *string `json:"type,omitempty"`
	// the values for ENUM type conditions
	Values    []*string             `json:"values,omitempty"`
	Condition *AddOnConfigCondition `json:"condition,omitempty"`
}

// the specification of a runtime service at a specific version
type AddonVersion struct {
	// add-on version, semver formatted
	Version *string `json:"version,omitempty"`
	// kubernetes versions this add-on works with
	Kube []*string `json:"kube,omitempty"`
	// any other add-ons this might require
	Requirements []*VersionReference `json:"requirements,omitempty"`
	// any add-ons this might break
	Incompatibilities []*VersionReference `json:"incompatibilities,omitempty"`
	// the version of the helm chart to install for this version
	ChartVersion *string `json:"chartVersion,omitempty"`
	// the release page for a runtime service at a version, this is a heavy operation not suitable for lists
	ReleaseURL *string `json:"releaseUrl,omitempty"`
	// checks if this is blocking a specific kubernetes upgrade
	Blocking *bool `json:"blocking,omitempty"`
}

// a representation of a bulk operation to be performed on all agent services
type AgentMigration struct {
	ID            string                 `json:"id"`
	Name          *string                `json:"name,omitempty"`
	Ref           *string                `json:"ref,omitempty"`
	Configuration map[string]interface{} `json:"configuration,omitempty"`
	Completed     *bool                  `json:"completed,omitempty"`
	InsertedAt    *string                `json:"insertedAt,omitempty"`
	UpdatedAt     *string                `json:"updatedAt,omitempty"`
}

type AgentMigrationAttributes struct {
	Name          *string `json:"name,omitempty"`
	Ref           *string `json:"ref,omitempty"`
	Configuration *string `json:"configuration,omitempty"`
}

type AiDelta struct {
	Seq     int64  `json:"seq"`
	Content string `json:"content"`
}

// A representation of a LLM-derived insight
type AiInsight struct {
	ID string `json:"id"`
	// a deduplication sha for this insight
	Sha *string `json:"sha,omitempty"`
	// the text of this insight
	Text *string `json:"text,omitempty"`
	// a shortish summary of this insight
	Summary   *string           `json:"summary,omitempty"`
	Freshness *InsightFreshness `json:"freshness,omitempty"`
	// any errors generated when compiling this insight
	Error                   []*ServiceError          `json:"error,omitempty"`
	Service                 *ServiceDeployment       `json:"service,omitempty"`
	Stack                   *InfrastructureStack     `json:"stack,omitempty"`
	Cluster                 *Cluster                 `json:"cluster,omitempty"`
	StackRun                *StackRun                `json:"stackRun,omitempty"`
	ServiceComponent        *ServiceComponent        `json:"serviceComponent,omitempty"`
	StackState              *StackState              `json:"stackState,omitempty"`
	ClusterInsightComponent *ClusterInsightComponent `json:"clusterInsightComponent,omitempty"`
	InsertedAt              *string                  `json:"insertedAt,omitempty"`
	UpdatedAt               *string                  `json:"updatedAt,omitempty"`
}

// A saved item for future ai-based investigation
type AiPin struct {
	ID         string      `json:"id"`
	Name       *string     `json:"name,omitempty"`
	Insight    *AiInsight  `json:"insight,omitempty"`
	Thread     *ChatThread `json:"thread,omitempty"`
	InsertedAt *string     `json:"insertedAt,omitempty"`
	UpdatedAt  *string     `json:"updatedAt,omitempty"`
}

// the items you want to reference in this pin
type AiPinAttributes struct {
	Name      *string `json:"name,omitempty"`
	InsightID *string `json:"insightId,omitempty"`
	ThreadID  *string `json:"threadId,omitempty"`
}

type AiPinConnection struct {
	PageInfo PageInfo     `json:"pageInfo"`
	Edges    []*AiPinEdge `json:"edges,omitempty"`
}

type AiPinEdge struct {
	Node   *AiPin  `json:"node,omitempty"`
	Cursor *string `json:"cursor,omitempty"`
}

// Settings for configuring access to common LLM providers
type AiSettings struct {
	Enabled   *bool                `json:"enabled,omitempty"`
	Provider  *AiProvider          `json:"provider,omitempty"`
	Openai    *OpenaiSettings      `json:"openai,omitempty"`
	Anthropic *AnthropicSettings   `json:"anthropic,omitempty"`
	Ollama    *OllamaSettings      `json:"ollama,omitempty"`
	Azure     *AzureOpenaiSettings `json:"azure,omitempty"`
	Bedrock   *BedrockAiSettings   `json:"bedrock,omitempty"`
	Vertex    *VertexAiSettings    `json:"vertex,omitempty"`
}

type AiSettingsAttributes struct {
	Enabled   *bool                        `json:"enabled,omitempty"`
	Tools     *ToolConfigAttributes        `json:"tools,omitempty"`
	Provider  *AiProvider                  `json:"provider,omitempty"`
	Openai    *OpenaiSettingsAttributes    `json:"openai,omitempty"`
	Anthropic *AnthropicSettingsAttributes `json:"anthropic,omitempty"`
	Ollama    *OllamaAttributes            `json:"ollama,omitempty"`
	Azure     *AzureOpenaiAttributes       `json:"azure,omitempty"`
	Bedrock   *BedrockAiAttributes         `json:"bedrock,omitempty"`
	Vertex    *VertexAiAttributes          `json:"vertex,omitempty"`
}

type Alert struct {
	ID          string                   `json:"id"`
	Provider    ObservabilityWebhookType `json:"provider"`
	Severity    AlertSeverity            `json:"severity"`
	State       AlertState               `json:"state"`
	Title       *string                  `json:"title,omitempty"`
	Message     *string                  `json:"message,omitempty"`
	Fingerprint *string                  `json:"fingerprint,omitempty"`
	Annotations map[string]interface{}   `json:"annotations,omitempty"`
	URL         *string                  `json:"url,omitempty"`
	// key/value tags to filter clusters
	Tags []*Tag `json:"tags,omitempty"`
	// the cluster this alert was associated with
	Cluster *Cluster `json:"cluster,omitempty"`
	// the service this alert was associated with
	Service *Service `json:"service,omitempty"`
	// the project this alert was associated with
	Project    *Project `json:"project,omitempty"`
	InsertedAt *string  `json:"insertedAt,omitempty"`
	UpdatedAt  *string  `json:"updatedAt,omitempty"`
}

type AlertConnection struct {
	PageInfo PageInfo     `json:"pageInfo"`
	Edges    []*AlertEdge `json:"edges,omitempty"`
}

type AlertEdge struct {
	Node   *Alert  `json:"node,omitempty"`
	Cursor *string `json:"cursor,omitempty"`
}

// Anthropic connection information
type AnthropicSettings struct {
	// the anthropic model version to use
	Model *string `json:"model,omitempty"`
}

type AnthropicSettingsAttributes struct {
	AccessToken *string `json:"accessToken,omitempty"`
	Model       *string `json:"model,omitempty"`
}

// a representation of a kubernetes api deprecation
type APIDeprecation struct {
	// the kubernetes version the deprecation was posted
	DeprecatedIn *string `json:"deprecatedIn,omitempty"`
	// the kubernetes version the api version will be removed and unusable in
	RemovedIn *string `json:"removedIn,omitempty"`
	// the api you can replace this resource with
	Replacement *string `json:"replacement,omitempty"`
	// the kubernetes version the replacement api was created in
	AvailableIn *string `json:"availableIn,omitempty"`
	// whether you cannot safely upgrade to the next kubernetes version if this deprecation exists
	Blocking *bool `json:"blocking,omitempty"`
	// the component of this deprecation
	Component *ServiceComponent `json:"component,omitempty"`
}

type AppNotification struct {
	ID         string                `json:"id"`
	Priority   *NotificationPriority `json:"priority,omitempty"`
	Text       *string               `json:"text,omitempty"`
	ReadAt     *string               `json:"readAt,omitempty"`
	InsertedAt *string               `json:"insertedAt,omitempty"`
	UpdatedAt  *string               `json:"updatedAt,omitempty"`
}

type AppNotificationConnection struct {
	PageInfo PageInfo               `json:"pageInfo"`
	Edges    []*AppNotificationEdge `json:"edges,omitempty"`
}

type AppNotificationEdge struct {
	Node   *AppNotification `json:"node,omitempty"`
	Cursor *string          `json:"cursor,omitempty"`
}

type Application struct {
	Name          string            `json:"name"`
	Spec          ApplicationSpec   `json:"spec"`
	Status        ApplicationStatus `json:"status"`
	Cost          *CostAnalysis     `json:"cost,omitempty"`
	License       *License          `json:"license,omitempty"`
	Configuration *Configuration    `json:"configuration,omitempty"`
	Info          *string           `json:"info,omitempty"`
}

type ApplicationDelta struct {
	Delta   *Delta       `json:"delta,omitempty"`
	Payload *Application `json:"payload,omitempty"`
}

type ApplicationDescriptor struct {
	Type        string             `json:"type"`
	Version     string             `json:"version"`
	Description *string            `json:"description,omitempty"`
	Icons       []*string          `json:"icons,omitempty"`
	Links       []*ApplicationLink `json:"links,omitempty"`
}

type ApplicationInfoItem struct {
	Type  *string `json:"type,omitempty"`
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

type ApplicationLink struct {
	URL         *string `json:"url,omitempty"`
	Description *string `json:"description,omitempty"`
}

type ApplicationSpec struct {
	Descriptor ApplicationDescriptor  `json:"descriptor"`
	Components []*Component           `json:"components,omitempty"`
	Info       []*ApplicationInfoItem `json:"info,omitempty"`
}

type ApplicationStatus struct {
	Components      []*StatusComponent `json:"components,omitempty"`
	Conditions      []*StatusCondition `json:"conditions,omitempty"`
	ComponentsReady string             `json:"componentsReady"`
}

type ArgoAnalysis struct {
	Templates []*ArgoAnalysisTemplate `json:"templates,omitempty"`
}

type ArgoAnalysisTemplate struct {
	TemplateName *string `json:"templateName,omitempty"`
}

type ArgoBlueGreenStrategy struct {
	ActiveService        *string `json:"activeService,omitempty"`
	AutoPromotionEnabled *bool   `json:"autoPromotionEnabled,omitempty"`
	AutoPromotionSeconds *int64  `json:"autoPromotionSeconds,omitempty"`
}

type ArgoCanaryStrategy struct {
	Steps []*ArgoStrategyStep `json:"steps,omitempty"`
}

type ArgoExperiment struct {
	Templates []*ArgoExperimentTemplate `json:"templates,omitempty"`
}

type ArgoExperimentTemplate struct {
	Name *string `json:"name,omitempty"`
}

type ArgoRollout struct {
	Metadata Metadata          `json:"metadata"`
	Status   ArgoRolloutStatus `json:"status"`
	Spec     ArgoRolloutSpec   `json:"spec"`
	Pods     []*Pod            `json:"pods,omitempty"`
	Raw      string            `json:"raw"`
	Events   []*Event          `json:"events,omitempty"`
}

type ArgoRolloutSpec struct {
	Replicas *int64               `json:"replicas,omitempty"`
	Strategy *ArgoRolloutStrategy `json:"strategy,omitempty"`
}

type ArgoRolloutStatus struct {
	Abort           *bool              `json:"abort,omitempty"`
	Phase           *string            `json:"phase,omitempty"`
	Replicas        *int64             `json:"replicas,omitempty"`
	ReadyReplicas   *int64             `json:"readyReplicas,omitempty"`
	PauseConditions []*PauseCondition  `json:"pauseConditions,omitempty"`
	Conditions      []*StatusCondition `json:"conditions,omitempty"`
}

type ArgoRolloutStrategy struct {
	BlueGreen *ArgoBlueGreenStrategy `json:"blueGreen,omitempty"`
	Canary    *ArgoCanaryStrategy    `json:"canary,omitempty"`
}

type ArgoStrategyStep struct {
	SetWeight  *int64          `json:"setWeight,omitempty"`
	Pause      *CanaryPause    `json:"pause,omitempty"`
	Experiment *ArgoExperiment `json:"experiment,omitempty"`
	Analysis   *ArgoAnalysis   `json:"analysis,omitempty"`
}

type Audit struct {
	ID         string      `json:"id"`
	Action     AuditAction `json:"action"`
	Type       AuditType   `json:"type"`
	Repository *string     `json:"repository,omitempty"`
	IP         *string     `json:"ip,omitempty"`
	City       *string     `json:"city,omitempty"`
	Country    *string     `json:"country,omitempty"`
	Latitude   *string     `json:"latitude,omitempty"`
	Longitude  *string     `json:"longitude,omitempty"`
	Actor      *User       `json:"actor,omitempty"`
	InsertedAt *string     `json:"insertedAt,omitempty"`
	UpdatedAt  *string     `json:"updatedAt,omitempty"`
}

type AuditConnection struct {
	PageInfo PageInfo     `json:"pageInfo"`
	Edges    []*AuditEdge `json:"edges,omitempty"`
}

type AuditEdge struct {
	Node   *Audit  `json:"node,omitempty"`
	Cursor *string `json:"cursor,omitempty"`
}

type AuditMetric struct {
	Country *string `json:"country,omitempty"`
	Count   *int64  `json:"count,omitempty"`
}

type AvailableFeatures struct {
	Vpn                *bool `json:"vpn,omitempty"`
	Audits             *bool `json:"audits,omitempty"`
	Cd                 *bool `json:"cd,omitempty"`
	UserManagement     *bool `json:"userManagement,omitempty"`
	DatabaseManagement *bool `json:"databaseManagement,omitempty"`
}

// aws node customizations
type AwsCloud struct {
	// custom launch template for your nodes, useful for Golden AMI setups
	LaunchTemplateID *string `json:"launchTemplateId,omitempty"`
}

type AwsCloudAttributes struct {
	Region *string `json:"region,omitempty"`
}

// aws specific cloud configuration
type AwsCloudSettings struct {
	Region *string `json:"region,omitempty"`
}

type AwsNodeCloudAttributes struct {
	LaunchTemplateID *string `json:"launchTemplateId,omitempty"`
}

type AwsSettingsAttributes struct {
	AccessKeyID     string `json:"accessKeyId"`
	SecretAccessKey string `json:"secretAccessKey"`
}

type AzureCloudAttributes struct {
	Location       *string `json:"location,omitempty"`
	SubscriptionID *string `json:"subscriptionId,omitempty"`
	ResourceGroup  *string `json:"resourceGroup,omitempty"`
	Network        *string `json:"network,omitempty"`
}

// azure-specific cluster cloud configuration
type AzureCloudSettings struct {
	Location       *string `json:"location,omitempty"`
	SubscriptionID *string `json:"subscriptionId,omitempty"`
	ResourceGroup  *string `json:"resourceGroup,omitempty"`
	Network        *string `json:"network,omitempty"`
}

type AzureOpenaiAttributes struct {
	// the endpoint of your azure openai version, should look like: https://{endpoint}/openai/deployments/{deployment-id}
	Endpoint string `json:"endpoint"`
	// the api version you want to use
	APIVersion *string `json:"apiVersion,omitempty"`
	// the exact model you wish to use
	Model *string `json:"model,omitempty"`
	// the azure openai access token to use
	AccessToken string `json:"accessToken"`
}

// Settings for configuring against Azure OpenAI
type AzureOpenaiSettings struct {
	// the endpoint of your azure openai version, should look like: https://{endpoint}/openai/deployments/{deployment-id}
	Endpoint string `json:"endpoint"`
	// the api version you want to use
	APIVersion *string `json:"apiVersion,omitempty"`
}

type AzureSettingsAttributes struct {
	TenantID       string `json:"tenantId"`
	SubscriptionID string `json:"subscriptionId"`
	ClientID       string `json:"clientId"`
	ClientSecret   string `json:"clientSecret"`
}

type AzureStore struct {
	StorageAccount string `json:"storageAccount"`
	Container      string `json:"container"`
	SubscriptionID string `json:"subscriptionId"`
	ResourceGroup  string `json:"resourceGroup"`
	TenantID       string `json:"tenantId"`
	ClientID       string `json:"clientId"`
}

type AzureStoreAttributes struct {
	StorageAccount string `json:"storageAccount"`
	Container      string `json:"container"`
	SubscriptionID string `json:"subscriptionId"`
	ResourceGroup  string `json:"resourceGroup"`
	TenantID       string `json:"tenantId"`
	ClientID       string `json:"clientId"`
	ClientSecret   string `json:"clientSecret"`
}

type BackupAttributes struct {
	Name             string                      `json:"name"`
	Namespace        string                      `json:"namespace"`
	GarbageCollected *bool                       `json:"garbageCollected,omitempty"`
	TTL              *string                     `json:"ttl,omitempty"`
	Namespaces       *ResourceSelectorAttributes `json:"namespaces,omitempty"`
	Resources        *ResourceSelectorAttributes `json:"resources,omitempty"`
}

type BedrockAiAttributes struct {
	// the bedrock model id to use
	ModelID string `json:"modelId"`
	// aws access key id to use, you can also use IRSA for self-hosted consoles
	AccessKeyID *string `json:"accessKeyId,omitempty"`
	// aws secret access key to use, you can also use IRSA for self-hosted consoles
	SecretAccessKey *string `json:"secretAccessKey,omitempty"`
}

// Settings for usage of AWS Bedrock for LLMs
type BedrockAiSettings struct {
	// the bedrock model to use
	ModelID string `json:"modelId"`
	// the aws access key to use, can also use IRSA when console is self-hosted
	AccessKeyID *string `json:"accessKeyId,omitempty"`
}

type BindingAttributes struct {
	ID      *string `json:"id,omitempty"`
	UserID  *string `json:"userId,omitempty"`
	GroupID *string `json:"groupId,omitempty"`
}

type Build struct {
	ID          string             `json:"id"`
	Repository  string             `json:"repository"`
	Type        BuildType          `json:"type"`
	Status      Status             `json:"status"`
	Message     *string            `json:"message,omitempty"`
	CompletedAt *string            `json:"completedAt,omitempty"`
	Sha         *string            `json:"sha,omitempty"`
	Commands    *CommandConnection `json:"commands,omitempty"`
	Creator     *User              `json:"creator,omitempty"`
	Approver    *User              `json:"approver,omitempty"`
	Changelogs  []*Changelog       `json:"changelogs,omitempty"`
	InsertedAt  *string            `json:"insertedAt,omitempty"`
	UpdatedAt   *string            `json:"updatedAt,omitempty"`
}

type BuildAttributes struct {
	Repository string     `json:"repository"`
	Type       *BuildType `json:"type,omitempty"`
	Message    *string    `json:"message,omitempty"`
}

type BuildConnection struct {
	PageInfo PageInfo     `json:"pageInfo"`
	Edges    []*BuildEdge `json:"edges,omitempty"`
}

type BuildDelta struct {
	Delta   *Delta `json:"delta,omitempty"`
	Payload *Build `json:"payload,omitempty"`
}

type BuildEdge struct {
	Node   *Build  `json:"node,omitempty"`
	Cursor *string `json:"cursor,omitempty"`
}

type BuildInfo struct {
	All        *int64 `json:"all,omitempty"`
	Failed     *int64 `json:"failed,omitempty"`
	Queued     *int64 `json:"queued,omitempty"`
	Running    *int64 `json:"running,omitempty"`
	Successful *int64 `json:"successful,omitempty"`
}

type Canary struct {
	Metadata          Metadata     `json:"metadata"`
	Status            CanaryStatus `json:"status"`
	Spec              CanarySpec   `json:"spec"`
	PrimaryDeployment *Deployment  `json:"primaryDeployment,omitempty"`
	CanaryDeployment  *Deployment  `json:"canaryDeployment,omitempty"`
	Ingress           *Ingress     `json:"ingress,omitempty"`
	IngressCanary     *Ingress     `json:"ingressCanary,omitempty"`
	Raw               string       `json:"raw"`
	Events            []*Event     `json:"events,omitempty"`
}

type CanaryAnalysis struct {
	Interval    *string  `json:"interval,omitempty"`
	MaxWeight   *int64   `json:"maxWeight,omitempty"`
	StepWeight  *int64   `json:"stepWeight,omitempty"`
	StepWeights []*int64 `json:"stepWeights,omitempty"`
	Threshold   *int64   `json:"threshold,omitempty"`
}

type CanaryPause struct {
	Duration *string `json:"duration,omitempty"`
}

type CanarySpec struct {
	AutoscalerRef *TargetRef      `json:"autoscalerRef,omitempty"`
	TargetRef     *TargetRef      `json:"targetRef,omitempty"`
	IngressRef    *TargetRef      `json:"ingressRef,omitempty"`
	Analysis      *CanaryAnalysis `json:"analysis,omitempty"`
	Provider      *string         `json:"provider,omitempty"`
}

type CanaryStatus struct {
	Conditions         []*StatusCondition `json:"conditions,omitempty"`
	FailedChecks       *int64             `json:"failedChecks,omitempty"`
	CanaryWeight       *int64             `json:"canaryWeight,omitempty"`
	Iterations         *int64             `json:"iterations,omitempty"`
	LastTransitionTime *string            `json:"lastTransitionTime,omitempty"`
	Phase              *string            `json:"phase,omitempty"`
}

// A spec for specifying cascade behavior on an owning resource
type Cascade struct {
	// whether to perform a drain-delete for all owned resources
	Delete *bool `json:"delete,omitempty"`
	// whether to perform a detach-delete for all owned resources
	Detach *bool `json:"detach,omitempty"`
}

// Whether you want to delete or detach owned resources
type CascadeAttributes struct {
	Delete *bool `json:"delete,omitempty"`
	Detach *bool `json:"detach,omitempty"`
}

// A catalog is an organized collection of PR Automations used for permissioning and discovery
type Catalog struct {
	ID   string `json:"id"`
	Name string `json:"name"`
	// longform description for the purpose of this catalog
	Description *string `json:"description,omitempty"`
	// short category name used for browsing catalogs
	Category *string `json:"category,omitempty"`
	// the name of the author of this catalog
	Author *string `json:"author,omitempty"`
	// an icon url to use for this catalog
	Icon *string `json:"icon,omitempty"`
	// a darkmode icon url to use for this catalog
	DarkIcon *string  `json:"darkIcon,omitempty"`
	Project  *Project `json:"project,omitempty"`
	// read policy for this catalog
	ReadBindings []*PolicyBinding `json:"readBindings,omitempty"`
	// write policy for this catalog
	WriteBindings []*PolicyBinding `json:"writeBindings,omitempty"`
	// create policy for this catalog, can give permission to just create prs
	CreateBindings []*PolicyBinding `json:"createBindings,omitempty"`
	InsertedAt     *string          `json:"insertedAt,omitempty"`
	UpdatedAt      *string          `json:"updatedAt,omitempty"`
}

type CatalogAttributes struct {
	Name string `json:"name"`
	// the name of the author of this catalog, used for attribution only
	Author      string  `json:"author"`
	Description *string `json:"description,omitempty"`
	// short category name for browsability
	Category *string `json:"category,omitempty"`
	// owning project of the catalog, permissions will propagate down
	ProjectID *string `json:"projectId,omitempty"`
	// an icon url to use for this catalog
	Icon *string `json:"icon,omitempty"`
	// a darkmode icon url to use for this catalog
	DarkIcon       *string                    `json:"darkIcon,omitempty"`
	Tags           []*TagAttributes           `json:"tags,omitempty"`
	ReadBindings   []*PolicyBindingAttributes `json:"readBindings,omitempty"`
	WriteBindings  []*PolicyBindingAttributes `json:"writeBindings,omitempty"`
	CreateBindings []*PolicyBindingAttributes `json:"createBindings,omitempty"`
}

type CatalogConnection struct {
	PageInfo PageInfo       `json:"pageInfo"`
	Edges    []*CatalogEdge `json:"edges,omitempty"`
}

type CatalogEdge struct {
	Node   *Catalog `json:"node,omitempty"`
	Cursor *string  `json:"cursor,omitempty"`
}

type Certificate struct {
	Metadata Metadata          `json:"metadata"`
	Status   CertificateStatus `json:"status"`
	Spec     CertificateSpec   `json:"spec"`
	Raw      string            `json:"raw"`
	Events   []*Event          `json:"events,omitempty"`
}

type CertificateSpec struct {
	DNSNames   []*string  `json:"dnsNames,omitempty"`
	SecretName string     `json:"secretName"`
	IssuerRef  *IssuerRef `json:"issuerRef,omitempty"`
}

type CertificateStatus struct {
	Conditions  []*StatusCondition `json:"conditions,omitempty"`
	NotAfter    *string            `json:"notAfter,omitempty"`
	NotBefore   *string            `json:"notBefore,omitempty"`
	RenewalTime *string            `json:"renewalTime,omitempty"`
}

type Changelog struct {
	ID         string  `json:"id"`
	Repo       string  `json:"repo"`
	Tool       string  `json:"tool"`
	Content    *string `json:"content,omitempty"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

type Chat struct {
	ID         string      `json:"id"`
	Role       AiRole      `json:"role"`
	Content    string      `json:"content"`
	Seq        int64       `json:"seq"`
	Thread     *ChatThread `json:"thread,omitempty"`
	InsertedAt *string     `json:"insertedAt,omitempty"`
	UpdatedAt  *string     `json:"updatedAt,omitempty"`
}

type ChatConnection struct {
	PageInfo PageInfo    `json:"pageInfo"`
	Edges    []*ChatEdge `json:"edges,omitempty"`
}

type ChatEdge struct {
	Node   *Chat   `json:"node,omitempty"`
	Cursor *string `json:"cursor,omitempty"`
}

// A basic AI chat message input, modeled after OpenAI's api model
type ChatMessage struct {
	Role    AiRole `json:"role"`
	Content string `json:"content"`
}

// A list of chat messages around a specific topic created on demand
type ChatThread struct {
	ID            string          `json:"id"`
	Summary       string          `json:"summary"`
	Default       bool            `json:"default"`
	LastMessageAt *string         `json:"lastMessageAt,omitempty"`
	User          *User           `json:"user,omitempty"`
	Insight       *AiInsight      `json:"insight,omitempty"`
	Chats         *ChatConnection `json:"chats,omitempty"`
	InsertedAt    *string         `json:"insertedAt,omitempty"`
	UpdatedAt     *string         `json:"updatedAt,omitempty"`
}

// basic user-supplied input for creating an AI chat thread
type ChatThreadAttributes struct {
	Summary string `json:"summary"`
	// controls whether this thread is autosummarized, set true when users explicitly set summary
	Summarized *bool `json:"summarized,omitempty"`
	// a list of messages to add initially when creating this thread
	Messages []*ChatMessage `json:"messages,omitempty"`
	// an ai insight this thread was created from
	InsightID *string `json:"insightId,omitempty"`
}

type ChatThreadConnection struct {
	PageInfo PageInfo          `json:"pageInfo"`
	Edges    []*ChatThreadEdge `json:"edges,omitempty"`
}

type ChatThreadEdge struct {
	Node   *ChatThread `json:"node,omitempty"`
	Cursor *string     `json:"cursor,omitempty"`
}

type CloneAttributes struct {
	S3AccessKeyID     *string `json:"s3AccessKeyId,omitempty"`
	S3SecretAccessKey *string `json:"s3SecretAccessKey,omitempty"`
	S3WalPath         *string `json:"s3WalPath,omitempty"`
	S3Endpoint        *string `json:"s3Endpoint,omitempty"`
	UID               *string `json:"uid,omitempty"`
}

type CloudProviderSettingsAttributes struct {
	Aws   *AwsSettingsAttributes   `json:"aws,omitempty"`
	Gcp   *GcpSettingsAttributes   `json:"gcp,omitempty"`
	Azure *AzureSettingsAttributes `json:"azure,omitempty"`
}

// the cloud configuration for a cluster
type CloudSettings struct {
	Aws   *AwsCloudSettings   `json:"aws,omitempty"`
	Gcp   *GcpCloudSettings   `json:"gcp,omitempty"`
	Azure *AzureCloudSettings `json:"azure,omitempty"`
}

type CloudSettingsAttributes struct {
	Aws   *AwsCloudAttributes   `json:"aws,omitempty"`
	Gcp   *GcpCloudAttributes   `json:"gcp,omitempty"`
	Azure *AzureCloudAttributes `json:"azure,omitempty"`
}

// a representation of a cluster you can deploy to
type Cluster struct {
	// internal id of this cluster
	ID string `json:"id"`
	// whether this is the management cluster itself
	Self *bool `json:"self,omitempty"`
	// human readable name of this cluster, will also translate to cloud k8s name
	Name string `json:"name"`
	// if true, this cluster cannot be deleted
	Protect *bool `json:"protect,omitempty"`
	// whether this is actually a virtual cluster
	Virtual *bool `json:"virtual,omitempty"`
	// desired k8s version for the cluster
	Version *string `json:"version,omitempty"`
	// the distribution of kubernetes this cluster is running
	Distro *ClusterDistro `json:"distro,omitempty"`
	// arbitrary json metadata to store user-specific state of this cluster (eg IAM roles for add-ons)
	Metadata map[string]interface{} `json:"metadata,omitempty"`
	// current k8s version as told to us by the deployment operator
	CurrentVersion *string `json:"currentVersion,omitempty"`
	// The lowest discovered kubelet version for all nodes in the cluster
	KubeletVersion *string `json:"kubeletVersion,omitempty"`
	// a short, unique human readable name used to identify this cluster and does not necessarily map to the cloud resource name
	Handle *string `json:"handle,omitempty"`
	// whether the deploy operator has been registered for this cluster
	Installed *bool `json:"installed,omitempty"`
	// the cloud settings for this cluster (for instance its aws region)
	Settings *CloudSettings `json:"settings,omitempty"`
	// Checklist of tasks to complete to safely upgrade this cluster
	UpgradePlan *ClusterUpgradePlan `json:"upgradePlan,omitempty"`
	// the url of the kas server you can access this cluster from
	KasURL *string `json:"kasUrl,omitempty"`
	// the url this clusters deployment operator will use for gql requests
	AgentURL *string `json:"agentUrl,omitempty"`
	// a auth token to be used by the deploy operator, only readable on create
	DeployToken *string `json:"deployToken,omitempty"`
	// when this cluster was scheduled for deletion
	DeletedAt *string `json:"deletedAt,omitempty"`
	// last time the deploy operator pinged this cluster
	PingedAt *string `json:"pingedAt,omitempty"`
	// read policy for this cluster
	ReadBindings []*PolicyBinding `json:"readBindings,omitempty"`
	// write policy for this cluster
	WriteBindings []*PolicyBinding `json:"writeBindings,omitempty"`
	// the project this cluster belongs to
	Project *Project `json:"project,omitempty"`
	// list of node pool specs managed by CAPI
	NodePools []*NodePool `json:"nodePools,omitempty"`
	// the provider we use to create this cluster (null if BYOK)
	Provider *ClusterProvider `json:"provider,omitempty"`
	// a custom credential to use when provisioning this cluster
	Credential *ProviderCredential `json:"credential,omitempty"`
	// the service used to deploy the CAPI resources of this cluster
	Service *ServiceDeployment `json:"service,omitempty"`
	// key/value tags to filter clusters
	Tags []*Tag `json:"tags,omitempty"`
	// all api deprecations for all services in this cluster
	APIDeprecations []*APIDeprecation `json:"apiDeprecations,omitempty"`
	// any errors which might have occurred during the bootstrap process
	ServiceErrors []*ServiceError `json:"serviceErrors,omitempty"`
	// a custom git repository if you want to define your own CAPI manifests
	Repository *GitRepository `json:"repository,omitempty"`
	// pr automations that are relevant to managing this cluster
	PrAutomations []*PrAutomation `json:"prAutomations,omitempty"`
	// the active restore for this cluster
	Restore *ClusterRestore `json:"restore,omitempty"`
	// the object store connection bound to this cluster for backup/restore
	ObjectStore *ObjectStore `json:"objectStore,omitempty"`
	// the parent of this virtual cluster
	ParentCluster *Cluster `json:"parentCluster,omitempty"`
	// an ai insight generated about issues discovered which might impact the health of this cluster
	Insight *AiInsight `json:"insight,omitempty"`
	// a set of kubernetes resources used to generate the ai insight for this cluster
	InsightComponents *ClusterInsightComponent `json:"insightComponents,omitempty"`
	// list cached nodes for a cluster, this can be stale up to 5m
	Nodes []*Node `json:"nodes,omitempty"`
	// list the cached node metrics for a cluster, can also be stale up to 5m
	NodeMetrics []*NodeMetric `json:"nodeMetrics,omitempty"`
	// custom resources with dedicated views for this cluster
	PinnedCustomResources []*PinnedCustomResource `json:"pinnedCustomResources,omitempty"`
	// any upgrade insights provided by your cloud provider that have been discovered by our agent
	UpgradeInsights []*UpgradeInsight `json:"upgradeInsights,omitempty"`
	// A summation of the metrics utilization of the current cluster
	MetricsSummary *ClusterMetricsSummary `json:"metricsSummary,omitempty"`
	// the status of the cluster as seen from the CAPI operator, since some clusters can be provisioned without CAPI, this can be null
	Status *ClusterStatus `json:"status,omitempty"`
	// a relay connection of all revisions of this cluster, these are periodically pruned up to a history limit
	Revisions *ClusterRevisionConnection `json:"revisions,omitempty"`
	// lists OPA constraints registered in this cluster
	PolicyConstraints *PolicyConstraintConnection `json:"policyConstraints,omitempty"`
	// Computes a list of statistics for OPA constraint violations w/in this cluster
	ViolationStatistics []*ViolationStatistic `json:"violationStatistics,omitempty"`
	// list all alerts discovered for this cluster
	Alerts *AlertConnection `json:"alerts,omitempty"`
	// Queries logs for a cluster out of loki
	Logs               []*LogStream        `json:"logs,omitempty"`
	ClusterMetrics     *ClusterMetrics     `json:"clusterMetrics,omitempty"`
	ClusterNodeMetrics *ClusterNodeMetrics `json:"clusterNodeMetrics,omitempty"`
	// fetches a list of runtime services found in this cluster, this is an expensive operation that should not be done in list queries
	RuntimeServices []*RuntimeService `json:"runtimeServices,omitempty"`
	// whether the current user can edit this cluster
	Editable   *bool   `json:"editable,omitempty"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

// A common kubernetes cluster add-on like cert-manager, istio, etc
type ClusterAddOn struct {
	Name          *string               `json:"name,omitempty"`
	Version       *string               `json:"version,omitempty"`
	Icon          *string               `json:"icon,omitempty"`
	Global        *bool                 `json:"global,omitempty"`
	Configuration []*AddOnConfiguration `json:"configuration,omitempty"`
}

type ClusterAttributes struct {
	Name string `json:"name"`
	// a short, unique human readable name used to identify this cluster and does not necessarily map to the cloud resource name
	Handle     *string `json:"handle,omitempty"`
	ProviderID *string `json:"providerId,omitempty"`
	// a cloud credential to use when provisioning this cluster
	CredentialID  *string                  `json:"credentialId,omitempty"`
	Version       *string                  `json:"version,omitempty"`
	Distro        *ClusterDistro           `json:"distro,omitempty"`
	Metadata      *string                  `json:"metadata,omitempty"`
	Protect       *bool                    `json:"protect,omitempty"`
	Kubeconfig    *KubeconfigAttributes    `json:"kubeconfig,omitempty"`
	CloudSettings *CloudSettingsAttributes `json:"cloudSettings,omitempty"`
	// the project id this cluster will belong to
	ProjectID *string `json:"projectId,omitempty"`
	// status of the upgrade plan for this cluster
	UpgradePlan   *UpgradePlanAttributes     `json:"upgradePlan,omitempty"`
	NodePools     []*NodePoolAttributes      `json:"nodePools,omitempty"`
	ReadBindings  []*PolicyBindingAttributes `json:"readBindings,omitempty"`
	WriteBindings []*PolicyBindingAttributes `json:"writeBindings,omitempty"`
	Tags          []*TagAttributes           `json:"tags,omitempty"`
}

type ClusterBackup struct {
	ID               string            `json:"id"`
	Name             string            `json:"name"`
	Namespace        string            `json:"namespace"`
	TTL              *string           `json:"ttl,omitempty"`
	GarbageCollected *bool             `json:"garbageCollected,omitempty"`
	Namespaces       *ResourceSelector `json:"namespaces,omitempty"`
	Resources        *ResourceSelector `json:"resources,omitempty"`
	Cluster          *Cluster          `json:"cluster,omitempty"`
	InsertedAt       *string           `json:"insertedAt,omitempty"`
	UpdatedAt        *string           `json:"updatedAt,omitempty"`
}

type ClusterBackupConnection struct {
	PageInfo PageInfo             `json:"pageInfo"`
	Edges    []*ClusterBackupEdge `json:"edges,omitempty"`
}

type ClusterBackupEdge struct {
	Node   *ClusterBackup `json:"node,omitempty"`
	Cursor *string        `json:"cursor,omitempty"`
}

// a single condition struct for various phases of the cluster provisionining process
type ClusterCondition struct {
	LastTransitionTime *string `json:"lastTransitionTime,omitempty"`
	Status             *string `json:"status,omitempty"`
	Type               *string `json:"type,omitempty"`
	Message            *string `json:"message,omitempty"`
	Reason             *string `json:"reason,omitempty"`
	Severity           *string `json:"severity,omitempty"`
}

type ClusterConnection struct {
	PageInfo PageInfo       `json:"pageInfo"`
	Edges    []*ClusterEdge `json:"edges,omitempty"`
}

type ClusterEdge struct {
	Node   *Cluster `json:"node,omitempty"`
	Cursor *string  `json:"cursor,omitempty"`
}

type ClusterInfo struct {
	GitCommit  *string `json:"gitCommit,omitempty"`
	GitVersion *string `json:"gitVersion,omitempty"`
	Platform   *string `json:"platform,omitempty"`
	Version    *string `json:"version,omitempty"`
}

// A kubernetes object used in the course of generating a cluster insight
type ClusterInsightComponent struct {
	ID        string   `json:"id"`
	Group     *string  `json:"group,omitempty"`
	Version   string   `json:"version"`
	Kind      string   `json:"kind"`
	Namespace *string  `json:"namespace,omitempty"`
	Name      string   `json:"name"`
	Cluster   *Cluster `json:"cluster,omitempty"`
	// the raw kubernetes resource itself, this is an expensive fetch and should be used sparingly
	Resource *KubernetesUnstructured `json:"resource,omitempty"`
}

type ClusterInsightComponentAttributes struct {
	Group     *string `json:"group,omitempty"`
	Version   string  `json:"version"`
	Kind      string  `json:"kind"`
	Namespace *string `json:"namespace,omitempty"`
	Name      string  `json:"name"`
}

type ClusterMetrics struct {
	CPU            []*MetricResponse `json:"cpu,omitempty"`
	Memory         []*MetricResponse `json:"memory,omitempty"`
	CPURequests    []*MetricResponse `json:"cpuRequests,omitempty"`
	MemoryRequests []*MetricResponse `json:"memoryRequests,omitempty"`
	CPULimits      []*MetricResponse `json:"cpuLimits,omitempty"`
	MemoryLimits   []*MetricResponse `json:"memoryLimits,omitempty"`
	Pods           []*MetricResponse `json:"pods,omitempty"`
	CPUUsage       []*MetricResponse `json:"cpuUsage,omitempty"`
	MemoryUsage    []*MetricResponse `json:"memoryUsage,omitempty"`
}

// A summarization of the core cpu and memory metrics for this cluster
type ClusterMetricsSummary struct {
	Nodes *int64 `json:"nodes,omitempty"`
	// the cpu available in vcpu
	CPUAvailable *float64 `json:"cpuAvailable,omitempty"`
	// the total cpu in use in the cluster measured in vcpu
	CPUTotal *float64 `json:"cpuTotal,omitempty"`
	// a percentage cpu utilization of the cluster
	CPUUsed *int64 `json:"cpuUsed,omitempty"`
	// the total number of megabytes available in the cluster
	MemoryAvailable *float64 `json:"memoryAvailable,omitempty"`
	// the total number of megabytes in use in the cluster
	MemoryTotal *float64 `json:"memoryTotal,omitempty"`
	// a percentage memory utilization of the cluster
	MemoryUsed *int64 `json:"memoryUsed,omitempty"`
}

type ClusterNodeMetrics struct {
	CPU         []*MetricResponse `json:"cpu,omitempty"`
	Memory      []*MetricResponse `json:"memory,omitempty"`
	CPUUsage    []*MetricResponse `json:"cpuUsage,omitempty"`
	MemoryUsage []*MetricResponse `json:"memoryUsage,omitempty"`
}

type ClusterPing struct {
	CurrentVersion string         `json:"currentVersion"`
	KubeletVersion *string        `json:"kubeletVersion,omitempty"`
	Distro         *ClusterDistro `json:"distro,omitempty"`
	// scraped k8s objects to use for cluster insights, don't send at all if not w/in the last scrape interval
	InsightComponents []*ClusterInsightComponentAttributes `json:"insightComponents,omitempty"`
}

// a CAPI provider for a cluster, cloud is inferred from name if not provided manually
type ClusterProvider struct {
	// the id of this provider
	ID string `json:"id"`
	// a human readable name for the provider, globally unique
	Name string `json:"name"`
	// the namespace the CAPI resources are deployed into
	Namespace string `json:"namespace"`
	// the name of the cloud service for this provider
	Cloud string `json:"cloud"`
	// the details of how cluster manifests will be synced from git when created with this provider
	Git GitRef `json:"git"`
	// the repository used to serve cluster manifests
	Repository *GitRepository `json:"repository,omitempty"`
	// the repository for the CAPI service itself if customized
	ProviderRepository *GitRepository `json:"providerRepository,omitempty"`
	// the service of the CAPI controller itself
	Service *ServiceDeployment `json:"service,omitempty"`
	// a list of credentials eligible for this provider
	Credentials []*ProviderCredential `json:"credentials,omitempty"`
	// when the cluster provider was deleted
	DeletedAt       *string           `json:"deletedAt,omitempty"`
	RuntimeServices []*RuntimeService `json:"runtimeServices,omitempty"`
	// the kubernetes versions this provider currently supports
	SupportedVersions []*string `json:"supportedVersions,omitempty"`
	// the region names this provider can deploy to
	Regions []*string `json:"regions,omitempty"`
	// whether the current user can edit this resource
	Editable   *bool   `json:"editable,omitempty"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

type ClusterProviderAttributes struct {
	Name          string                           `json:"name"`
	Namespace     *string                          `json:"namespace,omitempty"`
	Cloud         *string                          `json:"cloud,omitempty"`
	CloudSettings *CloudProviderSettingsAttributes `json:"cloudSettings,omitempty"`
}

type ClusterProviderConnection struct {
	PageInfo PageInfo               `json:"pageInfo"`
	Edges    []*ClusterProviderEdge `json:"edges,omitempty"`
}

type ClusterProviderEdge struct {
	Node   *ClusterProvider `json:"node,omitempty"`
	Cursor *string          `json:"cursor,omitempty"`
}

type ClusterProviderUpdateAttributes struct {
	// if you optionally want to reconfigure the git repository for the cluster provider
	Service       *ClusterServiceAttributes        `json:"service,omitempty"`
	CloudSettings *CloudProviderSettingsAttributes `json:"cloudSettings,omitempty"`
}

type ClusterRestore struct {
	ID         string         `json:"id"`
	Status     RestoreStatus  `json:"status"`
	Backup     *ClusterBackup `json:"backup,omitempty"`
	InsertedAt *string        `json:"insertedAt,omitempty"`
	UpdatedAt  *string        `json:"updatedAt,omitempty"`
}

type ClusterRestoreConnection struct {
	PageInfo PageInfo              `json:"pageInfo"`
	Edges    []*ClusterRestoreEdge `json:"edges,omitempty"`
}

type ClusterRestoreEdge struct {
	Node   *ClusterRestore `json:"node,omitempty"`
	Cursor *string         `json:"cursor,omitempty"`
}

// a historical revision of a cluster, including version, cloud and node group configuration
type ClusterRevision struct {
	ID         string      `json:"id"`
	Version    *string     `json:"version,omitempty"`
	NodePools  []*NodePool `json:"nodePools,omitempty"`
	InsertedAt *string     `json:"insertedAt,omitempty"`
	UpdatedAt  *string     `json:"updatedAt,omitempty"`
}

type ClusterRevisionConnection struct {
	PageInfo PageInfo               `json:"pageInfo"`
	Edges    []*ClusterRevisionEdge `json:"edges,omitempty"`
}

type ClusterRevisionEdge struct {
	Node   *ClusterRevision `json:"node,omitempty"`
	Cursor *string          `json:"cursor,omitempty"`
}

type ClusterServiceAttributes struct {
	ID           string           `json:"id"`
	RepositoryID *string          `json:"repositoryId,omitempty"`
	Git          GitRefAttributes `json:"git"`
}

// the crd status of the cluster as seen by the CAPI operator
type ClusterStatus struct {
	Phase             *string             `json:"phase,omitempty"`
	ControlPlaneReady *bool               `json:"controlPlaneReady,omitempty"`
	FailureMessage    *string             `json:"failureMessage,omitempty"`
	FailureReason     *string             `json:"failureReason,omitempty"`
	Conditions        []*ClusterCondition `json:"conditions,omitempty"`
}

// a cluster info data struct
type ClusterStatusInfo struct {
	Healthy *bool  `json:"healthy,omitempty"`
	Count   *int64 `json:"count,omitempty"`
}

// A spec for targeting clusters
type ClusterTarget struct {
	// the cluster tags to target
	Tags map[string]interface{} `json:"tags,omitempty"`
	// kubernetes distribution to target
	Distro *ClusterDistro `json:"distro,omitempty"`
}

// A spec for targeting clusters
type ClusterTargetAttributes struct {
	// the cluster tags to target
	Tags *string `json:"tags,omitempty"`
	// kubernetes distribution to target
	Distro *ClusterDistro `json:"distro,omitempty"`
}

type ClusterUpdateAttributes struct {
	Name    *string `json:"name,omitempty"`
	Version *string `json:"version,omitempty"`
	// a short, unique human readable name used to identify this cluster and does not necessarily map to the cloud resource name
	Handle *string `json:"handle,omitempty"`
	// if you optionally want to reconfigure the git repository for the cluster service
	Service *ClusterServiceAttributes `json:"service,omitempty"`
	// pass a kubeconfig for this cluster (DEPRECATED)
	Kubeconfig *KubeconfigAttributes `json:"kubeconfig,omitempty"`
	// status of the upgrade plan for this cluster
	UpgradePlan   *UpgradePlanAttributes     `json:"upgradePlan,omitempty"`
	Protect       *bool                      `json:"protect,omitempty"`
	Distro        *ClusterDistro             `json:"distro,omitempty"`
	Metadata      *string                    `json:"metadata,omitempty"`
	NodePools     []*NodePoolAttributes      `json:"nodePools,omitempty"`
	Tags          []*TagAttributes           `json:"tags,omitempty"`
	ReadBindings  []*PolicyBindingAttributes `json:"readBindings,omitempty"`
	WriteBindings []*PolicyBindingAttributes `json:"writeBindings,omitempty"`
}

// A consolidated checklist of tasks that need to be completed to upgrade this cluster
type ClusterUpgradePlan struct {
	// whether api compatibilities with all addons and kubernetes are satisfied
	Compatibilities *bool `json:"compatibilities,omitempty"`
	// whether mutual api incompatibilities with all addons and kubernetes have been satisfied
	Incompatibilities *bool `json:"incompatibilities,omitempty"`
	// whether all api deprecations have been cleared for the target version
	Deprecations *bool `json:"deprecations,omitempty"`
}

type Command struct {
	ID          string  `json:"id"`
	Command     string  `json:"command"`
	ExitCode    *int64  `json:"exitCode,omitempty"`
	Stdout      *string `json:"stdout,omitempty"`
	CompletedAt *string `json:"completedAt,omitempty"`
	Build       *Build  `json:"build,omitempty"`
	InsertedAt  *string `json:"insertedAt,omitempty"`
	UpdatedAt   *string `json:"updatedAt,omitempty"`
}

type CommandAttributes struct {
	Cmd  string    `json:"cmd"`
	Args []*string `json:"args,omitempty"`
	Dir  *string   `json:"dir,omitempty"`
}

type CommandConnection struct {
	PageInfo PageInfo       `json:"pageInfo"`
	Edges    []*CommandEdge `json:"edges,omitempty"`
}

type CommandDelta struct {
	Delta   *Delta   `json:"delta,omitempty"`
	Payload *Command `json:"payload,omitempty"`
}

type CommandEdge struct {
	Node   *Command `json:"node,omitempty"`
	Cursor *string  `json:"cursor,omitempty"`
}

type Component struct {
	Group string `json:"group"`
	Kind  string `json:"kind"`
}

type ComponentAttributes struct {
	State     *ComponentState             `json:"state,omitempty"`
	Synced    bool                        `json:"synced"`
	Group     string                      `json:"group"`
	Version   string                      `json:"version"`
	Kind      string                      `json:"kind"`
	Namespace string                      `json:"namespace"`
	Name      string                      `json:"name"`
	Content   *ComponentContentAttributes `json:"content,omitempty"`
}

// dry run content of a service component
type ComponentContent struct {
	ID   string  `json:"id"`
	Live *string `json:"live,omitempty"`
	// the inferred desired state of this component
	Desired    *string `json:"desired,omitempty"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

// the content of a component when visualized in dry run state
type ComponentContentAttributes struct {
	// the desired state of a service component as determined from the configured manifests
	Desired *string `json:"desired,omitempty"`
	Live    *string `json:"live,omitempty"`
}

// A tree view of the kubernetes object hierarchy beneath a component
type ComponentTree struct {
	Root         *KubernetesUnstructured `json:"root,omitempty"`
	Deployments  []*Deployment           `json:"deployments,omitempty"`
	Statefulsets []*StatefulSet          `json:"statefulsets,omitempty"`
	Replicasets  []*ReplicaSet           `json:"replicasets,omitempty"`
	Daemonsets   []*DaemonSet            `json:"daemonsets,omitempty"`
	Services     []*Service              `json:"services,omitempty"`
	Ingresses    []*Ingress              `json:"ingresses,omitempty"`
	Cronjobs     []*CronJob              `json:"cronjobs,omitempty"`
	Configmaps   []*ConfigMap            `json:"configmaps,omitempty"`
	Secrets      []*Secret               `json:"secrets,omitempty"`
	Certificates []*Certificate          `json:"certificates,omitempty"`
	Edges        []*ResourceEdge         `json:"edges,omitempty"`
}

// attributes for declaratively specifying whether a config item is relevant given prior config
type ConditionAttributes struct {
	Operation Operation `json:"operation"`
	Field     string    `json:"field"`
	Value     *string   `json:"value,omitempty"`
}

type ConfigAttributes struct {
	Name  string  `json:"name"`
	Value *string `json:"value,omitempty"`
}

type ConfigMap struct {
	Metadata Metadata               `json:"metadata"`
	Data     map[string]interface{} `json:"data"`
	Raw      string                 `json:"raw"`
}

type Configuration struct {
	Terraform *string `json:"terraform,omitempty"`
	Helm      *string `json:"helm,omitempty"`
	Readme    *string `json:"readme,omitempty"`
}

type ConfigurationAction struct {
	Updates []*PathUpdate `json:"updates,omitempty"`
}

type ConfigurationCondition struct {
	Field     *string `json:"field,omitempty"`
	Value     *string `json:"value,omitempty"`
	Operation *string `json:"operation,omitempty"`
}

type ConfigurationItem struct {
	Name          *string                  `json:"name,omitempty"`
	Type          *string                  `json:"type,omitempty"`
	Placeholder   *string                  `json:"placeholder,omitempty"`
	Documentation *string                  `json:"documentation,omitempty"`
	Default       *string                  `json:"default,omitempty"`
	Optional      *bool                    `json:"optional,omitempty"`
	Condition     *ConfigurationCondition  `json:"condition,omitempty"`
	Validation    *ConfigurationValidation `json:"validation,omitempty"`
}

type ConfigurationOverlay struct {
	Metadata Metadata                 `json:"metadata"`
	Spec     ConfigurationOverlaySpec `json:"spec"`
}

type ConfigurationOverlaySpec struct {
	Name          *string          `json:"name,omitempty"`
	Folder        *string          `json:"folder,omitempty"`
	Subfolder     *string          `json:"subfolder,omitempty"`
	Documentation *string          `json:"documentation,omitempty"`
	Updates       []*OverlayUpdate `json:"updates,omitempty"`
	InputType     *string          `json:"inputType,omitempty"`
	InputValues   []*string        `json:"inputValues,omitempty"`
}

type ConfigurationValidation struct {
	Type    *string `json:"type,omitempty"`
	Regex   *string `json:"regex,omitempty"`
	Message *string `json:"message,omitempty"`
}

// Validations to apply to this configuration entry prior to PR creation
type ConfigurationValidationAttributes struct {
	// regex a string value should match
	Regex *string `json:"regex,omitempty"`
	// whether the string is json encoded
	JSON *bool `json:"json,omitempty"`
	// configuration for name uniqueness
	UniqBy *UniqByAttributes `json:"uniqBy,omitempty"`
}

type ConsoleConfiguration struct {
	GitCommit     *string `json:"gitCommit,omitempty"`
	IsDemoProject *bool   `json:"isDemoProject,omitempty"`
	IsSandbox     *bool   `json:"isSandbox,omitempty"`
	PluralLogin   *bool   `json:"pluralLogin,omitempty"`
	VpnEnabled    *bool   `json:"vpnEnabled,omitempty"`
	// whether at least one cluster has been installed, false if a user hasn't fully onboarded
	Installed    *bool              `json:"installed,omitempty"`
	Cloud        *bool              `json:"cloud,omitempty"`
	Byok         *bool              `json:"byok,omitempty"`
	ExternalOidc *bool              `json:"externalOidc,omitempty"`
	OidcName     *string            `json:"oidcName,omitempty"`
	Features     *AvailableFeatures `json:"features,omitempty"`
	Manifest     *PluralManifest    `json:"manifest,omitempty"`
	GitStatus    *GitStatus         `json:"gitStatus,omitempty"`
}

type ConstraintRef struct {
	Kind string `json:"kind"`
	Name string `json:"name"`
}

type ConstraintRefAttributes struct {
	Kind string `json:"kind"`
	Name string `json:"name"`
}

type Container struct {
	Image     *string    `json:"image,omitempty"`
	Name      *string    `json:"name,omitempty"`
	Ports     []*Port    `json:"ports,omitempty"`
	Resources *Resources `json:"resources,omitempty"`
}

// the attributes for a container
type ContainerAttributes struct {
	Name      *string                       `json:"name,omitempty"`
	Image     string                        `json:"image"`
	Args      []*string                     `json:"args,omitempty"`
	Env       []*EnvAttributes              `json:"env,omitempty"`
	EnvFrom   []*EnvFromAttributes          `json:"envFrom,omitempty"`
	Resources *ContainerResourcesAttributes `json:"resources,omitempty"`
}

// container env variable
type ContainerEnv struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

// env from declarations for containers
type ContainerEnvFrom struct {
	ConfigMap string `json:"configMap"`
	Secret    string `json:"secret"`
}

type ContainerRecommendation struct {
	Name           *string          `json:"name,omitempty"`
	ContainerName  *string          `json:"containerName,omitempty"`
	Target         *ResourceRequest `json:"target,omitempty"`
	LowerBound     *ResourceRequest `json:"lowerBound,omitempty"`
	UpperBound     *ResourceRequest `json:"upperBound,omitempty"`
	UncappedTarget *ResourceRequest `json:"uncappedTarget,omitempty"`
}

// A combined kubernetes pod container resource requests spec
type ContainerResources struct {
	Requests *ResourceRequest `json:"requests,omitempty"`
	Limits   *ResourceRequest `json:"limits,omitempty"`
}

type ContainerResourcesAttributes struct {
	Requests *ResourceRequestAttributes `json:"requests,omitempty"`
	Limits   *ResourceRequestAttributes `json:"limits,omitempty"`
}

// a shortform spec for job containers, designed for ease-of-use
type ContainerSpec struct {
	Image     string              `json:"image"`
	Args      []*string           `json:"args,omitempty"`
	Env       []*ContainerEnv     `json:"env,omitempty"`
	EnvFrom   []*ContainerEnvFrom `json:"envFrom,omitempty"`
	Resources *ContainerResources `json:"resources,omitempty"`
}

type ContainerState struct {
	Running    *RunningState    `json:"running,omitempty"`
	Terminated *TerminatedState `json:"terminated,omitempty"`
	Waiting    *WaitingState    `json:"waiting,omitempty"`
}

type ContainerStatus struct {
	RestartCount *int64          `json:"restartCount,omitempty"`
	Ready        *bool           `json:"ready,omitempty"`
	Name         *string         `json:"name,omitempty"`
	Image        *string         `json:"image,omitempty"`
	State        *ContainerState `json:"state,omitempty"`
}

type ContextAttributes struct {
	Buckets       []*string              `json:"buckets,omitempty"`
	Domain        []*string              `json:"domain,omitempty"`
	Configuration map[string]interface{} `json:"configuration"`
	Protect       []*string              `json:"protect,omitempty"`
}

// a binding from a service to a service context
type ContextBindingAttributes struct {
	ContextID string `json:"contextId"`
}

type CostAnalysis struct {
	Minutes       *float64 `json:"minutes,omitempty"`
	CPUCost       *float64 `json:"cpuCost,omitempty"`
	CPUEfficiency *float64 `json:"cpuEfficiency,omitempty"`
	Efficiency    *float64 `json:"efficiency,omitempty"`
	GpuCost       *float64 `json:"gpuCost,omitempty"`
	NetworkCost   *float64 `json:"networkCost,omitempty"`
	PvCost        *float64 `json:"pvCost,omitempty"`
	RAMCost       *float64 `json:"ramCost,omitempty"`
	RAMEfficiency *float64 `json:"ramEfficiency,omitempty"`
	TotalCost     *float64 `json:"totalCost,omitempty"`
	SharedCost    *float64 `json:"sharedCost,omitempty"`
}

type CreatePrConfigAttributes struct {
	// a scm connection id to use for pr automations
	ConnectionID *string `json:"connectionId,omitempty"`
}

type CronJob struct {
	Metadata Metadata   `json:"metadata"`
	Status   CronStatus `json:"status"`
	Spec     CronSpec   `json:"spec"`
	Raw      string     `json:"raw"`
	Events   []*Event   `json:"events,omitempty"`
	Jobs     []*Job     `json:"jobs,omitempty"`
}

type CronSpec struct {
	Schedule          string  `json:"schedule"`
	Suspend           *bool   `json:"suspend,omitempty"`
	ConcurrencyPolicy *string `json:"concurrencyPolicy,omitempty"`
}

type CronStatus struct {
	Active           []*JobReference `json:"active,omitempty"`
	LastScheduleTime *string         `json:"lastScheduleTime,omitempty"`
}

type CrossVersionResourceTarget struct {
	APIVersion *string `json:"apiVersion,omitempty"`
	Kind       *string `json:"kind,omitempty"`
	Name       *string `json:"name,omitempty"`
}

type CustomRunStep struct {
	Cmd             string    `json:"cmd"`
	Args            []*string `json:"args,omitempty"`
	Stage           StepStage `json:"stage"`
	RequireApproval *bool     `json:"requireApproval,omitempty"`
}

type CustomStackRun struct {
	ID string `json:"id"`
	// Name of the custom stack run
	Name string `json:"name"`
	// Documentation to explain to users what this will do
	Documentation *string `json:"documentation,omitempty"`
	// the list of commands that will be executed
	Commands []*StackCommand `json:"commands,omitempty"`
	// self-service configuration fields presented in the UI to configure how this run executes
	Configuration []*PrConfiguration   `json:"configuration,omitempty"`
	Stack         *InfrastructureStack `json:"stack,omitempty"`
	InsertedAt    *string              `json:"insertedAt,omitempty"`
	UpdatedAt     *string              `json:"updatedAt,omitempty"`
}

type CustomStackRunAttributes struct {
	// human readable name for this custom run
	Name string `json:"name"`
	// extended documentation to explain what this will do
	Documentation *string `json:"documentation,omitempty"`
	// the stack to attach it to
	StackID *string `json:"stackId,omitempty"`
	// the commands for this custom run
	Commands []*CommandAttributes `json:"commands,omitempty"`
	// self-service configuration which will be presented in UI before triggering
	Configuration []*PrConfigurationAttributes `json:"configuration,omitempty"`
}

type CustomStackRunConnection struct {
	PageInfo PageInfo              `json:"pageInfo"`
	Edges    []*CustomStackRunEdge `json:"edges,omitempty"`
}

type CustomStackRunEdge struct {
	Node   *CustomStackRun `json:"node,omitempty"`
	Cursor *string         `json:"cursor,omitempty"`
}

type CustomStepAttributes struct {
	Stage           *StepStage `json:"stage,omitempty"`
	Cmd             string     `json:"cmd"`
	Args            []*string  `json:"args,omitempty"`
	RequireApproval *bool      `json:"requireApproval,omitempty"`
}

type Cvss struct {
	V2Vector  *string  `json:"v2Vector,omitempty"`
	V3Vector  *string  `json:"v3Vector,omitempty"`
	V40Vector *string  `json:"v40Vector,omitempty"`
	V2Score   *float64 `json:"v2Score,omitempty"`
	V3Score   *float64 `json:"v3Score,omitempty"`
	V40Score  *float64 `json:"v40Score,omitempty"`
}

type CvssAttributes struct {
	V2Vector  *string  `json:"v2Vector,omitempty"`
	V3Vector  *string  `json:"v3Vector,omitempty"`
	V40Vector *string  `json:"v40Vector,omitempty"`
	V2Score   *float64 `json:"v2Score,omitempty"`
	V3Score   *float64 `json:"v3Score,omitempty"`
	V40Score  *float64 `json:"v40Score,omitempty"`
}

type DaemonSet struct {
	Metadata Metadata        `json:"metadata"`
	Status   DaemonSetStatus `json:"status"`
	Spec     DaemonSetSpec   `json:"spec"`
	Pods     []*Pod          `json:"pods,omitempty"`
	Raw      string          `json:"raw"`
	Events   []*Event        `json:"events,omitempty"`
}

type DaemonSetSpec struct {
	Strategy *DeploymentStrategy `json:"strategy,omitempty"`
}

type DaemonSetStatus struct {
	CurrentNumberScheduled *int64             `json:"currentNumberScheduled,omitempty"`
	DesiredNumberScheduled *int64             `json:"desiredNumberScheduled,omitempty"`
	NumberReady            *int64             `json:"numberReady,omitempty"`
	Conditions             []*StatusCondition `json:"conditions,omitempty"`
}

type Dashboard struct {
	ID   string        `json:"id"`
	Spec DashboardSpec `json:"spec"`
}

type DashboardGraph struct {
	Name    string             `json:"name"`
	Queries []*DashboardMetric `json:"queries,omitempty"`
	Format  *string            `json:"format,omitempty"`
}

type DashboardLabel struct {
	Name   string    `json:"name"`
	Values []*string `json:"values,omitempty"`
}

type DashboardMetric struct {
	Legend  *string         `json:"legend,omitempty"`
	Query   *string         `json:"query,omitempty"`
	Results []*MetricResult `json:"results,omitempty"`
}

type DashboardSpec struct {
	Name        *string           `json:"name,omitempty"`
	Description *string           `json:"description,omitempty"`
	Timeslices  []*string         `json:"timeslices,omitempty"`
	Labels      []*DashboardLabel `json:"labels,omitempty"`
	Graphs      []*DashboardGraph `json:"graphs,omitempty"`
}

type DatabaseVolume struct {
	Size *string `json:"size,omitempty"`
}

type DatadogCredentialsAttributes struct {
	APIKey string `json:"apiKey"`
	AppKey string `json:"appKey"`
}

// A representation to a service which configures renovate for a scm connection
type DependencyManagementService struct {
	ID         string             `json:"id"`
	Connection *ScmConnection     `json:"connection,omitempty"`
	Service    *ServiceDeployment `json:"service,omitempty"`
	InsertedAt *string            `json:"insertedAt,omitempty"`
	UpdatedAt  *string            `json:"updatedAt,omitempty"`
}

type DependencyManagementServiceConnection struct {
	PageInfo PageInfo                           `json:"pageInfo"`
	Edges    []*DependencyManagementServiceEdge `json:"edges,omitempty"`
}

type DependencyManagementServiceEdge struct {
	Node   *DependencyManagementService `json:"node,omitempty"`
	Cursor *string                      `json:"cursor,omitempty"`
}

type Deployment struct {
	Metadata Metadata         `json:"metadata"`
	Status   DeploymentStatus `json:"status"`
	Spec     DeploymentSpec   `json:"spec"`
	Pods     []*Pod           `json:"pods,omitempty"`
	Raw      string           `json:"raw"`
	Events   []*Event         `json:"events,omitempty"`
}

func (Deployment) IsKubernetesData() {}

// global settings for CD, these specify global read/write policies and also allow for customization of the repos for CAPI resources and the deploy operator
type DeploymentSettings struct {
	ID string `json:"id"`
	// whether you've yet to enable CD for this instance
	Enabled bool   `json:"enabled"`
	Name    string `json:"name"`
	// whether the byok cluster has been brought under self-management
	SelfManaged *bool `json:"selfManaged,omitempty"`
	// the way we can connect to your loki instance
	LokiConnection *HTTPConnection `json:"lokiConnection,omitempty"`
	// the way we can connect to your prometheus instance
	PrometheusConnection *HTTPConnection `json:"prometheusConnection,omitempty"`
	// custom helm values to apply to all agents (useful for things like adding customary annotations/labels)
	AgentHelmValues *string `json:"agentHelmValues,omitempty"`
	// global settings for stack configuration
	Stacks *StackSettings `json:"stacks,omitempty"`
	// smtp server configuration for email notifications
	SMTP *SMTPSettings `json:"smtp,omitempty"`
	// settings for LLM provider clients
	Ai *AiSettings `json:"ai,omitempty"`
	// The console's expected agent version
	AgentVsn string `json:"agentVsn"`
	// the latest known k8s version
	LatestK8sVsn string `json:"latestK8sVsn"`
	// your compliant k8s version
	CompliantK8sVsn string `json:"compliantK8sVsn"`
	// the repo to fetch CAPI manifests from, for both providers and clusters
	ArtifactRepository *GitRepository `json:"artifactRepository,omitempty"`
	// the repo to fetch the deploy operators manifests from
	DeployerRepository *GitRepository `json:"deployerRepository,omitempty"`
	// read policy across all objects
	ReadBindings []*PolicyBinding `json:"readBindings,omitempty"`
	// write policy across all objects
	WriteBindings []*PolicyBinding `json:"writeBindings,omitempty"`
	// policy for managing git repos
	GitBindings []*PolicyBinding `json:"gitBindings,omitempty"`
	// policy for creation of new objects
	CreateBindings []*PolicyBinding `json:"createBindings,omitempty"`
	InsertedAt     *string          `json:"insertedAt,omitempty"`
	UpdatedAt      *string          `json:"updatedAt,omitempty"`
}

type DeploymentSettingsAttributes struct {
	ArtifactRepositoryID *string `json:"artifactRepositoryId,omitempty"`
	DeployerRepositoryID *string `json:"deployerRepositoryId,omitempty"`
	// custom helm values to apply to all agents (useful for things like adding customary annotations/labels)
	AgentHelmValues *string `json:"agentHelmValues,omitempty"`
	// global configuration for stack execution
	Stacks *StackSettingsAttributes `json:"stacks,omitempty"`
	// connection details for a prometheus instance to use
	PrometheusConnection *HTTPConnectionAttributes `json:"prometheusConnection,omitempty"`
	// connection details for a loki instance to use
	LokiConnection *HTTPConnectionAttributes `json:"lokiConnection,omitempty"`
	// configuration for smtp message delivery
	SMTP *SMTPSettingsAttributes `json:"smtp,omitempty"`
	// configuration for LLM provider clients
	Ai             *AiSettingsAttributes      `json:"ai,omitempty"`
	ReadBindings   []*PolicyBindingAttributes `json:"readBindings,omitempty"`
	WriteBindings  []*PolicyBindingAttributes `json:"writeBindings,omitempty"`
	GitBindings    []*PolicyBindingAttributes `json:"gitBindings,omitempty"`
	CreateBindings []*PolicyBindingAttributes `json:"createBindings,omitempty"`
}

type DeploymentSpec struct {
	Replicas *int64              `json:"replicas,omitempty"`
	Strategy *DeploymentStrategy `json:"strategy,omitempty"`
}

type DeploymentStatus struct {
	AvailableReplicas   *int64             `json:"availableReplicas,omitempty"`
	Replicas            *int64             `json:"replicas,omitempty"`
	ReadyReplicas       *int64             `json:"readyReplicas,omitempty"`
	UnavailableReplicas *int64             `json:"unavailableReplicas,omitempty"`
	Conditions          []*StatusCondition `json:"conditions,omitempty"`
}

type DeploymentStrategy struct {
	Type          *string        `json:"type,omitempty"`
	RollingUpdate *RollingUpdate `json:"rollingUpdate,omitempty"`
}

type EmailSettings struct {
	// whether you want to receive digest emails
	Digest *bool `json:"digest,omitempty"`
}

type EmailSettingsAttributes struct {
	// whether you want to receive digest emails
	Digest *bool `json:"digest,omitempty"`
}

type EnvAttributes struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

type EnvFromAttributes struct {
	Secret    string `json:"secret"`
	ConfigMap string `json:"configMap"`
}

type Event struct {
	Action        *string `json:"action,omitempty"`
	Count         *int64  `json:"count,omitempty"`
	EventTime     *string `json:"eventTime,omitempty"`
	LastTimestamp *string `json:"lastTimestamp,omitempty"`
	Message       *string `json:"message,omitempty"`
	Reason        *string `json:"reason,omitempty"`
	Type          *string `json:"type,omitempty"`
}

type FileContent struct {
	Path    *string `json:"path,omitempty"`
	Content *string `json:"content,omitempty"`
}

// a Flux crd representation of a Helm repository
type FluxHelmRepository struct {
	Metadata Metadata           `json:"metadata"`
	Spec     HelmRepositorySpec `json:"spec"`
	// the charts found in this repository (heavy operation, don't do in list endpoints)
	Charts []*HelmChartEntry `json:"charts,omitempty"`
	// can fetch the status of a given helm repository
	Status *HelmRepositoryStatus `json:"status,omitempty"`
}

// spec for a job gate
type GateJobAttributes struct {
	Namespace string `json:"namespace"`
	// if you'd rather define the job spec via straight k8s yaml
	Raw            *string                `json:"raw,omitempty"`
	Containers     []*ContainerAttributes `json:"containers,omitempty"`
	Labels         *string                `json:"labels,omitempty"`
	Annotations    *string                `json:"annotations,omitempty"`
	ServiceAccount *string                `json:"serviceAccount,omitempty"`
	// request overrides if you don't want to manually configure individual containers
	Resources *ContainerResourcesAttributes `json:"resources,omitempty"`
}

// detailed gate specifications
type GateSpec struct {
	Job *JobGateSpec `json:"job,omitempty"`
}

// a more refined spec for parameters needed for complex gates
type GateSpecAttributes struct {
	Job *GateJobAttributes `json:"job,omitempty"`
}

// state delineating the current status of this gate
type GateStatus struct {
	JobRef *JobReference `json:"jobRef,omitempty"`
}

type GateStatusAttributes struct {
	JobRef *NamespacedName `json:"jobRef,omitempty"`
}

// the allowed inputs for a deployment agent gate update
type GateUpdateAttributes struct {
	State  *GateState            `json:"state,omitempty"`
	Status *GateStatusAttributes `json:"status,omitempty"`
}

type GcpCloudAttributes struct {
	Project *string `json:"project,omitempty"`
	Network *string `json:"network,omitempty"`
	Region  *string `json:"region,omitempty"`
}

// gcp specific cluster cloud configuration
type GcpCloudSettings struct {
	Project *string `json:"project,omitempty"`
	Network *string `json:"network,omitempty"`
	Region  *string `json:"region,omitempty"`
}

type GcpSettingsAttributes struct {
	ApplicationCredentials string `json:"applicationCredentials"`
}

type GcsStore struct {
	Bucket string  `json:"bucket"`
	Region *string `json:"region,omitempty"`
}

type GcsStoreAttributes struct {
	Bucket                 string  `json:"bucket"`
	Region                 *string `json:"region,omitempty"`
	ApplicationCredentials string  `json:"applicationCredentials"`
}

type GitAttributes struct {
	// the url of this repository
	URL string `json:"url"`
	// an ssh private key to use with this repo if an ssh url was given
	PrivateKey *string `json:"privateKey,omitempty"`
	// a passphrase to decrypt the given private key
	Passphrase *string `json:"passphrase,omitempty"`
	// the http username for authenticated http repos, defaults to apiKey for github
	Username *string `json:"username,omitempty"`
	// the http password for http authenticated repos
	Password *string `json:"password,omitempty"`
	// a manually supplied https path for non standard git setups.  This is auto-inferred in many cases
	HTTPSPath *string `json:"httpsPath,omitempty"`
	// similar to https_path, a manually supplied url format for custom git.  Should be something like {url}/tree/{ref}/{folder}
	URLFormat *string `json:"urlFormat,omitempty"`
	// id of a scm connection to use for authentication
	ConnectionID *string `json:"connectionId,omitempty"`
	// whether to run plural crypto on this repo
	Decrypt *bool `json:"decrypt,omitempty"`
}

// a file fetched from a git repository, eg a docs .md file
type GitFile struct {
	Path    string `json:"path"`
	Content string `json:"content"`
}

// a representation of where to pull manifests from git
type GitRef struct {
	// a general git ref, either a branch name or commit sha understandable by `git checkout <ref>`
	Ref string `json:"ref"`
	// the folder manifests live under
	Folder string `json:"folder"`
	// a list of individual files to include as well
	Files []string `json:"files,omitempty"`
}

type GitRefAttributes struct {
	Ref    string   `json:"ref"`
	Folder string   `json:"folder"`
	Files  []string `json:"files,omitempty"`
}

// a git repository available for deployments
type GitRepository struct {
	// internal id of this repository
	ID string `json:"id"`
	// the git url of the repository, either https or ssh supported
	URL string `json:"url"`
	// whether its a http or ssh url
	AuthMethod *AuthMethod `json:"authMethod,omitempty"`
	// whether we can currently pull this repo with the provided credentials
	Health *GitHealth `json:"health,omitempty"`
	// the last successsful git pull timestamp
	PulledAt *string `json:"pulledAt,omitempty"`
	// the error message if there were any pull errors
	Error *string `json:"error,omitempty"`
	// the https url for this git repo
	HTTPSPath *string `json:"httpsPath,omitempty"`
	// a format string to get the http url for a subfolder in a git repo
	URLFormat *string `json:"urlFormat,omitempty"`
	// whether to run plural crypto unlock on this repo
	Decrypt *bool `json:"decrypt,omitempty"`
	// named refs like branches/tags for a repository
	Refs []string `json:"refs,omitempty"`
	// whether the current user can edit this repo
	Editable   *bool   `json:"editable,omitempty"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

type GitRepositoryConnection struct {
	PageInfo PageInfo             `json:"pageInfo"`
	Edges    []*GitRepositoryEdge `json:"edges,omitempty"`
}

type GitRepositoryEdge struct {
	Node   *GitRepository `json:"node,omitempty"`
	Cursor *string        `json:"cursor,omitempty"`
}

type GitStatus struct {
	Cloned *bool   `json:"cloned,omitempty"`
	Output *string `json:"output,omitempty"`
}

// Requirements to perform Github App authentication
type GithubAppAttributes struct {
	// Github App ID
	AppID string `json:"appId"`
	// ID of this github app installation
	InstallationID string `json:"installationId"`
	// PEM-encoded private key for this app
	PrivateKey string `json:"privateKey"`
}

// a rules based mechanism to redeploy a service across a fleet of clusters
type GlobalService struct {
	// internal id of this global service
	ID string `json:"id"`
	// a human readable name for this global service
	Name string `json:"name"`
	// a set of tags to select clusters for this global service
	Tags []*Tag `json:"tags,omitempty"`
	// the kubernetes distribution to target with this global service
	Distro *ClusterDistro `json:"distro,omitempty"`
	// whether you want to reparent existing plural services under this global service
	Reparent *bool `json:"reparent,omitempty"`
	// behavior for all owned resources when this global service is deleted
	Cascade *Cascade `json:"cascade,omitempty"`
	// the service which created this global service
	Parent *ServiceDeployment `json:"parent,omitempty"`
	// a project this global service is bound to
	Project *Project `json:"project,omitempty"`
	// the service template used to spawn services
	Template *ServiceTemplate `json:"template,omitempty"`
	// the service to replicate across clusters
	Service *ServiceDeployment `json:"service,omitempty"`
	// whether to only apply to clusters with this provider
	Provider   *ClusterProvider             `json:"provider,omitempty"`
	Services   *ServiceDeploymentConnection `json:"services,omitempty"`
	InsertedAt *string                      `json:"insertedAt,omitempty"`
	UpdatedAt  *string                      `json:"updatedAt,omitempty"`
}

// A reference for a globalized service, which targets clusters based on the configured criteria
type GlobalServiceAttributes struct {
	// name for this global service
	Name string `json:"name"`
	// the cluster tags to target
	Tags []*TagAttributes `json:"tags,omitempty"`
	// kubernetes distribution to target
	Distro *ClusterDistro `json:"distro,omitempty"`
	// cluster api provider to target
	ProviderID *string `json:"providerId,omitempty"`
	// a project this global service will sync across
	ProjectID *string `json:"projectId,omitempty"`
	// the id of the service creating this
	ParentID *string `json:"parentId,omitempty"`
	// whether you want the global service to take ownership of existing plural services
	Reparent *bool                      `json:"reparent,omitempty"`
	Template *ServiceTemplateAttributes `json:"template,omitempty"`
	// behavior for all owned resources when this global service is deleted
	Cascade *CascadeAttributes `json:"cascade,omitempty"`
}

type GlobalServiceConnection struct {
	PageInfo PageInfo             `json:"pageInfo"`
	Edges    []*GlobalServiceEdge `json:"edges,omitempty"`
}

type GlobalServiceEdge struct {
	Node   *GlobalService `json:"node,omitempty"`
	Cursor *string        `json:"cursor,omitempty"`
}

type Group struct {
	ID          string  `json:"id"`
	Name        string  `json:"name"`
	Description *string `json:"description,omitempty"`
	// automatically adds all users in the system to this group
	Global     *bool   `json:"global,omitempty"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

type GroupAttributes struct {
	Name        string  `json:"name"`
	Description *string `json:"description,omitempty"`
	Global      *bool   `json:"global,omitempty"`
}

type GroupConnection struct {
	PageInfo PageInfo     `json:"pageInfo"`
	Edges    []*GroupEdge `json:"edges,omitempty"`
}

type GroupEdge struct {
	Node   *Group  `json:"node,omitempty"`
	Cursor *string `json:"cursor,omitempty"`
}

type GroupMember struct {
	ID         string  `json:"id"`
	User       *User   `json:"user,omitempty"`
	Group      *Group  `json:"group,omitempty"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

type GroupMemberConnection struct {
	PageInfo PageInfo           `json:"pageInfo"`
	Edges    []*GroupMemberEdge `json:"edges,omitempty"`
}

type GroupMemberEdge struct {
	Node   *GroupMember `json:"node,omitempty"`
	Cursor *string      `json:"cursor,omitempty"`
}

type HelmAuthAttributes struct {
	Basic  *HelmBasicAuthAttributes  `json:"basic,omitempty"`
	Bearer *HelmBearerAuthAttributes `json:"bearer,omitempty"`
	Aws    *HelmAwsAuthAttributes    `json:"aws,omitempty"`
	Azure  *HelmAzureAuthAttributes  `json:"azure,omitempty"`
	Gcp    *HelmGcpAuthAttributes    `json:"gcp,omitempty"`
}

type HelmAwsAuthAttributes struct {
	AccessKey       *string `json:"accessKey,omitempty"`
	SecretAccessKey *string `json:"secretAccessKey,omitempty"`
	AssumeRoleArn   *string `json:"assumeRoleArn,omitempty"`
}

type HelmAzureAuthAttributes struct {
	ClientID       *string `json:"clientId,omitempty"`
	ClientSecret   *string `json:"clientSecret,omitempty"`
	TenantID       *string `json:"tenantId,omitempty"`
	SubscriptionID *string `json:"subscriptionId,omitempty"`
}

type HelmBasicAuthAttributes struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

type HelmBearerAuthAttributes struct {
	Token string `json:"token"`
}

// a chart manifest entry, including all versions
type HelmChartEntry struct {
	// the name of the chart
	Name *string `json:"name,omitempty"`
	// all found versions of the chart
	Versions []*HelmChartVersion `json:"versions,omitempty"`
}

// a chart version contained within a helm repository manifest
type HelmChartVersion struct {
	// the version of the app contained w/in this chart
	AppVersion *string `json:"appVersion,omitempty"`
	// the version of the chart itself
	Version *string `json:"version,omitempty"`
	// the name of the chart
	Name *string `json:"name,omitempty"`
	Type *string `json:"type,omitempty"`
	// sha digest of this chart's contents
	Digest *string `json:"digest,omitempty"`
}

type HelmConfigAttributes struct {
	Values      *string              `json:"values,omitempty"`
	ValuesFiles []*string            `json:"valuesFiles,omitempty"`
	Chart       *string              `json:"chart,omitempty"`
	Version     *string              `json:"version,omitempty"`
	Release     *string              `json:"release,omitempty"`
	URL         *string              `json:"url,omitempty"`
	IgnoreHooks *bool                `json:"ignoreHooks,omitempty"`
	Set         *HelmValueAttributes `json:"set,omitempty"`
	Repository  *NamespacedName      `json:"repository,omitempty"`
	Git         *GitRefAttributes    `json:"git,omitempty"`
	// pointer to a Plural GitRepository
	RepositoryID *string `json:"repositoryId,omitempty"`
}

type HelmGcpAuthAttributes struct {
	ApplicationCredentials *string `json:"applicationCredentials,omitempty"`
}

// A direct Plural representation of a Helm repository
type HelmRepository struct {
	ID         string            `json:"id"`
	URL        string            `json:"url"`
	Health     *GitHealth        `json:"health,omitempty"`
	Error      *string           `json:"error,omitempty"`
	Provider   *HelmAuthProvider `json:"provider,omitempty"`
	PulledAt   *string           `json:"pulledAt,omitempty"`
	InsertedAt *string           `json:"insertedAt,omitempty"`
	UpdatedAt  *string           `json:"updatedAt,omitempty"`
}

type HelmRepositoryAttributes struct {
	Provider *HelmAuthProvider   `json:"provider,omitempty"`
	Auth     *HelmAuthAttributes `json:"auth,omitempty"`
}

type HelmRepositoryConnection struct {
	PageInfo PageInfo              `json:"pageInfo"`
	Edges    []*HelmRepositoryEdge `json:"edges,omitempty"`
}

type HelmRepositoryEdge struct {
	Node   *HelmRepository `json:"node,omitempty"`
	Cursor *string         `json:"cursor,omitempty"`
}

// a specification of how a helm repository is fetched
type HelmRepositorySpec struct {
	Provider *string `json:"provider,omitempty"`
	URL      string  `json:"url"`
	Type     *string `json:"type,omitempty"`
}

// the state of this helm repository
type HelmRepositoryStatus struct {
	Ready   *bool   `json:"ready,omitempty"`
	Message *string `json:"message,omitempty"`
}

type HelmSpec struct {
	// the name of the chart this service is using
	Chart *string `json:"chart,omitempty"`
	// the helm repository url to use
	URL *string `json:"url,omitempty"`
	// a helm values file to use with this service, requires auth and so is heavy to query
	Values      *string `json:"values,omitempty"`
	Release     *string `json:"release,omitempty"`
	IgnoreHooks *bool   `json:"ignoreHooks,omitempty"`
	// spec of where to find the chart in git
	Git *GitRef `json:"git,omitempty"`
	// a git repository in Plural to use as a source
	RepositoryID *string `json:"repositoryId,omitempty"`
	// pointer to the flux helm repository resource used for this chart
	Repository *ObjectReference `json:"repository,omitempty"`
	// the chart version in use currently
	Version *string `json:"version,omitempty"`
	// a list of helm name/value pairs to precisely set individual values
	Set []*HelmValue `json:"set,omitempty"`
	// a list of relative paths to values files to use for helm applies
	ValuesFiles []*string `json:"valuesFiles,omitempty"`
}

// a (possibly nested) helm value pair
type HelmValue struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

type HelmValueAttributes struct {
	// helm value name, can be deeply nested via dot like `image.tag`
	Name *string `json:"name,omitempty"`
	// value of the attribute
	Value *string `json:"value,omitempty"`
}

// the details of how to connect to a http service like prometheus
type HTTPConnection struct {
	Host string `json:"host"`
	// user to connect w/ for basic auth
	User *string `json:"user,omitempty"`
}

type HTTPConnectionAttributes struct {
	Host string `json:"host"`
	// user to connect w/ for basic auth
	User *string `json:"user,omitempty"`
	// password to connect w/ for basic auth
	Password *string `json:"password,omitempty"`
}

type HTTPIngressRule struct {
	Paths []*IngressPath `json:"paths,omitempty"`
}

type InfrastructureStack struct {
	ID *string `json:"id,omitempty"`
	// the name of the stack
	Name string `json:"name"`
	// A type for the stack, specifies the tool to use to apply it
	Type StackType `json:"type"`
	// reference w/in the repository where the IaC lives
	Git GitRef `json:"git"`
	// whether the stack is actively tracking changes in git
	Paused *bool `json:"paused,omitempty"`
	// The status of the last run of the stack
	Status StackStatus `json:"status"`
	// optional k8s job configuration for the job that will apply this stack
	JobSpec *JobGateSpec `json:"jobSpec,omitempty"`
	// version/image config for the tool you're using
	Configuration StackConfiguration `json:"configuration"`
	// whether to require approval
	Approval *bool `json:"approval,omitempty"`
	// whether this stack was previously deleted and is pending cleanup
	DeletedAt *string `json:"deletedAt,omitempty"`
	// why this run was cancelled
	CancellationReason *string `json:"cancellationReason,omitempty"`
	// the subdirectory you want to run the stack's commands w/in
	Workdir *string `json:"workdir,omitempty"`
	// whether you want Plural to manage the state of this stack
	ManageState *bool `json:"manageState,omitempty"`
	// Arbitrary variables to add to a stack run
	Variables    map[string]interface{} `json:"variables,omitempty"`
	Runs         *StackRunConnection    `json:"runs,omitempty"`
	PullRequests *PullRequestConnection `json:"pullRequests,omitempty"`
	// files bound to a run of this stack
	Files []*StackFile `json:"files,omitempty"`
	// environment variables for this stack
	Environment []*StackEnvironment `json:"environment,omitempty"`
	// a list of metrics to poll to determine if a stack run should be cancelled
	ObservableMetrics []*ObservableMetric `json:"observableMetrics,omitempty"`
	// the run that physically destroys the stack
	DeleteRun *StackRun `json:"deleteRun,omitempty"`
	// the most recent output for this stack
	Output []*StackOutput `json:"output,omitempty"`
	// the most recent state of this stack
	State *StackState `json:"state,omitempty"`
	// The project this stack belongs to
	Project *Project `json:"project,omitempty"`
	// the cluster this stack runs on
	Cluster *Cluster `json:"cluster,omitempty"`
	// the git repository you're sourcing IaC from
	Repository *GitRepository `json:"repository,omitempty"`
	// the stack definition in-use by this stack
	Definition *StackDefinition `json:"definition,omitempty"`
	// a cron to spawn runs for this stack
	Cron *StackCron `json:"cron,omitempty"`
	// the service this stack was created w/in
	Parent *ServiceDeployment `json:"parent,omitempty"`
	// an insight explaining the state of this stack
	Insight *AiInsight `json:"insight,omitempty"`
	// the actor of this stack (defaults to root console user)
	Actor           *User                     `json:"actor,omitempty"`
	CustomStackRuns *CustomStackRunConnection `json:"customStackRuns,omitempty"`
	// key/value tags to filter stacks
	Tags          []*Tag           `json:"tags,omitempty"`
	ReadBindings  []*PolicyBinding `json:"readBindings,omitempty"`
	WriteBindings []*PolicyBinding `json:"writeBindings,omitempty"`
	InsertedAt    *string          `json:"insertedAt,omitempty"`
	UpdatedAt     *string          `json:"updatedAt,omitempty"`
}

type InfrastructureStackConnection struct {
	PageInfo PageInfo                   `json:"pageInfo"`
	Edges    []*InfrastructureStackEdge `json:"edges,omitempty"`
}

type InfrastructureStackEdge struct {
	Node   *InfrastructureStack `json:"node,omitempty"`
	Cursor *string              `json:"cursor,omitempty"`
}

type Ingress struct {
	Metadata     Metadata       `json:"metadata"`
	Status       ServiceStatus  `json:"status"`
	Spec         IngressSpec    `json:"spec"`
	Certificates []*Certificate `json:"certificates,omitempty"`
	Raw          string         `json:"raw"`
	Events       []*Event       `json:"events,omitempty"`
}

type IngressBackend struct {
	ServiceName *string `json:"serviceName,omitempty"`
	ServicePort *string `json:"servicePort,omitempty"`
}

type IngressPath struct {
	Backend *IngressBackend `json:"backend,omitempty"`
	Path    *string         `json:"path,omitempty"`
}

type IngressRule struct {
	Host *string          `json:"host,omitempty"`
	HTTP *HTTPIngressRule `json:"http,omitempty"`
}

type IngressSpec struct {
	IngressClassName *string        `json:"ingressClassName,omitempty"`
	Rules            []*IngressRule `json:"rules,omitempty"`
	TLS              []*IngressTLS  `json:"tls,omitempty"`
}

type IngressTLS struct {
	Hosts []*string `json:"hosts,omitempty"`
}

type InsightClientInfo struct {
	UserAgent     *string `json:"userAgent,omitempty"`
	Count         *string `json:"count,omitempty"`
	LastRequestAt *string `json:"lastRequestAt,omitempty"`
}

type InsightClientInfoAttributes struct {
	UserAgent     *string `json:"userAgent,omitempty"`
	Count         *string `json:"count,omitempty"`
	LastRequestAt *string `json:"lastRequestAt,omitempty"`
}

type Installation struct {
	ID         string      `json:"id"`
	Repository *Repository `json:"repository,omitempty"`
}

type InstallationConnection struct {
	PageInfo PageInfo            `json:"pageInfo"`
	Edges    []*InstallationEdge `json:"edges,omitempty"`
}

type InstallationEdge struct {
	Node   *Installation `json:"node,omitempty"`
	Cursor *string       `json:"cursor,omitempty"`
}

type Invite struct {
	SecureID string  `json:"secureId"`
	Email    *string `json:"email,omitempty"`
}

type InviteAttributes struct {
	Email *string `json:"email,omitempty"`
}

type IssuerRef struct {
	Group *string `json:"group,omitempty"`
	Kind  *string `json:"kind,omitempty"`
	Name  *string `json:"name,omitempty"`
}

type Job struct {
	Metadata Metadata  `json:"metadata"`
	Status   JobStatus `json:"status"`
	Spec     JobSpec   `json:"spec"`
	Raw      string    `json:"raw"`
	Events   []*Event  `json:"events,omitempty"`
	Pods     []*Pod    `json:"pods,omitempty"`
	Logs     []*string `json:"logs,omitempty"`
}

// the full specification of a job gate
type JobGateSpec struct {
	// the namespace the job will run in
	Namespace string `json:"namespace"`
	// a raw kubernetes job resource, overrides any other configuration
	Raw *string `json:"raw,omitempty"`
	// list of containers to run in this job
	Containers []*ContainerSpec `json:"containers,omitempty"`
	// any pod labels to apply
	Labels map[string]interface{} `json:"labels,omitempty"`
	// any pod annotations to apply
	Annotations map[string]interface{} `json:"annotations,omitempty"`
	// the service account the pod will use
	ServiceAccount *string `json:"serviceAccount,omitempty"`
	// requests overrides for cases where direct container configuration is unnecessary
	Requests *ContainerResources `json:"requests,omitempty"`
}

type JobReference struct {
	Name      string `json:"name"`
	Namespace string `json:"namespace"`
}

type JobSpec struct {
	BackoffLimit          *int64 `json:"backoffLimit,omitempty"`
	Parallelism           *int64 `json:"parallelism,omitempty"`
	ActiveDeadlineSeconds *int64 `json:"activeDeadlineSeconds,omitempty"`
}

type JobStatus struct {
	Active         *int64  `json:"active,omitempty"`
	CompletionTime *string `json:"completionTime,omitempty"`
	StartTime      *string `json:"startTime,omitempty"`
	Succeeded      *int64  `json:"succeeded,omitempty"`
	Failed         *int64  `json:"failed,omitempty"`
}

type KubeconfigAttributes struct {
	Raw *string `json:"raw,omitempty"`
}

type KubernetesDatasource struct {
	Resource string `json:"resource"`
	Name     string `json:"name"`
}

type KubernetesUnstructured struct {
	Group    *string                `json:"group,omitempty"`
	Version  string                 `json:"version"`
	Kind     string                 `json:"kind"`
	Raw      map[string]interface{} `json:"raw,omitempty"`
	Metadata Metadata               `json:"metadata"`
	Events   []*Event               `json:"events,omitempty"`
}

// metadata needed for configuring kustomize
type Kustomize struct {
	Path string `json:"path"`
}

type KustomizeAttributes struct {
	// the path to the kustomization file to use
	Path string `json:"path"`
}

type LabelInput struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

type LabelPair struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

type License struct {
	Metadata Metadata       `json:"metadata"`
	Spec     LicenseSpec    `json:"spec"`
	Status   *LicenseStatus `json:"status,omitempty"`
}

type LicenseFeature struct {
	Name        string  `json:"name"`
	Description *string `json:"description,omitempty"`
}

type LicenseSpec struct {
	SecretRef SecretKeySelector `json:"secretRef"`
}

type LicenseStatus struct {
	Plan     *string                `json:"plan,omitempty"`
	Free     *bool                  `json:"free,omitempty"`
	Features []*LicenseFeature      `json:"features,omitempty"`
	Limits   map[string]interface{} `json:"limits,omitempty"`
	Secrets  map[string]interface{} `json:"secrets,omitempty"`
}

type LoadBalancerIngressStatus struct {
	Hostname *string `json:"hostname,omitempty"`
	IP       *string `json:"ip,omitempty"`
}

type LoadBalancerStatus struct {
	Ingress []*LoadBalancerIngressStatus `json:"ingress,omitempty"`
}

type LogFilter struct {
	Metadata Metadata      `json:"metadata"`
	Spec     LogFilterSpec `json:"spec"`
}

type LogFilterSpec struct {
	Name        *string     `json:"name,omitempty"`
	Description *string     `json:"description,omitempty"`
	Query       *string     `json:"query,omitempty"`
	Labels      []*LogLabel `json:"labels,omitempty"`
}

type LogLabel struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

type LogStream struct {
	Stream map[string]interface{} `json:"stream,omitempty"`
	Values []*MetricResult        `json:"values,omitempty"`
}

type LoginInfo struct {
	OidcURI  *string `json:"oidcUri,omitempty"`
	External *bool   `json:"external,omitempty"`
	OidcName *string `json:"oidcName,omitempty"`
}

type LokiLabelFilter struct {
	Name  string `json:"name"`
	Value string `json:"value"`
	// whether to apply a regex match for this label
	Regex *bool `json:"regex,omitempty"`
}

type LokiLineFilter struct {
	// the string to filter for (eg what is put in our search ui)
	Text *string `json:"text,omitempty"`
	// whether to treat this string as a regex match
	Regex *bool `json:"regex,omitempty"`
}

type LokiQuery struct {
	Labels []*LokiLabelFilter `json:"labels,omitempty"`
	Filter *LokiLineFilter    `json:"filter,omitempty"`
}

// A representation of a managed namespace, which is k8s namespace configuration + a service spec to define a namespace runtime
type ManagedNamespace struct {
	ID string `json:"id"`
	// the name of this namespace once its placed on a cluster
	Name string `json:"name"`
	// override the name of the kubernetes namespace if `name` is not usable
	Namespace *string `json:"namespace,omitempty"`
	// A short description of the purpose of this namespace
	Description *string `json:"description,omitempty"`
	// labels for this namespace
	Labels map[string]interface{} `json:"labels,omitempty"`
	// annotations for this namespace
	Annotations map[string]interface{} `json:"annotations,omitempty"`
	// a list of pull secrets to attach to this namespace
	PullSecrets []*string `json:"pullSecrets,omitempty"`
	// The targeting criteria to select clusters this namespace is bound to
	Target *ClusterTarget `json:"target,omitempty"`
	// the timestamp this namespace was deleted at, indicating it's currently draining
	DeletedAt *string `json:"deletedAt,omitempty"`
	// behavior for all owned resources when this global service is deleted
	Cascade *Cascade `json:"cascade,omitempty"`
	// the service which created this managed namespace
	Parent *ServiceDeployment `json:"parent,omitempty"`
	// a project this global service is bound to
	Project *Project `json:"project,omitempty"`
	// A template for creating the core service for this namespace
	Service    *ServiceTemplate             `json:"service,omitempty"`
	Services   *ServiceDeploymentConnection `json:"services,omitempty"`
	InsertedAt *string                      `json:"insertedAt,omitempty"`
	UpdatedAt  *string                      `json:"updatedAt,omitempty"`
}

// Attributes for configuring a managed namespace
type ManagedNamespaceAttributes struct {
	// the name of this managed namespace (globally unique)
	Name string `json:"name"`
	// the name of the namespace if `name` doesn't align
	Namespace *string `json:"namespace,omitempty"`
	// A short description of the purpose of this namespace
	Description *string `json:"description,omitempty"`
	// labels for this namespace
	Labels *string `json:"labels,omitempty"`
	// annotations for this namespace
	Annotations *string `json:"annotations,omitempty"`
	// a list of pull secrets to attach to this namespace
	PullSecrets []*string `json:"pullSecrets,omitempty"`
	// a project this managed namespace will sync across
	ProjectID *string `json:"projectId,omitempty"`
	// the id of the service creating this
	ParentID *string                    `json:"parentId,omitempty"`
	Service  *ServiceTemplateAttributes `json:"service,omitempty"`
	Target   *ClusterTargetAttributes   `json:"target,omitempty"`
	// behavior for all owned resources when this global service is deleted
	Cascade *CascadeAttributes `json:"cascade,omitempty"`
}

type ManagedNamespaceConnection struct {
	PageInfo PageInfo                `json:"pageInfo"`
	Edges    []*ManagedNamespaceEdge `json:"edges,omitempty"`
}

type ManagedNamespaceEdge struct {
	Node   *ManagedNamespace `json:"node,omitempty"`
	Cursor *string           `json:"cursor,omitempty"`
}

type ManifestNetwork struct {
	PluralDNS *bool   `json:"pluralDns,omitempty"`
	Subdomain *string `json:"subdomain,omitempty"`
}

type Metadata struct {
	Labels            []*LabelPair `json:"labels,omitempty"`
	Annotations       []*LabelPair `json:"annotations,omitempty"`
	Name              string       `json:"name"`
	Namespace         *string      `json:"namespace,omitempty"`
	CreationTimestamp *string      `json:"creationTimestamp,omitempty"`
	UID               *string      `json:"uid,omitempty"`
}

type MetadataAttributes struct {
	Labels      *string `json:"labels,omitempty"`
	Annotations *string `json:"annotations,omitempty"`
}

type MetricResponse struct {
	Metric map[string]interface{} `json:"metric,omitempty"`
	Values []*MetricResult        `json:"values,omitempty"`
}

type MetricResult struct {
	Timestamp *string `json:"timestamp,omitempty"`
	Value     *string `json:"value,omitempty"`
}

type Namespace struct {
	Status   NamespaceStatus `json:"status"`
	Spec     NamespaceSpec   `json:"spec"`
	Metadata Metadata        `json:"metadata"`
	Raw      string          `json:"raw"`
	Events   []*Event        `json:"events,omitempty"`
}

// metadata fields for created namespaces
type NamespaceMetadata struct {
	Labels      map[string]interface{} `json:"labels,omitempty"`
	Annotations map[string]interface{} `json:"annotations,omitempty"`
}

type NamespaceSpec struct {
	Finalizers []*string `json:"finalizers,omitempty"`
}

type NamespaceStatus struct {
	Phase *string `json:"phase,omitempty"`
}

type NamespaceVuln struct {
	Namespace string `json:"namespace"`
}

type NamespaceVulnAttributes struct {
	Namespace string `json:"namespace"`
}

type NamespacedName struct {
	Name      string `json:"name"`
	Namespace string `json:"namespace"`
}

type NewRelicCredentialsAttributes struct {
	APIKey string `json:"apiKey"`
}

type Node struct {
	Status   NodeStatus `json:"status"`
	Spec     NodeSpec   `json:"spec"`
	Metadata Metadata   `json:"metadata"`
	Raw      string     `json:"raw"`
	Pods     []*Pod     `json:"pods,omitempty"`
	Events   []*Event   `json:"events,omitempty"`
}

// cloud specific settings for a node pool
type NodeCloudSettings struct {
	Aws *AwsCloud `json:"aws,omitempty"`
}

type NodeCondition struct {
	Message *string `json:"message,omitempty"`
	Reason  *string `json:"reason,omitempty"`
	Status  *string `json:"status,omitempty"`
	Type    *string `json:"type,omitempty"`
}

type NodeMetric struct {
	Metadata  Metadata   `json:"metadata"`
	Timestamp *string    `json:"timestamp,omitempty"`
	Window    *string    `json:"window,omitempty"`
	Usage     *NodeUsage `json:"usage,omitempty"`
}

// a specification for a node pool to be created in this cluster
type NodePool struct {
	// internal id for this node pool
	ID string `json:"id"`
	// name of this node pool (must be unique)
	Name string `json:"name"`
	// minimum number of instances in this node pool
	MinSize int64 `json:"minSize"`
	// maximum number of instances in this node pool
	MaxSize int64 `json:"maxSize"`
	// the type of node to use (usually cloud-specific)
	InstanceType string `json:"instanceType"`
	// whether this is a spot pool or not
	Spot *bool `json:"spot,omitempty"`
	// kubernetes labels to apply to the nodes in this pool, useful for node selectors
	Labels map[string]interface{} `json:"labels,omitempty"`
	// any taints you'd want to apply to a node, for eg preventing scheduling on spot instances
	Taints []*Taint `json:"taints,omitempty"`
	// cloud specific settings for the node groups
	CloudSettings *NodeCloudSettings `json:"cloudSettings,omitempty"`
	InsertedAt    *string            `json:"insertedAt,omitempty"`
	UpdatedAt     *string            `json:"updatedAt,omitempty"`
}

type NodePoolAttributes struct {
	Name          string                   `json:"name"`
	MinSize       int64                    `json:"minSize"`
	MaxSize       int64                    `json:"maxSize"`
	InstanceType  string                   `json:"instanceType"`
	Labels        *string                  `json:"labels,omitempty"`
	Taints        []*TaintAttributes       `json:"taints,omitempty"`
	CloudSettings *NodePoolCloudAttributes `json:"cloudSettings,omitempty"`
}

type NodePoolCloudAttributes struct {
	Aws *AwsNodeCloudAttributes `json:"aws,omitempty"`
}

type NodeSpec struct {
	PodCidr       *string `json:"podCidr,omitempty"`
	ProviderID    *string `json:"providerId,omitempty"`
	Unschedulable *bool   `json:"unschedulable,omitempty"`
}

type NodeStatus struct {
	Allocatable map[string]interface{} `json:"allocatable,omitempty"`
	Capacity    map[string]interface{} `json:"capacity,omitempty"`
	Phase       *string                `json:"phase,omitempty"`
	Conditions  []*NodeCondition       `json:"conditions,omitempty"`
}

type NodeUsage struct {
	CPU    *string `json:"cpu,omitempty"`
	Memory *string `json:"memory,omitempty"`
}

type Notification struct {
	ID          string                 `json:"id"`
	Title       string                 `json:"title"`
	Description *string                `json:"description,omitempty"`
	Fingerprint string                 `json:"fingerprint"`
	Status      *NotificationStatus    `json:"status,omitempty"`
	Labels      map[string]interface{} `json:"labels,omitempty"`
	Annotations map[string]interface{} `json:"annotations,omitempty"`
	Repository  string                 `json:"repository"`
	SeenAt      *string                `json:"seenAt,omitempty"`
	Severity    *Severity              `json:"severity,omitempty"`
	InsertedAt  *string                `json:"insertedAt,omitempty"`
	UpdatedAt   *string                `json:"updatedAt,omitempty"`
}

type NotificationConnection struct {
	PageInfo PageInfo            `json:"pageInfo"`
	Edges    []*NotificationEdge `json:"edges,omitempty"`
}

type NotificationDelta struct {
	Delta   *Delta        `json:"delta,omitempty"`
	Payload *Notification `json:"payload,omitempty"`
}

type NotificationEdge struct {
	Node   *Notification `json:"node,omitempty"`
	Cursor *string       `json:"cursor,omitempty"`
}

type NotificationFilter struct {
	ID       string             `json:"id"`
	Regex    *string            `json:"regex,omitempty"`
	Service  *ServiceDeployment `json:"service,omitempty"`
	Cluster  *Cluster           `json:"cluster,omitempty"`
	Pipeline *Pipeline          `json:"pipeline,omitempty"`
}

type NotificationRouter struct {
	ID string `json:"id"`
	// name of this router
	Name string `json:"name"`
	// events this router subscribes to, use * for all
	Events []string `json:"events,omitempty"`
	// resource-based filters to select events for services, clusters, pipelines
	Filters []*NotificationFilter `json:"filters,omitempty"`
	// sinks to deliver notifications to
	Sinks      []*NotificationSink `json:"sinks,omitempty"`
	InsertedAt *string             `json:"insertedAt,omitempty"`
	UpdatedAt  *string             `json:"updatedAt,omitempty"`
}

type NotificationRouterAttributes struct {
	// the name of this router
	Name string `json:"name"`
	// the events to trigger, or use * for any
	Events []string `json:"events,omitempty"`
	// filters by object type
	Filters []*RouterFilterAttributes `json:"filters,omitempty"`
	// sinks to deliver notifications to
	RouterSinks []*RouterSinkAttributes `json:"routerSinks,omitempty"`
}

type NotificationRouterConnection struct {
	PageInfo PageInfo                  `json:"pageInfo"`
	Edges    []*NotificationRouterEdge `json:"edges,omitempty"`
}

type NotificationRouterEdge struct {
	Node   *NotificationRouter `json:"node,omitempty"`
	Cursor *string             `json:"cursor,omitempty"`
}

type NotificationSink struct {
	ID string `json:"id"`
	// the name of the sink
	Name string `json:"name"`
	// the channel type of the sink, eg slack or teams
	Type SinkType `json:"type"`
	// the users/groups an in-app notification can be delivered to
	NotificationBindings []*PolicyBinding `json:"notificationBindings,omitempty"`
	// type specific sink configuration
	Configuration SinkConfiguration `json:"configuration"`
	InsertedAt    *string           `json:"insertedAt,omitempty"`
	UpdatedAt     *string           `json:"updatedAt,omitempty"`
}

type NotificationSinkAttributes struct {
	// the name of this sink
	Name string `json:"name"`
	// the channel type of this sink
	Type SinkType `json:"type"`
	// configuration for the specific type
	Configuration SinkConfigurationAttributes `json:"configuration"`
	// the users/groups you want this sink to deliver to if it's PLURAL type
	NotificationBindings []*PolicyBindingAttributes `json:"notificationBindings,omitempty"`
}

type NotificationSinkConnection struct {
	PageInfo PageInfo                `json:"pageInfo"`
	Edges    []*NotificationSinkEdge `json:"edges,omitempty"`
}

type NotificationSinkEdge struct {
	Node   *NotificationSink `json:"node,omitempty"`
	Cursor *string           `json:"cursor,omitempty"`
}

type ObjectReference struct {
	Name      *string `json:"name,omitempty"`
	Namespace *string `json:"namespace,omitempty"`
}

type ObjectStore struct {
	ID         string      `json:"id"`
	Name       string      `json:"name"`
	S3         *S3Store    `json:"s3,omitempty"`
	Gcs        *GcsStore   `json:"gcs,omitempty"`
	Azure      *AzureStore `json:"azure,omitempty"`
	InsertedAt *string     `json:"insertedAt,omitempty"`
	UpdatedAt  *string     `json:"updatedAt,omitempty"`
}

type ObjectStoreAttributes struct {
	Name  string                `json:"name"`
	S3    *S3StoreAttributes    `json:"s3,omitempty"`
	Gcs   *GcsStoreAttributes   `json:"gcs,omitempty"`
	Azure *AzureStoreAttributes `json:"azure,omitempty"`
}

type ObjectStoreConnection struct {
	PageInfo PageInfo           `json:"pageInfo"`
	Edges    []*ObjectStoreEdge `json:"edges,omitempty"`
}

type ObjectStoreEdge struct {
	Node   *ObjectStore `json:"node,omitempty"`
	Cursor *string      `json:"cursor,omitempty"`
}

type ObservabilityProvider struct {
	ID         string                    `json:"id"`
	Type       ObservabilityProviderType `json:"type"`
	Name       string                    `json:"name"`
	InsertedAt *string                   `json:"insertedAt,omitempty"`
	UpdatedAt  *string                   `json:"updatedAt,omitempty"`
}

type ObservabilityProviderAttributes struct {
	Type        ObservabilityProviderType                  `json:"type"`
	Name        string                                     `json:"name"`
	Credentials ObservabilityProviderCredentialsAttributes `json:"credentials"`
}

type ObservabilityProviderConnection struct {
	PageInfo PageInfo                     `json:"pageInfo"`
	Edges    []*ObservabilityProviderEdge `json:"edges,omitempty"`
}

type ObservabilityProviderCredentialsAttributes struct {
	Datadog  *DatadogCredentialsAttributes  `json:"datadog,omitempty"`
	Newrelic *NewRelicCredentialsAttributes `json:"newrelic,omitempty"`
}

type ObservabilityProviderEdge struct {
	Node   *ObservabilityProvider `json:"node,omitempty"`
	Cursor *string                `json:"cursor,omitempty"`
}

// A webhook receiver for an observability provider like grafana or datadog
type ObservabilityWebhook struct {
	ID   string                   `json:"id"`
	Type ObservabilityWebhookType `json:"type"`
	Name string                   `json:"name"`
	// the url for this specific webhook
	URL        string  `json:"url"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

// input data to persist a webhook receiver for an observability provider like grafana or datadog
type ObservabilityWebhookAttributes struct {
	Type   ObservabilityWebhookType `json:"type"`
	Name   string                   `json:"name"`
	Secret *string                  `json:"secret,omitempty"`
}

type ObservabilityWebhookConnection struct {
	PageInfo PageInfo                    `json:"pageInfo"`
	Edges    []*ObservabilityWebhookEdge `json:"edges,omitempty"`
}

type ObservabilityWebhookEdge struct {
	Node   *ObservabilityWebhook `json:"node,omitempty"`
	Cursor *string               `json:"cursor,omitempty"`
}

type ObservableMetric struct {
	ID         string                 `json:"id"`
	Identifier string                 `json:"identifier"`
	Provider   *ObservabilityProvider `json:"provider,omitempty"`
	InsertedAt *string                `json:"insertedAt,omitempty"`
	UpdatedAt  *string                `json:"updatedAt,omitempty"`
}

type ObservableMetricAttributes struct {
	Identifier string `json:"identifier"`
	ProviderID string `json:"providerId"`
}

// An observer is a mechanism to poll an external helm, oci or other datasources and perform a list of actions in response
type Observer struct {
	ID         string            `json:"id"`
	Name       string            `json:"name"`
	Status     ObserverStatus    `json:"status"`
	Crontab    string            `json:"crontab"`
	LastRunAt  string            `json:"lastRunAt"`
	NextRunAt  string            `json:"nextRunAt"`
	Target     ObserverTarget    `json:"target"`
	Actions    []*ObserverAction `json:"actions,omitempty"`
	Project    *Project          `json:"project,omitempty"`
	Errors     []*ServiceError   `json:"errors,omitempty"`
	InsertedAt *string           `json:"insertedAt,omitempty"`
	UpdatedAt  *string           `json:"updatedAt,omitempty"`
}

// A spec of an action that can be taken in response to an observed entity
type ObserverAction struct {
	Type          ObserverActionType          `json:"type"`
	Configuration ObserverActionConfiguration `json:"configuration"`
}

// A spec of an action that can be taken in response to an observed entity
type ObserverActionAttributes struct {
	Type          ObserverActionType                    `json:"type"`
	Configuration ObserverActionConfigurationAttributes `json:"configuration"`
}

// configuration for an observer action
type ObserverActionConfiguration struct {
	Pr       *ObserverPrAction       `json:"pr,omitempty"`
	Pipeline *ObserverPipelineAction `json:"pipeline,omitempty"`
}

// configuration for an observer action
type ObserverActionConfigurationAttributes struct {
	Pr       *ObserverPrActionAttributes       `json:"pr,omitempty"`
	Pipeline *ObserverPipelineActionAttributes `json:"pipeline,omitempty"`
}

// An observer is a mechanism to poll an external helm, oci or other datasources and perform a list of actions in response
type ObserverAttributes struct {
	Name      string                      `json:"name"`
	Crontab   string                      `json:"crontab"`
	Target    ObserverTargetAttributes    `json:"target"`
	Actions   []*ObserverActionAttributes `json:"actions,omitempty"`
	ProjectID *string                     `json:"projectId,omitempty"`
}

type ObserverConnection struct {
	PageInfo PageInfo        `json:"pageInfo"`
	Edges    []*ObserverEdge `json:"edges,omitempty"`
}

type ObserverEdge struct {
	Node   *Observer `json:"node,omitempty"`
	Cursor *string   `json:"cursor,omitempty"`
}

type ObserverGitAttributes struct {
	RepositoryID string                `json:"repositoryId"`
	Type         ObserverGitTargetType `json:"type"`
}

// a spec for polling a git repository for recent updates
type ObserverGitRepo struct {
	RepositoryID string `json:"repositoryId"`
	// the resource within the git repository you want to poll
	Type ObserverGitTargetType `json:"type"`
}

// a spec for querying a helm repository in an observer
type ObserverHelmAttributes struct {
	URL      string              `json:"url"`
	Chart    string              `json:"chart"`
	Provider *HelmAuthProvider   `json:"provider,omitempty"`
	Auth     *HelmAuthAttributes `json:"auth,omitempty"`
}

// a spec for querying a helm in an observer
type ObserverHelmRepo struct {
	URL      string            `json:"url"`
	Chart    string            `json:"chart"`
	Provider *HelmAuthProvider `json:"provider,omitempty"`
}

// a spec for querying a helm repository in an observer
type ObserverOciAttributes struct {
	URL      string              `json:"url"`
	Provider *HelmAuthProvider   `json:"provider,omitempty"`
	Auth     *HelmAuthAttributes `json:"auth,omitempty"`
}

// a spec for querying a oci repository in an observer
type ObserverOciRepo struct {
	URL      string            `json:"url"`
	Provider *HelmAuthProvider `json:"provider,omitempty"`
}

// Configuration for setting a pipeline context in an observer
type ObserverPipelineAction struct {
	PipelineID string `json:"pipelineId"`
	// the context to apply, use $value to interject the observed value
	Context map[string]interface{} `json:"context"`
}

// Configuration for setting a pipeline context in an observer
type ObserverPipelineActionAttributes struct {
	PipelineID string `json:"pipelineId"`
	// the context to apply, use $value to interject the observed value
	Context string `json:"context"`
}

// Configuration for sending a pr in response to an observer
type ObserverPrAction struct {
	AutomationID string  `json:"automationId"`
	Repository   *string `json:"repository,omitempty"`
	// a template to use for the created branch, use $value to interject the observed value
	BranchTemplate *string `json:"branchTemplate,omitempty"`
	// the context to apply, use $value to interject the observed value
	Context string `json:"context"`
}

// Configuration for sending a pr in response to an observer
type ObserverPrActionAttributes struct {
	AutomationID string  `json:"automationId"`
	Repository   *string `json:"repository,omitempty"`
	// a template to use for the created branch, use $value to interject the observed value
	BranchTemplate *string `json:"branchTemplate,omitempty"`
	// the context to apply, use $value to interject the observed value
	Context string `json:"context"`
}

// A spec for a target to poll
type ObserverTarget struct {
	Type ObserverTargetType `json:"type"`
	// present for backwards compat, use `type` instead
	Target ObserverTargetType `json:"target"`
	// a regex for extracting the target value, useful in cases where a semver is nested
	// in a larger release string.  The first capture group is the substring that is used for the value.
	Format *string `json:"format,omitempty"`
	// the order in which polled results are applied, defaults to SEMVER
	Order ObserverTargetOrder `json:"order"`
	Helm  *ObserverHelmRepo   `json:"helm,omitempty"`
	Oci   *ObserverOciRepo    `json:"oci,omitempty"`
	Git   *ObserverGitRepo    `json:"git,omitempty"`
}

// A spec for a target to poll
type ObserverTargetAttributes struct {
	Type *ObserverTargetType `json:"type,omitempty"`
	// present for backwards compat
	Target *ObserverTargetType     `json:"target,omitempty"`
	Format *string                 `json:"format,omitempty"`
	Order  ObserverTargetOrder     `json:"order"`
	Helm   *ObserverHelmAttributes `json:"helm,omitempty"`
	Oci    *ObserverOciAttributes  `json:"oci,omitempty"`
	Git    *ObserverGitAttributes  `json:"git,omitempty"`
}

// A representation of a created OIDC provider client
type OidcProvider struct {
	ID          string          `json:"id"`
	Name        string          `json:"name"`
	Description *string         `json:"description,omitempty"`
	AuthMethod  *OidcAuthMethod `json:"authMethod,omitempty"`
	// the redirect uris oidc is whitelisted to use
	RedirectUris []*string `json:"redirectUris,omitempty"`
	// the generated client ID used in configuring OAuth clients
	ClientID string `json:"clientId"`
	// the generated client secret, used in configuring an OAuth client
	ClientSecret string `json:"clientSecret"`
}

// Configuration settings for creating a new OIDC provider client
type OidcProviderAttributes struct {
	Name        string          `json:"name"`
	AuthMethod  *OidcAuthMethod `json:"authMethod,omitempty"`
	Description *string         `json:"description,omitempty"`
	// the redirect uris oidc is whitelisted to use
	RedirectUris []*string `json:"redirectUris,omitempty"`
}

type OllamaAttributes struct {
	Model string `json:"model"`
	URL   string `json:"url"`
	// An http authorization header to use on calls to the Ollama api
	Authorization *string `json:"authorization,omitempty"`
}

// Settings for a self-hosted ollama-based LLM deployment
type OllamaSettings struct {
	Model string `json:"model"`
	// the url your ollama deployment is hosted on
	URL string `json:"url"`
}

// OpenAI connection information
type OpenaiSettings struct {
	// the base url to use when querying an OpenAI compatible API, leave blank for OpenAI
	BaseURL *string `json:"baseUrl,omitempty"`
	// the openai model version to use
	Model *string `json:"model,omitempty"`
}

type OpenaiSettingsAttributes struct {
	BaseURL     *string `json:"baseUrl,omitempty"`
	AccessToken *string `json:"accessToken,omitempty"`
	Model       *string `json:"model,omitempty"`
}

type OverlayUpdate struct {
	Path []*string `json:"path,omitempty"`
}

type PageInfo struct {
	// When paginating backwards, are there more items?
	HasPreviousPage bool `json:"hasPreviousPage"`
	// When paginating forwards, are there more items?
	HasNextPage bool `json:"hasNextPage"`
	// When paginating backwards, the cursor to continue.
	StartCursor *string `json:"startCursor,omitempty"`
	// When paginating forwards, the cursor to continue.
	EndCursor *string `json:"endCursor,omitempty"`
}

type PathUpdate struct {
	Path      []*string `json:"path,omitempty"`
	ValueFrom string    `json:"valueFrom"`
}

type PauseCondition struct {
	Reason    *string `json:"reason,omitempty"`
	StartTime *string `json:"startTime,omitempty"`
}

type Persona struct {
	ID string `json:"id"`
	// the name for this persona
	Name string `json:"name"`
	// longform description of this persona
	Description *string `json:"description,omitempty"`
	// the ui configuration for this persona (additive across personas)
	Configuration *PersonaConfiguration `json:"configuration,omitempty"`
	// the group bindings for this persona
	Bindings   []*PolicyBinding `json:"bindings,omitempty"`
	InsertedAt *string          `json:"insertedAt,omitempty"`
	UpdatedAt  *string          `json:"updatedAt,omitempty"`
}

type PersonaAttributes struct {
	Name *string `json:"name,omitempty"`
	// longform description of this persona
	Description   *string                         `json:"description,omitempty"`
	Configuration *PersonaConfigurationAttributes `json:"configuration,omitempty"`
	Bindings      []*BindingAttributes            `json:"bindings,omitempty"`
}

type PersonaConfiguration struct {
	// enable full ui for this persona
	All *bool `json:"all,omitempty"`
	// settings for the home page for this persona
	Home *PersonaHome `json:"home,omitempty"`
	// enable individual parts of the deployments views
	Deployments *PersonaDeployment `json:"deployments,omitempty"`
	// enable individual aspects of the sidebar
	Sidebar *PersonaSidebar `json:"sidebar,omitempty"`
}

type PersonaConfigurationAttributes struct {
	// enable full ui for this persona
	All *bool `json:"all,omitempty"`
	// configuration for the homepage for the given persona
	Home *PersonaHomeAttributes `json:"home,omitempty"`
	// enable individual parts of the deployments views
	Deployments *PersonaDeploymentAttributes `json:"deployments,omitempty"`
	// enable individual aspects of the sidebar
	Sidebar *PersonaSidebarAttributes `json:"sidebar,omitempty"`
}

type PersonaConnection struct {
	PageInfo PageInfo       `json:"pageInfo"`
	Edges    []*PersonaEdge `json:"edges,omitempty"`
}

type PersonaDeployment struct {
	Clusters     *bool `json:"clusters,omitempty"`
	Deployments  *bool `json:"deployments,omitempty"`
	Repositories *bool `json:"repositories,omitempty"`
	Services     *bool `json:"services,omitempty"`
	Pipelines    *bool `json:"pipelines,omitempty"`
	Providers    *bool `json:"providers,omitempty"`
	AddOns       *bool `json:"addOns,omitempty"`
}

type PersonaDeploymentAttributes struct {
	Clusters     *bool `json:"clusters,omitempty"`
	Deployments  *bool `json:"deployments,omitempty"`
	Repositories *bool `json:"repositories,omitempty"`
	Services     *bool `json:"services,omitempty"`
	Pipelines    *bool `json:"pipelines,omitempty"`
	Providers    *bool `json:"providers,omitempty"`
	AddOns       *bool `json:"addOns,omitempty"`
}

type PersonaEdge struct {
	Node   *Persona `json:"node,omitempty"`
	Cursor *string  `json:"cursor,omitempty"`
}

type PersonaHome struct {
	Manager  *bool `json:"manager,omitempty"`
	Security *bool `json:"security,omitempty"`
}

type PersonaHomeAttributes struct {
	Manager  *bool `json:"manager,omitempty"`
	Security *bool `json:"security,omitempty"`
}

type PersonaSidebar struct {
	Audits       *bool `json:"audits,omitempty"`
	Kubernetes   *bool `json:"kubernetes,omitempty"`
	PullRequests *bool `json:"pullRequests,omitempty"`
	Settings     *bool `json:"settings,omitempty"`
	Backups      *bool `json:"backups,omitempty"`
	Stacks       *bool `json:"stacks,omitempty"`
}

type PersonaSidebarAttributes struct {
	Audits       *bool `json:"audits,omitempty"`
	Kubernetes   *bool `json:"kubernetes,omitempty"`
	PullRequests *bool `json:"pullRequests,omitempty"`
	Settings     *bool `json:"settings,omitempty"`
	Backups      *bool `json:"backups,omitempty"`
	Stacks       *bool `json:"stacks,omitempty"`
}

// A reference to a custom resource you want to be displayed in the k8s dashboard
type PinnedCustomResource struct {
	ID          string   `json:"id"`
	Name        string   `json:"name"`
	DisplayName string   `json:"displayName"`
	Group       string   `json:"group"`
	Version     string   `json:"version"`
	Kind        string   `json:"kind"`
	Namespaced  *bool    `json:"namespaced,omitempty"`
	Cluster     *Cluster `json:"cluster,omitempty"`
}

type PinnedCustomResourceAttributes struct {
	Name        string  `json:"name"`
	DisplayName string  `json:"displayName"`
	Group       string  `json:"group"`
	Version     string  `json:"version"`
	Kind        string  `json:"kind"`
	Namespaced  *bool   `json:"namespaced,omitempty"`
	ClusterID   *string `json:"clusterId,omitempty"`
}

// a release pipeline, composed of multiple stages each with potentially multiple services
type Pipeline struct {
	ID string `json:"id"`
	// the name of the pipeline
	Name string `json:"name"`
	// the stages of this pipeline
	Stages []*PipelineStage `json:"stages,omitempty"`
	Status *PipelineStatus  `json:"status,omitempty"`
	// the project this pipeline belongs to
	Project *Project `json:"project,omitempty"`
	// read policy for this pipeline
	ReadBindings []*PolicyBinding `json:"readBindings,omitempty"`
	// write policy of this pipeline
	WriteBindings []*PolicyBinding `json:"writeBindings,omitempty"`
	// edges linking two stages w/in the pipeline in a full DAG
	Edges []*PipelineStageEdge `json:"edges,omitempty"`
	// lists the contexts applied to a pipeline
	Contexts   *PipelineContextConnection `json:"contexts,omitempty"`
	InsertedAt *string                    `json:"insertedAt,omitempty"`
	UpdatedAt  *string                    `json:"updatedAt,omitempty"`
}

// the top level input object for creating/deleting pipelines
type PipelineAttributes struct {
	ProjectID     *string                    `json:"projectId,omitempty"`
	Stages        []*PipelineStageAttributes `json:"stages,omitempty"`
	Edges         []*PipelineEdgeAttributes  `json:"edges,omitempty"`
	ReadBindings  []*PolicyBindingAttributes `json:"readBindings,omitempty"`
	WriteBindings []*PolicyBindingAttributes `json:"writeBindings,omitempty"`
}

type PipelineConnection struct {
	PageInfo PageInfo        `json:"pageInfo"`
	Edges    []*PipelineEdge `json:"edges,omitempty"`
}

// A variable context that can be used to generate pull requests as a pipeline progresses
type PipelineContext struct {
	ID string `json:"id"`
	// the context map that will be passed to the pipeline
	Context  map[string]interface{} `json:"context"`
	Pipeline *Pipeline              `json:"pipeline,omitempty"`
	// a history of pull requests created by this context thus far
	PullRequests []*PullRequest `json:"pullRequests,omitempty"`
	// a list of pipeline-specific PRs for this context
	PipelinePullRequests []*PipelinePullRequest `json:"pipelinePullRequests,omitempty"`
	InsertedAt           *string                `json:"insertedAt,omitempty"`
	UpdatedAt            *string                `json:"updatedAt,omitempty"`
}

// attributes needed to create a new pipeline context
type PipelineContextAttributes struct {
	Context string `json:"context"`
}

type PipelineContextConnection struct {
	PageInfo PageInfo               `json:"pageInfo"`
	Edges    []*PipelineContextEdge `json:"edges,omitempty"`
}

type PipelineContextEdge struct {
	Node   *PipelineContext `json:"node,omitempty"`
	Cursor *string          `json:"cursor,omitempty"`
}

// A record of a prior pipeline context attached to a stage
type PipelineContextHistory struct {
	ID         string           `json:"id"`
	Stage      *PipelineStage   `json:"stage,omitempty"`
	Context    *PipelineContext `json:"context,omitempty"`
	InsertedAt *string          `json:"insertedAt,omitempty"`
	UpdatedAt  *string          `json:"updatedAt,omitempty"`
}

type PipelineContextHistoryConnection struct {
	PageInfo PageInfo                      `json:"pageInfo"`
	Edges    []*PipelineContextHistoryEdge `json:"edges,omitempty"`
}

type PipelineContextHistoryEdge struct {
	Node   *PipelineContextHistory `json:"node,omitempty"`
	Cursor *string                 `json:"cursor,omitempty"`
}

type PipelineEdge struct {
	Node   *Pipeline `json:"node,omitempty"`
	Cursor *string   `json:"cursor,omitempty"`
}

// specification of an edge between two pipeline stages
type PipelineEdgeAttributes struct {
	// stage id the edge is from, can also be specified by name
	FromID *string `json:"fromId,omitempty"`
	// stage id the edge is to, can also be specified by name
	ToID *string `json:"toId,omitempty"`
	// the name of the pipeline stage this edge emits from
	From *string `json:"from,omitempty"`
	// the name of the pipeline stage this edge points to
	To *string `json:"to,omitempty"`
	// any optional promotion gates you wish to configure
	Gates []*PipelineGateAttributes `json:"gates,omitempty"`
}

// A gate blocking promotion along a release pipeline
type PipelineGate struct {
	ID string `json:"id"`
	// the name of this gate as seen in the UI
	Name string `json:"name"`
	// the type of gate this is
	Type GateType `json:"type"`
	// the current state of this gate
	State GateState `json:"state"`
	// more detailed specification for complex gates
	Spec *GateSpec `json:"spec,omitempty"`
	// state related to the current status of this job
	Status *GateStatus `json:"status,omitempty"`
	// the kubernetes job running this gate (should only be fetched lazily as this is a heavy operation)
	Job *Job `json:"job,omitempty"`
	// the edge this gate lives on
	Edge *PipelineStageEdge `json:"edge,omitempty"`
	// the cluster this gate can run on
	Cluster *Cluster `json:"cluster,omitempty"`
	// the last user to approve this gate
	Approver   *User   `json:"approver,omitempty"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

// will configure a promotion gate for a pipeline
type PipelineGateAttributes struct {
	// the name of this gate
	Name string `json:"name"`
	// the type of gate this is
	Type GateType `json:"type"`
	// the handle of a cluster this gate will execute on
	Cluster *string `json:"cluster,omitempty"`
	// the id of the cluster this gate will execute on
	ClusterID *string `json:"clusterId,omitempty"`
	// a specification for more complex gate types
	Spec *GateSpecAttributes `json:"spec,omitempty"`
}

type PipelineGateConnection struct {
	PageInfo PageInfo            `json:"pageInfo"`
	Edges    []*PipelineGateEdge `json:"edges,omitempty"`
}

type PipelineGateEdge struct {
	Node   *PipelineGate `json:"node,omitempty"`
	Cursor *string       `json:"cursor,omitempty"`
}

// a representation of an individual pipeline promotion, which is a list of services/revisions and timestamps to determine promotion status
type PipelinePromotion struct {
	ID string `json:"id"`
	// the last time this promotion was updated
	RevisedAt *string `json:"revisedAt,omitempty"`
	// the last time this promotion was fully promoted, it's no longer pending if promoted_at > revised_at
	PromotedAt *string `json:"promotedAt,omitempty"`
	// the services included in this promotion
	Services   []*PromotionService `json:"services,omitempty"`
	InsertedAt *string             `json:"insertedAt,omitempty"`
	UpdatedAt  *string             `json:"updatedAt,omitempty"`
}

// A pull request created in the course of executing a pipeline
type PipelinePullRequest struct {
	ID          string             `json:"id"`
	Service     *ServiceDeployment `json:"service,omitempty"`
	PullRequest *PullRequest       `json:"pullRequest,omitempty"`
}

// a pipeline stage, has a list of services and potentially a promotion which might be pending
type PipelineStage struct {
	ID string `json:"id"`
	// the name of this stage (eg dev, prod, staging)
	Name string `json:"name"`
	// the errors for this stage
	Errors []*ServiceError `json:"errors,omitempty"`
	// the services within this stage
	Services []*StageService `json:"services,omitempty"`
	// the context that is to be applied to this stage for PR promotions
	Context *PipelineContext `json:"context,omitempty"`
	// a promotion which might be outstanding for this stage
	Promotion      *PipelinePromotion                `json:"promotion,omitempty"`
	ContextHistory *PipelineContextHistoryConnection `json:"contextHistory,omitempty"`
	InsertedAt     *string                           `json:"insertedAt,omitempty"`
	UpdatedAt      *string                           `json:"updatedAt,omitempty"`
}

// specification of a stage of a pipeline
type PipelineStageAttributes struct {
	Name     string                    `json:"name"`
	Services []*StageServiceAttributes `json:"services,omitempty"`
}

// an edge in the pipeline DAG
type PipelineStageEdge struct {
	ID string `json:"id"`
	// when the edge was last promoted, if greater than the promotion objects revised at, was successfully promoted
	PromotedAt *string         `json:"promotedAt,omitempty"`
	From       PipelineStage   `json:"from"`
	To         PipelineStage   `json:"to"`
	Gates      []*PipelineGate `json:"gates,omitempty"`
	Pipeline   *Pipeline       `json:"pipeline,omitempty"`
	InsertedAt *string         `json:"insertedAt,omitempty"`
	UpdatedAt  *string         `json:"updatedAt,omitempty"`
}

// a report of gate statuses within a pipeline to gauge its health
type PipelineStatus struct {
	// if > 0, consider the pipeline pending
	Pending *int64 `json:"pending,omitempty"`
	// if > 0, consider the pipeline stopped
	Closed *int64 `json:"closed,omitempty"`
	// if > 0, consider the pipeline runnning
	Running *int64 `json:"running,omitempty"`
}

type Plan struct {
	ID     *string `json:"id,omitempty"`
	Name   *string `json:"name,omitempty"`
	Period *string `json:"period,omitempty"`
}

type PluralCluster struct {
	Status    PluralObjectStatus `json:"status"`
	Metadata  Metadata           `json:"metadata"`
	Reference *Cluster           `json:"reference,omitempty"`
	Raw       string             `json:"raw"`
	Events    []*Event           `json:"events,omitempty"`
}

type PluralContext struct {
	Buckets       []*string              `json:"buckets,omitempty"`
	Domains       []*string              `json:"domains,omitempty"`
	Configuration map[string]interface{} `json:"configuration"`
}

// temporary credentials for the user attached to this stack
type PluralCreds struct {
	// authentication token to use for gql requests
	Token *string `json:"token,omitempty"`
	// the api url of this instance
	URL *string `json:"url,omitempty"`
}

type PluralGitRepository struct {
	Status    PluralObjectStatus `json:"status"`
	Metadata  Metadata           `json:"metadata"`
	Reference *GitRepository     `json:"reference,omitempty"`
	Raw       string             `json:"raw"`
	Events    []*Event           `json:"events,omitempty"`
}

type PluralManifest struct {
	Network      *ManifestNetwork `json:"network,omitempty"`
	BucketPrefix *string          `json:"bucketPrefix,omitempty"`
	Cluster      *string          `json:"cluster,omitempty"`
}

type PluralObjectStatus struct {
	ID         *string            `json:"id,omitempty"`
	Conditions []*StatusCondition `json:"conditions,omitempty"`
}

type PluralServiceDeployment struct {
	Status    PluralObjectStatus `json:"status"`
	Metadata  Metadata           `json:"metadata"`
	Reference *ServiceDeployment `json:"reference,omitempty"`
	Raw       string             `json:"raw"`
	Events    []*Event           `json:"events,omitempty"`
}

type PluralSinkAttributes struct {
	Priority NotificationPriority `json:"priority"`
	// whether to immediately deliver the derived notification via SMTP
	Urgent *bool `json:"urgent,omitempty"`
}

type PluralSinkConfiguration struct {
	Priority NotificationPriority `json:"priority"`
	// whether to immediately deliver the derived notification via SMTP
	Urgent *bool `json:"urgent,omitempty"`
}

type PluralSubscription struct {
	ID   *string `json:"id,omitempty"`
	Plan *Plan   `json:"plan,omitempty"`
}

type Pod struct {
	Status   PodStatus `json:"status"`
	Spec     PodSpec   `json:"spec"`
	Metadata Metadata  `json:"metadata"`
	Raw      string    `json:"raw"`
	Logs     []*string `json:"logs,omitempty"`
	Events   []*Event  `json:"events,omitempty"`
}

type PodCondition struct {
	LastProbeTime      *string `json:"lastProbeTime,omitempty"`
	LastTransitionTime *string `json:"lastTransitionTime,omitempty"`
	Message            *string `json:"message,omitempty"`
	Reason             *string `json:"reason,omitempty"`
	Status             *string `json:"status,omitempty"`
	Type               *string `json:"type,omitempty"`
}

type PodConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []*PodEdge `json:"edges,omitempty"`
}

type PodDelta struct {
	Delta   *Delta `json:"delta,omitempty"`
	Payload *Pod   `json:"payload,omitempty"`
}

type PodEdge struct {
	Node   *Pod    `json:"node,omitempty"`
	Cursor *string `json:"cursor,omitempty"`
}

type PodSpec struct {
	ServiceAccountName *string      `json:"serviceAccountName,omitempty"`
	NodeName           *string      `json:"nodeName,omitempty"`
	Containers         []*Container `json:"containers,omitempty"`
	InitContainers     []*Container `json:"initContainers,omitempty"`
}

type PodStatus struct {
	Message               *string            `json:"message,omitempty"`
	Phase                 *string            `json:"phase,omitempty"`
	HostIP                *string            `json:"hostIp,omitempty"`
	PodIP                 *string            `json:"podIp,omitempty"`
	Reason                *string            `json:"reason,omitempty"`
	Conditions            []*PodCondition    `json:"conditions,omitempty"`
	ContainerStatuses     []*ContainerStatus `json:"containerStatuses,omitempty"`
	InitContainerStatuses []*ContainerStatus `json:"initContainerStatuses,omitempty"`
}

type PolicyBinding struct {
	ID    *string `json:"id,omitempty"`
	User  *User   `json:"user,omitempty"`
	Group *Group  `json:"group,omitempty"`
}

type PolicyBindingAttributes struct {
	ID      *string `json:"id,omitempty"`
	UserID  *string `json:"userId,omitempty"`
	GroupID *string `json:"groupId,omitempty"`
}

// A OPA Gatekeeper Constraint reference
type PolicyConstraint struct {
	ID             string                 `json:"id"`
	Name           string                 `json:"name"`
	Description    *string                `json:"description,omitempty"`
	Recommendation *string                `json:"recommendation,omitempty"`
	ViolationCount *int64                 `json:"violationCount,omitempty"`
	Enforcement    *ConstraintEnforcement `json:"enforcement,omitempty"`
	// Fetches the live constraint object from K8s, this is an expensive query and should not be done in list endpoints
	Object *KubernetesUnstructured `json:"object,omitempty"`
	// pointer to the kubernetes resource itself
	Ref        *ConstraintRef `json:"ref,omitempty"`
	Cluster    *Cluster       `json:"cluster,omitempty"`
	Violations []*Violation   `json:"violations,omitempty"`
	InsertedAt *string        `json:"insertedAt,omitempty"`
	UpdatedAt  *string        `json:"updatedAt,omitempty"`
}

// inputs to add constraint data from an OPA gatekeeper constraint CRD
type PolicyConstraintAttributes struct {
	Name           string  `json:"name"`
	Description    *string `json:"description,omitempty"`
	Recommendation *string `json:"recommendation,omitempty"`
	ViolationCount *int64  `json:"violationCount,omitempty"`
	// pointer to the group/name for the CR
	Ref         *ConstraintRefAttributes `json:"ref,omitempty"`
	Violations  []*ViolationAttributes   `json:"violations,omitempty"`
	Enforcement *ConstraintEnforcement   `json:"enforcement,omitempty"`
}

type PolicyConstraintConnection struct {
	PageInfo PageInfo                `json:"pageInfo"`
	Edges    []*PolicyConstraintEdge `json:"edges,omitempty"`
}

type PolicyConstraintEdge struct {
	Node   *PolicyConstraint `json:"node,omitempty"`
	Cursor *string           `json:"cursor,omitempty"`
}

// Aggregate statistics for policies across your fleet
type PolicyStatistic struct {
	// the field you're computing this statistic on
	Aggregate *string `json:"aggregate,omitempty"`
	// the count for this aggregate
	Count *int64 `json:"count,omitempty"`
}

type Port struct {
	HostPort      *int64  `json:"hostPort,omitempty"`
	ContainerPort *int64  `json:"containerPort,omitempty"`
	Protocol      *string `json:"protocol,omitempty"`
}

type PostgresInstance struct {
	UID string `json:"uid"`
}

type PostgresSettings struct {
	Version *string `json:"version,omitempty"`
}

type Postgresql struct {
	Metadata  Metadata            `json:"metadata"`
	Spec      PostgresqlSpec      `json:"spec"`
	Status    *PostgresqlStatus   `json:"status,omitempty"`
	Instances []*PostgresInstance `json:"instances,omitempty"`
}

type PostgresqlSpec struct {
	TeamID            *string                `json:"teamId,omitempty"`
	Users             map[string]interface{} `json:"users,omitempty"`
	Resources         *Resources             `json:"resources,omitempty"`
	Postgresql        *PostgresSettings      `json:"postgresql,omitempty"`
	NumberOfInstances *int64                 `json:"numberOfInstances,omitempty"`
	Databases         map[string]interface{} `json:"databases,omitempty"`
	Volume            *DatabaseVolume        `json:"volume,omitempty"`
	Pods              []*Pod                 `json:"pods,omitempty"`
}

type PostgresqlStatus struct {
	ClusterStatus *string `json:"clusterStatus,omitempty"`
}

// a description of how to generate a pr, which can either modify existing files or generate new ones w/in a repo
type PrAutomation struct {
	ID string `json:"id"`
	// string id for a repository, eg for github, this is {organization}/{repository-name}
	Identifier string `json:"identifier"`
	// the name for this automation
	Name string `json:"name"`
	// An enum describing the high-level responsibility of this pr, eg creating a cluster or service, or upgrading a cluster
	Role          *PrRole       `json:"role,omitempty"`
	Documentation *string       `json:"documentation,omitempty"`
	Title         string        `json:"title"`
	Message       string        `json:"message"`
	Updates       *PrUpdateSpec `json:"updates,omitempty"`
	Creates       *PrCreateSpec `json:"creates,omitempty"`
	Deletes       *PrDeleteSpec `json:"deletes,omitempty"`
	// an icon url to use for this catalog
	Icon *string `json:"icon,omitempty"`
	// a darkmode icon url to use for this catalog
	DarkIcon      *string            `json:"darkIcon,omitempty"`
	Configuration []*PrConfiguration `json:"configuration,omitempty"`
	// optional confirmation block to express prerequisites for this PR
	Confirmation *PrConfirmation `json:"confirmation,omitempty"`
	// write policy for this pr automation, also propagates to the notifications list for any created PRs
	WriteBindings []*PolicyBinding `json:"writeBindings,omitempty"`
	// users who can generate prs with this automation
	CreateBindings []*PolicyBinding `json:"createBindings,omitempty"`
	// link to an add-on name if this can update it
	Addon *string `json:"addon,omitempty"`
	// the git repository to use for sourcing external templates
	Repository *GitRepository `json:"repository,omitempty"`
	// the catalog this pr automation belongs to
	Catalog *Catalog `json:"catalog,omitempty"`
	// the project this automation lives w/in
	Project *Project `json:"project,omitempty"`
	// link to a cluster if this is to perform an upgrade
	Cluster *Cluster `json:"cluster,omitempty"`
	// link to a service if this can update its configuration
	Service *ServiceDeployment `json:"service,omitempty"`
	// the scm connection to use for pr generation
	Connection *ScmConnection `json:"connection,omitempty"`
	InsertedAt *string        `json:"insertedAt,omitempty"`
	UpdatedAt  *string        `json:"updatedAt,omitempty"`
}

// A way to create a self-service means of generating PRs against an IaC repo
type PrAutomationAttributes struct {
	Name *string `json:"name,omitempty"`
	Role *PrRole `json:"role,omitempty"`
	// string id for a repository, eg for github, this is {organization}/{repository-name}
	Identifier    *string                           `json:"identifier,omitempty"`
	Documentation *string                           `json:"documentation,omitempty"`
	Title         *string                           `json:"title,omitempty"`
	Message       *string                           `json:"message,omitempty"`
	Branch        *string                           `json:"branch,omitempty"`
	Updates       *PrAutomationUpdateSpecAttributes `json:"updates,omitempty"`
	Creates       *PrAutomationCreateSpecAttributes `json:"creates,omitempty"`
	Deletes       *PrAutomationDeleteSpecAttributes `json:"deletes,omitempty"`
	// an icon url to use for this catalog
	Icon *string `json:"icon,omitempty"`
	// a darkmode icon url to use for this catalog
	DarkIcon *string `json:"darkIcon,omitempty"`
	// link to an add-on name if this can update it
	Addon *string `json:"addon,omitempty"`
	// link to a cluster if this is to perform an upgrade
	ClusterID *string `json:"clusterId,omitempty"`
	// link to a service if this can modify its configuration
	ServiceID *string `json:"serviceId,omitempty"`
	// the scm connection to use for pr generation
	ConnectionID *string `json:"connectionId,omitempty"`
	// the catalog this automation will belong to
	CatalogID *string `json:"catalogId,omitempty"`
	// the project this automation lives in
	ProjectID *string `json:"projectId,omitempty"`
	// a git repository to use for create mode prs
	RepositoryID  *string                      `json:"repositoryId,omitempty"`
	Configuration []*PrConfigurationAttributes `json:"configuration,omitempty"`
	Confirmation  *PrConfirmationAttributes    `json:"confirmation,omitempty"`
	// users who can update this automation
	WriteBindings []*PolicyBindingAttributes `json:"writeBindings,omitempty"`
	// users who can create prs with this automation
	CreateBindings []*PolicyBindingAttributes `json:"createBindings,omitempty"`
}

type PrAutomationConnection struct {
	PageInfo PageInfo            `json:"pageInfo"`
	Edges    []*PrAutomationEdge `json:"edges,omitempty"`
}

// Operations to create new templated files within this pr
type PrAutomationCreateSpecAttributes struct {
	Git       *GitRefAttributes                 `json:"git,omitempty"`
	Templates []*PrAutomationTemplateAttributes `json:"templates,omitempty"`
}

// Operations to delete files within this pr
type PrAutomationDeleteSpecAttributes struct {
	Files   []string `json:"files,omitempty"`
	Folders []string `json:"folders,omitempty"`
}

type PrAutomationEdge struct {
	Node   *PrAutomation `json:"node,omitempty"`
	Cursor *string       `json:"cursor,omitempty"`
}

// templates to apply in this pr
type PrAutomationTemplateAttributes struct {
	Source      string `json:"source"`
	Destination string `json:"destination"`
	// whether the source template is sourced from an external git repo bound to this automation
	External bool `json:"external"`
}

// The operations to be performed on the files w/in the pr
type PrAutomationUpdateSpecAttributes struct {
	Regexes []*string `json:"regexes,omitempty"`
	// list of regex scope replacement templates, useful for ANY strategies
	RegexReplacements []*RegexReplacementAttributes `json:"regexReplacements,omitempty"`
	// list of yaml overlay operations to apply to a file
	YamlOverlays    []*YamlOverlayAttributes `json:"yamlOverlays,omitempty"`
	Files           []*string                `json:"files,omitempty"`
	ReplaceTemplate *string                  `json:"replaceTemplate,omitempty"`
	Yq              *string                  `json:"yq,omitempty"`
	MatchStrategy   *MatchStrategy           `json:"matchStrategy,omitempty"`
}

// a checkbox item to render before creating a pr
type PrChecklist struct {
	// the label for the checkbox
	Label string `json:"label"`
}

// a checkbox item to render before creating a pr
type PrChecklistAttributes struct {
	// the label for the checkbox
	Label string `json:"label"`
}

// the a configuration item for creating a new pr, used for templating the ultimate code changes made
type PrConfiguration struct {
	Type          ConfigurationType         `json:"type"`
	Name          string                    `json:"name"`
	Default       *string                   `json:"default,omitempty"`
	Documentation *string                   `json:"documentation,omitempty"`
	Longform      *string                   `json:"longform,omitempty"`
	Placeholder   *string                   `json:"placeholder,omitempty"`
	Optional      *bool                     `json:"optional,omitempty"`
	Values        []*string                 `json:"values,omitempty"`
	Condition     *PrConfigurationCondition `json:"condition,omitempty"`
}

// the a configuration item for creating a new pr
type PrConfigurationAttributes struct {
	Type          ConfigurationType                  `json:"type"`
	Name          string                             `json:"name"`
	Default       *string                            `json:"default,omitempty"`
	Documentation *string                            `json:"documentation,omitempty"`
	Longform      *string                            `json:"longform,omitempty"`
	Placeholder   *string                            `json:"placeholder,omitempty"`
	Optional      *bool                              `json:"optional,omitempty"`
	Condition     *ConditionAttributes               `json:"condition,omitempty"`
	Validation    *ConfigurationValidationAttributes `json:"validation,omitempty"`
	Values        []*string                          `json:"values,omitempty"`
}

// declaritive spec for whether a config item is relevant given prior config
type PrConfigurationCondition struct {
	// a boolean operation to apply
	Operation Operation `json:"operation"`
	// the prior field to check
	Field string `json:"field"`
	// a fixed value to check against if its a binary operation
	Value *string `json:"value,omitempty"`
}

// Additional details to verify all prerequisites are satisfied before generating this pr
type PrConfirmation struct {
	// optional markdown text to present before pr create
	Text *string `json:"text,omitempty"`
	// itemized checklist to complete before pr create
	Checklist []*PrChecklist `json:"checklist,omitempty"`
}

// Additional details to verify all prerequisites are satisfied before generating this pr
type PrConfirmationAttributes struct {
	// optional markdown text to present before pr create
	Text *string `json:"text,omitempty"`
	// itemized checklist to complete before pr create
	Checklist []*PrChecklistAttributes `json:"checklist,omitempty"`
}

// templated files used to add new files to a given pr
type PrCreateSpec struct {
	// pointer within an external git repository to source templates from
	Git       *GitRef           `json:"git,omitempty"`
	Templates []*PrTemplateSpec `json:"templates,omitempty"`
}

// Files or folders you want to delete in this pr
type PrDeleteSpec struct {
	Files   []string `json:"files,omitempty"`
	Folders []string `json:"folders,omitempty"`
}

// the details of where to find and place a templated file
type PrTemplateSpec struct {
	Source      string `json:"source"`
	Destination string `json:"destination"`
	External    bool   `json:"external"`
}

// existing file updates that can be performed in a PR
type PrUpdateSpec struct {
	Regexes           []*string           `json:"regexes,omitempty"`
	RegexReplacements []*RegexReplacement `json:"regexReplacements,omitempty"`
	YamlOverlays      []*YamlOverlay      `json:"yamlOverlays,omitempty"`
	Files             []*string           `json:"files,omitempty"`
	ReplaceTemplate   *string             `json:"replaceTemplate,omitempty"`
	Yq                *string             `json:"yq,omitempty"`
	MatchStrategy     *MatchStrategy      `json:"matchStrategy,omitempty"`
}

// A unit of organization to control permissions for a set of objects within your Console instance
type Project struct {
	ID          string  `json:"id"`
	Name        string  `json:"name"`
	Description *string `json:"description,omitempty"`
	Default     *bool   `json:"default,omitempty"`
	// list all alerts discovered for this project
	Alerts *AlertConnection `json:"alerts,omitempty"`
	// read policy across this project
	ReadBindings []*PolicyBinding `json:"readBindings,omitempty"`
	// write policy across this project
	WriteBindings []*PolicyBinding `json:"writeBindings,omitempty"`
	InsertedAt    *string          `json:"insertedAt,omitempty"`
	UpdatedAt     *string          `json:"updatedAt,omitempty"`
}

type ProjectAttributes struct {
	Name          string                     `json:"name"`
	Description   *string                    `json:"description,omitempty"`
	ReadBindings  []*PolicyBindingAttributes `json:"readBindings,omitempty"`
	WriteBindings []*PolicyBindingAttributes `json:"writeBindings,omitempty"`
}

type ProjectConnection struct {
	PageInfo PageInfo       `json:"pageInfo"`
	Edges    []*ProjectEdge `json:"edges,omitempty"`
}

type ProjectEdge struct {
	Node   *Project `json:"node,omitempty"`
	Cursor *string  `json:"cursor,omitempty"`
}

type PrometheusDatasource struct {
	Query  string  `json:"query"`
	Format *string `json:"format,omitempty"`
	Legend *string `json:"legend,omitempty"`
}

// how a promotion for a service will be performed
type PromotionCriteria struct {
	ID string `json:"id"`
	// overrides the repository slug for the referenced pr automation
	Repository *string `json:"repository,omitempty"`
	// the source service in a prior stage to promote settings from
	Source *ServiceDeployment `json:"source,omitempty"`
	// whether you want to copy any configuration values from the source service
	Secrets    []*string `json:"secrets,omitempty"`
	InsertedAt *string   `json:"insertedAt,omitempty"`
	UpdatedAt  *string   `json:"updatedAt,omitempty"`
}

// actions to perform if this stage service were promoted
type PromotionCriteriaAttributes struct {
	// the handle of the cluster for the source service
	Handle *string `json:"handle,omitempty"`
	// the name of the source service
	Name *string `json:"name,omitempty"`
	// the id of the service to promote from
	SourceID *string `json:"sourceId,omitempty"`
	// the id of a pr automation to update this service
	PrAutomationID *string `json:"prAutomationId,omitempty"`
	// overrides the repository slug for the referenced pr automation
	Repository *string `json:"repository,omitempty"`
	// the secrets to copy over in a promotion
	Secrets []*string `json:"secrets,omitempty"`
}

// a service to be potentially promoted
type PromotionService struct {
	ID string `json:"id"`
	// a service to promote
	Service *ServiceDeployment `json:"service,omitempty"`
	// the revision of the service to promote
	Revision   *Revision `json:"revision,omitempty"`
	InsertedAt *string   `json:"insertedAt,omitempty"`
	UpdatedAt  *string   `json:"updatedAt,omitempty"`
}

// a cloud credential that can be used while creating new clusters
type ProviderCredential struct {
	ID         string  `json:"id"`
	Name       string  `json:"name"`
	Namespace  string  `json:"namespace"`
	Kind       string  `json:"kind"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

type ProviderCredentialAttributes struct {
	Namespace *string `json:"namespace,omitempty"`
	Name      string  `json:"name"`
	Kind      *string `json:"kind,omitempty"`
}

// A reference to a pull request for your kubernetes related IaC
type PullRequest struct {
	ID      string    `json:"id"`
	Status  *PrStatus `json:"status,omitempty"`
	URL     string    `json:"url"`
	Title   *string   `json:"title,omitempty"`
	Creator *string   `json:"creator,omitempty"`
	Labels  []*string `json:"labels,omitempty"`
	// the cluster this pr is meant to modify
	Cluster *Cluster `json:"cluster,omitempty"`
	// the service this pr is meant to modify
	Service    *ServiceDeployment `json:"service,omitempty"`
	InsertedAt *string            `json:"insertedAt,omitempty"`
	UpdatedAt  *string            `json:"updatedAt,omitempty"`
}

// attributes for a pull request pointer record
type PullRequestAttributes struct {
	URL       string          `json:"url"`
	Title     string          `json:"title"`
	Creator   *string         `json:"creator,omitempty"`
	Labels    []*string       `json:"labels,omitempty"`
	ServiceID *string         `json:"serviceId,omitempty"`
	ClusterID *string         `json:"clusterId,omitempty"`
	Service   *NamespacedName `json:"service,omitempty"`
	Cluster   *NamespacedName `json:"cluster,omitempty"`
}

type PullRequestConnection struct {
	PageInfo PageInfo           `json:"pageInfo"`
	Edges    []*PullRequestEdge `json:"edges,omitempty"`
}

type PullRequestEdge struct {
	Node   *PullRequest `json:"node,omitempty"`
	Cursor *string      `json:"cursor,omitempty"`
}

// attributes for a pull request pointer record
type PullRequestUpdateAttributes struct {
	Title     string          `json:"title"`
	Labels    []*string       `json:"labels,omitempty"`
	Status    PrStatus        `json:"status"`
	ServiceID *string         `json:"serviceId,omitempty"`
	ClusterID *string         `json:"clusterId,omitempty"`
	Service   *NamespacedName `json:"service,omitempty"`
	Cluster   *NamespacedName `json:"cluster,omitempty"`
}

type RbacAttributes struct {
	ReadBindings  []*PolicyBindingAttributes `json:"readBindings,omitempty"`
	WriteBindings []*PolicyBindingAttributes `json:"writeBindings,omitempty"`
}

type Recipe struct {
	ID             string           `json:"id"`
	Name           string           `json:"name"`
	Description    *string          `json:"description,omitempty"`
	Provider       *string          `json:"provider,omitempty"`
	Restricted     *bool            `json:"restricted,omitempty"`
	RecipeSections []*RecipeSection `json:"recipeSections,omitempty"`
	OidcEnabled    *bool            `json:"oidcEnabled,omitempty"`
}

type RecipeConnection struct {
	PageInfo PageInfo      `json:"pageInfo"`
	Edges    []*RecipeEdge `json:"edges,omitempty"`
}

type RecipeEdge struct {
	Node   *Recipe `json:"node,omitempty"`
	Cursor *string `json:"cursor,omitempty"`
}

type RecipeItem struct {
	ID            string               `json:"id"`
	Configuration []*ConfigurationItem `json:"configuration,omitempty"`
}

type RecipeSection struct {
	ID            string               `json:"id"`
	Repository    *Repository          `json:"repository,omitempty"`
	RecipeItems   []*RecipeItem        `json:"recipeItems,omitempty"`
	Configuration []*ConfigurationItem `json:"configuration,omitempty"`
}

type Recommendation struct {
	ContainerRecommendations []*ContainerRecommendation `json:"containerRecommendations,omitempty"`
}

type RefreshToken struct {
	ID string `json:"id"`
	// the token to use to request a refresh
	Token      string  `json:"token"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

type RefreshTokenConnection struct {
	PageInfo PageInfo            `json:"pageInfo"`
	Edges    []*RefreshTokenEdge `json:"edges,omitempty"`
}

type RefreshTokenEdge struct {
	Node   *RefreshToken `json:"node,omitempty"`
	Cursor *string       `json:"cursor,omitempty"`
}

// a fully specified regex/replace flow
type RegexReplacement struct {
	Regex string `json:"regex"`
	// the file to apply this replacement on
	File string `json:"file"`
	// template string to replace any match with
	Replacement string `json:"replacement"`
	// Whether to apply liquid templating before compiling this regex
	Templated *bool `json:"templated,omitempty"`
}

// a fully specified regex/replace flow
type RegexReplacementAttributes struct {
	Regex       string `json:"regex"`
	Replacement string `json:"replacement"`
	// the filename to apply this regex on
	File string `json:"file"`
	// whether you want to apply liquid templating on the regex before compiling
	Templated *bool `json:"templated,omitempty"`
}

type ReplicaSet struct {
	Metadata Metadata         `json:"metadata"`
	Spec     ReplicaSetSpec   `json:"spec"`
	Status   ReplicaSetStatus `json:"status"`
	Pods     []*Pod           `json:"pods,omitempty"`
	Raw      string           `json:"raw"`
}

type ReplicaSetSpec struct {
	Replicas *int64 `json:"replicas,omitempty"`
}

type ReplicaSetStatus struct {
	AvailableReplicas    *int64             `json:"availableReplicas,omitempty"`
	Conditions           []*StatusCondition `json:"conditions,omitempty"`
	Replicas             *int64             `json:"replicas,omitempty"`
	ReadyReplicas        *int64             `json:"readyReplicas,omitempty"`
	FullyLabeledReplicas *int64             `json:"fullyLabeledReplicas,omitempty"`
}

type Repository struct {
	ID            string         `json:"id"`
	Name          string         `json:"name"`
	Description   *string        `json:"description,omitempty"`
	Icon          *string        `json:"icon,omitempty"`
	Docs          []*FileContent `json:"docs,omitempty"`
	Configuration *Configuration `json:"configuration,omitempty"`
	GrafanaDNS    *string        `json:"grafanaDns,omitempty"`
}

type RepositoryConnection struct {
	PageInfo PageInfo          `json:"pageInfo"`
	Edges    []*RepositoryEdge `json:"edges,omitempty"`
}

type RepositoryContext struct {
	Repository string                 `json:"repository"`
	Context    map[string]interface{} `json:"context,omitempty"`
}

type RepositoryEdge struct {
	Node   *Repository `json:"node,omitempty"`
	Cursor *string     `json:"cursor,omitempty"`
}

// an edge representing mapping from kubernetes object metadata.uid -> metadata.uid
type ResourceEdge struct {
	From string `json:"from"`
	To   string `json:"to"`
}

// A kubernetes pod container resource request spec
type ResourceRequest struct {
	CPU    *string `json:"cpu,omitempty"`
	Memory *string `json:"memory,omitempty"`
}

type ResourceRequestAttributes struct {
	CPU    *string `json:"cpu,omitempty"`
	Memory *string `json:"memory,omitempty"`
}

type ResourceSelector struct {
	Included []*string `json:"included,omitempty"`
	Excluded []*string `json:"excluded,omitempty"`
}

type ResourceSelectorAttributes struct {
	Included []*string `json:"included,omitempty"`
	Excluded []*string `json:"excluded,omitempty"`
}

type ResourceSpec struct {
	CPU    *string `json:"cpu,omitempty"`
	Memory *string `json:"memory,omitempty"`
}

type Resources struct {
	Limits   *ResourceSpec `json:"limits,omitempty"`
	Requests *ResourceSpec `json:"requests,omitempty"`
}

type RestoreAttributes struct {
	Status RestoreStatus `json:"status"`
}

// a representation of a past revision of a service
type Revision struct {
	// id of this revision
	ID string `json:"id"`
	// the service's semver
	Version string `json:"version"`
	// git spec of the prior revision
	Git *GitRef `json:"git,omitempty"`
	// description of how helm charts should be applied
	Helm *HelmSpec `json:"helm,omitempty"`
	// the sha this service was pulled from
	Sha *string `json:"sha,omitempty"`
	// the commit message for this revision
	Message    *string `json:"message,omitempty"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

type RevisionConnection struct {
	PageInfo PageInfo        `json:"pageInfo"`
	Edges    []*RevisionEdge `json:"edges,omitempty"`
}

type RevisionEdge struct {
	Node   *Revision `json:"node,omitempty"`
	Cursor *string   `json:"cursor,omitempty"`
}

type Role struct {
	ID           string         `json:"id"`
	Name         string         `json:"name"`
	Description  *string        `json:"description,omitempty"`
	Repositories []*string      `json:"repositories,omitempty"`
	Permissions  []*Permission  `json:"permissions,omitempty"`
	RoleBindings []*RoleBinding `json:"roleBindings,omitempty"`
	InsertedAt   *string        `json:"insertedAt,omitempty"`
	UpdatedAt    *string        `json:"updatedAt,omitempty"`
}

type RoleAttributes struct {
	Name         *string              `json:"name,omitempty"`
	Description  *string              `json:"description,omitempty"`
	Repositories []*string            `json:"repositories,omitempty"`
	RoleBindings []*BindingAttributes `json:"roleBindings,omitempty"`
	Permissions  []*Permission        `json:"permissions,omitempty"`
}

type RoleBinding struct {
	ID         string  `json:"id"`
	User       *User   `json:"user,omitempty"`
	Group      *Group  `json:"group,omitempty"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

type RoleConnection struct {
	PageInfo PageInfo    `json:"pageInfo"`
	Edges    []*RoleEdge `json:"edges,omitempty"`
}

type RoleEdge struct {
	Node   *Role   `json:"node,omitempty"`
	Cursor *string `json:"cursor,omitempty"`
}

type RollingUpdate struct {
	MaxSurge       *int64 `json:"maxSurge,omitempty"`
	MaxUnavailable *int64 `json:"maxUnavailable,omitempty"`
}

type RootMutationType struct {
}

type RootQueryType struct {
}

type RootSubscriptionType struct {
}

type RouterFilterAttributes struct {
	// a regex for filtering by things like pr url
	Regex *string `json:"regex,omitempty"`
	// whether to enable delivery for events associated with this service
	ServiceID *string `json:"serviceId,omitempty"`
	// whether to enable delivery for events associated with this cluster
	ClusterID *string `json:"clusterId,omitempty"`
	// whether to enable delivery for events associated with this pipeline
	PipelineID *string `json:"pipelineId,omitempty"`
}

type RouterSinkAttributes struct {
	SinkID string `json:"sinkId"`
}

type RunLogAttributes struct {
	Logs string `json:"logs"`
}

type RunLogs struct {
	ID         string  `json:"id"`
	Logs       string  `json:"logs"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

type RunLogsDelta struct {
	Delta   *Delta   `json:"delta,omitempty"`
	Payload *RunLogs `json:"payload,omitempty"`
}

type RunStep struct {
	ID              string     `json:"id"`
	Status          StepStatus `json:"status"`
	Stage           StepStage  `json:"stage"`
	Name            string     `json:"name"`
	Cmd             string     `json:"cmd"`
	Args            []string   `json:"args,omitempty"`
	RequireApproval *bool      `json:"requireApproval,omitempty"`
	Index           int64      `json:"index"`
	Logs            []*RunLogs `json:"logs,omitempty"`
	InsertedAt      *string    `json:"insertedAt,omitempty"`
	UpdatedAt       *string    `json:"updatedAt,omitempty"`
}

type RunStepAttributes struct {
	Status StepStatus `json:"status"`
}

type Runbook struct {
	Name       string                      `json:"name"`
	Spec       RunbookSpec                 `json:"spec"`
	Status     *RunbookStatus              `json:"status,omitempty"`
	Data       []*RunbookData              `json:"data,omitempty"`
	Executions *RunbookExecutionConnection `json:"executions,omitempty"`
}

type RunbookAction struct {
	Name          string               `json:"name"`
	Type          string               `json:"type"`
	Configuration *ConfigurationAction `json:"configuration,omitempty"`
}

type RunbookActionInput struct {
	Action  string                 `json:"action"`
	Context map[string]interface{} `json:"context"`
}

type RunbookActionResponse struct {
	RedirectTo *string `json:"redirectTo,omitempty"`
}

type RunbookAlertStatus struct {
	Name        string                 `json:"name"`
	StartsAt    *string                `json:"startsAt,omitempty"`
	Fingerprint *string                `json:"fingerprint,omitempty"`
	Annotations map[string]interface{} `json:"annotations,omitempty"`
	Labels      map[string]interface{} `json:"labels,omitempty"`
}

type RunbookContext struct {
	TimeseriesStart *int64  `json:"timeseriesStart,omitempty"`
	TimeseriesStep  *string `json:"timeseriesStep,omitempty"`
}

type RunbookData struct {
	Name       string             `json:"name"`
	Source     *RunbookDatasource `json:"source,omitempty"`
	Kubernetes KubernetesData     `json:"kubernetes,omitempty"`
	Prometheus []*MetricResponse  `json:"prometheus,omitempty"`
	Nodes      []*Node            `json:"nodes,omitempty"`
}

type RunbookDatasource struct {
	Name       string                `json:"name"`
	Type       string                `json:"type"`
	Prometheus *PrometheusDatasource `json:"prometheus,omitempty"`
	Kubernetes *KubernetesDatasource `json:"kubernetes,omitempty"`
}

type RunbookExecution struct {
	ID         string                 `json:"id"`
	Name       string                 `json:"name"`
	Namespace  string                 `json:"namespace"`
	Context    map[string]interface{} `json:"context"`
	User       *User                  `json:"user,omitempty"`
	InsertedAt *string                `json:"insertedAt,omitempty"`
	UpdatedAt  *string                `json:"updatedAt,omitempty"`
}

type RunbookExecutionConnection struct {
	PageInfo PageInfo                `json:"pageInfo"`
	Edges    []*RunbookExecutionEdge `json:"edges,omitempty"`
}

type RunbookExecutionEdge struct {
	Node   *RunbookExecution `json:"node,omitempty"`
	Cursor *string           `json:"cursor,omitempty"`
}

type RunbookSpec struct {
	Name        string                 `json:"name"`
	Description *string                `json:"description,omitempty"`
	Display     map[string]interface{} `json:"display,omitempty"`
	Datasources []*RunbookDatasource   `json:"datasources,omitempty"`
	Actions     []*RunbookAction       `json:"actions,omitempty"`
}

type RunbookStatus struct {
	Alerts []*RunbookAlertStatus `json:"alerts,omitempty"`
}

type RunningState struct {
	StartedAt *string `json:"startedAt,omitempty"`
}

// a full specification of a kubernetes runtime component's requirements
type RuntimeAddon struct {
	// an icon to identify this runtime add-on
	Icon *string `json:"icon,omitempty"`
	// the url to the add-ons git repository
	GitURL *string `json:"gitUrl,omitempty"`
	// the add-on's readme, this is a heavy operation that should not be performed w/in lists
	Readme *string `json:"readme,omitempty"`
	// the release page for a runtime service at a version, this is a heavy operation not suitable for lists
	ReleaseURL *string         `json:"releaseUrl,omitempty"`
	Versions   []*AddonVersion `json:"versions,omitempty"`
}

// a service encapsulating a controller like istio/ingress-nginx/etc that is meant to extend the kubernetes api
type RuntimeService struct {
	ID string `json:"id"`
	// add-on name
	Name string `json:"name"`
	// add-on version, should be semver formatted
	Version string `json:"version"`
	// the number of instances of this service we've detected
	InstanceCount *int64 `json:"instanceCount,omitempty"`
	// the full specification of this kubernetes add-on
	Addon *RuntimeAddon `json:"addon,omitempty"`
	// the version of the add-on you've currently deployed
	AddonVersion *AddonVersion `json:"addonVersion,omitempty"`
	// the plural service it came from
	Service    *ServiceDeployment `json:"service,omitempty"`
	InsertedAt *string            `json:"insertedAt,omitempty"`
	UpdatedAt  *string            `json:"updatedAt,omitempty"`
}

type RuntimeServiceAttributes struct {
	Name    string `json:"name"`
	Version string `json:"version"`
	// the number of instances of this service we've found
	InstanceCount *int64 `json:"instanceCount,omitempty"`
}

type S3Store struct {
	Bucket      string  `json:"bucket"`
	Region      *string `json:"region,omitempty"`
	Endpoint    *string `json:"endpoint,omitempty"`
	AccessKeyID string  `json:"accessKeyId"`
}

type S3StoreAttributes struct {
	Bucket          string  `json:"bucket"`
	Region          *string `json:"region,omitempty"`
	Endpoint        *string `json:"endpoint,omitempty"`
	AccessKeyID     string  `json:"accessKeyId"`
	SecretAccessKey string  `json:"secretAccessKey"`
}

// an object representing the means to connect to SCM apis
type ScmConnection struct {
	ID       string  `json:"id"`
	Name     string  `json:"name"`
	Type     ScmType `json:"type"`
	Default  *bool   `json:"default,omitempty"`
	Username *string `json:"username,omitempty"`
	// base url for git clones for self-hosted versions
	BaseURL *string `json:"baseUrl,omitempty"`
	// base url for HTTP apis for self-hosted versions if different from base url
	APIURL     *string `json:"apiUrl,omitempty"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

// an object representing a means to authenticate to a source control provider like Github
type ScmConnectionAttributes struct {
	Name string  `json:"name"`
	Type ScmType `json:"type"`
	// the owning entity in this scm provider, eg a github organization
	Owner    *string              `json:"owner,omitempty"`
	Username *string              `json:"username,omitempty"`
	Token    *string              `json:"token,omitempty"`
	BaseURL  *string              `json:"baseUrl,omitempty"`
	APIURL   *string              `json:"apiUrl,omitempty"`
	Github   *GithubAppAttributes `json:"github,omitempty"`
	Default  *bool                `json:"default,omitempty"`
	// a ssh private key to be used for commit signing
	SigningPrivateKey *string `json:"signingPrivateKey,omitempty"`
}

type ScmConnectionConnection struct {
	PageInfo PageInfo             `json:"pageInfo"`
	Edges    []*ScmConnectionEdge `json:"edges,omitempty"`
}

type ScmConnectionEdge struct {
	Node   *ScmConnection `json:"node,omitempty"`
	Cursor *string        `json:"cursor,omitempty"`
}

type ScmWebhook struct {
	ID    string  `json:"id"`
	Type  ScmType `json:"type"`
	Owner string  `json:"owner"`
	// the url for this specific webhook
	URL string `json:"url"`
	// the name in your SCM provider for this webhook
	Name       string  `json:"name"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

// The attributes to configure a new webhook for a SCM provider
type ScmWebhookAttributes struct {
	// the secret token for authenticating this webhook via hmac signature
	Hmac string `json:"hmac"`
	// the type of webhook to create
	Type ScmType `json:"type"`
	// the owner for this webhook in your SCM, eg a github org or gitlab group
	Owner string `json:"owner"`
}

type ScmWebhookConnection struct {
	PageInfo PageInfo          `json:"pageInfo"`
	Edges    []*ScmWebhookEdge `json:"edges,omitempty"`
}

type ScmWebhookEdge struct {
	Node   *ScmWebhook `json:"node,omitempty"`
	Cursor *string     `json:"cursor,omitempty"`
}

type ScopeAttributes struct {
	API        *string  `json:"api,omitempty"`
	Apis       []string `json:"apis,omitempty"`
	Identifier *string  `json:"identifier,omitempty"`
	Ids        []string `json:"ids,omitempty"`
}

type Secret struct {
	Metadata Metadata               `json:"metadata"`
	Type     *string                `json:"type,omitempty"`
	Data     map[string]interface{} `json:"data"`
}

type SecretKeySelector struct {
	Name string  `json:"name"`
	Key  *string `json:"key,omitempty"`
}

type Service struct {
	Metadata Metadata      `json:"metadata"`
	Status   ServiceStatus `json:"status"`
	Spec     ServiceSpec   `json:"spec"`
	Pods     []*Pod        `json:"pods,omitempty"`
	Raw      string        `json:"raw"`
	Events   []*Event      `json:"events,omitempty"`
}

type ServiceAccountAttributes struct {
	Name           *string                    `json:"name,omitempty"`
	Email          *string                    `json:"email,omitempty"`
	Roles          *UserRoleAttributes        `json:"roles,omitempty"`
	AssumeBindings []*PolicyBindingAttributes `json:"assumeBindings,omitempty"`
}

type ServiceCloneAttributes struct {
	Name          string              `json:"name"`
	Namespace     *string             `json:"namespace,omitempty"`
	Configuration []*ConfigAttributes `json:"configuration,omitempty"`
}

// representation of a kubernetes component deployed by a service
type ServiceComponent struct {
	// internal id
	ID string `json:"id"`
	// kubernetes component health enum
	State *ComponentState `json:"state,omitempty"`
	// whether this component has been applied to the k8s api
	Synced bool `json:"synced"`
	// api group of this resource
	Group *string `json:"group,omitempty"`
	// api version of this resource
	Version *string `json:"version,omitempty"`
	// api kind of this resource
	Kind string `json:"kind"`
	// kubernetes namespace of this resource
	Namespace *string `json:"namespace,omitempty"`
	// kubernetes name of this resource
	Name string `json:"name"`
	// an insight explaining the state of this component
	Insight *AiInsight `json:"insight,omitempty"`
	// the live and desired states of this service component
	Content *ComponentContent `json:"content,omitempty"`
	// the service this component belongs to
	Service *ServiceDeployment `json:"service,omitempty"`
	// any api deprecations discovered from this component
	APIDeprecations []*APIDeprecation `json:"apiDeprecations,omitempty"`
}

type ServiceComponentMetrics struct {
	CPU    []*MetricResponse `json:"cpu,omitempty"`
	Mem    []*MetricResponse `json:"mem,omitempty"`
	PodCPU []*MetricResponse `json:"podCpu,omitempty"`
	PodMem []*MetricResponse `json:"podMem,omitempty"`
}

// a configuration item k/v pair
type ServiceConfiguration struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

// A reusable bundle of configuration designed to make it easy to communicate between tools like tf/pulumi and k8s
type ServiceContext struct {
	ID            string                  `json:"id"`
	Name          string                  `json:"name"`
	Configuration map[string]interface{}  `json:"configuration,omitempty"`
	Secrets       []*ServiceConfiguration `json:"secrets,omitempty"`
	InsertedAt    *string                 `json:"insertedAt,omitempty"`
	UpdatedAt     *string                 `json:"updatedAt,omitempty"`
}

// A reusable configuration context, useful for plumbing data from external tools like terraform/pulumi/etc
type ServiceContextAttributes struct {
	Configuration *string             `json:"configuration,omitempty"`
	Secrets       []*ConfigAttributes `json:"secrets,omitempty"`
}

// A dependency of a service, the service will not actualize until all dependencies are ready
type ServiceDependency struct {
	ID         string                   `json:"id"`
	Status     *ServiceDeploymentStatus `json:"status,omitempty"`
	Name       string                   `json:"name"`
	InsertedAt *string                  `json:"insertedAt,omitempty"`
	UpdatedAt  *string                  `json:"updatedAt,omitempty"`
}

// A named depedency of a service, will prevent applying any manifests until the dependency has become ready
type ServiceDependencyAttributes struct {
	Name string `json:"name"`
}

// a reference to a service deployed from a git repo into a cluster
type ServiceDeployment struct {
	// internal id of this service
	ID string `json:"id"`
	// human readable name of this service, must be unique per cluster
	Name string `json:"name"`
	// kubernetes namespace this service will be deployed to
	Namespace string `json:"namespace"`
	// A summary status enum for the health of this service
	Status ServiceDeploymentStatus `json:"status"`
	// semver of this service
	Version string `json:"version"`
	// the desired sync interval for this service
	Interval *string `json:"interval,omitempty"`
	// description on where in git the service's manifests should be fetched
	Git *GitRef `json:"git,omitempty"`
	// description of how helm charts should be applied
	Helm *HelmSpec `json:"helm,omitempty"`
	// how you'd like to perform a canary promotion
	Promotion *ServicePromotion `json:"promotion,omitempty"`
	// if you should apply liquid templating to raw yaml files, defaults to true
	Templated *bool `json:"templated,omitempty"`
	// if true, deletion of this service is not allowed
	Protect *bool `json:"protect,omitempty"`
	// latest git sha we pulled from
	Sha *string `json:"sha,omitempty"`
	// https url to fetch the latest tarball of kubernetes manifests
	Tarball *string `json:"tarball,omitempty"`
	// a n / m representation of the number of healthy components of this service
	ComponentStatus *string `json:"componentStatus,omitempty"`
	// settings for advanced tuning of the sync process
	SyncConfig *SyncConfig `json:"syncConfig,omitempty"`
	// kustomize related service metadata
	Kustomize *Kustomize `json:"kustomize,omitempty"`
	// the commit message currently in use
	Message *string `json:"message,omitempty"`
	// the time this service was scheduled for deletion
	DeletedAt *string `json:"deletedAt,omitempty"`
	// whether this service should not actively reconcile state and instead simply report pending changes
	DryRun *bool `json:"dryRun,omitempty"`
	// fetches the /docs directory within this services git tree.  This is a heavy operation and should NOT be used in list queries
	Docs []*GitFile `json:"docs,omitempty"`
	// the git repo of this service
	Repository     *GitRepository      `json:"repository,omitempty"`
	HelmRepository *FluxHelmRepository `json:"helmRepository,omitempty"`
	// Queries logs for a service out of loki
	Logs []*LogStream `json:"logs,omitempty"`
	// read policy for this service
	ReadBindings []*PolicyBinding `json:"readBindings,omitempty"`
	// write policy of this service
	WriteBindings []*PolicyBinding `json:"writeBindings,omitempty"`
	// the service that owns this service in a service-of-services setup
	Parent *ServiceDeployment `json:"parent,omitempty"`
	// a list of errors generated by the deployment operator
	Errors []*ServiceError `json:"errors,omitempty"`
	// the cluster this service is deployed into
	Cluster *Cluster `json:"cluster,omitempty"`
	// the current revision of this service
	Revision *Revision `json:"revision,omitempty"`
	// possibly secret configuration used to template the manifests of this service
	Configuration []*ServiceConfiguration `json:"configuration,omitempty"`
	// the kubernetes component of a service
	Components []*ServiceComponent `json:"components,omitempty"`
	// the global service this service is the source for
	GlobalService *GlobalService `json:"globalService,omitempty"`
	// whether this service is controlled by a global service
	Owner *GlobalService `json:"owner,omitempty"`
	// bound contexts for this service
	Contexts []*ServiceContext `json:"contexts,omitempty"`
	// the dependencies of this service, actualization will not happen until all are HEALTHY
	Dependencies []*ServiceDependency `json:"dependencies,omitempty"`
	// imports from stack outputs
	Imports []*ServiceImport `json:"imports,omitempty"`
	// an insight explaining the state of this service
	Insight *AiInsight `json:"insight,omitempty"`
	// sideload detected vulnerabilities for this service
	Vulns *ServiceVuln `json:"vulns,omitempty"`
	// a relay connection of all revisions of this service, these are periodically pruned up to a history limit
	Revisions *RevisionConnection `json:"revisions,omitempty"`
	// list all alerts discovered for this service
	Alerts           *AlertConnection         `json:"alerts,omitempty"`
	ComponentMetrics *ServiceComponentMetrics `json:"componentMetrics,omitempty"`
	// whether this service is editable
	Editable   *bool   `json:"editable,omitempty"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

type ServiceDeploymentAttributes struct {
	Name         string                `json:"name"`
	Namespace    string                `json:"namespace"`
	Version      *string               `json:"version,omitempty"`
	DocsPath     *string               `json:"docsPath,omitempty"`
	SyncConfig   *SyncConfigAttributes `json:"syncConfig,omitempty"`
	Protect      *bool                 `json:"protect,omitempty"`
	RepositoryID *string               `json:"repositoryId,omitempty"`
	DryRun       *bool                 `json:"dryRun,omitempty"`
	Interval     *string               `json:"interval,omitempty"`
	// if you should apply liquid templating to raw yaml files, defaults to true
	Templated       *bool                          `json:"templated,omitempty"`
	Git             *GitRefAttributes              `json:"git,omitempty"`
	Helm            *HelmConfigAttributes          `json:"helm,omitempty"`
	Kustomize       *KustomizeAttributes           `json:"kustomize,omitempty"`
	ParentID        *string                        `json:"parentId,omitempty"`
	Configuration   []*ConfigAttributes            `json:"configuration,omitempty"`
	Dependencies    []*ServiceDependencyAttributes `json:"dependencies,omitempty"`
	ReadBindings    []*PolicyBindingAttributes     `json:"readBindings,omitempty"`
	WriteBindings   []*PolicyBindingAttributes     `json:"writeBindings,omitempty"`
	ContextBindings []*ContextBindingAttributes    `json:"contextBindings,omitempty"`
	Imports         []*ServiceImportAttributes     `json:"imports,omitempty"`
}

type ServiceDeploymentConnection struct {
	PageInfo PageInfo                 `json:"pageInfo"`
	Edges    []*ServiceDeploymentEdge `json:"edges,omitempty"`
}

type ServiceDeploymentEdge struct {
	Node   *ServiceDeployment `json:"node,omitempty"`
	Cursor *string            `json:"cursor,omitempty"`
}

// an error sent from the deploy operator about sync progress
type ServiceError struct {
	Source  string `json:"source"`
	Message string `json:"message"`
}

type ServiceErrorAttributes struct {
	Source  string `json:"source"`
	Message string `json:"message"`
}

// Import of stack data into a service's context
type ServiceImport struct {
	ID string `json:"id"`
	// The stack you're importing from
	Stack *InfrastructureStack `json:"stack,omitempty"`
	// The outputs of that stack
	Outputs    []*StackOutput `json:"outputs,omitempty"`
	InsertedAt *string        `json:"insertedAt,omitempty"`
	UpdatedAt  *string        `json:"updatedAt,omitempty"`
}

type ServiceImportAttributes struct {
	StackID string `json:"stackId"`
}

type ServicePort struct {
	Name       *string `json:"name,omitempty"`
	Protocol   *string `json:"protocol,omitempty"`
	Port       *int64  `json:"port,omitempty"`
	TargetPort *string `json:"targetPort,omitempty"`
}

type ServiceSpec struct {
	Type      *string                `json:"type,omitempty"`
	ClusterIP *string                `json:"clusterIp,omitempty"`
	Selector  map[string]interface{} `json:"selector,omitempty"`
	Ports     []*ServicePort         `json:"ports,omitempty"`
}

type ServiceStatus struct {
	LoadBalancer *LoadBalancerStatus `json:"loadBalancer,omitempty"`
	Conditions   []*StatusCondition  `json:"conditions,omitempty"`
}

// a rollup count of the statuses of services in a query
type ServiceStatusCount struct {
	Status ServiceDeploymentStatus `json:"status"`
	Count  int64                   `json:"count"`
}

// Attributes for configuring a service in something like a managed namespace
type ServiceTemplate struct {
	// the name for this service (optional for managed namespaces)
	Name *string `json:"name,omitempty"`
	// the namespace for this service (optional for managed namespaces)
	Namespace *string `json:"namespace,omitempty"`
	Templated *bool   `json:"templated,omitempty"`
	// the id of a repository to source manifests for this service
	RepositoryID *string `json:"repositoryId,omitempty"`
	// a list of context ids to add to this service
	Contexts     []*string            `json:"contexts,omitempty"`
	Repository   *GitRepository       `json:"repository,omitempty"`
	Dependencies []*ServiceDependency `json:"dependencies,omitempty"`
	// possibly secret configuration for all spawned services, don't query this in list endpoints
	Configuration []*ServiceConfiguration `json:"configuration,omitempty"`
	// settings to configure git for a service
	Git *GitRef `json:"git,omitempty"`
	// settings to configure helm for a service
	Helm *HelmSpec `json:"helm,omitempty"`
	// settings for service kustomization
	Kustomize *Kustomize `json:"kustomize,omitempty"`
	// specification of how the templated service will be synced
	SyncConfig *SyncConfig `json:"syncConfig,omitempty"`
}

// Attributes for configuring a service in something like a managed namespace
type ServiceTemplateAttributes struct {
	// the name for this service (optional for managed namespaces)
	Name *string `json:"name,omitempty"`
	// the namespace for this service (optional for managed namespaces)
	Namespace *string `json:"namespace,omitempty"`
	Templated *bool   `json:"templated,omitempty"`
	// whether to protect this templated service from deletion
	Protect *bool `json:"protect,omitempty"`
	// the id of a repository to source manifests for this service
	RepositoryID *string `json:"repositoryId,omitempty"`
	// a list of context ids to add to this service
	Contexts []*string `json:"contexts,omitempty"`
	// a list of secure configuration that will be added to any services created by this template
	Configuration []*ConfigAttributes `json:"configuration,omitempty"`
	// dependencies for the service to be spawned
	Dependencies []*ServiceDependencyAttributes `json:"dependencies,omitempty"`
	// settings to configure git for a service
	Git *GitRefAttributes `json:"git,omitempty"`
	// settings to configure helm for a service
	Helm *HelmConfigAttributes `json:"helm,omitempty"`
	// settings for service kustomization
	Kustomize *KustomizeAttributes `json:"kustomize,omitempty"`
	// attributes to configure sync settings for this service
	SyncConfig *SyncConfigAttributes `json:"syncConfig,omitempty"`
}

type ServiceUpdateAttributes struct {
	Version    *string               `json:"version,omitempty"`
	Protect    *bool                 `json:"protect,omitempty"`
	DryRun     *bool                 `json:"dryRun,omitempty"`
	Interval   *string               `json:"interval,omitempty"`
	SyncConfig *SyncConfigAttributes `json:"syncConfig,omitempty"`
	// if you should apply liquid templating to raw yaml files, defaults to true
	Templated       *bool                          `json:"templated,omitempty"`
	Git             *GitRefAttributes              `json:"git,omitempty"`
	Helm            *HelmConfigAttributes          `json:"helm,omitempty"`
	Configuration   []*ConfigAttributes            `json:"configuration,omitempty"`
	Kustomize       *KustomizeAttributes           `json:"kustomize,omitempty"`
	ParentID        *string                        `json:"parentId,omitempty"`
	Dependencies    []*ServiceDependencyAttributes `json:"dependencies,omitempty"`
	ReadBindings    []*PolicyBindingAttributes     `json:"readBindings,omitempty"`
	WriteBindings   []*PolicyBindingAttributes     `json:"writeBindings,omitempty"`
	ContextBindings []*ContextBindingAttributes    `json:"contextBindings,omitempty"`
}

type ServiceVuln struct {
	Service *Service `json:"service,omitempty"`
}

type ServiceVulnAttributes struct {
	ServiceID string `json:"serviceId"`
}

type SharedSecret struct {
	Name       string  `json:"name"`
	Handle     string  `json:"handle"`
	Secret     string  `json:"secret"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

type SharedSecretAttributes struct {
	Name   string `json:"name"`
	Secret string `json:"secret"`
	// the users/groups you want this secret to be delivered to
	NotificationBindings []*PolicyBindingAttributes `json:"notificationBindings,omitempty"`
}

type SinkConfiguration struct {
	ID     string                   `json:"id"`
	Slack  *URLSinkConfiguration    `json:"slack,omitempty"`
	Teams  *URLSinkConfiguration    `json:"teams,omitempty"`
	Plural *PluralSinkConfiguration `json:"plural,omitempty"`
}

type SinkConfigurationAttributes struct {
	Slack  *URLSinkAttributes    `json:"slack,omitempty"`
	Teams  *URLSinkAttributes    `json:"teams,omitempty"`
	Plural *PluralSinkAttributes `json:"plural,omitempty"`
}

type SMTP struct {
	Server   *string `json:"server,omitempty"`
	Port     *int64  `json:"port,omitempty"`
	Password *string `json:"password,omitempty"`
	Sender   *string `json:"sender,omitempty"`
	User     *string `json:"user,omitempty"`
}

type SMTPInput struct {
	Server   *string `json:"server,omitempty"`
	Port     *int64  `json:"port,omitempty"`
	Password *string `json:"password,omitempty"`
	Sender   *string `json:"sender,omitempty"`
	User     *string `json:"user,omitempty"`
}

// SMTP server configuration for email notifications
type SMTPSettings struct {
	Server string `json:"server"`
	Port   int64  `json:"port"`
	Sender string `json:"sender"`
	User   string `json:"user"`
	Ssl    bool   `json:"ssl"`
}

type SMTPSettingsAttributes struct {
	Server   string `json:"server"`
	Port     int64  `json:"port"`
	Sender   string `json:"sender"`
	User     string `json:"user"`
	Password string `json:"password"`
	Ssl      bool   `json:"ssl"`
}

type Stack struct {
	ID         string           `json:"id"`
	Name       string           `json:"name"`
	Bundles    []*Recipe        `json:"bundles,omitempty"`
	Sections   []*RecipeSection `json:"sections,omitempty"`
	InsertedAt *string          `json:"insertedAt,omitempty"`
	UpdatedAt  *string          `json:"updatedAt,omitempty"`
}

type StackAttributes struct {
	// the name of the stack
	Name string `json:"name"`
	// A type for the stack, specifies the tool to use to apply it
	Type StackType `json:"type"`
	// The repository to source IaC from
	RepositoryID string `json:"repositoryId"`
	// The cluster on which the terraform will be applied
	ClusterID string `json:"clusterId"`
	// reference w/in the repository where the IaC lives
	Git GitRefAttributes `json:"git"`
	// optional k8s job configuration for the job that will apply this stack
	JobSpec *GateJobAttributes `json:"jobSpec,omitempty"`
	// version/image config for the tool you're using
	Configuration *StackConfigurationAttributes `json:"configuration,omitempty"`
	// whether to require approval
	Approval *bool `json:"approval,omitempty"`
	// whether you want Plural to manage your terraform state for this stack
	ManageState *bool `json:"manageState,omitempty"`
	// the subdirectory you want to run the stack's commands w/in
	Workdir *string `json:"workdir,omitempty"`
	// user id to use for default Plural authentication in this stack
	ActorID *string `json:"actorId,omitempty"`
	// the project id this stack will belong to
	ProjectID *string `json:"projectId,omitempty"`
	// the parent service this stack was created w/in
	ParentID *string `json:"parentId,omitempty"`
	// id of an scm connection to use for pr callbacks
	ConnectionID *string `json:"connectionId,omitempty"`
	// the id of a stack definition to use
	DefinitionID *string `json:"definitionId,omitempty"`
	// a cron to spawn runs for this stack
	Cron *StackCronAttributes `json:"cron,omitempty"`
	// arbitrary variables to pass into the stack
	Variables         *string                       `json:"variables,omitempty"`
	ReadBindings      []*PolicyBindingAttributes    `json:"readBindings,omitempty"`
	WriteBindings     []*PolicyBindingAttributes    `json:"writeBindings,omitempty"`
	Tags              []*TagAttributes              `json:"tags,omitempty"`
	Files             []*StackFileAttributes        `json:"files,omitempty"`
	Environment       []*StackEnvironmentAttributes `json:"environment,omitempty"`
	ObservableMetrics []*ObservableMetricAttributes `json:"observableMetrics,omitempty"`
}

type StackCommand struct {
	// the executable to call
	Cmd string `json:"cmd"`
	// cli args to pass
	Args []*string `json:"args,omitempty"`
	// working directory for this command (not required)
	Dir *string `json:"dir,omitempty"`
}

type StackConfiguration struct {
	// optional custom image you might want to use
	Image *string `json:"image,omitempty"`
	// the semver of the tool you wish to use
	Version *string `json:"version,omitempty"`
	// the docker image tag you wish to use if you're customizing the version
	Tag *string `json:"tag,omitempty"`
	// the hooks to customize execution for this stack
	Hooks []*StackHook `json:"hooks,omitempty"`
}

type StackConfigurationAttributes struct {
	// optional custom image you might want to use
	Image *string `json:"image,omitempty"`
	// the semver of the tool you wish to use
	Version *string `json:"version,omitempty"`
	// the docker image tag you wish to use if you're customizing the version
	Tag *string `json:"tag,omitempty"`
	// the hooks to customize execution for this stack
	Hooks []*StackHookAttributes `json:"hooks,omitempty"`
}

type StackCron struct {
	// the crontab used to independently spawn runs for this stack
	Crontab string `json:"crontab"`
	// whether you want any cron-derived runs to automatically approve changes
	AutoApprove *bool `json:"autoApprove,omitempty"`
}

type StackCronAttributes struct {
	// the crontab to use for spawning stack runs
	Crontab string `json:"crontab"`
	// whether you want to auto approve any changes spawned by the cron worker
	AutoApprove *bool `json:"autoApprove,omitempty"`
}

type StackDefinition struct {
	ID            string             `json:"id"`
	Name          string             `json:"name"`
	Description   *string            `json:"description,omitempty"`
	Configuration StackConfiguration `json:"configuration"`
	Steps         []*CustomRunStep   `json:"steps,omitempty"`
	InsertedAt    *string            `json:"insertedAt,omitempty"`
	UpdatedAt     *string            `json:"updatedAt,omitempty"`
}

type StackDefinitionAttributes struct {
	Name          string                        `json:"name"`
	Description   *string                       `json:"description,omitempty"`
	Steps         []*CustomStepAttributes       `json:"steps,omitempty"`
	Configuration *StackConfigurationAttributes `json:"configuration,omitempty"`
}

type StackDefinitionConnection struct {
	PageInfo PageInfo               `json:"pageInfo"`
	Edges    []*StackDefinitionEdge `json:"edges,omitempty"`
}

type StackDefinitionEdge struct {
	Node   *StackDefinition `json:"node,omitempty"`
	Cursor *string          `json:"cursor,omitempty"`
}

type StackEnvironment struct {
	Name   string `json:"name"`
	Value  string `json:"value"`
	Secret *bool  `json:"secret,omitempty"`
}

type StackEnvironmentAttributes struct {
	Name   string `json:"name"`
	Value  string `json:"value"`
	Secret *bool  `json:"secret,omitempty"`
}

type StackFile struct {
	Path    string `json:"path"`
	Content string `json:"content"`
}

type StackFileAttributes struct {
	Path    string `json:"path"`
	Content string `json:"content"`
}

type StackHook struct {
	// a script hook to run at a stage
	Cmd string `json:"cmd"`
	// args for `cmd`
	Args []*string `json:"args,omitempty"`
	// the stage to run this hook before
	AfterStage StepStage `json:"afterStage"`
}

type StackHookAttributes struct {
	// a script hook to run at a stage
	Cmd string `json:"cmd"`
	// args for `cmd`
	Args []*string `json:"args,omitempty"`
	// the stage to run this hook before
	AfterStage StepStage `json:"afterStage"`
}

type StackOutput struct {
	Name   string `json:"name"`
	Value  string `json:"value"`
	Secret *bool  `json:"secret,omitempty"`
}

type StackOutputAttributes struct {
	Name   string `json:"name"`
	Value  string `json:"value"`
	Secret *bool  `json:"secret,omitempty"`
}

type StackRun struct {
	ID string `json:"id"`
	// The status of this run
	Status StackStatus `json:"status"`
	// A type for the stack, specifies the tool to use to apply it
	Type StackType `json:"type"`
	// reference w/in the repository where the IaC lives
	Git GitRef `json:"git"`
	// optional k8s job configuration for the job that will apply this stack
	JobSpec *JobGateSpec `json:"jobSpec,omitempty"`
	// version/image config for the tool you're using
	Configuration StackConfiguration `json:"configuration"`
	// whether to require approval
	Approval *bool `json:"approval,omitempty"`
	// the commit message
	Message *string `json:"message,omitempty"`
	// when this run was approved
	ApprovedAt *string `json:"approvedAt,omitempty"`
	// the subdirectory you want to run the stack's commands w/in
	Workdir *string `json:"workdir,omitempty"`
	// whether you want Plural to manage the state of this stack
	ManageState *bool `json:"manageState,omitempty"`
	// Arbitrary variables to add to a stack run
	Variables map[string]interface{} `json:"variables,omitempty"`
	// explanation for why this run was cancelled
	CancellationReason *string    `json:"cancellationReason,omitempty"`
	StateUrls          *StateUrls `json:"stateUrls,omitempty"`
	// the kubernetes job for this run (useful for debugging if issues arise)
	Job *Job `json:"job,omitempty"`
	// temporary plural creds usable for terraform authentication
	PluralCreds *PluralCreds `json:"pluralCreds,omitempty"`
	// https url to fetch the latest tarball of stack IaC
	Tarball string `json:"tarball"`
	// the pull request this stack belongs to
	PullRequest *PullRequest `json:"pullRequest,omitempty"`
	// the approver of this job
	Approver *User `json:"approver,omitempty"`
	// the actor of this run (defaults to root console user)
	Actor *User `json:"actor,omitempty"`
	// The steps to perform when running this stack
	Steps []*RunStep `json:"steps,omitempty"`
	// files bound to a run of this stack
	Files []*StackFile `json:"files,omitempty"`
	// environment variables for this stack
	Environment []*StackEnvironment `json:"environment,omitempty"`
	// the stack attached to this run
	Stack *InfrastructureStack `json:"stack,omitempty"`
	// the most recent output for this stack
	Output []*StackOutput `json:"output,omitempty"`
	// the most recent state of this stack
	State *StackState `json:"state,omitempty"`
	// a list of errors generated by the deployment operator
	Errors []*ServiceError `json:"errors,omitempty"`
	// an insight explaining the state of this stack run
	Insight *AiInsight `json:"insight,omitempty"`
	// the cluster this stack runs on
	Cluster *Cluster `json:"cluster,omitempty"`
	// the git repository you're sourcing IaC from
	Repository *GitRepository `json:"repository,omitempty"`
	InsertedAt *string        `json:"insertedAt,omitempty"`
	UpdatedAt  *string        `json:"updatedAt,omitempty"`
}

type StackRunAttributes struct {
	// The status of this run
	Status StackStatus `json:"status"`
	// the reference to the k8s job running this stack
	JobRef *NamespacedName `json:"jobRef,omitempty"`
	// The state from this runs plan or apply
	State *StackStateAttributes `json:"state,omitempty"`
	// Output generated by this run
	Output []*StackOutputAttributes `json:"output,omitempty"`
	// Any errors detected when trying to run this stack
	Errors []*ServiceErrorAttributes `json:"errors,omitempty"`
	// Why you decided to cancel this run
	CancellationReason *string `json:"cancellationReason,omitempty"`
}

type StackRunConnection struct {
	PageInfo PageInfo        `json:"pageInfo"`
	Edges    []*StackRunEdge `json:"edges,omitempty"`
}

type StackRunEdge struct {
	Node   *StackRun `json:"node,omitempty"`
	Cursor *string   `json:"cursor,omitempty"`
}

type StackSettings struct {
	JobSpec      *JobGateSpec `json:"jobSpec,omitempty"`
	ConnectionID *string      `json:"connectionId,omitempty"`
}

type StackSettingsAttributes struct {
	JobSpec      *GateJobAttributes `json:"jobSpec,omitempty"`
	ConnectionID *string            `json:"connectionId,omitempty"`
}

type StackState struct {
	ID    string                `json:"id"`
	Plan  *string               `json:"plan,omitempty"`
	State []*StackStateResource `json:"state,omitempty"`
	// an insight explaining the state of this stack state, eg the terraform plan it represents
	Insight    *AiInsight `json:"insight,omitempty"`
	InsertedAt *string    `json:"insertedAt,omitempty"`
	UpdatedAt  *string    `json:"updatedAt,omitempty"`
}

type StackStateAttributes struct {
	Plan  *string                         `json:"plan,omitempty"`
	State []*StackStateResourceAttributes `json:"state,omitempty"`
}

type StackStateResource struct {
	// a string identifier for this resource, different tools will have different conventions
	Identifier string `json:"identifier"`
	// a string name of the resource type
	Resource string `json:"resource"`
	// the name of the resource within that type
	Name string `json:"name"`
	// arbitrary configuration used to create the resource
	Configuration map[string]interface{} `json:"configuration,omitempty"`
	// identifiers this resource is linked to for graphing in the UI
	Links []*string `json:"links,omitempty"`
}

type StackStateResourceAttributes struct {
	// a string identifier for this resource, different tools will have different conventions
	Identifier string `json:"identifier"`
	// a string name of the resource type
	Resource string `json:"resource"`
	// the name of the resource within that type
	Name string `json:"name"`
	// arbitrary configuration used to create the resource
	Configuration *string `json:"configuration,omitempty"`
	// identifiers this resource is linked to for graphing in the UI
	Links []*string `json:"links,omitempty"`
}

// the configuration of a service within a pipeline stage, including optional promotion criteria
type StageService struct {
	ID string `json:"id"`
	// a pointer to a service
	Service *ServiceDeployment `json:"service,omitempty"`
	// criteria for how a promotion of this service shall be performed
	Criteria   *PromotionCriteria `json:"criteria,omitempty"`
	InsertedAt *string            `json:"insertedAt,omitempty"`
	UpdatedAt  *string            `json:"updatedAt,omitempty"`
}

// the attributes of a service w/in a specific stage
type StageServiceAttributes struct {
	// the cluster handle of this service
	Handle *string `json:"handle,omitempty"`
	// the name of this service
	Name *string `json:"name,omitempty"`
	// the name of this service
	ServiceID *string                      `json:"serviceId,omitempty"`
	Criteria  *PromotionCriteriaAttributes `json:"criteria,omitempty"`
}

// grab-bag of state configuration urls for supported tools
type StateUrls struct {
	Terraform *TerraformStateUrls `json:"terraform,omitempty"`
}

type StatefulSet struct {
	Metadata Metadata          `json:"metadata"`
	Status   StatefulSetStatus `json:"status"`
	Spec     StatefulSetSpec   `json:"spec"`
	Pods     []*Pod            `json:"pods,omitempty"`
	Raw      string            `json:"raw"`
	Events   []*Event          `json:"events,omitempty"`
}

func (StatefulSet) IsKubernetesData() {}

type StatefulSetSpec struct {
	Replicas    *int64  `json:"replicas,omitempty"`
	ServiceName *string `json:"serviceName,omitempty"`
}

type StatefulSetStatus struct {
	CurrentReplicas *int64             `json:"currentReplicas,omitempty"`
	Replicas        *int64             `json:"replicas,omitempty"`
	ReadyReplicas   *int64             `json:"readyReplicas,omitempty"`
	UpdatedReplicas *int64             `json:"updatedReplicas,omitempty"`
	Conditions      []*StatusCondition `json:"conditions,omitempty"`
}

type StatusComponent struct {
	Group  *string `json:"group,omitempty"`
	Kind   string  `json:"kind"`
	Name   string  `json:"name"`
	Status string  `json:"status"`
}

type StatusCondition struct {
	Message string `json:"message"`
	Reason  string `json:"reason"`
	Status  string `json:"status"`
	Type    string `json:"type"`
}

// Advanced configuration of how to sync resources
type SyncConfig struct {
	// whether the agent should auto-create the namespace for this service
	CreateNamespace *bool `json:"createNamespace,omitempty"`
	// Whether to require all resources are placed in the same namespace
	EnforceNamespace  *bool              `json:"enforceNamespace,omitempty"`
	NamespaceMetadata *NamespaceMetadata `json:"namespaceMetadata,omitempty"`
}

type SyncConfigAttributes struct {
	CreateNamespace   *bool               `json:"createNamespace,omitempty"`
	EnforceNamespace  *bool               `json:"enforceNamespace,omitempty"`
	NamespaceMetadata *MetadataAttributes `json:"namespaceMetadata,omitempty"`
}

type Tag struct {
	ID    string `json:"id"`
	Name  string `json:"name"`
	Value string `json:"value"`
}

type TagAttributes struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

type TagConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []*TagEdge `json:"edges,omitempty"`
}

type TagEdge struct {
	Node   *Tag    `json:"node,omitempty"`
	Cursor *string `json:"cursor,omitempty"`
}

type TagInput struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

type TagQuery struct {
	Op   Conjunction `json:"op"`
	Tags []*TagInput `json:"tags,omitempty"`
}

// a kubernetes node taint
type Taint struct {
	Key    string `json:"key"`
	Value  string `json:"value"`
	Effect string `json:"effect"`
}

type TaintAttributes struct {
	Key    string `json:"key"`
	Value  string `json:"value"`
	Effect string `json:"effect"`
}

type TargetRef struct {
	APIVersion *string `json:"apiVersion,omitempty"`
	Kind       *string `json:"kind,omitempty"`
	Name       *string `json:"name,omitempty"`
}

type TerminatedState struct {
	ExitCode   *int64  `json:"exitCode,omitempty"`
	FinishedAt *string `json:"finishedAt,omitempty"`
	StartedAt  *string `json:"startedAt,omitempty"`
	Message    *string `json:"message,omitempty"`
	Reason     *string `json:"reason,omitempty"`
}

// Urls for configuring terraform HTTP remote state
type TerraformStateUrls struct {
	// GET and POST urls for uploadnig state
	Address *string `json:"address,omitempty"`
	// POST url to lock state
	Lock *string `json:"lock,omitempty"`
	// POST url to unlock state
	Unlock *string `json:"unlock,omitempty"`
}

type ToolConfigAttributes struct {
	CreatePr *CreatePrConfigAttributes `json:"createPr,omitempty"`
}

// How to enforce uniqueness for a field
type UniqByAttributes struct {
	// the scope this name is uniq w/in
	Scope ValidationUniqScope `json:"scope"`
}

type UpgradeInsight struct {
	ID   string `json:"id"`
	Name string `json:"name"`
	// the k8s version this insight applies to
	Version *string `json:"version,omitempty"`
	// longform description of this insight
	Description    *string                 `json:"description,omitempty"`
	Status         *UpgradeInsightStatus   `json:"status,omitempty"`
	RefreshedAt    *string                 `json:"refreshedAt,omitempty"`
	TransitionedAt *string                 `json:"transitionedAt,omitempty"`
	Details        []*UpgradeInsightDetail `json:"details,omitempty"`
	InsertedAt     *string                 `json:"insertedAt,omitempty"`
	UpdatedAt      *string                 `json:"updatedAt,omitempty"`
}

type UpgradeInsightAttributes struct {
	Name string `json:"name"`
	// the k8s version this insight applies to
	Version *string `json:"version,omitempty"`
	// longform description of this insight
	Description    *string                           `json:"description,omitempty"`
	Status         *UpgradeInsightStatus             `json:"status,omitempty"`
	RefreshedAt    *string                           `json:"refreshedAt,omitempty"`
	TransitionedAt *string                           `json:"transitionedAt,omitempty"`
	Details        []*UpgradeInsightDetailAttributes `json:"details,omitempty"`
}

type UpgradeInsightDetail struct {
	ID     string                `json:"id"`
	Status *UpgradeInsightStatus `json:"status,omitempty"`
	// a possibly deprecated API
	Used *string `json:"used,omitempty"`
	// the replacement for this API
	Replacement *string `json:"replacement,omitempty"`
	// information about the HTTP clients triggering this insight
	ClientInfo []*InsightClientInfo `json:"clientInfo,omitempty"`
	ReplacedIn *string              `json:"replacedIn,omitempty"`
	RemovedIn  *string              `json:"removedIn,omitempty"`
	LastUsedAt *string              `json:"lastUsedAt,omitempty"`
	InsertedAt *string              `json:"insertedAt,omitempty"`
	UpdatedAt  *string              `json:"updatedAt,omitempty"`
}

type UpgradeInsightDetailAttributes struct {
	Status *UpgradeInsightStatus `json:"status,omitempty"`
	// a possibly deprecated API
	Used *string `json:"used,omitempty"`
	// the replacement for this API
	Replacement *string `json:"replacement,omitempty"`
	// descriptions of the HTTP clients triggering this insight
	ClientInfo []*InsightClientInfoAttributes `json:"clientInfo,omitempty"`
	ReplacedIn *string                        `json:"replacedIn,omitempty"`
	RemovedIn  *string                        `json:"removedIn,omitempty"`
	// the latest timestamp this insight has been observed
	LastUsedAt *string `json:"lastUsedAt,omitempty"`
}

type UpgradePlan struct {
	Metadata Metadata          `json:"metadata"`
	Status   UpgradePlanStatus `json:"status"`
	Spec     UpgradePlanSpec   `json:"spec"`
	Pods     []*Pod            `json:"pods,omitempty"`
	Raw      string            `json:"raw"`
	Events   []*Event          `json:"events,omitempty"`
}

type UpgradePlanAttributes struct {
	// whether all compatibilities for a cluster upgrade have been cleared
	Compatibilities *bool `json:"compatibilities,omitempty"`
	// whether all incompatibilities w/in runtime components have been cleared
	Incompatibilities *bool `json:"incompatibilities,omitempty"`
	// whether all deprecated apis for a cluster have been cleared
	Deprecations *bool `json:"deprecations,omitempty"`
}

type UpgradePlanSpec struct {
	Version     *string `json:"version,omitempty"`
	Cordon      *bool   `json:"cordon,omitempty"`
	Concurrency *int64  `json:"concurrency,omitempty"`
}

type UpgradePlanStatus struct {
	Conditions []*StatusCondition `json:"conditions,omitempty"`
}

type UpgradePolicy struct {
	ID           string            `json:"id"`
	Name         string            `json:"name"`
	Description  *string           `json:"description,omitempty"`
	Repositories []*string         `json:"repositories,omitempty"`
	Type         UpgradePolicyType `json:"type"`
	Target       string            `json:"target"`
	Weight       *int64            `json:"weight,omitempty"`
	InsertedAt   *string           `json:"insertedAt,omitempty"`
	UpdatedAt    *string           `json:"updatedAt,omitempty"`
}

type UpgradePolicyAttributes struct {
	Name         string            `json:"name"`
	Description  *string           `json:"description,omitempty"`
	Target       string            `json:"target"`
	Type         UpgradePolicyType `json:"type"`
	Repositories []*string         `json:"repositories,omitempty"`
	Weight       *int64            `json:"weight,omitempty"`
}

// Summary statistics of the upgradeability of your fleet
type UpgradeStatistics struct {
	// total number of clusters
	Count *int64 `json:"count,omitempty"`
	// the number of clusters currently upgradeable
	Upgradeable *int64 `json:"upgradeable,omitempty"`
	// the number of clusters currently at the latest version
	Latest *int64 `json:"latest,omitempty"`
	// the number of clusters compliant w/ your versioning policy
	Compliant *int64 `json:"compliant,omitempty"`
}

type URLSinkAttributes struct {
	URL string `json:"url"`
}

// A notification sink based off slack incoming webhook urls
type URLSinkConfiguration struct {
	// incoming webhook url to deliver to
	URL string `json:"url"`
}

type User struct {
	ID                  string           `json:"id"`
	Name                string           `json:"name"`
	Email               string           `json:"email"`
	DeletedAt           *string          `json:"deletedAt,omitempty"`
	Profile             *string          `json:"profile,omitempty"`
	PluralID            *string          `json:"pluralId,omitempty"`
	Roles               *UserRoles       `json:"roles,omitempty"`
	EmailSettings       *EmailSettings   `json:"emailSettings,omitempty"`
	ReadTimestamp       *string          `json:"readTimestamp,omitempty"`
	BuildTimestamp      *string          `json:"buildTimestamp,omitempty"`
	RefreshToken        *RefreshToken    `json:"refreshToken,omitempty"`
	AssumeBindings      []*PolicyBinding `json:"assumeBindings,omitempty"`
	Groups              []*Group         `json:"groups,omitempty"`
	Personas            []*Persona       `json:"personas,omitempty"`
	BoundRoles          []*Role          `json:"boundRoles,omitempty"`
	Jwt                 *string          `json:"jwt,omitempty"`
	UnreadNotifications *int64           `json:"unreadNotifications,omitempty"`
	BackgroundColor     *string          `json:"backgroundColor,omitempty"`
	InsertedAt          *string          `json:"insertedAt,omitempty"`
	UpdatedAt           *string          `json:"updatedAt,omitempty"`
}

type UserAttributes struct {
	Name              *string                  `json:"name,omitempty"`
	Email             *string                  `json:"email,omitempty"`
	Password          *string                  `json:"password,omitempty"`
	Roles             *UserRoleAttributes      `json:"roles,omitempty"`
	EmailSettings     *EmailSettingsAttributes `json:"emailSettings,omitempty"`
	SigningPrivateKey *string                  `json:"signingPrivateKey,omitempty"`
}

type UserConnection struct {
	PageInfo PageInfo    `json:"pageInfo"`
	Edges    []*UserEdge `json:"edges,omitempty"`
}

type UserEdge struct {
	Node   *User   `json:"node,omitempty"`
	Cursor *string `json:"cursor,omitempty"`
}

type UserRoleAttributes struct {
	Admin *bool `json:"admin,omitempty"`
}

type UserRoles struct {
	Admin *bool `json:"admin,omitempty"`
}

// a shortform reference to an addon by version
type VersionReference struct {
	Name    string `json:"name"`
	Version string `json:"version"`
}

type VertexAiAttributes struct {
	// the vertex model id to use
	Model *string `json:"model,omitempty"`
	// optional service account json to auth to the GCP vertex apis
	ServiceAccountJSON *string `json:"serviceAccountJson,omitempty"`
	// custom vertexai endpoint if for dedicated customer deployments
	Endpoint *string `json:"endpoint,omitempty"`
	// the gcp project id to use
	Project string `json:"project"`
	// the gcp region the model is hosted in
	Location string `json:"location"`
}

// Settings for usage of GCP VertexAI for LLMs
type VertexAiSettings struct {
	// the vertex ai model to use
	Model *string `json:"model,omitempty"`
	// the gcp project id to use
	Project string `json:"project"`
	// the gcp region the model
	Location string `json:"location"`
}

type VerticalPodAutoscaler struct {
	Metadata Metadata                     `json:"metadata"`
	Spec     VerticalPodAutoscalerSpec    `json:"spec"`
	Status   *VerticalPodAutoscalerStatus `json:"status,omitempty"`
}

type VerticalPodAutoscalerSpec struct {
	TargetRef    CrossVersionResourceTarget        `json:"targetRef"`
	UpdatePolicy VerticalPodAutoscalerUpdatePolicy `json:"updatePolicy"`
}

type VerticalPodAutoscalerStatus struct {
	Recommendation *Recommendation `json:"recommendation,omitempty"`
}

type VerticalPodAutoscalerUpdatePolicy struct {
	UpdateMode *string `json:"updateMode,omitempty"`
}

// A violation of a given OPA Gatekeeper constraint
type Violation struct {
	ID         string  `json:"id"`
	Group      *string `json:"group,omitempty"`
	Version    *string `json:"version,omitempty"`
	Kind       *string `json:"kind,omitempty"`
	Namespace  *string `json:"namespace,omitempty"`
	Name       *string `json:"name,omitempty"`
	Message    *string `json:"message,omitempty"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

type ViolationAttributes struct {
	Group     *string `json:"group,omitempty"`
	Version   *string `json:"version,omitempty"`
	Kind      *string `json:"kind,omitempty"`
	Namespace *string `json:"namespace,omitempty"`
	Name      *string `json:"name,omitempty"`
	Message   *string `json:"message,omitempty"`
}

// A summary of statistics for violations w/in a specific column
type ViolationStatistic struct {
	// the value of this field being aggregated
	Value *string `json:"value,omitempty"`
	// the total number of violations found
	Violations *int64 `json:"violations,omitempty"`
	// the total number of policy constraints
	Count *int64 `json:"count,omitempty"`
}

type VulnArtifact struct {
	Registry   *string `json:"registry,omitempty"`
	Repository *string `json:"repository,omitempty"`
	Digest     *string `json:"digest,omitempty"`
	Tag        *string `json:"tag,omitempty"`
	Mime       *string `json:"mime,omitempty"`
}

type VulnArtifactAttributes struct {
	Registry   *string `json:"registry,omitempty"`
	Repository *string `json:"repository,omitempty"`
	Digest     *string `json:"digest,omitempty"`
	Tag        *string `json:"tag,omitempty"`
	Mime       *string `json:"mime,omitempty"`
}

type VulnOs struct {
	Eosl   *bool   `json:"eosl,omitempty"`
	Family *string `json:"family,omitempty"`
	Name   *string `json:"name,omitempty"`
}

type VulnOsAttributes struct {
	Eosl   *bool   `json:"eosl,omitempty"`
	Family *string `json:"family,omitempty"`
	Name   *string `json:"name,omitempty"`
}

type VulnSummary struct {
	CriticalCount *int64 `json:"criticalCount,omitempty"`
	HighCount     *int64 `json:"highCount,omitempty"`
	MediumCount   *int64 `json:"mediumCount,omitempty"`
	LowCount      *int64 `json:"lowCount,omitempty"`
	UnknownCount  *int64 `json:"unknownCount,omitempty"`
	NoneCount     *int64 `json:"noneCount,omitempty"`
}

type VulnSummaryAttributes struct {
	CriticalCount *int64 `json:"criticalCount,omitempty"`
	HighCount     *int64 `json:"highCount,omitempty"`
	MediumCount   *int64 `json:"mediumCount,omitempty"`
	LowCount      *int64 `json:"lowCount,omitempty"`
	UnknownCount  *int64 `json:"unknownCount,omitempty"`
	NoneCount     *int64 `json:"noneCount,omitempty"`
}

type Vulnerability struct {
	ID               string        `json:"id"`
	Resource         *string       `json:"resource,omitempty"`
	FixedVersion     *string       `json:"fixedVersion,omitempty"`
	InstalledVersion *string       `json:"installedVersion,omitempty"`
	Severity         *VulnSeverity `json:"severity,omitempty"`
	Score            *float64      `json:"score,omitempty"`
	Title            *string       `json:"title,omitempty"`
	Description      *string       `json:"description,omitempty"`
	CvssSource       *string       `json:"cvssSource,omitempty"`
	PrimaryLink      *string       `json:"primaryLink,omitempty"`
	Links            []*string     `json:"links,omitempty"`
	Target           *string       `json:"target,omitempty"`
	Class            *string       `json:"class,omitempty"`
	PackageType      *string       `json:"packageType,omitempty"`
	PkgPath          *string       `json:"pkgPath,omitempty"`
	PublishedDate    *string       `json:"publishedDate,omitempty"`
	LastModifiedDate *string       `json:"lastModifiedDate,omitempty"`
	Cvss             *Cvss         `json:"cvss,omitempty"`
	InsertedAt       *string       `json:"insertedAt,omitempty"`
	UpdatedAt        *string       `json:"updatedAt,omitempty"`
}

type VulnerabilityAttributes struct {
	Resource         *string         `json:"resource,omitempty"`
	FixedVersion     *string         `json:"fixedVersion,omitempty"`
	InstalledVersion *string         `json:"installedVersion,omitempty"`
	Severity         *VulnSeverity   `json:"severity,omitempty"`
	Score            *float64        `json:"score,omitempty"`
	Title            *string         `json:"title,omitempty"`
	Description      *string         `json:"description,omitempty"`
	CvssSource       *string         `json:"cvssSource,omitempty"`
	PrimaryLink      *string         `json:"primaryLink,omitempty"`
	Links            []*string       `json:"links,omitempty"`
	Target           *string         `json:"target,omitempty"`
	Class            *string         `json:"class,omitempty"`
	PackageType      *string         `json:"packageType,omitempty"`
	PkgPath          *string         `json:"pkgPath,omitempty"`
	PublishedDate    *string         `json:"publishedDate,omitempty"`
	LastModifiedDate *string         `json:"lastModifiedDate,omitempty"`
	Cvss             *CvssAttributes `json:"cvss,omitempty"`
}

type VulnerabilityReport struct {
	ID              string           `json:"id"`
	ArtifactURL     *string          `json:"artifactUrl,omitempty"`
	Os              *VulnOs          `json:"os,omitempty"`
	Summary         *VulnSummary     `json:"summary,omitempty"`
	Artifact        *VulnArtifact    `json:"artifact,omitempty"`
	Vulnerabilities []*Vulnerability `json:"vulnerabilities,omitempty"`
	Services        []*ServiceVuln   `json:"services,omitempty"`
	Namespaces      []*NamespaceVuln `json:"namespaces,omitempty"`
	InsertedAt      *string          `json:"insertedAt,omitempty"`
	UpdatedAt       *string          `json:"updatedAt,omitempty"`
}

type VulnerabilityReportAttributes struct {
	ArtifactURL     *string                    `json:"artifactUrl,omitempty"`
	Os              *VulnOsAttributes          `json:"os,omitempty"`
	Summary         *VulnSummaryAttributes     `json:"summary,omitempty"`
	Artifact        *VulnArtifactAttributes    `json:"artifact,omitempty"`
	Vulnerabilities []*VulnerabilityAttributes `json:"vulnerabilities,omitempty"`
	Services        []*ServiceVulnAttributes   `json:"services,omitempty"`
	Namespaces      []*NamespaceVulnAttributes `json:"namespaces,omitempty"`
}

type VulnerabilityReportConnection struct {
	PageInfo PageInfo                   `json:"pageInfo"`
	Edges    []*VulnerabilityReportEdge `json:"edges,omitempty"`
}

type VulnerabilityReportEdge struct {
	Node   *VulnerabilityReport `json:"node,omitempty"`
	Cursor *string              `json:"cursor,omitempty"`
}

type WaitingState struct {
	Message *string `json:"message,omitempty"`
	Reason  *string `json:"reason,omitempty"`
}

type Webhook struct {
	ID         string        `json:"id"`
	URL        string        `json:"url"`
	Health     WebhookHealth `json:"health"`
	Type       WebhookType   `json:"type"`
	InsertedAt *string       `json:"insertedAt,omitempty"`
	UpdatedAt  *string       `json:"updatedAt,omitempty"`
}

type WebhookAttributes struct {
	URL string `json:"url"`
}

type WebhookConnection struct {
	PageInfo PageInfo       `json:"pageInfo"`
	Edges    []*WebhookEdge `json:"edges,omitempty"`
}

type WebhookEdge struct {
	Node   *Webhook `json:"node,omitempty"`
	Cursor *string  `json:"cursor,omitempty"`
}

type WireguardPeer struct {
	Metadata Metadata             `json:"metadata"`
	Status   *WireguardPeerStatus `json:"status,omitempty"`
	Spec     WireguardPeerSpec    `json:"spec"`
	Config   *string              `json:"config,omitempty"`
	User     *User                `json:"user,omitempty"`
	Raw      string               `json:"raw"`
}

type WireguardPeerSpec struct {
	WireguardRef *string `json:"wireguardRef,omitempty"`
	Address      *string `json:"address,omitempty"`
	PublicKey    *string `json:"publicKey,omitempty"`
}

type WireguardPeerStatus struct {
	Ready      *bool              `json:"ready,omitempty"`
	Conditions []*StatusCondition `json:"conditions,omitempty"`
}

// a description of a yaml-merge operation on a file
type YamlOverlay struct {
	Yaml string `json:"yaml"`
	// the filename to apply this yaml overlay on
	File string `json:"file"`
	// whether you want to apply liquid templating on the yaml before compiling
	Templated *bool `json:"templated,omitempty"`
	// configure how list merge should be performed
	ListMerge *ListMerge `json:"listMerge,omitempty"`
}

// a description of a yaml-merge operation on a file
type YamlOverlayAttributes struct {
	// the filename to apply this yaml overlay on
	File string `json:"file"`
	Yaml string `json:"yaml"`
	// configure how list merge should be performed
	ListMerge *ListMerge `json:"listMerge,omitempty"`
	// whether you want to apply liquid templating on the yaml before compiling
	Templated *bool `json:"templated,omitempty"`
}

type AiProvider string

const (
	AiProviderOpenai    AiProvider = "OPENAI"
	AiProviderAnthropic AiProvider = "ANTHROPIC"
	AiProviderOllama    AiProvider = "OLLAMA"
	AiProviderAzure     AiProvider = "AZURE"
	AiProviderBedrock   AiProvider = "BEDROCK"
	AiProviderVertex    AiProvider = "VERTEX"
)

var AllAiProvider = []AiProvider{
	AiProviderOpenai,
	AiProviderAnthropic,
	AiProviderOllama,
	AiProviderAzure,
	AiProviderBedrock,
	AiProviderVertex,
}

func (e AiProvider) IsValid() bool {
	switch e {
	case AiProviderOpenai, AiProviderAnthropic, AiProviderOllama, AiProviderAzure, AiProviderBedrock, AiProviderVertex:
		return true
	}
	return false
}

func (e AiProvider) String() string {
	return string(e)
}

func (e *AiProvider) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AiProvider(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AiProvider", str)
	}
	return nil
}

func (e AiProvider) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// A role to pass to an LLM, modeled after OpenAI's chat api roles
type AiRole string

const (
	AiRoleSystem    AiRole = "SYSTEM"
	AiRoleAssistant AiRole = "ASSISTANT"
	AiRoleUser      AiRole = "USER"
)

var AllAiRole = []AiRole{
	AiRoleSystem,
	AiRoleAssistant,
	AiRoleUser,
}

func (e AiRole) IsValid() bool {
	switch e {
	case AiRoleSystem, AiRoleAssistant, AiRoleUser:
		return true
	}
	return false
}

func (e AiRole) String() string {
	return string(e)
}

func (e *AiRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AiRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AiRole", str)
	}
	return nil
}

func (e AiRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AlertSeverity string

const (
	AlertSeverityLow       AlertSeverity = "LOW"
	AlertSeverityMedium    AlertSeverity = "MEDIUM"
	AlertSeverityHigh      AlertSeverity = "HIGH"
	AlertSeverityCritical  AlertSeverity = "CRITICAL"
	AlertSeverityUndefined AlertSeverity = "UNDEFINED"
)

var AllAlertSeverity = []AlertSeverity{
	AlertSeverityLow,
	AlertSeverityMedium,
	AlertSeverityHigh,
	AlertSeverityCritical,
	AlertSeverityUndefined,
}

func (e AlertSeverity) IsValid() bool {
	switch e {
	case AlertSeverityLow, AlertSeverityMedium, AlertSeverityHigh, AlertSeverityCritical, AlertSeverityUndefined:
		return true
	}
	return false
}

func (e AlertSeverity) String() string {
	return string(e)
}

func (e *AlertSeverity) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlertSeverity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlertSeverity", str)
	}
	return nil
}

func (e AlertSeverity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AlertState string

const (
	AlertStateFiring   AlertState = "FIRING"
	AlertStateResolved AlertState = "RESOLVED"
)

var AllAlertState = []AlertState{
	AlertStateFiring,
	AlertStateResolved,
}

func (e AlertState) IsValid() bool {
	switch e {
	case AlertStateFiring, AlertStateResolved:
		return true
	}
	return false
}

func (e AlertState) String() string {
	return string(e)
}

func (e *AlertState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlertState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlertState", str)
	}
	return nil
}

func (e AlertState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AuditAction string

const (
	AuditActionCreate  AuditAction = "CREATE"
	AuditActionUpdate  AuditAction = "UPDATE"
	AuditActionDelete  AuditAction = "DELETE"
	AuditActionApprove AuditAction = "APPROVE"
	AuditActionCancel  AuditAction = "CANCEL"
)

var AllAuditAction = []AuditAction{
	AuditActionCreate,
	AuditActionUpdate,
	AuditActionDelete,
	AuditActionApprove,
	AuditActionCancel,
}

func (e AuditAction) IsValid() bool {
	switch e {
	case AuditActionCreate, AuditActionUpdate, AuditActionDelete, AuditActionApprove, AuditActionCancel:
		return true
	}
	return false
}

func (e AuditAction) String() string {
	return string(e)
}

func (e *AuditAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuditAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuditAction", str)
	}
	return nil
}

func (e AuditAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AuditType string

const (
	AuditTypeBuild              AuditType = "BUILD"
	AuditTypePod                AuditType = "POD"
	AuditTypeConfiguration      AuditType = "CONFIGURATION"
	AuditTypeUser               AuditType = "USER"
	AuditTypeGroup              AuditType = "GROUP"
	AuditTypeRole               AuditType = "ROLE"
	AuditTypeGroupMember        AuditType = "GROUP_MEMBER"
	AuditTypePolicy             AuditType = "POLICY"
	AuditTypeTempToken          AuditType = "TEMP_TOKEN"
	AuditTypeService            AuditType = "SERVICE"
	AuditTypeCluster            AuditType = "CLUSTER"
	AuditTypeClusterProvider    AuditType = "CLUSTER_PROVIDER"
	AuditTypeGitRepository      AuditType = "GIT_REPOSITORY"
	AuditTypeDeploymentSettings AuditType = "DEPLOYMENT_SETTINGS"
	AuditTypeProviderCredential AuditType = "PROVIDER_CREDENTIAL"
	AuditTypePipeline           AuditType = "PIPELINE"
	AuditTypeGlobal             AuditType = "GLOBAL"
	AuditTypeObjectStore        AuditType = "OBJECT_STORE"
	AuditTypeClusterRestore     AuditType = "CLUSTER_RESTORE"
)

var AllAuditType = []AuditType{
	AuditTypeBuild,
	AuditTypePod,
	AuditTypeConfiguration,
	AuditTypeUser,
	AuditTypeGroup,
	AuditTypeRole,
	AuditTypeGroupMember,
	AuditTypePolicy,
	AuditTypeTempToken,
	AuditTypeService,
	AuditTypeCluster,
	AuditTypeClusterProvider,
	AuditTypeGitRepository,
	AuditTypeDeploymentSettings,
	AuditTypeProviderCredential,
	AuditTypePipeline,
	AuditTypeGlobal,
	AuditTypeObjectStore,
	AuditTypeClusterRestore,
}

func (e AuditType) IsValid() bool {
	switch e {
	case AuditTypeBuild, AuditTypePod, AuditTypeConfiguration, AuditTypeUser, AuditTypeGroup, AuditTypeRole, AuditTypeGroupMember, AuditTypePolicy, AuditTypeTempToken, AuditTypeService, AuditTypeCluster, AuditTypeClusterProvider, AuditTypeGitRepository, AuditTypeDeploymentSettings, AuditTypeProviderCredential, AuditTypePipeline, AuditTypeGlobal, AuditTypeObjectStore, AuditTypeClusterRestore:
		return true
	}
	return false
}

func (e AuditType) String() string {
	return string(e)
}

func (e *AuditType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuditType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuditType", str)
	}
	return nil
}

func (e AuditType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AuthMethod string

const (
	AuthMethodBasic AuthMethod = "BASIC"
	AuthMethodSSH   AuthMethod = "SSH"
)

var AllAuthMethod = []AuthMethod{
	AuthMethodBasic,
	AuthMethodSSH,
}

func (e AuthMethod) IsValid() bool {
	switch e {
	case AuthMethodBasic, AuthMethodSSH:
		return true
	}
	return false
}

func (e AuthMethod) String() string {
	return string(e)
}

func (e *AuthMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuthMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuthMethod", str)
	}
	return nil
}

func (e AuthMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AutoscalingTarget string

const (
	AutoscalingTargetStatefulset AutoscalingTarget = "STATEFULSET"
	AutoscalingTargetDeployment  AutoscalingTarget = "DEPLOYMENT"
)

var AllAutoscalingTarget = []AutoscalingTarget{
	AutoscalingTargetStatefulset,
	AutoscalingTargetDeployment,
}

func (e AutoscalingTarget) IsValid() bool {
	switch e {
	case AutoscalingTargetStatefulset, AutoscalingTargetDeployment:
		return true
	}
	return false
}

func (e AutoscalingTarget) String() string {
	return string(e)
}

func (e *AutoscalingTarget) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AutoscalingTarget(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AutoscalingTarget", str)
	}
	return nil
}

func (e AutoscalingTarget) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BuildType string

const (
	BuildTypeDeploy    BuildType = "DEPLOY"
	BuildTypeBounce    BuildType = "BOUNCE"
	BuildTypeApproval  BuildType = "APPROVAL"
	BuildTypeInstall   BuildType = "INSTALL"
	BuildTypeDestroy   BuildType = "DESTROY"
	BuildTypeDedicated BuildType = "DEDICATED"
	BuildTypeConfig    BuildType = "CONFIG"
)

var AllBuildType = []BuildType{
	BuildTypeDeploy,
	BuildTypeBounce,
	BuildTypeApproval,
	BuildTypeInstall,
	BuildTypeDestroy,
	BuildTypeDedicated,
	BuildTypeConfig,
}

func (e BuildType) IsValid() bool {
	switch e {
	case BuildTypeDeploy, BuildTypeBounce, BuildTypeApproval, BuildTypeInstall, BuildTypeDestroy, BuildTypeDedicated, BuildTypeConfig:
		return true
	}
	return false
}

func (e BuildType) String() string {
	return string(e)
}

func (e *BuildType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BuildType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BuildType", str)
	}
	return nil
}

func (e BuildType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ClusterDistro string

const (
	ClusterDistroGeneric ClusterDistro = "GENERIC"
	ClusterDistroEks     ClusterDistro = "EKS"
	ClusterDistroAks     ClusterDistro = "AKS"
	ClusterDistroGke     ClusterDistro = "GKE"
	ClusterDistroRke     ClusterDistro = "RKE"
	ClusterDistroK3s     ClusterDistro = "K3S"
)

var AllClusterDistro = []ClusterDistro{
	ClusterDistroGeneric,
	ClusterDistroEks,
	ClusterDistroAks,
	ClusterDistroGke,
	ClusterDistroRke,
	ClusterDistroK3s,
}

func (e ClusterDistro) IsValid() bool {
	switch e {
	case ClusterDistroGeneric, ClusterDistroEks, ClusterDistroAks, ClusterDistroGke, ClusterDistroRke, ClusterDistroK3s:
		return true
	}
	return false
}

func (e ClusterDistro) String() string {
	return string(e)
}

func (e *ClusterDistro) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ClusterDistro(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ClusterDistro", str)
	}
	return nil
}

func (e ClusterDistro) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ComponentState string

const (
	ComponentStateRunning ComponentState = "RUNNING"
	ComponentStatePending ComponentState = "PENDING"
	ComponentStateFailed  ComponentState = "FAILED"
	ComponentStatePaused  ComponentState = "PAUSED"
)

var AllComponentState = []ComponentState{
	ComponentStateRunning,
	ComponentStatePending,
	ComponentStateFailed,
	ComponentStatePaused,
}

func (e ComponentState) IsValid() bool {
	switch e {
	case ComponentStateRunning, ComponentStatePending, ComponentStateFailed, ComponentStatePaused:
		return true
	}
	return false
}

func (e ComponentState) String() string {
	return string(e)
}

func (e *ComponentState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ComponentState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ComponentState", str)
	}
	return nil
}

func (e ComponentState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ConfigurationType string

const (
	ConfigurationTypeString   ConfigurationType = "STRING"
	ConfigurationTypeInt      ConfigurationType = "INT"
	ConfigurationTypeBool     ConfigurationType = "BOOL"
	ConfigurationTypeDomain   ConfigurationType = "DOMAIN"
	ConfigurationTypeBucket   ConfigurationType = "BUCKET"
	ConfigurationTypeFile     ConfigurationType = "FILE"
	ConfigurationTypeFunction ConfigurationType = "FUNCTION"
	ConfigurationTypePassword ConfigurationType = "PASSWORD"
	ConfigurationTypeEnum     ConfigurationType = "ENUM"
)

var AllConfigurationType = []ConfigurationType{
	ConfigurationTypeString,
	ConfigurationTypeInt,
	ConfigurationTypeBool,
	ConfigurationTypeDomain,
	ConfigurationTypeBucket,
	ConfigurationTypeFile,
	ConfigurationTypeFunction,
	ConfigurationTypePassword,
	ConfigurationTypeEnum,
}

func (e ConfigurationType) IsValid() bool {
	switch e {
	case ConfigurationTypeString, ConfigurationTypeInt, ConfigurationTypeBool, ConfigurationTypeDomain, ConfigurationTypeBucket, ConfigurationTypeFile, ConfigurationTypeFunction, ConfigurationTypePassword, ConfigurationTypeEnum:
		return true
	}
	return false
}

func (e ConfigurationType) String() string {
	return string(e)
}

func (e *ConfigurationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConfigurationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConfigurationType", str)
	}
	return nil
}

func (e ConfigurationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Conjunction string

const (
	ConjunctionAnd Conjunction = "AND"
	ConjunctionOr  Conjunction = "OR"
)

var AllConjunction = []Conjunction{
	ConjunctionAnd,
	ConjunctionOr,
}

func (e Conjunction) IsValid() bool {
	switch e {
	case ConjunctionAnd, ConjunctionOr:
		return true
	}
	return false
}

func (e Conjunction) String() string {
	return string(e)
}

func (e *Conjunction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Conjunction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Conjunction", str)
	}
	return nil
}

func (e Conjunction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ConstraintEnforcement string

const (
	ConstraintEnforcementWarn   ConstraintEnforcement = "WARN"
	ConstraintEnforcementDeny   ConstraintEnforcement = "DENY"
	ConstraintEnforcementDryRun ConstraintEnforcement = "DRY_RUN"
)

var AllConstraintEnforcement = []ConstraintEnforcement{
	ConstraintEnforcementWarn,
	ConstraintEnforcementDeny,
	ConstraintEnforcementDryRun,
}

func (e ConstraintEnforcement) IsValid() bool {
	switch e {
	case ConstraintEnforcementWarn, ConstraintEnforcementDeny, ConstraintEnforcementDryRun:
		return true
	}
	return false
}

func (e ConstraintEnforcement) String() string {
	return string(e)
}

func (e *ConstraintEnforcement) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConstraintEnforcement(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConstraintEnforcement", str)
	}
	return nil
}

func (e ConstraintEnforcement) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ConstraintViolationField string

const (
	ConstraintViolationFieldNamespace ConstraintViolationField = "NAMESPACE"
	ConstraintViolationFieldKind      ConstraintViolationField = "KIND"
)

var AllConstraintViolationField = []ConstraintViolationField{
	ConstraintViolationFieldNamespace,
	ConstraintViolationFieldKind,
}

func (e ConstraintViolationField) IsValid() bool {
	switch e {
	case ConstraintViolationFieldNamespace, ConstraintViolationFieldKind:
		return true
	}
	return false
}

func (e ConstraintViolationField) String() string {
	return string(e)
}

func (e *ConstraintViolationField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConstraintViolationField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConstraintViolationField", str)
	}
	return nil
}

func (e ConstraintViolationField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Delta string

const (
	DeltaCreate Delta = "CREATE"
	DeltaUpdate Delta = "UPDATE"
	DeltaDelete Delta = "DELETE"
)

var AllDelta = []Delta{
	DeltaCreate,
	DeltaUpdate,
	DeltaDelete,
}

func (e Delta) IsValid() bool {
	switch e {
	case DeltaCreate, DeltaUpdate, DeltaDelete:
		return true
	}
	return false
}

func (e Delta) String() string {
	return string(e)
}

func (e *Delta) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Delta(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Delta", str)
	}
	return nil
}

func (e Delta) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GateState string

const (
	GateStatePending GateState = "PENDING"
	GateStateOpen    GateState = "OPEN"
	GateStateClosed  GateState = "CLOSED"
	GateStateRunning GateState = "RUNNING"
)

var AllGateState = []GateState{
	GateStatePending,
	GateStateOpen,
	GateStateClosed,
	GateStateRunning,
}

func (e GateState) IsValid() bool {
	switch e {
	case GateStatePending, GateStateOpen, GateStateClosed, GateStateRunning:
		return true
	}
	return false
}

func (e GateState) String() string {
	return string(e)
}

func (e *GateState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GateState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GateState", str)
	}
	return nil
}

func (e GateState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GateType string

const (
	GateTypeApproval GateType = "APPROVAL"
	GateTypeWindow   GateType = "WINDOW"
	GateTypeJob      GateType = "JOB"
)

var AllGateType = []GateType{
	GateTypeApproval,
	GateTypeWindow,
	GateTypeJob,
}

func (e GateType) IsValid() bool {
	switch e {
	case GateTypeApproval, GateTypeWindow, GateTypeJob:
		return true
	}
	return false
}

func (e GateType) String() string {
	return string(e)
}

func (e *GateType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GateType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GateType", str)
	}
	return nil
}

func (e GateType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GitHealth string

const (
	GitHealthPullable GitHealth = "PULLABLE"
	GitHealthFailed   GitHealth = "FAILED"
)

var AllGitHealth = []GitHealth{
	GitHealthPullable,
	GitHealthFailed,
}

func (e GitHealth) IsValid() bool {
	switch e {
	case GitHealthPullable, GitHealthFailed:
		return true
	}
	return false
}

func (e GitHealth) String() string {
	return string(e)
}

func (e *GitHealth) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GitHealth(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GitHealth", str)
	}
	return nil
}

func (e GitHealth) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HelmAuthProvider string

const (
	HelmAuthProviderBasic  HelmAuthProvider = "BASIC"
	HelmAuthProviderBearer HelmAuthProvider = "BEARER"
	HelmAuthProviderGcp    HelmAuthProvider = "GCP"
	HelmAuthProviderAzure  HelmAuthProvider = "AZURE"
	HelmAuthProviderAws    HelmAuthProvider = "AWS"
)

var AllHelmAuthProvider = []HelmAuthProvider{
	HelmAuthProviderBasic,
	HelmAuthProviderBearer,
	HelmAuthProviderGcp,
	HelmAuthProviderAzure,
	HelmAuthProviderAws,
}

func (e HelmAuthProvider) IsValid() bool {
	switch e {
	case HelmAuthProviderBasic, HelmAuthProviderBearer, HelmAuthProviderGcp, HelmAuthProviderAzure, HelmAuthProviderAws:
		return true
	}
	return false
}

func (e HelmAuthProvider) String() string {
	return string(e)
}

func (e *HelmAuthProvider) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HelmAuthProvider(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HelmAuthProvider", str)
	}
	return nil
}

func (e HelmAuthProvider) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// enumerable to describe the recency of this insight
type InsightFreshness string

const (
	InsightFreshnessFresh   InsightFreshness = "FRESH"
	InsightFreshnessStale   InsightFreshness = "STALE"
	InsightFreshnessExpired InsightFreshness = "EXPIRED"
)

var AllInsightFreshness = []InsightFreshness{
	InsightFreshnessFresh,
	InsightFreshnessStale,
	InsightFreshnessExpired,
}

func (e InsightFreshness) IsValid() bool {
	switch e {
	case InsightFreshnessFresh, InsightFreshnessStale, InsightFreshnessExpired:
		return true
	}
	return false
}

func (e InsightFreshness) String() string {
	return string(e)
}

func (e *InsightFreshness) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InsightFreshness(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InsightFreshness", str)
	}
	return nil
}

func (e InsightFreshness) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ListMerge string

const (
	ListMergeOverwrite ListMerge = "OVERWRITE"
	ListMergeAppend    ListMerge = "APPEND"
)

var AllListMerge = []ListMerge{
	ListMergeOverwrite,
	ListMergeAppend,
}

func (e ListMerge) IsValid() bool {
	switch e {
	case ListMergeOverwrite, ListMergeAppend:
		return true
	}
	return false
}

func (e ListMerge) String() string {
	return string(e)
}

func (e *ListMerge) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ListMerge(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ListMerge", str)
	}
	return nil
}

func (e ListMerge) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MatchStrategy string

const (
	MatchStrategyAny       MatchStrategy = "ANY"
	MatchStrategyAll       MatchStrategy = "ALL"
	MatchStrategyRecursive MatchStrategy = "RECURSIVE"
)

var AllMatchStrategy = []MatchStrategy{
	MatchStrategyAny,
	MatchStrategyAll,
	MatchStrategyRecursive,
}

func (e MatchStrategy) IsValid() bool {
	switch e {
	case MatchStrategyAny, MatchStrategyAll, MatchStrategyRecursive:
		return true
	}
	return false
}

func (e MatchStrategy) String() string {
	return string(e)
}

func (e *MatchStrategy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MatchStrategy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MatchStrategy", str)
	}
	return nil
}

func (e MatchStrategy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NotificationPriority string

const (
	NotificationPriorityLow    NotificationPriority = "LOW"
	NotificationPriorityMedium NotificationPriority = "MEDIUM"
	NotificationPriorityHigh   NotificationPriority = "HIGH"
)

var AllNotificationPriority = []NotificationPriority{
	NotificationPriorityLow,
	NotificationPriorityMedium,
	NotificationPriorityHigh,
}

func (e NotificationPriority) IsValid() bool {
	switch e {
	case NotificationPriorityLow, NotificationPriorityMedium, NotificationPriorityHigh:
		return true
	}
	return false
}

func (e NotificationPriority) String() string {
	return string(e)
}

func (e *NotificationPriority) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationPriority(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotificationPriority", str)
	}
	return nil
}

func (e NotificationPriority) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NotificationStatus string

const (
	NotificationStatusFiring   NotificationStatus = "FIRING"
	NotificationStatusResolved NotificationStatus = "RESOLVED"
)

var AllNotificationStatus = []NotificationStatus{
	NotificationStatusFiring,
	NotificationStatusResolved,
}

func (e NotificationStatus) IsValid() bool {
	switch e {
	case NotificationStatusFiring, NotificationStatusResolved:
		return true
	}
	return false
}

func (e NotificationStatus) String() string {
	return string(e)
}

func (e *NotificationStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotificationStatus", str)
	}
	return nil
}

func (e NotificationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ObservabilityProviderType string

const (
	ObservabilityProviderTypeDatadog  ObservabilityProviderType = "DATADOG"
	ObservabilityProviderTypeNewrelic ObservabilityProviderType = "NEWRELIC"
)

var AllObservabilityProviderType = []ObservabilityProviderType{
	ObservabilityProviderTypeDatadog,
	ObservabilityProviderTypeNewrelic,
}

func (e ObservabilityProviderType) IsValid() bool {
	switch e {
	case ObservabilityProviderTypeDatadog, ObservabilityProviderTypeNewrelic:
		return true
	}
	return false
}

func (e ObservabilityProviderType) String() string {
	return string(e)
}

func (e *ObservabilityProviderType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ObservabilityProviderType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ObservabilityProviderType", str)
	}
	return nil
}

func (e ObservabilityProviderType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ObservabilityWebhookType string

const (
	ObservabilityWebhookTypeGrafana ObservabilityWebhookType = "GRAFANA"
)

var AllObservabilityWebhookType = []ObservabilityWebhookType{
	ObservabilityWebhookTypeGrafana,
}

func (e ObservabilityWebhookType) IsValid() bool {
	switch e {
	case ObservabilityWebhookTypeGrafana:
		return true
	}
	return false
}

func (e ObservabilityWebhookType) String() string {
	return string(e)
}

func (e *ObservabilityWebhookType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ObservabilityWebhookType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ObservabilityWebhookType", str)
	}
	return nil
}

func (e ObservabilityWebhookType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ObserverActionType string

const (
	ObserverActionTypePipeline ObserverActionType = "PIPELINE"
	ObserverActionTypePr       ObserverActionType = "PR"
)

var AllObserverActionType = []ObserverActionType{
	ObserverActionTypePipeline,
	ObserverActionTypePr,
}

func (e ObserverActionType) IsValid() bool {
	switch e {
	case ObserverActionTypePipeline, ObserverActionTypePr:
		return true
	}
	return false
}

func (e ObserverActionType) String() string {
	return string(e)
}

func (e *ObserverActionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ObserverActionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ObserverActionType", str)
	}
	return nil
}

func (e ObserverActionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ObserverGitTargetType string

const (
	ObserverGitTargetTypeTags ObserverGitTargetType = "TAGS"
)

var AllObserverGitTargetType = []ObserverGitTargetType{
	ObserverGitTargetTypeTags,
}

func (e ObserverGitTargetType) IsValid() bool {
	switch e {
	case ObserverGitTargetTypeTags:
		return true
	}
	return false
}

func (e ObserverGitTargetType) String() string {
	return string(e)
}

func (e *ObserverGitTargetType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ObserverGitTargetType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ObserverGitTargetType", str)
	}
	return nil
}

func (e ObserverGitTargetType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ObserverStatus string

const (
	ObserverStatusHealthy ObserverStatus = "HEALTHY"
	ObserverStatusFailed  ObserverStatus = "FAILED"
)

var AllObserverStatus = []ObserverStatus{
	ObserverStatusHealthy,
	ObserverStatusFailed,
}

func (e ObserverStatus) IsValid() bool {
	switch e {
	case ObserverStatusHealthy, ObserverStatusFailed:
		return true
	}
	return false
}

func (e ObserverStatus) String() string {
	return string(e)
}

func (e *ObserverStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ObserverStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ObserverStatus", str)
	}
	return nil
}

func (e ObserverStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ObserverTargetOrder string

const (
	ObserverTargetOrderSemver ObserverTargetOrder = "SEMVER"
	ObserverTargetOrderLatest ObserverTargetOrder = "LATEST"
)

var AllObserverTargetOrder = []ObserverTargetOrder{
	ObserverTargetOrderSemver,
	ObserverTargetOrderLatest,
}

func (e ObserverTargetOrder) IsValid() bool {
	switch e {
	case ObserverTargetOrderSemver, ObserverTargetOrderLatest:
		return true
	}
	return false
}

func (e ObserverTargetOrder) String() string {
	return string(e)
}

func (e *ObserverTargetOrder) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ObserverTargetOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ObserverTargetOrder", str)
	}
	return nil
}

func (e ObserverTargetOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ObserverTargetType string

const (
	ObserverTargetTypeOci  ObserverTargetType = "OCI"
	ObserverTargetTypeHelm ObserverTargetType = "HELM"
	ObserverTargetTypeGit  ObserverTargetType = "GIT"
)

var AllObserverTargetType = []ObserverTargetType{
	ObserverTargetTypeOci,
	ObserverTargetTypeHelm,
	ObserverTargetTypeGit,
}

func (e ObserverTargetType) IsValid() bool {
	switch e {
	case ObserverTargetTypeOci, ObserverTargetTypeHelm, ObserverTargetTypeGit:
		return true
	}
	return false
}

func (e ObserverTargetType) String() string {
	return string(e)
}

func (e *ObserverTargetType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ObserverTargetType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ObserverTargetType", str)
	}
	return nil
}

func (e ObserverTargetType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Supported methods for fetching an OIDC auth token
type OidcAuthMethod string

const (
	OidcAuthMethodPost  OidcAuthMethod = "POST"
	OidcAuthMethodBasic OidcAuthMethod = "BASIC"
)

var AllOidcAuthMethod = []OidcAuthMethod{
	OidcAuthMethodPost,
	OidcAuthMethodBasic,
}

func (e OidcAuthMethod) IsValid() bool {
	switch e {
	case OidcAuthMethodPost, OidcAuthMethodBasic:
		return true
	}
	return false
}

func (e OidcAuthMethod) String() string {
	return string(e)
}

func (e *OidcAuthMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OidcAuthMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OidcAuthMethod", str)
	}
	return nil
}

func (e OidcAuthMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Supported OIDC-compatible Auth Providers
type OidcProviderType string

const (
	OidcProviderTypePlural OidcProviderType = "PLURAL"
)

var AllOidcProviderType = []OidcProviderType{
	OidcProviderTypePlural,
}

func (e OidcProviderType) IsValid() bool {
	switch e {
	case OidcProviderTypePlural:
		return true
	}
	return false
}

func (e OidcProviderType) String() string {
	return string(e)
}

func (e *OidcProviderType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OidcProviderType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OidcProviderType", str)
	}
	return nil
}

func (e OidcProviderType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Operation string

const (
	OperationNot    Operation = "NOT"
	OperationGt     Operation = "GT"
	OperationLt     Operation = "LT"
	OperationEq     Operation = "EQ"
	OperationGte    Operation = "GTE"
	OperationLte    Operation = "LTE"
	OperationPrefix Operation = "PREFIX"
	OperationSuffix Operation = "SUFFIX"
)

var AllOperation = []Operation{
	OperationNot,
	OperationGt,
	OperationLt,
	OperationEq,
	OperationGte,
	OperationLte,
	OperationPrefix,
	OperationSuffix,
}

func (e Operation) IsValid() bool {
	switch e {
	case OperationNot, OperationGt, OperationLt, OperationEq, OperationGte, OperationLte, OperationPrefix, OperationSuffix:
		return true
	}
	return false
}

func (e Operation) String() string {
	return string(e)
}

func (e *Operation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Operation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Operation", str)
	}
	return nil
}

func (e Operation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Permission string

const (
	PermissionRead      Permission = "READ"
	PermissionConfigure Permission = "CONFIGURE"
	PermissionDeploy    Permission = "DEPLOY"
	PermissionOperate   Permission = "OPERATE"
)

var AllPermission = []Permission{
	PermissionRead,
	PermissionConfigure,
	PermissionDeploy,
	PermissionOperate,
}

func (e Permission) IsValid() bool {
	switch e {
	case PermissionRead, PermissionConfigure, PermissionDeploy, PermissionOperate:
		return true
	}
	return false
}

func (e Permission) String() string {
	return string(e)
}

func (e *Permission) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Permission(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Permission", str)
	}
	return nil
}

func (e Permission) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PolicyAggregate string

const (
	PolicyAggregateCluster     PolicyAggregate = "CLUSTER"
	PolicyAggregateEnforcement PolicyAggregate = "ENFORCEMENT"
	PolicyAggregateInstalled   PolicyAggregate = "INSTALLED"
)

var AllPolicyAggregate = []PolicyAggregate{
	PolicyAggregateCluster,
	PolicyAggregateEnforcement,
	PolicyAggregateInstalled,
}

func (e PolicyAggregate) IsValid() bool {
	switch e {
	case PolicyAggregateCluster, PolicyAggregateEnforcement, PolicyAggregateInstalled:
		return true
	}
	return false
}

func (e PolicyAggregate) String() string {
	return string(e)
}

func (e *PolicyAggregate) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicyAggregate(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicyAggregate", str)
	}
	return nil
}

func (e PolicyAggregate) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PrRole string

const (
	PrRoleCluster  PrRole = "CLUSTER"
	PrRoleService  PrRole = "SERVICE"
	PrRolePipeline PrRole = "PIPELINE"
	PrRoleUpdate   PrRole = "UPDATE"
	PrRoleUpgrade  PrRole = "UPGRADE"
)

var AllPrRole = []PrRole{
	PrRoleCluster,
	PrRoleService,
	PrRolePipeline,
	PrRoleUpdate,
	PrRoleUpgrade,
}

func (e PrRole) IsValid() bool {
	switch e {
	case PrRoleCluster, PrRoleService, PrRolePipeline, PrRoleUpdate, PrRoleUpgrade:
		return true
	}
	return false
}

func (e PrRole) String() string {
	return string(e)
}

func (e *PrRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PrRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PrRole", str)
	}
	return nil
}

func (e PrRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PrStatus string

const (
	PrStatusOpen   PrStatus = "OPEN"
	PrStatusMerged PrStatus = "MERGED"
	PrStatusClosed PrStatus = "CLOSED"
)

var AllPrStatus = []PrStatus{
	PrStatusOpen,
	PrStatusMerged,
	PrStatusClosed,
}

func (e PrStatus) IsValid() bool {
	switch e {
	case PrStatusOpen, PrStatusMerged, PrStatusClosed:
		return true
	}
	return false
}

func (e PrStatus) String() string {
	return string(e)
}

func (e *PrStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PrStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PrStatus", str)
	}
	return nil
}

func (e PrStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ReadType string

const (
	ReadTypeNotification ReadType = "NOTIFICATION"
	ReadTypeBuild        ReadType = "BUILD"
)

var AllReadType = []ReadType{
	ReadTypeNotification,
	ReadTypeBuild,
}

func (e ReadType) IsValid() bool {
	switch e {
	case ReadTypeNotification, ReadTypeBuild:
		return true
	}
	return false
}

func (e ReadType) String() string {
	return string(e)
}

func (e *ReadType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReadType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReadType", str)
	}
	return nil
}

func (e ReadType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RestoreStatus string

const (
	RestoreStatusCreated    RestoreStatus = "CREATED"
	RestoreStatusPending    RestoreStatus = "PENDING"
	RestoreStatusSuccessful RestoreStatus = "SUCCESSFUL"
	RestoreStatusFailed     RestoreStatus = "FAILED"
)

var AllRestoreStatus = []RestoreStatus{
	RestoreStatusCreated,
	RestoreStatusPending,
	RestoreStatusSuccessful,
	RestoreStatusFailed,
}

func (e RestoreStatus) IsValid() bool {
	switch e {
	case RestoreStatusCreated, RestoreStatusPending, RestoreStatusSuccessful, RestoreStatusFailed:
		return true
	}
	return false
}

func (e RestoreStatus) String() string {
	return string(e)
}

func (e *RestoreStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RestoreStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RestoreStatus", str)
	}
	return nil
}

func (e RestoreStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ScmType string

const (
	ScmTypeGithub    ScmType = "GITHUB"
	ScmTypeGitlab    ScmType = "GITLAB"
	ScmTypeBitbucket ScmType = "BITBUCKET"
)

var AllScmType = []ScmType{
	ScmTypeGithub,
	ScmTypeGitlab,
	ScmTypeBitbucket,
}

func (e ScmType) IsValid() bool {
	switch e {
	case ScmTypeGithub, ScmTypeGitlab, ScmTypeBitbucket:
		return true
	}
	return false
}

func (e ScmType) String() string {
	return string(e)
}

func (e *ScmType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScmType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ScmType", str)
	}
	return nil
}

func (e ScmType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ServiceDeploymentStatus string

const (
	ServiceDeploymentStatusStale   ServiceDeploymentStatus = "STALE"
	ServiceDeploymentStatusSynced  ServiceDeploymentStatus = "SYNCED"
	ServiceDeploymentStatusHealthy ServiceDeploymentStatus = "HEALTHY"
	ServiceDeploymentStatusFailed  ServiceDeploymentStatus = "FAILED"
	ServiceDeploymentStatusPaused  ServiceDeploymentStatus = "PAUSED"
)

var AllServiceDeploymentStatus = []ServiceDeploymentStatus{
	ServiceDeploymentStatusStale,
	ServiceDeploymentStatusSynced,
	ServiceDeploymentStatusHealthy,
	ServiceDeploymentStatusFailed,
	ServiceDeploymentStatusPaused,
}

func (e ServiceDeploymentStatus) IsValid() bool {
	switch e {
	case ServiceDeploymentStatusStale, ServiceDeploymentStatusSynced, ServiceDeploymentStatusHealthy, ServiceDeploymentStatusFailed, ServiceDeploymentStatusPaused:
		return true
	}
	return false
}

func (e ServiceDeploymentStatus) String() string {
	return string(e)
}

func (e *ServiceDeploymentStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServiceDeploymentStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServiceDeploymentStatus", str)
	}
	return nil
}

func (e ServiceDeploymentStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ServicePromotion string

const (
	ServicePromotionIgnore   ServicePromotion = "IGNORE"
	ServicePromotionProceed  ServicePromotion = "PROCEED"
	ServicePromotionRollback ServicePromotion = "ROLLBACK"
)

var AllServicePromotion = []ServicePromotion{
	ServicePromotionIgnore,
	ServicePromotionProceed,
	ServicePromotionRollback,
}

func (e ServicePromotion) IsValid() bool {
	switch e {
	case ServicePromotionIgnore, ServicePromotionProceed, ServicePromotionRollback:
		return true
	}
	return false
}

func (e ServicePromotion) String() string {
	return string(e)
}

func (e *ServicePromotion) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServicePromotion(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServicePromotion", str)
	}
	return nil
}

func (e ServicePromotion) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Severity string

const (
	SeverityNone     Severity = "NONE"
	SeverityLow      Severity = "LOW"
	SeverityMedium   Severity = "MEDIUM"
	SeverityHigh     Severity = "HIGH"
	SeverityCritical Severity = "CRITICAL"
)

var AllSeverity = []Severity{
	SeverityNone,
	SeverityLow,
	SeverityMedium,
	SeverityHigh,
	SeverityCritical,
}

func (e Severity) IsValid() bool {
	switch e {
	case SeverityNone, SeverityLow, SeverityMedium, SeverityHigh, SeverityCritical:
		return true
	}
	return false
}

func (e Severity) String() string {
	return string(e)
}

func (e *Severity) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Severity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Severity", str)
	}
	return nil
}

func (e Severity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SinkType string

const (
	SinkTypeSLACk  SinkType = "SLACK"
	SinkTypeTeams  SinkType = "TEAMS"
	SinkTypePlural SinkType = "PLURAL"
)

var AllSinkType = []SinkType{
	SinkTypeSLACk,
	SinkTypeTeams,
	SinkTypePlural,
}

func (e SinkType) IsValid() bool {
	switch e {
	case SinkTypeSLACk, SinkTypeTeams, SinkTypePlural:
		return true
	}
	return false
}

func (e SinkType) String() string {
	return string(e)
}

func (e *SinkType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SinkType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SinkType", str)
	}
	return nil
}

func (e SinkType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StackStatus string

const (
	StackStatusQueued          StackStatus = "QUEUED"
	StackStatusPending         StackStatus = "PENDING"
	StackStatusRunning         StackStatus = "RUNNING"
	StackStatusSuccessful      StackStatus = "SUCCESSFUL"
	StackStatusFailed          StackStatus = "FAILED"
	StackStatusCancelled       StackStatus = "CANCELLED"
	StackStatusPendingApproval StackStatus = "PENDING_APPROVAL"
)

var AllStackStatus = []StackStatus{
	StackStatusQueued,
	StackStatusPending,
	StackStatusRunning,
	StackStatusSuccessful,
	StackStatusFailed,
	StackStatusCancelled,
	StackStatusPendingApproval,
}

func (e StackStatus) IsValid() bool {
	switch e {
	case StackStatusQueued, StackStatusPending, StackStatusRunning, StackStatusSuccessful, StackStatusFailed, StackStatusCancelled, StackStatusPendingApproval:
		return true
	}
	return false
}

func (e StackStatus) String() string {
	return string(e)
}

func (e *StackStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StackStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StackStatus", str)
	}
	return nil
}

func (e StackStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StackType string

const (
	StackTypeTerraform StackType = "TERRAFORM"
	StackTypeAnsible   StackType = "ANSIBLE"
	StackTypeCustom    StackType = "CUSTOM"
)

var AllStackType = []StackType{
	StackTypeTerraform,
	StackTypeAnsible,
	StackTypeCustom,
}

func (e StackType) IsValid() bool {
	switch e {
	case StackTypeTerraform, StackTypeAnsible, StackTypeCustom:
		return true
	}
	return false
}

func (e StackType) String() string {
	return string(e)
}

func (e *StackType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StackType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StackType", str)
	}
	return nil
}

func (e StackType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Status string

const (
	StatusQueued     Status = "QUEUED"
	StatusRunning    Status = "RUNNING"
	StatusSuccessful Status = "SUCCESSFUL"
	StatusFailed     Status = "FAILED"
	StatusCancelled  Status = "CANCELLED"
	StatusPending    Status = "PENDING"
)

var AllStatus = []Status{
	StatusQueued,
	StatusRunning,
	StatusSuccessful,
	StatusFailed,
	StatusCancelled,
	StatusPending,
}

func (e Status) IsValid() bool {
	switch e {
	case StatusQueued, StatusRunning, StatusSuccessful, StatusFailed, StatusCancelled, StatusPending:
		return true
	}
	return false
}

func (e Status) String() string {
	return string(e)
}

func (e *Status) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Status(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Status", str)
	}
	return nil
}

func (e Status) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StepStage string

const (
	StepStagePlan    StepStage = "PLAN"
	StepStageVerify  StepStage = "VERIFY"
	StepStageApply   StepStage = "APPLY"
	StepStageInit    StepStage = "INIT"
	StepStageDestroy StepStage = "DESTROY"
)

var AllStepStage = []StepStage{
	StepStagePlan,
	StepStageVerify,
	StepStageApply,
	StepStageInit,
	StepStageDestroy,
}

func (e StepStage) IsValid() bool {
	switch e {
	case StepStagePlan, StepStageVerify, StepStageApply, StepStageInit, StepStageDestroy:
		return true
	}
	return false
}

func (e StepStage) String() string {
	return string(e)
}

func (e *StepStage) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StepStage(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StepStage", str)
	}
	return nil
}

func (e StepStage) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StepStatus string

const (
	StepStatusPending    StepStatus = "PENDING"
	StepStatusRunning    StepStatus = "RUNNING"
	StepStatusSuccessful StepStatus = "SUCCESSFUL"
	StepStatusFailed     StepStatus = "FAILED"
)

var AllStepStatus = []StepStatus{
	StepStatusPending,
	StepStatusRunning,
	StepStatusSuccessful,
	StepStatusFailed,
}

func (e StepStatus) IsValid() bool {
	switch e {
	case StepStatusPending, StepStatusRunning, StepStatusSuccessful, StepStatusFailed:
		return true
	}
	return false
}

func (e StepStatus) String() string {
	return string(e)
}

func (e *StepStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StepStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StepStatus", str)
	}
	return nil
}

func (e StepStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TagType string

const (
	TagTypeCluster TagType = "CLUSTER"
	TagTypeStack   TagType = "STACK"
)

var AllTagType = []TagType{
	TagTypeCluster,
	TagTypeStack,
}

func (e TagType) IsValid() bool {
	switch e {
	case TagTypeCluster, TagTypeStack:
		return true
	}
	return false
}

func (e TagType) String() string {
	return string(e)
}

func (e *TagType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TagType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TagType", str)
	}
	return nil
}

func (e TagType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Tool string

const (
	ToolHelm      Tool = "HELM"
	ToolTerraform Tool = "TERRAFORM"
)

var AllTool = []Tool{
	ToolHelm,
	ToolTerraform,
}

func (e Tool) IsValid() bool {
	switch e {
	case ToolHelm, ToolTerraform:
		return true
	}
	return false
}

func (e Tool) String() string {
	return string(e)
}

func (e *Tool) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Tool(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Tool", str)
	}
	return nil
}

func (e Tool) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UpgradeInsightStatus string

const (
	UpgradeInsightStatusPassing UpgradeInsightStatus = "PASSING"
	UpgradeInsightStatusFailed  UpgradeInsightStatus = "FAILED"
	UpgradeInsightStatusUnknown UpgradeInsightStatus = "UNKNOWN"
	UpgradeInsightStatusWarning UpgradeInsightStatus = "WARNING"
)

var AllUpgradeInsightStatus = []UpgradeInsightStatus{
	UpgradeInsightStatusPassing,
	UpgradeInsightStatusFailed,
	UpgradeInsightStatusUnknown,
	UpgradeInsightStatusWarning,
}

func (e UpgradeInsightStatus) IsValid() bool {
	switch e {
	case UpgradeInsightStatusPassing, UpgradeInsightStatusFailed, UpgradeInsightStatusUnknown, UpgradeInsightStatusWarning:
		return true
	}
	return false
}

func (e UpgradeInsightStatus) String() string {
	return string(e)
}

func (e *UpgradeInsightStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpgradeInsightStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpgradeInsightStatus", str)
	}
	return nil
}

func (e UpgradeInsightStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UpgradePolicyType string

const (
	UpgradePolicyTypeDeploy   UpgradePolicyType = "DEPLOY"
	UpgradePolicyTypeApproval UpgradePolicyType = "APPROVAL"
	UpgradePolicyTypeIgnore   UpgradePolicyType = "IGNORE"
)

var AllUpgradePolicyType = []UpgradePolicyType{
	UpgradePolicyTypeDeploy,
	UpgradePolicyTypeApproval,
	UpgradePolicyTypeIgnore,
}

func (e UpgradePolicyType) IsValid() bool {
	switch e {
	case UpgradePolicyTypeDeploy, UpgradePolicyTypeApproval, UpgradePolicyTypeIgnore:
		return true
	}
	return false
}

func (e UpgradePolicyType) String() string {
	return string(e)
}

func (e *UpgradePolicyType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpgradePolicyType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpgradePolicyType", str)
	}
	return nil
}

func (e UpgradePolicyType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ValidationUniqScope string

const (
	ValidationUniqScopeProject ValidationUniqScope = "PROJECT"
	ValidationUniqScopeCluster ValidationUniqScope = "CLUSTER"
)

var AllValidationUniqScope = []ValidationUniqScope{
	ValidationUniqScopeProject,
	ValidationUniqScopeCluster,
}

func (e ValidationUniqScope) IsValid() bool {
	switch e {
	case ValidationUniqScopeProject, ValidationUniqScopeCluster:
		return true
	}
	return false
}

func (e ValidationUniqScope) String() string {
	return string(e)
}

func (e *ValidationUniqScope) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ValidationUniqScope(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ValidationUniqScope", str)
	}
	return nil
}

func (e ValidationUniqScope) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VulnSeverity string

const (
	VulnSeverityUnknown  VulnSeverity = "UNKNOWN"
	VulnSeverityLow      VulnSeverity = "LOW"
	VulnSeverityMedium   VulnSeverity = "MEDIUM"
	VulnSeverityHigh     VulnSeverity = "HIGH"
	VulnSeverityCritical VulnSeverity = "CRITICAL"
)

var AllVulnSeverity = []VulnSeverity{
	VulnSeverityUnknown,
	VulnSeverityLow,
	VulnSeverityMedium,
	VulnSeverityHigh,
	VulnSeverityCritical,
}

func (e VulnSeverity) IsValid() bool {
	switch e {
	case VulnSeverityUnknown, VulnSeverityLow, VulnSeverityMedium, VulnSeverityHigh, VulnSeverityCritical:
		return true
	}
	return false
}

func (e VulnSeverity) String() string {
	return string(e)
}

func (e *VulnSeverity) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VulnSeverity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VulnSeverity", str)
	}
	return nil
}

func (e VulnSeverity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WebhookHealth string

const (
	WebhookHealthHealthy   WebhookHealth = "HEALTHY"
	WebhookHealthUnhealthy WebhookHealth = "UNHEALTHY"
)

var AllWebhookHealth = []WebhookHealth{
	WebhookHealthHealthy,
	WebhookHealthUnhealthy,
}

func (e WebhookHealth) IsValid() bool {
	switch e {
	case WebhookHealthHealthy, WebhookHealthUnhealthy:
		return true
	}
	return false
}

func (e WebhookHealth) String() string {
	return string(e)
}

func (e *WebhookHealth) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WebhookHealth(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WebhookHealth", str)
	}
	return nil
}

func (e WebhookHealth) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WebhookType string

const (
	WebhookTypePiazza WebhookType = "PIAZZA"
	WebhookTypeSLACk  WebhookType = "SLACK"
)

var AllWebhookType = []WebhookType{
	WebhookTypePiazza,
	WebhookTypeSLACk,
}

func (e WebhookType) IsValid() bool {
	switch e {
	case WebhookTypePiazza, WebhookTypeSLACk:
		return true
	}
	return false
}

func (e WebhookType) String() string {
	return string(e)
}

func (e *WebhookType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WebhookType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WebhookType", str)
	}
	return nil
}

func (e WebhookType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
