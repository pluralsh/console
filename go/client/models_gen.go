// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package client

import (
	"fmt"
	"io"
	"strconv"
)

type AccessToken struct {
	ID         *string                     `json:"id,omitempty"`
	Token      *string                     `json:"token,omitempty"`
	Scopes     []*AccessTokenScope         `json:"scopes,omitempty"`
	Audits     *AccessTokenAuditConnection `json:"audits,omitempty"`
	InsertedAt *string                     `json:"insertedAt,omitempty"`
	UpdatedAt  *string                     `json:"updatedAt,omitempty"`
}

type AccessTokenAudit struct {
	ID         *string `json:"id,omitempty"`
	IP         *string `json:"ip,omitempty"`
	Timestamp  *string `json:"timestamp,omitempty"`
	Count      *int64  `json:"count,omitempty"`
	City       *string `json:"city,omitempty"`
	Country    *string `json:"country,omitempty"`
	Latitude   *string `json:"latitude,omitempty"`
	Longitude  *string `json:"longitude,omitempty"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

type AccessTokenAuditConnection struct {
	PageInfo PageInfo                `json:"pageInfo"`
	Edges    []*AccessTokenAuditEdge `json:"edges,omitempty"`
}

type AccessTokenAuditEdge struct {
	Node   *AccessTokenAudit `json:"node,omitempty"`
	Cursor *string           `json:"cursor,omitempty"`
}

type AccessTokenConnection struct {
	PageInfo PageInfo           `json:"pageInfo"`
	Edges    []*AccessTokenEdge `json:"edges,omitempty"`
}

type AccessTokenEdge struct {
	Node   *AccessToken `json:"node,omitempty"`
	Cursor *string      `json:"cursor,omitempty"`
}

type AccessTokenScope struct {
	API        *string  `json:"api,omitempty"`
	Apis       []string `json:"apis,omitempty"`
	Identifier *string  `json:"identifier,omitempty"`
	Ids        []string `json:"ids,omitempty"`
}

type Account struct {
	DelinquentAt       *string             `json:"delinquentAt,omitempty"`
	GrandfatheredUntil *string             `json:"grandfatheredUntil,omitempty"`
	AvailableFeatures  *AvailableFeatures  `json:"availableFeatures,omitempty"`
	Subscription       *PluralSubscription `json:"subscription,omitempty"`
}

// a condition that determines whether its configuration is viewable
type AddOnConfigCondition struct {
	// the operation for this condition, eg EQ, LT, GT
	Operation *string `json:"operation,omitempty"`
	// the field this condition applies to
	Field *string `json:"field,omitempty"`
	// the value to apply the condition with, for binary operators like LT/GT
	Value *string `json:"value,omitempty"`
}

// Input configuration for an add-on you can install
type AddOnConfiguration struct {
	// name for this configuration
	Name *string `json:"name,omitempty"`
	// a docstring explaining this configuration
	Documentation *string `json:"documentation,omitempty"`
	// a type for the configuration (should eventually be coerced back to string)
	Type *string `json:"type,omitempty"`
	// the values for ENUM type conditions
	Values    []*string             `json:"values,omitempty"`
	Condition *AddOnConfigCondition `json:"condition,omitempty"`
}

// the specification of a runtime service at a specific version
type AddonVersion struct {
	// add-on version, semver formatted
	Version *string `json:"version,omitempty"`
	// kubernetes versions this add-on works with
	Kube []*string `json:"kube,omitempty"`
	// any other add-ons this might require
	Requirements []*VersionReference `json:"requirements,omitempty"`
	// any add-ons this might break
	Incompatibilities []*VersionReference `json:"incompatibilities,omitempty"`
	// the version of the helm chart to install for this version
	ChartVersion *string `json:"chartVersion,omitempty"`
	// the release page for a runtime service at a version, this is a heavy operation not suitable for lists
	ReleaseURL *string `json:"releaseUrl,omitempty"`
	// checks if this is blocking a specific kubernetes upgrade
	Blocking *bool `json:"blocking,omitempty"`
}

// a representation of a bulk operation to be performed on all agent services
type AgentMigration struct {
	ID            string         `json:"id"`
	Name          *string        `json:"name,omitempty"`
	Ref           *string        `json:"ref,omitempty"`
	Configuration map[string]any `json:"configuration,omitempty"`
	Completed     *bool          `json:"completed,omitempty"`
	InsertedAt    *string        `json:"insertedAt,omitempty"`
	UpdatedAt     *string        `json:"updatedAt,omitempty"`
}

type AgentMigrationAttributes struct {
	Name          *string `json:"name,omitempty"`
	Ref           *string `json:"ref,omitempty"`
	Configuration *string `json:"configuration,omitempty"`
}

type AgentSessionAttributes struct {
	// whether the provisioning plan has been confirmed
	PlanConfirmed *bool `json:"planConfirmed,omitempty"`
	// the prompt to use for this session
	Prompt *string `json:"prompt,omitempty"`
	// the id of the cloud connection to use for this session
	ConnectionID *string `json:"connectionId,omitempty"`
}

type AiDelta struct {
	Seq     int64   `json:"seq"`
	Content string  `json:"content"`
	Message *int64  `json:"message,omitempty"`
	Role    *AiRole `json:"role,omitempty"`
}

// A representation of a LLM-derived insight
type AiInsight struct {
	ID string `json:"id"`
	// a deduplication sha for this insight
	Sha *string `json:"sha,omitempty"`
	// the text of this insight
	Text *string `json:"text,omitempty"`
	// a shortish summary of this insight
	Summary *string `json:"summary,omitempty"`
	// any errors generated when compiling this insight
	Error                   []*ServiceError          `json:"error,omitempty"`
	Freshness               *InsightFreshness        `json:"freshness,omitempty"`
	Alert                   *Alert                   `json:"alert,omitempty"`
	Service                 *ServiceDeployment       `json:"service,omitempty"`
	Stack                   *InfrastructureStack     `json:"stack,omitempty"`
	Cluster                 *Cluster                 `json:"cluster,omitempty"`
	StackRun                *StackRun                `json:"stackRun,omitempty"`
	ServiceComponent        *ServiceComponent        `json:"serviceComponent,omitempty"`
	StackState              *StackState              `json:"stackState,omitempty"`
	Evidence                []*AiInsightEvidence     `json:"evidence,omitempty"`
	ClusterInsightComponent *ClusterInsightComponent `json:"clusterInsightComponent,omitempty"`
	InsertedAt              *string                  `json:"insertedAt,omitempty"`
	UpdatedAt               *string                  `json:"updatedAt,omitempty"`
}

type AiInsightEvidence struct {
	ID          string               `json:"id"`
	Type        EvidenceType         `json:"type"`
	Logs        *LogsEvidence        `json:"logs,omitempty"`
	Alert       *AlertEvidence       `json:"alert,omitempty"`
	PullRequest *PullRequestEvidence `json:"pullRequest,omitempty"`
	Knowledge   *KnowledgeEvidence   `json:"knowledge,omitempty"`
	InsertedAt  *string              `json:"insertedAt,omitempty"`
	UpdatedAt   *string              `json:"updatedAt,omitempty"`
}

// A saved item for future ai-based investigation
type AiPin struct {
	ID         string      `json:"id"`
	Name       *string     `json:"name,omitempty"`
	Insight    *AiInsight  `json:"insight,omitempty"`
	Thread     *ChatThread `json:"thread,omitempty"`
	InsertedAt *string     `json:"insertedAt,omitempty"`
	UpdatedAt  *string     `json:"updatedAt,omitempty"`
}

// the items you want to reference in this pin
type AiPinAttributes struct {
	Name      *string `json:"name,omitempty"`
	InsightID *string `json:"insightId,omitempty"`
	ThreadID  *string `json:"threadId,omitempty"`
}

type AiPinConnection struct {
	PageInfo PageInfo     `json:"pageInfo"`
	Edges    []*AiPinEdge `json:"edges,omitempty"`
}

type AiPinEdge struct {
	Node   *AiPin  `json:"node,omitempty"`
	Cursor *string `json:"cursor,omitempty"`
}

// Settings for configuring access to common LLM providers
type AiSettings struct {
	Enabled      *bool       `json:"enabled,omitempty"`
	ToolsEnabled *bool       `json:"toolsEnabled,omitempty"`
	Provider     *AiProvider `json:"provider,omitempty"`
	// ai provider to use with tool calls
	ToolProvider *AiProvider          `json:"toolProvider,omitempty"`
	Openai       *OpenaiSettings      `json:"openai,omitempty"`
	Anthropic    *AnthropicSettings   `json:"anthropic,omitempty"`
	Ollama       *OllamaSettings      `json:"ollama,omitempty"`
	Azure        *AzureOpenaiSettings `json:"azure,omitempty"`
	Bedrock      *BedrockAiSettings   `json:"bedrock,omitempty"`
	Vertex       *VertexAiSettings    `json:"vertex,omitempty"`
}

type AiSettingsAttributes struct {
	Enabled  *bool                 `json:"enabled,omitempty"`
	Tools    *ToolConfigAttributes `json:"tools,omitempty"`
	Provider *AiProvider           `json:"provider,omitempty"`
	// ai provider to use with tool calls
	ToolProvider *AiProvider `json:"toolProvider,omitempty"`
	// ai provider to use with embeddings (for vector indexing)
	EmbeddingProvider *AiProvider                  `json:"embeddingProvider,omitempty"`
	Openai            *OpenaiSettingsAttributes    `json:"openai,omitempty"`
	Anthropic         *AnthropicSettingsAttributes `json:"anthropic,omitempty"`
	Ollama            *OllamaAttributes            `json:"ollama,omitempty"`
	Azure             *AzureOpenaiAttributes       `json:"azure,omitempty"`
	Bedrock           *BedrockAiAttributes         `json:"bedrock,omitempty"`
	Vertex            *VertexAiAttributes          `json:"vertex,omitempty"`
	VectorStore       *VectorStoreAttributes       `json:"vectorStore,omitempty"`
	Graph             *GraphStoreAttributes        `json:"graph,omitempty"`
}

type Alert struct {
	ID          string                   `json:"id"`
	Type        ObservabilityWebhookType `json:"type"`
	Severity    AlertSeverity            `json:"severity"`
	State       AlertState               `json:"state"`
	Title       *string                  `json:"title,omitempty"`
	Message     *string                  `json:"message,omitempty"`
	Fingerprint *string                  `json:"fingerprint,omitempty"`
	Annotations map[string]any           `json:"annotations,omitempty"`
	URL         *string                  `json:"url,omitempty"`
	// key/value tags to filter clusters
	Tags []*Tag `json:"tags,omitempty"`
	// the resolution for this alert
	Resolution *AlertResolution `json:"resolution,omitempty"`
	// an insight explaining the state of this alert
	Insight *AiInsight `json:"insight,omitempty"`
	// the cluster this alert was associated with
	Cluster *Cluster `json:"cluster,omitempty"`
	// the service this alert was associated with
	Service *Service `json:"service,omitempty"`
	// the project this alert was associated with
	Project    *Project `json:"project,omitempty"`
	InsertedAt *string  `json:"insertedAt,omitempty"`
	UpdatedAt  *string  `json:"updatedAt,omitempty"`
}

type AlertConnection struct {
	PageInfo PageInfo     `json:"pageInfo"`
	Edges    []*AlertEdge `json:"edges,omitempty"`
}

type AlertEdge struct {
	Node   *Alert  `json:"node,omitempty"`
	Cursor *string `json:"cursor,omitempty"`
}

type AlertEvidence struct {
	Title      *string `json:"title,omitempty"`
	Message    *string `json:"message,omitempty"`
	AlertID    *string `json:"alertId,omitempty"`
	Resolution *string `json:"resolution,omitempty"`
}

type AlertResolution struct {
	ID string `json:"id"`
	// the resolution for this alert
	Resolution string `json:"resolution"`
	// the alert this resolution was associated with
	Alert      *Alert  `json:"alert,omitempty"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

type AlertResolutionAttributes struct {
	Resolution string `json:"resolution"`
}

// Anthropic connection information
type AnthropicSettings struct {
	// the anthropic model version to use
	Model *string `json:"model,omitempty"`
	// the model to use for tool calls, which are less frequent and require more complex reasoning
	ToolModel *string `json:"toolModel,omitempty"`
}

type AnthropicSettingsAttributes struct {
	AccessToken *string `json:"accessToken,omitempty"`
	Model       *string `json:"model,omitempty"`
	// the model to use for tool calls, which are less frequent and require more complex reasoning
	ToolModel *string `json:"toolModel,omitempty"`
	// the model to use for vector embeddings
	EmbeddingModel *string `json:"embeddingModel,omitempty"`
}

// a representation of a kubernetes api deprecation
type APIDeprecation struct {
	// the kubernetes version the deprecation was posted
	DeprecatedIn *string `json:"deprecatedIn,omitempty"`
	// the kubernetes version the api version will be removed and unusable in
	RemovedIn *string `json:"removedIn,omitempty"`
	// the api you can replace this resource with
	Replacement *string `json:"replacement,omitempty"`
	// the kubernetes version the replacement api was created in
	AvailableIn *string `json:"availableIn,omitempty"`
	// whether you cannot safely upgrade to the next kubernetes version if this deprecation exists
	Blocking *bool `json:"blocking,omitempty"`
	// the component of this deprecation
	Component *ServiceComponent `json:"component,omitempty"`
}

type AppNotification struct {
	ID         string                `json:"id"`
	Priority   *NotificationPriority `json:"priority,omitempty"`
	Text       *string               `json:"text,omitempty"`
	ReadAt     *string               `json:"readAt,omitempty"`
	InsertedAt *string               `json:"insertedAt,omitempty"`
	UpdatedAt  *string               `json:"updatedAt,omitempty"`
}

type AppNotificationConnection struct {
	PageInfo PageInfo               `json:"pageInfo"`
	Edges    []*AppNotificationEdge `json:"edges,omitempty"`
}

type AppNotificationEdge struct {
	Node   *AppNotification `json:"node,omitempty"`
	Cursor *string          `json:"cursor,omitempty"`
}

type ArgoAnalysis struct {
	Templates []*ArgoAnalysisTemplate `json:"templates,omitempty"`
}

type ArgoAnalysisTemplate struct {
	TemplateName *string `json:"templateName,omitempty"`
}

type ArgoBlueGreenStrategy struct {
	ActiveService        *string `json:"activeService,omitempty"`
	AutoPromotionEnabled *bool   `json:"autoPromotionEnabled,omitempty"`
	AutoPromotionSeconds *int64  `json:"autoPromotionSeconds,omitempty"`
}

type ArgoCanaryStrategy struct {
	Steps []*ArgoStrategyStep `json:"steps,omitempty"`
}

type ArgoExperiment struct {
	Templates []*ArgoExperimentTemplate `json:"templates,omitempty"`
}

type ArgoExperimentTemplate struct {
	Name *string `json:"name,omitempty"`
}

type ArgoRollout struct {
	Metadata Metadata          `json:"metadata"`
	Status   ArgoRolloutStatus `json:"status"`
	Spec     ArgoRolloutSpec   `json:"spec"`
	Pods     []*Pod            `json:"pods,omitempty"`
	Raw      string            `json:"raw"`
	Events   []*Event          `json:"events,omitempty"`
}

type ArgoRolloutSpec struct {
	Replicas *int64               `json:"replicas,omitempty"`
	Strategy *ArgoRolloutStrategy `json:"strategy,omitempty"`
}

type ArgoRolloutStatus struct {
	Abort           *bool              `json:"abort,omitempty"`
	Phase           *string            `json:"phase,omitempty"`
	Replicas        *int64             `json:"replicas,omitempty"`
	ReadyReplicas   *int64             `json:"readyReplicas,omitempty"`
	PauseConditions []*PauseCondition  `json:"pauseConditions,omitempty"`
	Conditions      []*StatusCondition `json:"conditions,omitempty"`
}

type ArgoRolloutStrategy struct {
	BlueGreen *ArgoBlueGreenStrategy `json:"blueGreen,omitempty"`
	Canary    *ArgoCanaryStrategy    `json:"canary,omitempty"`
}

type ArgoStrategyStep struct {
	SetWeight  *int64          `json:"setWeight,omitempty"`
	Pause      *CanaryPause    `json:"pause,omitempty"`
	Experiment *ArgoExperiment `json:"experiment,omitempty"`
	Analysis   *ArgoAnalysis   `json:"analysis,omitempty"`
}

type Audit struct {
	ID         string      `json:"id"`
	Action     AuditAction `json:"action"`
	Type       AuditType   `json:"type"`
	Repository *string     `json:"repository,omitempty"`
	IP         *string     `json:"ip,omitempty"`
	City       *string     `json:"city,omitempty"`
	Country    *string     `json:"country,omitempty"`
	Latitude   *string     `json:"latitude,omitempty"`
	Longitude  *string     `json:"longitude,omitempty"`
	Actor      *User       `json:"actor,omitempty"`
	InsertedAt *string     `json:"insertedAt,omitempty"`
	UpdatedAt  *string     `json:"updatedAt,omitempty"`
}

type AuditConnection struct {
	PageInfo PageInfo     `json:"pageInfo"`
	Edges    []*AuditEdge `json:"edges,omitempty"`
}

type AuditEdge struct {
	Node   *Audit  `json:"node,omitempty"`
	Cursor *string `json:"cursor,omitempty"`
}

type AuditMetric struct {
	Country *string `json:"country,omitempty"`
	Count   *int64  `json:"count,omitempty"`
}

type AvailableFeatures struct {
	Vpn                *bool `json:"vpn,omitempty"`
	Audits             *bool `json:"audits,omitempty"`
	Cd                 *bool `json:"cd,omitempty"`
	UserManagement     *bool `json:"userManagement,omitempty"`
	DatabaseManagement *bool `json:"databaseManagement,omitempty"`
}

// aws node customizations
type AWSCloud struct {
	// custom launch template for your nodes, useful for Golden AMI setups
	LaunchTemplateID *string `json:"launchTemplateId,omitempty"`
}

type AWSCloudAttributes struct {
	Region *string `json:"region,omitempty"`
}

type AWSCloudConnectionAttributes struct {
	AccessKeyID     string `json:"accessKeyId"`
	SecretAccessKey string `json:"secretAccessKey"`
	Region          string `json:"region"`
}

// aws specific cloud configuration
type AWSCloudSettings struct {
	Region *string `json:"region,omitempty"`
}

// The configuration for a cloud provider
type AWSConnectionAttributes struct {
	// the access key id for aws
	AccessKeyID string `json:"accessKeyId"`
	// the secret access key for aws
	SecretAccessKey string `json:"secretAccessKey"`
	// the region for aws
	Region string `json:"region"`
}

type AWSNodeCloudAttributes struct {
	LaunchTemplateID *string `json:"launchTemplateId,omitempty"`
}

type AWSSettingsAttributes struct {
	AccessKeyID     string `json:"accessKeyId"`
	SecretAccessKey string `json:"secretAccessKey"`
}

type AzureCloudAttributes struct {
	Location       *string `json:"location,omitempty"`
	SubscriptionID *string `json:"subscriptionId,omitempty"`
	ResourceGroup  *string `json:"resourceGroup,omitempty"`
	Network        *string `json:"network,omitempty"`
}

type AzureCloudConnectionAttributes struct {
	SubscriptionID string `json:"subscriptionId"`
	TenantID       string `json:"tenantId"`
	ClientID       string `json:"clientId"`
	ClientSecret   string `json:"clientSecret"`
}

// azure-specific cluster cloud configuration
type AzureCloudSettings struct {
	Location       *string `json:"location,omitempty"`
	SubscriptionID *string `json:"subscriptionId,omitempty"`
	ResourceGroup  *string `json:"resourceGroup,omitempty"`
	Network        *string `json:"network,omitempty"`
}

// The configuration for a cloud provider
type AzureConnectionAttributes struct {
	// the subscription id for azure
	SubscriptionID string `json:"subscriptionId"`
	// the tenant id for azure
	TenantID string `json:"tenantId"`
	// the client id for azure
	ClientID string `json:"clientId"`
	// the client secret for azure
	ClientSecret string `json:"clientSecret"`
}

type AzureOpenaiAttributes struct {
	// the endpoint of your azure openai version, should look like: https://{endpoint}/openai/deployments/{deployment-id}
	Endpoint string `json:"endpoint"`
	// the api version you want to use
	APIVersion *string `json:"apiVersion,omitempty"`
	// the exact model you wish to use
	Model *string `json:"model,omitempty"`
	// the model to use for tool calls, which are less frequent and require more complex reasoning
	ToolModel *string `json:"toolModel,omitempty"`
	// the model to use for vector embeddings
	EmbeddingModel *string `json:"embeddingModel,omitempty"`
	// the azure openai access token to use
	AccessToken string `json:"accessToken"`
}

// Settings for configuring against Azure OpenAI
type AzureOpenaiSettings struct {
	// the endpoint of your azure openai version, should look like: https://{endpoint}/openai/deployments/{deployment-id}
	Endpoint string  `json:"endpoint"`
	Model    *string `json:"model,omitempty"`
	// the model to use for tool calls, which are less frequent and require more complex reasoning
	ToolModel *string `json:"toolModel,omitempty"`
	// the api version you want to use
	APIVersion *string `json:"apiVersion,omitempty"`
}

type AzureSettingsAttributes struct {
	TenantID       string `json:"tenantId"`
	SubscriptionID string `json:"subscriptionId"`
	ClientID       string `json:"clientId"`
	ClientSecret   string `json:"clientSecret"`
}

type AzureStore struct {
	StorageAccount string `json:"storageAccount"`
	Container      string `json:"container"`
	SubscriptionID string `json:"subscriptionId"`
	ResourceGroup  string `json:"resourceGroup"`
	TenantID       string `json:"tenantId"`
	ClientID       string `json:"clientId"`
}

type AzureStoreAttributes struct {
	StorageAccount string `json:"storageAccount"`
	Container      string `json:"container"`
	SubscriptionID string `json:"subscriptionId"`
	ResourceGroup  string `json:"resourceGroup"`
	TenantID       string `json:"tenantId"`
	ClientID       string `json:"clientId"`
	ClientSecret   string `json:"clientSecret"`
}

type BackupAttributes struct {
	Name             string                      `json:"name"`
	Namespace        string                      `json:"namespace"`
	GarbageCollected *bool                       `json:"garbageCollected,omitempty"`
	TTL              *string                     `json:"ttl,omitempty"`
	Namespaces       *ResourceSelectorAttributes `json:"namespaces,omitempty"`
	Resources        *ResourceSelectorAttributes `json:"resources,omitempty"`
}

type BedrockAiAttributes struct {
	// the bedrock model id to use
	ModelID string `json:"modelId"`
	// the model to use for tool calls, which are less frequent and require more complex reasoning
	ToolModelID *string `json:"toolModelId,omitempty"`
	// aws access key id to use, you can also use IRSA for self-hosted consoles
	AccessKeyID *string `json:"accessKeyId,omitempty"`
	// aws secret access key to use, you can also use IRSA for self-hosted consoles
	SecretAccessKey *string `json:"secretAccessKey,omitempty"`
	// the model to use for vector embeddings
	EmbeddingModel *string `json:"embeddingModel,omitempty"`
}

// Settings for usage of AWS Bedrock for LLMs
type BedrockAiSettings struct {
	// the bedrock model to use
	ModelID string `json:"modelId"`
	// the model to use for tool calls, which are less frequent and require more complex reasoning
	ToolModelID *string `json:"toolModelId,omitempty"`
	// the aws access key to use, can also use IRSA when console is self-hosted
	AccessKeyID *string `json:"accessKeyId,omitempty"`
}

type BindingAttributes struct {
	ID      *string `json:"id,omitempty"`
	UserID  *string `json:"userId,omitempty"`
	GroupID *string `json:"groupId,omitempty"`
}

// A restricted token meant only for use in registering clusters, esp for edge devices
type BootstrapToken struct {
	ID string `json:"id"`
	// the token to use when bootstrapping clusters
	Token string `json:"token"`
	User  *User  `json:"user,omitempty"`
	// the project for all clusters to live within
	Project    *Project `json:"project,omitempty"`
	InsertedAt *string  `json:"insertedAt,omitempty"`
	UpdatedAt  *string  `json:"updatedAt,omitempty"`
}

type BootstrapTokenAttributes struct {
	// An optional external user id to be the user identity for this bootstrap token in audit logs
	UserID *string `json:"userId,omitempty"`
	// the project all clusters spawned by this bootstrap token are put into
	ProjectID string `json:"projectId"`
}

type Canary struct {
	Metadata          Metadata     `json:"metadata"`
	Status            CanaryStatus `json:"status"`
	Spec              CanarySpec   `json:"spec"`
	PrimaryDeployment *Deployment  `json:"primaryDeployment,omitempty"`
	CanaryDeployment  *Deployment  `json:"canaryDeployment,omitempty"`
	Ingress           *Ingress     `json:"ingress,omitempty"`
	IngressCanary     *Ingress     `json:"ingressCanary,omitempty"`
	Raw               string       `json:"raw"`
	Events            []*Event     `json:"events,omitempty"`
}

type CanaryAnalysis struct {
	Interval    *string  `json:"interval,omitempty"`
	MaxWeight   *int64   `json:"maxWeight,omitempty"`
	StepWeight  *int64   `json:"stepWeight,omitempty"`
	StepWeights []*int64 `json:"stepWeights,omitempty"`
	Threshold   *int64   `json:"threshold,omitempty"`
}

type CanaryPause struct {
	Duration *string `json:"duration,omitempty"`
}

type CanarySpec struct {
	AutoscalerRef *TargetRef      `json:"autoscalerRef,omitempty"`
	TargetRef     *TargetRef      `json:"targetRef,omitempty"`
	IngressRef    *TargetRef      `json:"ingressRef,omitempty"`
	Analysis      *CanaryAnalysis `json:"analysis,omitempty"`
	Provider      *string         `json:"provider,omitempty"`
}

type CanaryStatus struct {
	Conditions         []*StatusCondition `json:"conditions,omitempty"`
	FailedChecks       *int64             `json:"failedChecks,omitempty"`
	CanaryWeight       *int64             `json:"canaryWeight,omitempty"`
	Iterations         *int64             `json:"iterations,omitempty"`
	LastTransitionTime *string            `json:"lastTransitionTime,omitempty"`
	Phase              *string            `json:"phase,omitempty"`
}

// A spec for specifying cascade behavior on an owning resource
type Cascade struct {
	// whether to perform a drain-delete for all owned resources
	Delete *bool `json:"delete,omitempty"`
	// whether to perform a detach-delete for all owned resources
	Detach *bool `json:"detach,omitempty"`
}

// Whether you want to delete or detach owned resources
type CascadeAttributes struct {
	Delete *bool `json:"delete,omitempty"`
	Detach *bool `json:"detach,omitempty"`
}

// A catalog is an organized collection of PR Automations used for permissioning and discovery
type Catalog struct {
	ID   string `json:"id"`
	Name string `json:"name"`
	// longform description for the purpose of this catalog
	Description *string `json:"description,omitempty"`
	// short category name used for browsing catalogs
	Category *string `json:"category,omitempty"`
	// the name of the author of this catalog
	Author *string `json:"author,omitempty"`
	// an icon url to use for this catalog
	Icon *string `json:"icon,omitempty"`
	// a darkmode icon url to use for this catalog
	DarkIcon *string  `json:"darkIcon,omitempty"`
	Project  *Project `json:"project,omitempty"`
	// read policy for this catalog
	ReadBindings []*PolicyBinding `json:"readBindings,omitempty"`
	// write policy for this catalog
	WriteBindings []*PolicyBinding `json:"writeBindings,omitempty"`
	// create policy for this catalog, can give permission to just create prs
	CreateBindings []*PolicyBinding `json:"createBindings,omitempty"`
	InsertedAt     *string          `json:"insertedAt,omitempty"`
	UpdatedAt      *string          `json:"updatedAt,omitempty"`
}

type CatalogAttributes struct {
	Name string `json:"name"`
	// the name of the author of this catalog, used for attribution only
	Author      string  `json:"author"`
	Description *string `json:"description,omitempty"`
	// short category name for browsability
	Category *string `json:"category,omitempty"`
	// owning project of the catalog, permissions will propagate down
	ProjectID *string `json:"projectId,omitempty"`
	// an icon url to use for this catalog
	Icon *string `json:"icon,omitempty"`
	// a darkmode icon url to use for this catalog
	DarkIcon       *string                    `json:"darkIcon,omitempty"`
	Tags           []*TagAttributes           `json:"tags,omitempty"`
	ReadBindings   []*PolicyBindingAttributes `json:"readBindings,omitempty"`
	WriteBindings  []*PolicyBindingAttributes `json:"writeBindings,omitempty"`
	CreateBindings []*PolicyBindingAttributes `json:"createBindings,omitempty"`
}

type CatalogConnection struct {
	PageInfo PageInfo       `json:"pageInfo"`
	Edges    []*CatalogEdge `json:"edges,omitempty"`
}

type CatalogEdge struct {
	Node   *Catalog `json:"node,omitempty"`
	Cursor *string  `json:"cursor,omitempty"`
}

type Certificate struct {
	Metadata Metadata          `json:"metadata"`
	Status   CertificateStatus `json:"status"`
	Spec     CertificateSpec   `json:"spec"`
	Raw      string            `json:"raw"`
	Events   []*Event          `json:"events,omitempty"`
}

type CertificateSpec struct {
	DNSNames   []*string  `json:"dnsNames,omitempty"`
	SecretName string     `json:"secretName"`
	IssuerRef  *IssuerRef `json:"issuerRef,omitempty"`
}

type CertificateStatus struct {
	Conditions  []*StatusCondition `json:"conditions,omitempty"`
	NotAfter    *string            `json:"notAfter,omitempty"`
	NotBefore   *string            `json:"notBefore,omitempty"`
	RenewalTime *string            `json:"renewalTime,omitempty"`
}

type Chat struct {
	ID      string   `json:"id"`
	Type    ChatType `json:"type"`
	Role    AiRole   `json:"role"`
	Content *string  `json:"content,omitempty"`
	Seq     int64    `json:"seq"`
	// whether this chat requires confirmation
	Confirm *bool `json:"confirm,omitempty"`
	// when the chat was confirmed
	ConfirmedAt  *string             `json:"confirmedAt,omitempty"`
	Attributes   *ChatTypeAttributes `json:"attributes,omitempty"`
	PullRequest  *PullRequest        `json:"pullRequest,omitempty"`
	Thread       *ChatThread         `json:"thread,omitempty"`
	Server       *McpServer          `json:"server,omitempty"`
	PrAutomation *PrAutomation       `json:"prAutomation,omitempty"`
	InsertedAt   *string             `json:"insertedAt,omitempty"`
	UpdatedAt    *string             `json:"updatedAt,omitempty"`
}

type ChatConnection struct {
	PageInfo PageInfo    `json:"pageInfo"`
	Edges    []*ChatEdge `json:"edges,omitempty"`
}

type ChatEdge struct {
	Node   *Chat   `json:"node,omitempty"`
	Cursor *string `json:"cursor,omitempty"`
}

// Additional attributes for describing a file type chat
type ChatFile struct {
	Name *string `json:"name,omitempty"`
}

// A basic AI chat message input, modeled after OpenAI's api model
type ChatMessage struct {
	Role    AiRole `json:"role"`
	Content string `json:"content"`
}

// A list of chat messages around a specific topic created on demand
type ChatThread struct {
	ID            string              `json:"id"`
	Summary       string              `json:"summary"`
	Default       bool                `json:"default"`
	Settings      *ChatThreadSettings `json:"settings,omitempty"`
	LastMessageAt *string             `json:"lastMessageAt,omitempty"`
	Flow          *Flow               `json:"flow,omitempty"`
	User          *User               `json:"user,omitempty"`
	Insight       *AiInsight          `json:"insight,omitempty"`
	// the tools associated with this chat.  This is a complex operation that requires querying associated mcp servers, do not use in lists
	Tools      []*McpServerTool `json:"tools,omitempty"`
	Chats      *ChatConnection  `json:"chats,omitempty"`
	InsertedAt *string          `json:"insertedAt,omitempty"`
	UpdatedAt  *string          `json:"updatedAt,omitempty"`
}

// basic user-supplied input for creating an AI chat thread
type ChatThreadAttributes struct {
	Summary string `json:"summary"`
	// controls whether this thread is autosummarized, set true when users explicitly set summary
	Summarized *bool `json:"summarized,omitempty"`
	// a list of messages to add initially when creating this thread
	Messages []*ChatMessage `json:"messages,omitempty"`
	// an ai insight this thread was created from
	InsightID *string `json:"insightId,omitempty"`
	// the flow this thread was created in
	FlowID *string `json:"flowId,omitempty"`
	// the settings for this thread
	Settings *ChatThreadSettingsAttributes `json:"settings,omitempty"`
	// the session to use for this thread
	Session *AgentSessionAttributes `json:"session,omitempty"`
}

type ChatThreadConnection struct {
	PageInfo PageInfo          `json:"pageInfo"`
	Edges    []*ChatThreadEdge `json:"edges,omitempty"`
}

type ChatThreadEdge struct {
	Node   *ChatThread `json:"node,omitempty"`
	Cursor *string     `json:"cursor,omitempty"`
}

// the settings for an AI chat thread
type ChatThreadSettings struct {
	// controls whether this thread uses knowledge graph-basedmemory
	Memory *bool `json:"memory,omitempty"`
}

// the settings for an AI chat thread
type ChatThreadSettingsAttributes struct {
	// controls whether this thread uses knowledge graph-basedmemory
	Memory *bool `json:"memory,omitempty"`
}

// Additional attributes for describing a tool call that derived this chat message
type ChatTool struct {
	Name      *string        `json:"name,omitempty"`
	Arguments map[string]any `json:"arguments,omitempty"`
}

// Additional attributes of this chat message, used for formatting it in the display
type ChatTypeAttributes struct {
	File   *ChatFile         `json:"file,omitempty"`
	Tool   *ChatTool         `json:"tool,omitempty"`
	PrCall *PrCallAttributes `json:"prCall,omitempty"`
}

type CloudAddon struct {
	ID          string                        `json:"id"`
	Distro      ClusterDistro                 `json:"distro"`
	Name        string                        `json:"name"`
	Version     string                        `json:"version"`
	Info        *CloudAddonInformation        `json:"info,omitempty"`
	VersionInfo *CloudAddonVersionInformation `json:"versionInfo,omitempty"`
	Cluster     *Cluster                      `json:"cluster,omitempty"`
	InsertedAt  *string                       `json:"insertedAt,omitempty"`
	UpdatedAt   *string                       `json:"updatedAt,omitempty"`
}

type CloudAddonAttributes struct {
	Distro  *ClusterDistro `json:"distro,omitempty"`
	Name    *string        `json:"name,omitempty"`
	Version *string        `json:"version,omitempty"`
}

type CloudAddonInformation struct {
	Name      *string                         `json:"name,omitempty"`
	Publisher *string                         `json:"publisher,omitempty"`
	Versions  []*CloudAddonVersionInformation `json:"versions,omitempty"`
}

type CloudAddonVersionInformation struct {
	Version         *string   `json:"version,omitempty"`
	Compatibilities []*string `json:"compatibilities,omitempty"`
	// checks if this is blocking a specific kubernetes upgrade
	Blocking *bool `json:"blocking,omitempty"`
}

// A read-only connection to a cloud provider
type CloudConnection struct {
	ID string `json:"id"`
	// the name of the cloud connection
	Name string `json:"name"`
	// the provider of the cloud connection
	Provider Provider `json:"provider"`
	// the configuration for the cloud connection
	Configuration CloudConnectionConfiguration `json:"configuration"`
	// read policy across this cloud connection
	ReadBindings []*PolicyBinding `json:"readBindings,omitempty"`
	InsertedAt   *string          `json:"insertedAt,omitempty"`
	UpdatedAt    *string          `json:"updatedAt,omitempty"`
}

type CloudConnectionAttributes struct {
	Name          string                                 `json:"name"`
	Provider      Provider                               `json:"provider"`
	Configuration CloudConnectionConfigurationAttributes `json:"configuration"`
	ReadBindings  []*PolicyBindingAttributes             `json:"readBindings,omitempty"`
}

// The configuration for a cloud provider
type CloudConnectionConfiguration struct {
	// the credentials for aws
	AWS *AWSConnectionAttributes `json:"aws,omitempty"`
	// the credentials for gcp
	GCP *GCPConnectionAttributes `json:"gcp,omitempty"`
	// the credentials for azure
	Azure *AzureConnectionAttributes `json:"azure,omitempty"`
}

type CloudConnectionConfigurationAttributes struct {
	AWS   *AWSCloudConnectionAttributes   `json:"aws,omitempty"`
	GCP   *GCPCloudConnectionAttributes   `json:"gcp,omitempty"`
	Azure *AzureCloudConnectionAttributes `json:"azure,omitempty"`
}

type CloudConnectionConnection struct {
	PageInfo PageInfo               `json:"pageInfo"`
	Edges    []*CloudConnectionEdge `json:"edges,omitempty"`
}

type CloudConnectionEdge struct {
	Node   *CloudConnection `json:"node,omitempty"`
	Cursor *string          `json:"cursor,omitempty"`
}

type CloudProviderSettingsAttributes struct {
	AWS   *AWSSettingsAttributes   `json:"aws,omitempty"`
	GCP   *GCPSettingsAttributes   `json:"gcp,omitempty"`
	Azure *AzureSettingsAttributes `json:"azure,omitempty"`
}

// the cloud configuration for a cluster
type CloudSettings struct {
	AWS   *AWSCloudSettings   `json:"aws,omitempty"`
	GCP   *GCPCloudSettings   `json:"gcp,omitempty"`
	Azure *AzureCloudSettings `json:"azure,omitempty"`
}

type CloudSettingsAttributes struct {
	AWS   *AWSCloudAttributes   `json:"aws,omitempty"`
	GCP   *GCPCloudAttributes   `json:"gcp,omitempty"`
	Azure *AzureCloudAttributes `json:"azure,omitempty"`
}

// a representation of a cluster you can deploy to
type Cluster struct {
	// internal id of this cluster
	ID string `json:"id"`
	// whether this is the management cluster itself
	Self *bool `json:"self,omitempty"`
	// human readable name of this cluster, will also translate to cloud k8s name
	Name string `json:"name"`
	// if true, this cluster cannot be deleted
	Protect *bool `json:"protect,omitempty"`
	// whether this is actually a virtual cluster
	Virtual *bool `json:"virtual,omitempty"`
	// desired k8s version for the cluster
	Version *string `json:"version,omitempty"`
	// the distribution of kubernetes this cluster is running
	Distro *ClusterDistro `json:"distro,omitempty"`
	// arbitrary json metadata to store user-specific state of this cluster (eg IAM roles for add-ons)
	Metadata map[string]any `json:"metadata,omitempty"`
	// current k8s version as told to us by the deployment operator
	CurrentVersion *string `json:"currentVersion,omitempty"`
	// The lowest discovered kubelet version for all nodes in the cluster
	KubeletVersion *string `json:"kubeletVersion,omitempty"`
	// The health score of the cluster
	HealthScore *int64 `json:"healthScore,omitempty"`
	// a short, unique human readable name used to identify this cluster and does not necessarily map to the cloud resource name
	Handle *string `json:"handle,omitempty"`
	// whether the deploy operator has been registered for this cluster
	Installed *bool `json:"installed,omitempty"`
	// the cloud settings for this cluster (for instance its aws region)
	Settings *CloudSettings `json:"settings,omitempty"`
	// Checklist of tasks to complete to safely upgrade this cluster
	UpgradePlan *ClusterUpgradePlan `json:"upgradePlan,omitempty"`
	// The helm values for the agent installation
	AgentHelmValues *string `json:"agentHelmValues,omitempty"`
	// Whether this cluster was recently pinged
	Healthy *bool `json:"healthy,omitempty"`
	// the url of the kas server you can access this cluster from
	KasURL *string `json:"kasUrl,omitempty"`
	// the url this clusters deployment operator will use for gql requests
	AgentURL *string `json:"agentUrl,omitempty"`
	// a auth token to be used by the deploy operator, only readable on create
	DeployToken *string `json:"deployToken,omitempty"`
	// when this cluster was scheduled for deletion
	DeletedAt *string `json:"deletedAt,omitempty"`
	// last time the deploy operator pinged this cluster
	PingedAt *string `json:"pingedAt,omitempty"`
	// read policy for this cluster
	ReadBindings []*PolicyBinding `json:"readBindings,omitempty"`
	// write policy for this cluster
	WriteBindings []*PolicyBinding `json:"writeBindings,omitempty"`
	// the project this cluster belongs to
	Project *Project `json:"project,omitempty"`
	// list of node pool specs managed by CAPI
	NodePools []*NodePool `json:"nodePools,omitempty"`
	// the provider we use to create this cluster (null if BYOK)
	Provider *ClusterProvider `json:"provider,omitempty"`
	// a custom credential to use when provisioning this cluster
	Credential *ProviderCredential `json:"credential,omitempty"`
	// the service used to deploy the CAPI resources of this cluster
	Service *ServiceDeployment `json:"service,omitempty"`
	// key/value tags to filter clusters
	Tags []*Tag `json:"tags,omitempty"`
	// all api deprecations for all services in this cluster
	APIDeprecations []*APIDeprecation `json:"apiDeprecations,omitempty"`
	// any errors which might have occurred during the bootstrap process
	ServiceErrors []*ServiceError `json:"serviceErrors,omitempty"`
	// a custom git repository if you want to define your own CAPI manifests
	Repository *GitRepository `json:"repository,omitempty"`
	// pr automations that are relevant to managing this cluster
	PrAutomations []*PrAutomation `json:"prAutomations,omitempty"`
	// the active restore for this cluster
	Restore *ClusterRestore `json:"restore,omitempty"`
	// the object store connection bound to this cluster for backup/restore
	ObjectStore *ObjectStore `json:"objectStore,omitempty"`
	// the parent of this virtual cluster
	ParentCluster *Cluster `json:"parentCluster,omitempty"`
	// an ai insight generated about issues discovered which might impact the health of this cluster
	Insight *AiInsight `json:"insight,omitempty"`
	// a high level description of the setup of common resources in a cluster
	OperationalLayout *OperationalLayout `json:"operationalLayout,omitempty"`
	// a set of kubernetes resources used to generate the ai insight for this cluster
	InsightComponents []*ClusterInsightComponent `json:"insightComponents,omitempty"`
	// list cached nodes for a cluster, this can be stale up to 5m
	Nodes []*Node `json:"nodes,omitempty"`
	// list the cached node metrics for a cluster, can also be stale up to 5m
	NodeMetrics []*NodeMetric `json:"nodeMetrics,omitempty"`
	// custom resources with dedicated views for this cluster
	PinnedCustomResources []*PinnedCustomResource `json:"pinnedCustomResources,omitempty"`
	// any upgrade insights provided by your cloud provider that have been discovered by our agent
	UpgradeInsights []*UpgradeInsight `json:"upgradeInsights,omitempty"`
	// A summation of the metrics utilization of the current cluster
	MetricsSummary *ClusterMetricsSummary `json:"metricsSummary,omitempty"`
	// the status of the cluster as seen from the CAPI operator, since some clusters can be provisioned without CAPI, this can be null
	Status *ClusterStatus `json:"status,omitempty"`
	// a relay connection of all revisions of this cluster, these are periodically pruned up to a history limit
	Revisions *ClusterRevisionConnection `json:"revisions,omitempty"`
	// lists OPA constraints registered in this cluster
	PolicyConstraints *PolicyConstraintConnection `json:"policyConstraints,omitempty"`
	// Computes a list of statistics for OPA constraint violations w/in this cluster
	ViolationStatistics []*ViolationStatistic `json:"violationStatistics,omitempty"`
	// list all alerts discovered for this cluster
	Alerts *AlertConnection `json:"alerts,omitempty"`
	// Queries logs for a cluster out of loki
	Logs               []*LogStream        `json:"logs,omitempty"`
	ClusterMetrics     *ClusterMetrics     `json:"clusterMetrics,omitempty"`
	ClusterNodeMetrics *ClusterNodeMetrics `json:"clusterNodeMetrics,omitempty"`
	NetworkGraph       []*NetworkMeshEdge  `json:"networkGraph,omitempty"`
	// a list of node healthstatistics for this cluster
	NodeStatistics []*NodeStatistic `json:"nodeStatistics,omitempty"`
	// A pod-level set of utilization metrics for this cluster for rendering a heat map
	HeatMap *UtilizationHeatMap `json:"heatMap,omitempty"`
	// A pod-level set of utilization metrics exceeding our noisy threshold
	NoisyNeighbors *UtilizationHeatMap `json:"noisyNeighbors,omitempty"`
	// fetches a list of runtime services found in this cluster, this is an expensive operation that should not be done in list queries
	RuntimeServices []*RuntimeService `json:"runtimeServices,omitempty"`
	// fetches the discovered custom resources with new versions to be used
	DeprecatedCustomResources []*DeprecatedCustomResource `json:"deprecatedCustomResources,omitempty"`
	// any upgrade insights provided by your cloud provider that have been discovered by our agent
	CloudAddons []*CloudAddon `json:"cloudAddons,omitempty"`
	// whether the current user can edit this cluster
	Editable   *bool                      `json:"editable,omitempty"`
	AuditLogs  *ClusterAuditLogConnection `json:"auditLogs,omitempty"`
	InsertedAt *string                    `json:"insertedAt,omitempty"`
	UpdatedAt  *string                    `json:"updatedAt,omitempty"`
}

// A common kubernetes cluster add-on like cert-manager, istio, etc
type ClusterAddOn struct {
	Name          *string               `json:"name,omitempty"`
	Version       *string               `json:"version,omitempty"`
	Icon          *string               `json:"icon,omitempty"`
	Global        *bool                 `json:"global,omitempty"`
	Configuration []*AddOnConfiguration `json:"configuration,omitempty"`
}

type ClusterAttributes struct {
	Name string `json:"name"`
	// a short, unique human readable name used to identify this cluster and does not necessarily map to the cloud resource name
	Handle     *string `json:"handle,omitempty"`
	ProviderID *string `json:"providerId,omitempty"`
	// a cloud credential to use when provisioning this cluster
	CredentialID  *string                  `json:"credentialId,omitempty"`
	Version       *string                  `json:"version,omitempty"`
	Distro        *ClusterDistro           `json:"distro,omitempty"`
	Metadata      *string                  `json:"metadata,omitempty"`
	Protect       *bool                    `json:"protect,omitempty"`
	Kubeconfig    *KubeconfigAttributes    `json:"kubeconfig,omitempty"`
	CloudSettings *CloudSettingsAttributes `json:"cloudSettings,omitempty"`
	// the project id this cluster will belong to
	ProjectID *string `json:"projectId,omitempty"`
	// status of the upgrade plan for this cluster
	UpgradePlan   *UpgradePlanAttributes     `json:"upgradePlan,omitempty"`
	NodePools     []*NodePoolAttributes      `json:"nodePools,omitempty"`
	ReadBindings  []*PolicyBindingAttributes `json:"readBindings,omitempty"`
	WriteBindings []*PolicyBindingAttributes `json:"writeBindings,omitempty"`
	Tags          []*TagAttributes           `json:"tags,omitempty"`
}

type ClusterAuditAttributes struct {
	// the cluster this request was made on
	ClusterID string `json:"clusterId"`
	// the http method from the given request
	Method string `json:"method"`
	// the path made for the given request
	Path         string `json:"path"`
	ResponseCode *int64 `json:"responseCode,omitempty"`
}

type ClusterAuditLog struct {
	ID           string   `json:"id"`
	Method       string   `json:"method"`
	Path         string   `json:"path"`
	ResponseCode *int64   `json:"responseCode,omitempty"`
	Cluster      *Cluster `json:"cluster,omitempty"`
	Actor        *User    `json:"actor,omitempty"`
	InsertedAt   *string  `json:"insertedAt,omitempty"`
	UpdatedAt    *string  `json:"updatedAt,omitempty"`
}

type ClusterAuditLogConnection struct {
	PageInfo PageInfo               `json:"pageInfo"`
	Edges    []*ClusterAuditLogEdge `json:"edges,omitempty"`
}

type ClusterAuditLogEdge struct {
	Node   *ClusterAuditLog `json:"node,omitempty"`
	Cursor *string          `json:"cursor,omitempty"`
}

type ClusterBackup struct {
	ID               string            `json:"id"`
	Name             string            `json:"name"`
	Namespace        string            `json:"namespace"`
	TTL              *string           `json:"ttl,omitempty"`
	GarbageCollected *bool             `json:"garbageCollected,omitempty"`
	Namespaces       *ResourceSelector `json:"namespaces,omitempty"`
	Resources        *ResourceSelector `json:"resources,omitempty"`
	Cluster          *Cluster          `json:"cluster,omitempty"`
	InsertedAt       *string           `json:"insertedAt,omitempty"`
	UpdatedAt        *string           `json:"updatedAt,omitempty"`
}

type ClusterBackupConnection struct {
	PageInfo PageInfo             `json:"pageInfo"`
	Edges    []*ClusterBackupEdge `json:"edges,omitempty"`
}

type ClusterBackupEdge struct {
	Node   *ClusterBackup `json:"node,omitempty"`
	Cursor *string        `json:"cursor,omitempty"`
}

// a single condition struct for various phases of the cluster provisionining process
type ClusterCondition struct {
	LastTransitionTime *string `json:"lastTransitionTime,omitempty"`
	Status             *string `json:"status,omitempty"`
	Type               *string `json:"type,omitempty"`
	Message            *string `json:"message,omitempty"`
	Reason             *string `json:"reason,omitempty"`
	Severity           *string `json:"severity,omitempty"`
}

type ClusterConnection struct {
	PageInfo PageInfo       `json:"pageInfo"`
	Edges    []*ClusterEdge `json:"edges,omitempty"`
}

type ClusterEdge struct {
	Node   *Cluster `json:"node,omitempty"`
	Cursor *string  `json:"cursor,omitempty"`
}

type ClusterInfo struct {
	GitCommit  *string `json:"gitCommit,omitempty"`
	GitVersion *string `json:"gitVersion,omitempty"`
	Platform   *string `json:"platform,omitempty"`
	Version    *string `json:"version,omitempty"`
}

// A kubernetes object used in the course of generating a cluster insight
type ClusterInsightComponent struct {
	ID        string                    `json:"id"`
	Group     *string                   `json:"group,omitempty"`
	Version   string                    `json:"version"`
	Kind      string                    `json:"kind"`
	Namespace *string                   `json:"namespace,omitempty"`
	Name      string                    `json:"name"`
	Priority  *InsightComponentPriority `json:"priority,omitempty"`
	Cluster   *Cluster                  `json:"cluster,omitempty"`
	Insight   *AiInsight                `json:"insight,omitempty"`
	// the raw kubernetes resource itself, this is an expensive fetch and should be used sparingly
	Resource *KubernetesUnstructured `json:"resource,omitempty"`
}

type ClusterInsightComponentAttributes struct {
	Group     *string                   `json:"group,omitempty"`
	Version   string                    `json:"version"`
	Kind      string                    `json:"kind"`
	Namespace *string                   `json:"namespace,omitempty"`
	Name      string                    `json:"name"`
	Priority  *InsightComponentPriority `json:"priority,omitempty"`
}

// A reference to a built ISO image to be used for flashing new edge clusters
type ClusterIsoImage struct {
	ID string `json:"id"`
	// the image this iso was pushed to
	Image string `json:"image"`
	// the registry holding the image
	Registry string `json:"registry"`
	// ssh username for the new device
	User *string `json:"user,omitempty"`
	// ssh password for the new device
	Password *string `json:"password,omitempty"`
	// the project this cluster will live in (can be inferred from bootstrap token)
	Project    *Project `json:"project,omitempty"`
	InsertedAt *string  `json:"insertedAt,omitempty"`
	UpdatedAt  *string  `json:"updatedAt,omitempty"`
}

type ClusterIsoImageAttributes struct {
	// the image this iso was pushed to
	Image string `json:"image"`
	// the registry holding the image
	Registry string `json:"registry"`
	// ssh username for the new device
	User *string `json:"user,omitempty"`
	// ssh password for the new device
	Password *string `json:"password,omitempty"`
	// the project this cluster will live in (can be inferred from bootstrap token)
	ProjectID *string `json:"projectId,omitempty"`
}

type ClusterIsoImageConnection struct {
	PageInfo PageInfo               `json:"pageInfo"`
	Edges    []*ClusterIsoImageEdge `json:"edges,omitempty"`
}

type ClusterIsoImageEdge struct {
	Node   *ClusterIsoImage `json:"node,omitempty"`
	Cursor *string          `json:"cursor,omitempty"`
}

type ClusterMetrics struct {
	CPU            []*MetricResponse `json:"cpu,omitempty"`
	Memory         []*MetricResponse `json:"memory,omitempty"`
	CPURequests    []*MetricResponse `json:"cpuRequests,omitempty"`
	MemoryRequests []*MetricResponse `json:"memoryRequests,omitempty"`
	CPULimits      []*MetricResponse `json:"cpuLimits,omitempty"`
	MemoryLimits   []*MetricResponse `json:"memoryLimits,omitempty"`
	Pods           []*MetricResponse `json:"pods,omitempty"`
	CPUUsage       []*MetricResponse `json:"cpuUsage,omitempty"`
	MemoryUsage    []*MetricResponse `json:"memoryUsage,omitempty"`
}

// A summarization of the core cpu and memory metrics for this cluster
type ClusterMetricsSummary struct {
	Nodes *int64 `json:"nodes,omitempty"`
	// the cpu available in vcpu
	CPUAvailable *float64 `json:"cpuAvailable,omitempty"`
	// the total cpu in use in the cluster measured in vcpu
	CPUTotal *float64 `json:"cpuTotal,omitempty"`
	// a percentage cpu utilization of the cluster
	CPUUsed *int64 `json:"cpuUsed,omitempty"`
	// the total number of megabytes available in the cluster
	MemoryAvailable *float64 `json:"memoryAvailable,omitempty"`
	// the total number of megabytes in use in the cluster
	MemoryTotal *float64 `json:"memoryTotal,omitempty"`
	// a percentage memory utilization of the cluster
	MemoryUsed *int64 `json:"memoryUsed,omitempty"`
}

type ClusterNamespaceUsage struct {
	ID        string   `json:"id"`
	Namespace *string  `json:"namespace,omitempty"`
	CPU       *float64 `json:"cpu,omitempty"`
	Memory    *float64 `json:"memory,omitempty"`
	Gpu       *float64 `json:"gpu,omitempty"`
	// the amount of storage used by this namespace
	Storage *float64 `json:"storage,omitempty"`
	// the amount of cpu utilized
	CPUUtil *float64 `json:"cpuUtil,omitempty"`
	// the amount of memory utilized
	MemUtil          *float64 `json:"memUtil,omitempty"`
	CPUCost          *float64 `json:"cpuCost,omitempty"`
	MemoryCost       *float64 `json:"memoryCost,omitempty"`
	GpuCost          *float64 `json:"gpuCost,omitempty"`
	IngressCost      *float64 `json:"ingressCost,omitempty"`
	StorageCost      *float64 `json:"storageCost,omitempty"`
	LoadBalancerCost *float64 `json:"loadBalancerCost,omitempty"`
	EgressCost       *float64 `json:"egressCost,omitempty"`
	Cluster          *Cluster `json:"cluster,omitempty"`
	InsertedAt       *string  `json:"insertedAt,omitempty"`
	UpdatedAt        *string  `json:"updatedAt,omitempty"`
}

type ClusterNamespaceUsageConnection struct {
	PageInfo PageInfo                     `json:"pageInfo"`
	Edges    []*ClusterNamespaceUsageEdge `json:"edges,omitempty"`
}

type ClusterNamespaceUsageEdge struct {
	Node   *ClusterNamespaceUsage `json:"node,omitempty"`
	Cursor *string                `json:"cursor,omitempty"`
}

type ClusterNamespacesAttributes struct {
	ExternalDNS  []*string `json:"externalDns,omitempty"`
	CertManager  *string   `json:"certManager,omitempty"`
	Istio        *string   `json:"istio,omitempty"`
	Linkerd      *string   `json:"linkerd,omitempty"`
	Cilium       *string   `json:"cilium,omitempty"`
	EbsCsiDriver *string   `json:"ebsCsiDriver,omitempty"`
}

type ClusterNodeMetrics struct {
	CPU         []*MetricResponse `json:"cpu,omitempty"`
	Memory      []*MetricResponse `json:"memory,omitempty"`
	CPUUsage    []*MetricResponse `json:"cpuUsage,omitempty"`
	MemoryUsage []*MetricResponse `json:"memoryUsage,omitempty"`
}

type ClusterPing struct {
	CurrentVersion string         `json:"currentVersion"`
	KubeletVersion *string        `json:"kubeletVersion,omitempty"`
	Distro         *ClusterDistro `json:"distro,omitempty"`
	HealthScore    *int64         `json:"healthScore,omitempty"`
	// scraped k8s objects to use for cluster insights, don't send at all if not w/in the last scrape interval
	InsightComponents []*ClusterInsightComponentAttributes `json:"insightComponents,omitempty"`
	NodeStatistics    []*NodeStatisticAttributes           `json:"nodeStatistics,omitempty"`
}

// a CAPI provider for a cluster, cloud is inferred from name if not provided manually
type ClusterProvider struct {
	// the id of this provider
	ID string `json:"id"`
	// a human readable name for the provider, globally unique
	Name string `json:"name"`
	// the namespace the CAPI resources are deployed into
	Namespace string `json:"namespace"`
	// the name of the cloud service for this provider
	Cloud string `json:"cloud"`
	// the details of how cluster manifests will be synced from git when created with this provider
	Git GitRef `json:"git"`
	// the repository used to serve cluster manifests
	Repository *GitRepository `json:"repository,omitempty"`
	// the repository for the CAPI service itself if customized
	ProviderRepository *GitRepository `json:"providerRepository,omitempty"`
	// the service of the CAPI controller itself
	Service *ServiceDeployment `json:"service,omitempty"`
	// a list of credentials eligible for this provider
	Credentials []*ProviderCredential `json:"credentials,omitempty"`
	// when the cluster provider was deleted
	DeletedAt       *string           `json:"deletedAt,omitempty"`
	RuntimeServices []*RuntimeService `json:"runtimeServices,omitempty"`
	// the kubernetes versions this provider currently supports
	SupportedVersions []*string `json:"supportedVersions,omitempty"`
	// the region names this provider can deploy to
	Regions []*string `json:"regions,omitempty"`
	// whether the current user can edit this resource
	Editable   *bool   `json:"editable,omitempty"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

type ClusterProviderAttributes struct {
	Name          string                           `json:"name"`
	Namespace     *string                          `json:"namespace,omitempty"`
	Cloud         *string                          `json:"cloud,omitempty"`
	CloudSettings *CloudProviderSettingsAttributes `json:"cloudSettings,omitempty"`
}

type ClusterProviderConnection struct {
	PageInfo PageInfo               `json:"pageInfo"`
	Edges    []*ClusterProviderEdge `json:"edges,omitempty"`
}

type ClusterProviderEdge struct {
	Node   *ClusterProvider `json:"node,omitempty"`
	Cursor *string          `json:"cursor,omitempty"`
}

type ClusterProviderUpdateAttributes struct {
	// if you optionally want to reconfigure the git repository for the cluster provider
	Service       *ClusterServiceAttributes        `json:"service,omitempty"`
	CloudSettings *CloudProviderSettingsAttributes `json:"cloudSettings,omitempty"`
}

type ClusterRecommendationAttributes struct {
	Type      *ScalingRecommendationType `json:"type,omitempty"`
	Namespace *string                    `json:"namespace,omitempty"`
	Name      *string                    `json:"name,omitempty"`
	Container *string                    `json:"container,omitempty"`
	// the historical cpu utilization for this scope
	CPUUtil *float64 `json:"cpuUtil,omitempty"`
	// the historical gpu utilization for this scope
	GpuUtil *float64 `json:"gpuUtil,omitempty"`
	// the historical memory utilization for this scope
	MemoryUtil    *float64 `json:"memoryUtil,omitempty"`
	MemoryRequest *float64 `json:"memoryRequest,omitempty"`
	CPURequest    *float64 `json:"cpuRequest,omitempty"`
	CPUCost       *float64 `json:"cpuCost,omitempty"`
	MemoryCost    *float64 `json:"memoryCost,omitempty"`
	GpuCost       *float64 `json:"gpuCost,omitempty"`
	// the service id known to be attached to this recommendation
	ServiceID *string `json:"serviceId,omitempty"`
}

type ClusterRegistration struct {
	ID string `json:"id"`
	// the name to give to the cluster
	Name *string `json:"name,omitempty"`
	// the handle to apply to the cluster
	Handle *string `json:"handle,omitempty"`
	// a unique machine id for the created cluster
	MachineID string `json:"machineId"`
	// the tags to apply to the given cluster
	Tags []*Tag `json:"tags,omitempty"`
	// additional metadata to apply to the cluster
	Metadata map[string]any `json:"metadata,omitempty"`
	Creator  *User          `json:"creator,omitempty"`
	// the project the cluster will live in
	Project    *Project `json:"project,omitempty"`
	InsertedAt *string  `json:"insertedAt,omitempty"`
	UpdatedAt  *string  `json:"updatedAt,omitempty"`
}

type ClusterRegistrationConnection struct {
	PageInfo PageInfo                   `json:"pageInfo"`
	Edges    []*ClusterRegistrationEdge `json:"edges,omitempty"`
}

type ClusterRegistrationCreateAttributes struct {
	// a unique machine id for the created cluster
	MachineID string `json:"machineId"`
	// the project this cluster will live in (can be inferred from bootstrap token)
	ProjectID *string `json:"projectId,omitempty"`
}

type ClusterRegistrationEdge struct {
	Node   *ClusterRegistration `json:"node,omitempty"`
	Cursor *string              `json:"cursor,omitempty"`
}

type ClusterRegistrationUpdateAttributes struct {
	// the name to give to the cluster
	Name string `json:"name"`
	// the handle to apply to the cluster
	Handle *string `json:"handle,omitempty"`
	// the tags to apply to the given cluster
	Tags []*TagInput `json:"tags,omitempty"`
	// additional metadata to apply to the cluster
	Metadata *string `json:"metadata,omitempty"`
}

type ClusterRestore struct {
	ID         string         `json:"id"`
	Status     RestoreStatus  `json:"status"`
	Backup     *ClusterBackup `json:"backup,omitempty"`
	InsertedAt *string        `json:"insertedAt,omitempty"`
	UpdatedAt  *string        `json:"updatedAt,omitempty"`
}

type ClusterRestoreConnection struct {
	PageInfo PageInfo              `json:"pageInfo"`
	Edges    []*ClusterRestoreEdge `json:"edges,omitempty"`
}

type ClusterRestoreEdge struct {
	Node   *ClusterRestore `json:"node,omitempty"`
	Cursor *string         `json:"cursor,omitempty"`
}

// a historical revision of a cluster, including version, cloud and node group configuration
type ClusterRevision struct {
	ID         string      `json:"id"`
	Version    *string     `json:"version,omitempty"`
	NodePools  []*NodePool `json:"nodePools,omitempty"`
	InsertedAt *string     `json:"insertedAt,omitempty"`
	UpdatedAt  *string     `json:"updatedAt,omitempty"`
}

type ClusterRevisionConnection struct {
	PageInfo PageInfo               `json:"pageInfo"`
	Edges    []*ClusterRevisionEdge `json:"edges,omitempty"`
}

type ClusterRevisionEdge struct {
	Node   *ClusterRevision `json:"node,omitempty"`
	Cursor *string          `json:"cursor,omitempty"`
}

type ClusterScalingRecommendation struct {
	ID                   string                     `json:"id"`
	Type                 *ScalingRecommendationType `json:"type,omitempty"`
	Namespace            *string                    `json:"namespace,omitempty"`
	Name                 *string                    `json:"name,omitempty"`
	Container            *string                    `json:"container,omitempty"`
	MemoryRequest        *float64                   `json:"memoryRequest,omitempty"`
	CPURequest           *float64                   `json:"cpuRequest,omitempty"`
	MemoryRecommendation *float64                   `json:"memoryRecommendation,omitempty"`
	CPURecommendation    *float64                   `json:"cpuRecommendation,omitempty"`
	CPUCost              *float64                   `json:"cpuCost,omitempty"`
	MemoryCost           *float64                   `json:"memoryCost,omitempty"`
	GpuCost              *float64                   `json:"gpuCost,omitempty"`
	// the historical cpu utilization for this scope
	CPUUtil *float64 `json:"cpuUtil,omitempty"`
	// the historical memory utilization for this scope
	MemoryUtil *float64 `json:"memoryUtil,omitempty"`
	// the historical gpu utilization for this scope
	GpuUtil    *float64           `json:"gpuUtil,omitempty"`
	Service    *ServiceDeployment `json:"service,omitempty"`
	Cluster    *Cluster           `json:"cluster,omitempty"`
	InsertedAt *string            `json:"insertedAt,omitempty"`
	UpdatedAt  *string            `json:"updatedAt,omitempty"`
}

type ClusterScalingRecommendationConnection struct {
	PageInfo PageInfo                            `json:"pageInfo"`
	Edges    []*ClusterScalingRecommendationEdge `json:"edges,omitempty"`
}

type ClusterScalingRecommendationEdge struct {
	Node   *ClusterScalingRecommendation `json:"node,omitempty"`
	Cursor *string                       `json:"cursor,omitempty"`
}

type ClusterServiceAttributes struct {
	ID           string           `json:"id"`
	RepositoryID *string          `json:"repositoryId,omitempty"`
	Git          GitRefAttributes `json:"git"`
}

// the crd status of the cluster as seen by the CAPI operator
type ClusterStatus struct {
	Phase             *string             `json:"phase,omitempty"`
	ControlPlaneReady *bool               `json:"controlPlaneReady,omitempty"`
	FailureMessage    *string             `json:"failureMessage,omitempty"`
	FailureReason     *string             `json:"failureReason,omitempty"`
	Conditions        []*ClusterCondition `json:"conditions,omitempty"`
}

// a cluster info data struct
type ClusterStatusInfo struct {
	Healthy *bool  `json:"healthy,omitempty"`
	Count   *int64 `json:"count,omitempty"`
}

// A spec for targeting clusters
type ClusterTarget struct {
	// the cluster tags to target
	Tags map[string]any `json:"tags,omitempty"`
	// kubernetes distribution to target
	Distro *ClusterDistro `json:"distro,omitempty"`
}

// A spec for targeting clusters
type ClusterTargetAttributes struct {
	// the cluster tags to target
	Tags *string `json:"tags,omitempty"`
	// kubernetes distribution to target
	Distro *ClusterDistro `json:"distro,omitempty"`
}

type ClusterUpdateAttributes struct {
	Name    *string `json:"name,omitempty"`
	Version *string `json:"version,omitempty"`
	// a short, unique human readable name used to identify this cluster and does not necessarily map to the cloud resource name
	Handle *string `json:"handle,omitempty"`
	// if you optionally want to reconfigure the git repository for the cluster service
	Service *ClusterServiceAttributes `json:"service,omitempty"`
	// pass a kubeconfig for this cluster (DEPRECATED)
	Kubeconfig *KubeconfigAttributes `json:"kubeconfig,omitempty"`
	// status of the upgrade plan for this cluster
	UpgradePlan   *UpgradePlanAttributes     `json:"upgradePlan,omitempty"`
	Protect       *bool                      `json:"protect,omitempty"`
	Distro        *ClusterDistro             `json:"distro,omitempty"`
	Metadata      *string                    `json:"metadata,omitempty"`
	NodePools     []*NodePoolAttributes      `json:"nodePools,omitempty"`
	Tags          []*TagAttributes           `json:"tags,omitempty"`
	ReadBindings  []*PolicyBindingAttributes `json:"readBindings,omitempty"`
	WriteBindings []*PolicyBindingAttributes `json:"writeBindings,omitempty"`
}

// A consolidated checklist of tasks that need to be completed to upgrade this cluster
type ClusterUpgradePlan struct {
	// whether api compatibilities with all addons and kubernetes are satisfied
	Compatibilities *bool `json:"compatibilities,omitempty"`
	// whether mutual api incompatibilities with all addons and kubernetes have been satisfied
	Incompatibilities *bool `json:"incompatibilities,omitempty"`
	// whether all api deprecations have been cleared for the target version
	Deprecations *bool `json:"deprecations,omitempty"`
	// whether the kubelet version is in line with the current version
	KubeletSkew *bool `json:"kubeletSkew,omitempty"`
}

type ClusterUsage struct {
	ID     string   `json:"id"`
	CPU    *float64 `json:"cpu,omitempty"`
	Memory *float64 `json:"memory,omitempty"`
	Gpu    *float64 `json:"gpu,omitempty"`
	// the amount of storage used by this cluster
	Storage *float64 `json:"storage,omitempty"`
	// the amount of cpu utilized
	CPUUtil *float64 `json:"cpuUtil,omitempty"`
	// the amount of memory utilized
	MemUtil          *float64                                `json:"memUtil,omitempty"`
	CPUCost          *float64                                `json:"cpuCost,omitempty"`
	MemoryCost       *float64                                `json:"memoryCost,omitempty"`
	GpuCost          *float64                                `json:"gpuCost,omitempty"`
	IngressCost      *float64                                `json:"ingressCost,omitempty"`
	LoadBalancerCost *float64                                `json:"loadBalancerCost,omitempty"`
	EgressCost       *float64                                `json:"egressCost,omitempty"`
	NodeCost         *float64                                `json:"nodeCost,omitempty"`
	StorageCost      *float64                                `json:"storageCost,omitempty"`
	ControlPlaneCost *float64                                `json:"controlPlaneCost,omitempty"`
	Cluster          *Cluster                                `json:"cluster,omitempty"`
	Namespaces       *ClusterNamespaceUsageConnection        `json:"namespaces,omitempty"`
	Recommendations  *ClusterScalingRecommendationConnection `json:"recommendations,omitempty"`
	History          *ClusterUsageHistoryConnection          `json:"history,omitempty"`
	InsertedAt       *string                                 `json:"insertedAt,omitempty"`
	UpdatedAt        *string                                 `json:"updatedAt,omitempty"`
}

type ClusterUsageConnection struct {
	PageInfo PageInfo            `json:"pageInfo"`
	Edges    []*ClusterUsageEdge `json:"edges,omitempty"`
}

type ClusterUsageEdge struct {
	Node   *ClusterUsage `json:"node,omitempty"`
	Cursor *string       `json:"cursor,omitempty"`
}

type ClusterUsageHistory struct {
	ID               string   `json:"id"`
	Timestamp        string   `json:"timestamp"`
	CPUCost          *float64 `json:"cpuCost,omitempty"`
	MemoryCost       *float64 `json:"memoryCost,omitempty"`
	GpuCost          *float64 `json:"gpuCost,omitempty"`
	IngressCost      *float64 `json:"ingressCost,omitempty"`
	LoadBalancerCost *float64 `json:"loadBalancerCost,omitempty"`
	EgressCost       *float64 `json:"egressCost,omitempty"`
	NodeCost         *float64 `json:"nodeCost,omitempty"`
	StorageCost      *float64 `json:"storageCost,omitempty"`
	ControlPlaneCost *float64 `json:"controlPlaneCost,omitempty"`
	Cluster          *Cluster `json:"cluster,omitempty"`
	InsertedAt       *string  `json:"insertedAt,omitempty"`
	UpdatedAt        *string  `json:"updatedAt,omitempty"`
}

type ClusterUsageHistoryConnection struct {
	PageInfo PageInfo                   `json:"pageInfo"`
	Edges    []*ClusterUsageHistoryEdge `json:"edges,omitempty"`
}

type ClusterUsageHistoryEdge struct {
	Node   *ClusterUsageHistory `json:"node,omitempty"`
	Cursor *string              `json:"cursor,omitempty"`
}

type ClusterVulnAggregate struct {
	Cluster *Cluster `json:"cluster,omitempty"`
	Count   int64    `json:"count"`
}

type CommandAttributes struct {
	Cmd  string    `json:"cmd"`
	Args []*string `json:"args,omitempty"`
	Dir  *string   `json:"dir,omitempty"`
}

type ComplianceReportGenerator struct {
	ID     string                 `json:"id"`
	Name   string                 `json:"name"`
	Format ComplianceReportFormat `json:"format"`
	// download policy for this report
	ReadBindings      []*PolicyBinding             `json:"readBindings,omitempty"`
	ComplianceReports *ComplianceReportsConnection `json:"complianceReports,omitempty"`
	InsertedAt        *string                      `json:"insertedAt,omitempty"`
	UpdatedAt         *string                      `json:"updatedAt,omitempty"`
}

type ComplianceReportGeneratorAttributes struct {
	// the format of the compliance report when a user generates it
	Format ComplianceReportFormat `json:"format"`
	// the name of this generator
	Name         string                     `json:"name"`
	ReadBindings []*PolicyBindingAttributes `json:"readBindings,omitempty"`
}

type ComplianceReportGeneratorConnection struct {
	PageInfo PageInfo                         `json:"pageInfo"`
	Edges    []*ComplianceReportGeneratorEdge `json:"edges,omitempty"`
}

type ComplianceReportGeneratorEdge struct {
	Node   *ComplianceReportGenerator `json:"node,omitempty"`
	Cursor *string                    `json:"cursor,omitempty"`
}

type ComplianceReports struct {
	ID         string  `json:"id"`
	Name       string  `json:"name"`
	Sha256     *string `json:"sha256,omitempty"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

type ComplianceReportsConnection struct {
	PageInfo PageInfo                 `json:"pageInfo"`
	Edges    []*ComplianceReportsEdge `json:"edges,omitempty"`
}

type ComplianceReportsEdge struct {
	Node   *ComplianceReports `json:"node,omitempty"`
	Cursor *string            `json:"cursor,omitempty"`
}

type ComponentAttributes struct {
	State     *ComponentState             `json:"state,omitempty"`
	Synced    bool                        `json:"synced"`
	Group     string                      `json:"group"`
	Version   string                      `json:"version"`
	Kind      string                      `json:"kind"`
	Namespace string                      `json:"namespace"`
	Name      string                      `json:"name"`
	UID       *string                     `json:"uid,omitempty"`
	Content   *ComponentContentAttributes `json:"content,omitempty"`
	Children  []*ComponentChildAttributes `json:"children,omitempty"`
}

type ComponentChildAttributes struct {
	UID       string          `json:"uid"`
	State     *ComponentState `json:"state,omitempty"`
	ParentUID *string         `json:"parentUid,omitempty"`
	Name      string          `json:"name"`
	Namespace *string         `json:"namespace,omitempty"`
	Group     *string         `json:"group,omitempty"`
	Version   string          `json:"version"`
	Kind      string          `json:"kind"`
}

// dry run content of a service component
type ComponentContent struct {
	ID   string  `json:"id"`
	Live *string `json:"live,omitempty"`
	// the inferred desired state of this component
	Desired    *string `json:"desired,omitempty"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

// the content of a component when visualized in dry run state
type ComponentContentAttributes struct {
	// the desired state of a service component as determined from the configured manifests
	Desired *string `json:"desired,omitempty"`
	Live    *string `json:"live,omitempty"`
}

// A tree view of the kubernetes object hierarchy beneath a component
type ComponentTree struct {
	Root         *KubernetesUnstructured `json:"root,omitempty"`
	Deployments  []*Deployment           `json:"deployments,omitempty"`
	Statefulsets []*StatefulSet          `json:"statefulsets,omitempty"`
	Replicasets  []*ReplicaSet           `json:"replicasets,omitempty"`
	Daemonsets   []*DaemonSet            `json:"daemonsets,omitempty"`
	Services     []*Service              `json:"services,omitempty"`
	Ingresses    []*Ingress              `json:"ingresses,omitempty"`
	Cronjobs     []*CronJob              `json:"cronjobs,omitempty"`
	Configmaps   []*ConfigMap            `json:"configmaps,omitempty"`
	Secrets      []*Secret               `json:"secrets,omitempty"`
	Certificates []*Certificate          `json:"certificates,omitempty"`
	Edges        []*ResourceEdge         `json:"edges,omitempty"`
}

// attributes for declaratively specifying whether a config item is relevant given prior config
type ConditionAttributes struct {
	Operation Operation `json:"operation"`
	Field     string    `json:"field"`
	Value     *string   `json:"value,omitempty"`
}

type ConfigAttributes struct {
	Name  string  `json:"name"`
	Value *string `json:"value,omitempty"`
}

type ConfigMap struct {
	Metadata Metadata       `json:"metadata"`
	Data     map[string]any `json:"data"`
	Raw      string         `json:"raw"`
}

// Validations to apply to this configuration entry prior to PR creation
type ConfigurationValidationAttributes struct {
	// regex a string value should match
	Regex *string `json:"regex,omitempty"`
	// whether the string is json encoded
	JSON *bool `json:"json,omitempty"`
	// configuration for name uniqueness
	UniqBy *UniqByAttributes `json:"uniqBy,omitempty"`
}

type ConsentRequest struct {
	RequestedScope []*string `json:"requestedScope,omitempty"`
	Skip           *bool     `json:"skip,omitempty"`
}

type ConsoleConfiguration struct {
	GitCommit      *string `json:"gitCommit,omitempty"`
	ConsoleVersion *string `json:"consoleVersion,omitempty"`
	IsDemoProject  *bool   `json:"isDemoProject,omitempty"`
	IsSandbox      *bool   `json:"isSandbox,omitempty"`
	PluralLogin    *bool   `json:"pluralLogin,omitempty"`
	VpnEnabled     *bool   `json:"vpnEnabled,omitempty"`
	// whether at least one cluster has been installed, false if a user hasn't fully onboarded
	Installed    *bool              `json:"installed,omitempty"`
	Cloud        *bool              `json:"cloud,omitempty"`
	Byok         *bool              `json:"byok,omitempty"`
	ExternalOidc *bool              `json:"externalOidc,omitempty"`
	OidcName     *string            `json:"oidcName,omitempty"`
	Features     *AvailableFeatures `json:"features,omitempty"`
	Manifest     *PluralManifest    `json:"manifest,omitempty"`
	GitStatus    *GitStatus         `json:"gitStatus,omitempty"`
}

type ConstraintRef struct {
	Kind string `json:"kind"`
	Name string `json:"name"`
}

type ConstraintRefAttributes struct {
	Kind string `json:"kind"`
	Name string `json:"name"`
}

type Container struct {
	Image     *string    `json:"image,omitempty"`
	Name      *string    `json:"name,omitempty"`
	Ports     []*Port    `json:"ports,omitempty"`
	Resources *Resources `json:"resources,omitempty"`
}

// the attributes for a container
type ContainerAttributes struct {
	Name      *string                       `json:"name,omitempty"`
	Image     string                        `json:"image"`
	Args      []*string                     `json:"args,omitempty"`
	Env       []*EnvAttributes              `json:"env,omitempty"`
	EnvFrom   []*EnvFromAttributes          `json:"envFrom,omitempty"`
	Resources *ContainerResourcesAttributes `json:"resources,omitempty"`
}

// container env variable
type ContainerEnv struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

// env from declarations for containers
type ContainerEnvFrom struct {
	ConfigMap string `json:"configMap"`
	Secret    string `json:"secret"`
}

type ContainerRecommendation struct {
	Name           *string          `json:"name,omitempty"`
	ContainerName  *string          `json:"containerName,omitempty"`
	Target         *ResourceRequest `json:"target,omitempty"`
	LowerBound     *ResourceRequest `json:"lowerBound,omitempty"`
	UpperBound     *ResourceRequest `json:"upperBound,omitempty"`
	UncappedTarget *ResourceRequest `json:"uncappedTarget,omitempty"`
}

// A combined kubernetes pod container resource requests spec
type ContainerResources struct {
	Requests *ResourceRequest `json:"requests,omitempty"`
	Limits   *ResourceRequest `json:"limits,omitempty"`
}

type ContainerResourcesAttributes struct {
	Requests *ResourceRequestAttributes `json:"requests,omitempty"`
	Limits   *ResourceRequestAttributes `json:"limits,omitempty"`
}

// a shortform spec for job containers, designed for ease-of-use
type ContainerSpec struct {
	Image     string              `json:"image"`
	Args      []*string           `json:"args,omitempty"`
	Env       []*ContainerEnv     `json:"env,omitempty"`
	EnvFrom   []*ContainerEnvFrom `json:"envFrom,omitempty"`
	Resources *ContainerResources `json:"resources,omitempty"`
}

type ContainerState struct {
	Running    *RunningState    `json:"running,omitempty"`
	Terminated *TerminatedState `json:"terminated,omitempty"`
	Waiting    *WaitingState    `json:"waiting,omitempty"`
}

type ContainerStatus struct {
	RestartCount *int64          `json:"restartCount,omitempty"`
	Ready        *bool           `json:"ready,omitempty"`
	Name         *string         `json:"name,omitempty"`
	Image        *string         `json:"image,omitempty"`
	State        *ContainerState `json:"state,omitempty"`
}

// a binding from a service to a service context
type ContextBindingAttributes struct {
	ContextID string `json:"contextId"`
}

type CostAttributes struct {
	// leave null if cluster scoped
	Namespace *string  `json:"namespace,omitempty"`
	Memory    *float64 `json:"memory,omitempty"`
	CPU       *float64 `json:"cpu,omitempty"`
	Gpu       *float64 `json:"gpu,omitempty"`
	Storage   *float64 `json:"storage,omitempty"`
	// the historical memory utilization for this scope
	MemoryUtil *float64 `json:"memoryUtil,omitempty"`
	// the historical cpu utilization for this scope
	CPUUtil *float64 `json:"cpuUtil,omitempty"`
	// the historical gpu utilization for this scope
	GpuUtil *float64 `json:"gpuUtil,omitempty"`
	// the historical cpu cost for this scope
	CPUCost *float64 `json:"cpuCost,omitempty"`
	// the historical memory cost for this scope
	MemoryCost *float64 `json:"memoryCost,omitempty"`
	// the historical gpu cost for this scope
	GpuCost          *float64 `json:"gpuCost,omitempty"`
	IngressCost      *float64 `json:"ingressCost,omitempty"`
	LoadBalancerCost *float64 `json:"loadBalancerCost,omitempty"`
	EgressCost       *float64 `json:"egressCost,omitempty"`
	NodeCost         *float64 `json:"nodeCost,omitempty"`
	ControlPlaneCost *float64 `json:"controlPlaneCost,omitempty"`
	StorageCost      *float64 `json:"storageCost,omitempty"`
}

type CostIngestAttributes struct {
	Cluster         *CostAttributes                    `json:"cluster,omitempty"`
	Namespaces      []*CostAttributes                  `json:"namespaces,omitempty"`
	Recommendations []*ClusterRecommendationAttributes `json:"recommendations,omitempty"`
}

// Settings for cost management
type CostSettings struct {
	Enabled *bool `json:"enabled,omitempty"`
	// the percentage change needed to generate a recommendation, default 30%
	RecommendationThreshold *int64 `json:"recommendationThreshold,omitempty"`
	// the percentage cushion above baseline usage to give when generation recommendations, default 20%
	RecommendationCushion *int64 `json:"recommendationCushion,omitempty"`
}

// Settings for cost management
type CostSettingsAttributes struct {
	Enabled *bool `json:"enabled,omitempty"`
	// the percentage change needed to generate a recommendation, default 30%
	RecommendationThreshold *int64 `json:"recommendationThreshold,omitempty"`
	// the percentage change needed to generate a recommendation, default 20%
	RecommendationCushion *int64 `json:"recommendationCushion,omitempty"`
}

type CreatePrConfigAttributes struct {
	// a scm connection id to use for pr automations
	ConnectionID *string `json:"connectionId,omitempty"`
}

type CronJob struct {
	Metadata Metadata   `json:"metadata"`
	Status   CronStatus `json:"status"`
	Spec     CronSpec   `json:"spec"`
	Raw      string     `json:"raw"`
	Events   []*Event   `json:"events,omitempty"`
	Jobs     []*Job     `json:"jobs,omitempty"`
}

type CronSpec struct {
	Schedule          string  `json:"schedule"`
	Suspend           *bool   `json:"suspend,omitempty"`
	ConcurrencyPolicy *string `json:"concurrencyPolicy,omitempty"`
}

type CronStatus struct {
	Active           []*JobReference `json:"active,omitempty"`
	LastScheduleTime *string         `json:"lastScheduleTime,omitempty"`
}

type CrossVersionResourceTarget struct {
	APIVersion *string `json:"apiVersion,omitempty"`
	Kind       *string `json:"kind,omitempty"`
	Name       *string `json:"name,omitempty"`
}

type CustomRunStep struct {
	Cmd             string    `json:"cmd"`
	Args            []*string `json:"args,omitempty"`
	Stage           StepStage `json:"stage"`
	RequireApproval *bool     `json:"requireApproval,omitempty"`
}

type CustomStackRun struct {
	ID string `json:"id"`
	// Name of the custom stack run
	Name string `json:"name"`
	// Documentation to explain to users what this will do
	Documentation *string `json:"documentation,omitempty"`
	// the list of commands that will be executed
	Commands []*StackCommand `json:"commands,omitempty"`
	// self-service configuration fields presented in the UI to configure how this run executes
	Configuration []*PrConfiguration   `json:"configuration,omitempty"`
	Stack         *InfrastructureStack `json:"stack,omitempty"`
	InsertedAt    *string              `json:"insertedAt,omitempty"`
	UpdatedAt     *string              `json:"updatedAt,omitempty"`
}

type CustomStackRunAttributes struct {
	// human readable name for this custom run
	Name string `json:"name"`
	// extended documentation to explain what this will do
	Documentation *string `json:"documentation,omitempty"`
	// the stack to attach it to
	StackID *string `json:"stackId,omitempty"`
	// the commands for this custom run
	Commands []*CommandAttributes `json:"commands,omitempty"`
	// self-service configuration which will be presented in UI before triggering
	Configuration []*PrConfigurationAttributes `json:"configuration,omitempty"`
}

type CustomStackRunConnection struct {
	PageInfo PageInfo              `json:"pageInfo"`
	Edges    []*CustomStackRunEdge `json:"edges,omitempty"`
}

type CustomStackRunEdge struct {
	Node   *CustomStackRun `json:"node,omitempty"`
	Cursor *string         `json:"cursor,omitempty"`
}

type CustomStepAttributes struct {
	Stage           *StepStage `json:"stage,omitempty"`
	Cmd             string     `json:"cmd"`
	Args            []*string  `json:"args,omitempty"`
	RequireApproval *bool      `json:"requireApproval,omitempty"`
}

type Cvss struct {
	V2Vector  *string  `json:"v2Vector,omitempty"`
	V3Vector  *string  `json:"v3Vector,omitempty"`
	V40Vector *string  `json:"v40Vector,omitempty"`
	V2Score   *float64 `json:"v2Score,omitempty"`
	V3Score   *float64 `json:"v3Score,omitempty"`
	V40Score  *float64 `json:"v40Score,omitempty"`
}

type CvssAttributes struct {
	V2Vector  *string  `json:"v2Vector,omitempty"`
	V3Vector  *string  `json:"v3Vector,omitempty"`
	V40Vector *string  `json:"v40Vector,omitempty"`
	V2Score   *float64 `json:"v2Score,omitempty"`
	V3Score   *float64 `json:"v3Score,omitempty"`
	V40Score  *float64 `json:"v40Score,omitempty"`
}

type CvssBundle struct {
	AttackVector       *VulnAttackVector    `json:"attackVector,omitempty"`
	AttackComplexity   *VulnSeverity        `json:"attackComplexity,omitempty"`
	PrivilegesRequired *VulnSeverity        `json:"privilegesRequired,omitempty"`
	UserInteraction    *VulnUserInteraction `json:"userInteraction,omitempty"`
	Confidentiality    *VulnSeverity        `json:"confidentiality,omitempty"`
	Integrity          *VulnSeverity        `json:"integrity,omitempty"`
	Availability       *VulnSeverity        `json:"availability,omitempty"`
	Nvidia             *Cvss                `json:"nvidia,omitempty"`
	Redhat             *Cvss                `json:"redhat,omitempty"`
}

type CvssBundleAttributes struct {
	Nvidia *CvssAttributes `json:"nvidia,omitempty"`
	Redhat *CvssAttributes `json:"redhat,omitempty"`
}

type DaemonSet struct {
	Metadata Metadata        `json:"metadata"`
	Status   DaemonSetStatus `json:"status"`
	Spec     DaemonSetSpec   `json:"spec"`
	Pods     []*Pod          `json:"pods,omitempty"`
	Raw      string          `json:"raw"`
	Events   []*Event        `json:"events,omitempty"`
}

type DaemonSetSpec struct {
	Strategy *DeploymentStrategy `json:"strategy,omitempty"`
}

type DaemonSetStatus struct {
	CurrentNumberScheduled *int64             `json:"currentNumberScheduled,omitempty"`
	DesiredNumberScheduled *int64             `json:"desiredNumberScheduled,omitempty"`
	NumberReady            *int64             `json:"numberReady,omitempty"`
	Conditions             []*StatusCondition `json:"conditions,omitempty"`
}

type Dashboard struct {
	ID   string        `json:"id"`
	Spec DashboardSpec `json:"spec"`
}

type DashboardGraph struct {
	Name    string             `json:"name"`
	Queries []*DashboardMetric `json:"queries,omitempty"`
	Format  *string            `json:"format,omitempty"`
}

type DashboardLabel struct {
	Name   string    `json:"name"`
	Values []*string `json:"values,omitempty"`
}

type DashboardMetric struct {
	Legend  *string         `json:"legend,omitempty"`
	Query   *string         `json:"query,omitempty"`
	Results []*MetricResult `json:"results,omitempty"`
}

type DashboardSpec struct {
	Name        *string           `json:"name,omitempty"`
	Description *string           `json:"description,omitempty"`
	Timeslices  []*string         `json:"timeslices,omitempty"`
	Labels      []*DashboardLabel `json:"labels,omitempty"`
	Graphs      []*DashboardGraph `json:"graphs,omitempty"`
}

type DatadogCredentialsAttributes struct {
	APIKey string `json:"apiKey"`
	AppKey string `json:"appKey"`
}

// A representation to a service which configures renovate for a scm connection
type DependencyManagementService struct {
	ID         string             `json:"id"`
	Connection *ScmConnection     `json:"connection,omitempty"`
	Service    *ServiceDeployment `json:"service,omitempty"`
	InsertedAt *string            `json:"insertedAt,omitempty"`
	UpdatedAt  *string            `json:"updatedAt,omitempty"`
}

type DependencyManagementServiceConnection struct {
	PageInfo PageInfo                           `json:"pageInfo"`
	Edges    []*DependencyManagementServiceEdge `json:"edges,omitempty"`
}

type DependencyManagementServiceEdge struct {
	Node   *DependencyManagementService `json:"node,omitempty"`
	Cursor *string                      `json:"cursor,omitempty"`
}

type Deployment struct {
	Metadata Metadata         `json:"metadata"`
	Status   DeploymentStatus `json:"status"`
	Spec     DeploymentSpec   `json:"spec"`
	Pods     []*Pod           `json:"pods,omitempty"`
	Raw      string           `json:"raw"`
	Events   []*Event         `json:"events,omitempty"`
}

// global settings for CD, these specify global read/write policies and also allow for customization of the repos for CAPI resources and the deploy operator
type DeploymentSettings struct {
	ID string `json:"id"`
	// whether you've yet to enable CD for this instance
	Enabled bool   `json:"enabled"`
	Name    string `json:"name"`
	// whether the byok cluster has been brought under self-management
	SelfManaged *bool `json:"selfManaged,omitempty"`
	// the way we can connect to your loki instance
	LokiConnection *HTTPConnection `json:"lokiConnection,omitempty"`
	// the way we can connect to your prometheus instance
	PrometheusConnection *HTTPConnection `json:"prometheusConnection,omitempty"`
	// custom helm values to apply to all agents (useful for things like adding customary annotations/labels)
	AgentHelmValues *string `json:"agentHelmValues,omitempty"`
	// global settings for stack configuration
	Stacks *StackSettings `json:"stacks,omitempty"`
	// smtp server configuration for email notifications
	SMTP *SMTPSettings `json:"smtp,omitempty"`
	// settings for LLM provider clients
	Ai *AiSettings `json:"ai,omitempty"`
	// settings for cost management
	Cost *CostSettings `json:"cost,omitempty"`
	// settings for connections to log aggregation datastores
	Logging *LoggingSettings `json:"logging,omitempty"`
	// the root repo you used to run `plural up`
	MgmtRepo *string `json:"mgmtRepo,omitempty"`
	// whether the console has been onboarded and getting started pages need to be shown
	Onboarded *bool `json:"onboarded,omitempty"`
	// The console's expected agent version
	AgentVsn string `json:"agentVsn"`
	// the latest known k8s version
	LatestK8sVsn string `json:"latestK8sVsn"`
	// your compliant k8s version
	CompliantK8sVsn string `json:"compliantK8sVsn"`
	// the repo to fetch CAPI manifests from, for both providers and clusters
	ArtifactRepository *GitRepository `json:"artifactRepository,omitempty"`
	// the repo to fetch the deploy operators manifests from
	DeployerRepository *GitRepository `json:"deployerRepository,omitempty"`
	// read policy across all objects
	ReadBindings []*PolicyBinding `json:"readBindings,omitempty"`
	// write policy across all objects
	WriteBindings []*PolicyBinding `json:"writeBindings,omitempty"`
	// policy for managing git repos
	GitBindings []*PolicyBinding `json:"gitBindings,omitempty"`
	// policy for creation of new objects
	CreateBindings []*PolicyBinding `json:"createBindings,omitempty"`
	InsertedAt     *string          `json:"insertedAt,omitempty"`
	UpdatedAt      *string          `json:"updatedAt,omitempty"`
}

type DeploymentSettingsAttributes struct {
	ArtifactRepositoryID *string `json:"artifactRepositoryId,omitempty"`
	DeployerRepositoryID *string `json:"deployerRepositoryId,omitempty"`
	// custom helm values to apply to all agents (useful for things like adding customary annotations/labels)
	AgentHelmValues *string `json:"agentHelmValues,omitempty"`
	// global configuration for stack execution
	Stacks *StackSettingsAttributes `json:"stacks,omitempty"`
	// connection details for a prometheus instance to use
	PrometheusConnection *HTTPConnectionAttributes `json:"prometheusConnection,omitempty"`
	// connection details for a loki instance to use
	LokiConnection *HTTPConnectionAttributes  `json:"lokiConnection,omitempty"`
	Logging        *LoggingSettingsAttributes `json:"logging,omitempty"`
	MgmtRepo       *string                    `json:"mgmtRepo,omitempty"`
	// configuration for smtp message delivery
	SMTP *SMTPSettingsAttributes `json:"smtp,omitempty"`
	// configuration for LLM provider clients
	Ai *AiSettingsAttributes `json:"ai,omitempty"`
	// settings for cost management functionality
	Cost           *CostSettingsAttributes    `json:"cost,omitempty"`
	ReadBindings   []*PolicyBindingAttributes `json:"readBindings,omitempty"`
	WriteBindings  []*PolicyBindingAttributes `json:"writeBindings,omitempty"`
	GitBindings    []*PolicyBindingAttributes `json:"gitBindings,omitempty"`
	CreateBindings []*PolicyBindingAttributes `json:"createBindings,omitempty"`
}

type DeploymentSpec struct {
	Replicas *int64              `json:"replicas,omitempty"`
	Strategy *DeploymentStrategy `json:"strategy,omitempty"`
}

type DeploymentStatus struct {
	AvailableReplicas   *int64             `json:"availableReplicas,omitempty"`
	Replicas            *int64             `json:"replicas,omitempty"`
	ReadyReplicas       *int64             `json:"readyReplicas,omitempty"`
	UnavailableReplicas *int64             `json:"unavailableReplicas,omitempty"`
	Conditions          []*StatusCondition `json:"conditions,omitempty"`
}

type DeploymentStrategy struct {
	Type          *string        `json:"type,omitempty"`
	RollingUpdate *RollingUpdate `json:"rollingUpdate,omitempty"`
}

type DeprecatedCustomResource struct {
	ID        string  `json:"id"`
	Group     string  `json:"group"`
	Version   string  `json:"version"`
	Kind      string  `json:"kind"`
	Namespace *string `json:"namespace,omitempty"`
	Name      *string `json:"name,omitempty"`
	// the next discovered version of this resource
	NextVersion string `json:"nextVersion"`
	// the cluster this resource belongs to
	Cluster    *Cluster `json:"cluster,omitempty"`
	InsertedAt *string  `json:"insertedAt,omitempty"`
	UpdatedAt  *string  `json:"updatedAt,omitempty"`
}

type DeprecatedCustomResourceAttributes struct {
	Group     string  `json:"group"`
	Version   string  `json:"version"`
	Kind      string  `json:"kind"`
	Namespace *string `json:"namespace,omitempty"`
	Name      string  `json:"name"`
	// the next valid version for this resource
	NextVersion string `json:"nextVersion"`
}

type ElasticsearchConnection struct {
	Host string `json:"host"`
	// the index to query for log data
	Index string  `json:"index"`
	User  *string `json:"user,omitempty"`
}

type ElasticsearchConnectionAttributes struct {
	Host     string  `json:"host"`
	Index    string  `json:"index"`
	User     *string `json:"user,omitempty"`
	Password *string `json:"password,omitempty"`
}

type EmailSettings struct {
	// whether you want to receive digest emails
	Digest *bool `json:"digest,omitempty"`
}

type EmailSettingsAttributes struct {
	// whether you want to receive digest emails
	Digest *bool `json:"digest,omitempty"`
}

type EnvAttributes struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

type EnvFromAttributes struct {
	Secret    string `json:"secret"`
	ConfigMap string `json:"configMap"`
}

type Event struct {
	Action        *string `json:"action,omitempty"`
	Count         *int64  `json:"count,omitempty"`
	EventTime     *string `json:"eventTime,omitempty"`
	LastTimestamp *string `json:"lastTimestamp,omitempty"`
	Message       *string `json:"message,omitempty"`
	Reason        *string `json:"reason,omitempty"`
	Type          *string `json:"type,omitempty"`
}

type Flow struct {
	ID          string  `json:"id"`
	Name        string  `json:"name"`
	Description *string `json:"description,omitempty"`
	Icon        *string `json:"icon,omitempty"`
	// servers that are bound to this flow
	Servers []*McpServer `json:"servers,omitempty"`
	// read policy for this flow
	ReadBindings []*PolicyBinding `json:"readBindings,omitempty"`
	// write policy for this flow
	WriteBindings []*PolicyBinding `json:"writeBindings,omitempty"`
	// the project this flow belongs to
	Project                     *Project                              `json:"project,omitempty"`
	Services                    *ServiceDeploymentConnection          `json:"services,omitempty"`
	Pipelines                   *PipelineConnection                   `json:"pipelines,omitempty"`
	PullRequests                *PullRequestConnection                `json:"pullRequests,omitempty"`
	Alerts                      *AlertConnection                      `json:"alerts,omitempty"`
	PreviewEnvironmentTemplates *PreviewEnvironmentTemplateConnection `json:"previewEnvironmentTemplates,omitempty"`
	PreviewEnvironmentInstances *PreviewEnvironmentInstanceConnection `json:"previewEnvironmentInstances,omitempty"`
	InsertedAt                  *string                               `json:"insertedAt,omitempty"`
	UpdatedAt                   *string                               `json:"updatedAt,omitempty"`
}

type FlowAttributes struct {
	Name               string                            `json:"name"`
	Description        *string                           `json:"description,omitempty"`
	Icon               *string                           `json:"icon,omitempty"`
	ProjectID          *string                           `json:"projectId,omitempty"`
	ReadBindings       []*PolicyBindingAttributes        `json:"readBindings,omitempty"`
	WriteBindings      []*PolicyBindingAttributes        `json:"writeBindings,omitempty"`
	ServerAssociations []*McpServerAssociationAttributes `json:"serverAssociations,omitempty"`
}

type FlowConnection struct {
	PageInfo PageInfo    `json:"pageInfo"`
	Edges    []*FlowEdge `json:"edges,omitempty"`
}

type FlowEdge struct {
	Node   *Flow   `json:"node,omitempty"`
	Cursor *string `json:"cursor,omitempty"`
}

// a Flux crd representation of a Helm repository
type FluxHelmRepository struct {
	Metadata Metadata           `json:"metadata"`
	Spec     HelmRepositorySpec `json:"spec"`
	// the charts found in this repository (heavy operation, don't do in list endpoints)
	Charts []*HelmChartEntry `json:"charts,omitempty"`
	// can fetch the status of a given helm repository
	Status *HelmRepositoryStatus `json:"status,omitempty"`
}

// spec for a job gate
type GateJobAttributes struct {
	Namespace string `json:"namespace"`
	// if you'd rather define the job spec via straight k8s yaml
	Raw            *string                `json:"raw,omitempty"`
	Containers     []*ContainerAttributes `json:"containers,omitempty"`
	Labels         *string                `json:"labels,omitempty"`
	Annotations    *string                `json:"annotations,omitempty"`
	ServiceAccount *string                `json:"serviceAccount,omitempty"`
	// request overrides if you don't want to manually configure individual containers
	Resources *ContainerResourcesAttributes `json:"resources,omitempty"`
}

// detailed gate specifications
type GateSpec struct {
	Job *JobGateSpec `json:"job,omitempty"`
}

// a more refined spec for parameters needed for complex gates
type GateSpecAttributes struct {
	Job *GateJobAttributes `json:"job,omitempty"`
}

// state delineating the current status of this gate
type GateStatus struct {
	JobRef *JobReference `json:"jobRef,omitempty"`
}

type GateStatusAttributes struct {
	JobRef *NamespacedName `json:"jobRef,omitempty"`
}

// the allowed inputs for a deployment agent gate update
type GateUpdateAttributes struct {
	State  *GateState            `json:"state,omitempty"`
	Status *GateStatusAttributes `json:"status,omitempty"`
}

type GCPCloudAttributes struct {
	Project *string `json:"project,omitempty"`
	Network *string `json:"network,omitempty"`
	Region  *string `json:"region,omitempty"`
}

type GCPCloudConnectionAttributes struct {
	ServiceAccountKey string `json:"serviceAccountKey"`
	ProjectID         string `json:"projectId"`
}

// gcp specific cluster cloud configuration
type GCPCloudSettings struct {
	Project *string `json:"project,omitempty"`
	Network *string `json:"network,omitempty"`
	Region  *string `json:"region,omitempty"`
}

// The configuration for a cloud provider
type GCPConnectionAttributes struct {
	// the service account key for gcp
	ServiceAccountKey string `json:"serviceAccountKey"`
	// the project id for gcp
	ProjectID string `json:"projectId"`
}

type GCPSettingsAttributes struct {
	ApplicationCredentials string `json:"applicationCredentials"`
}

type GcsStore struct {
	Bucket string  `json:"bucket"`
	Region *string `json:"region,omitempty"`
}

type GcsStoreAttributes struct {
	Bucket                 string  `json:"bucket"`
	Region                 *string `json:"region,omitempty"`
	ApplicationCredentials string  `json:"applicationCredentials"`
}

type GitAttributes struct {
	// the url of this repository
	URL string `json:"url"`
	// an ssh private key to use with this repo if an ssh url was given
	PrivateKey *string `json:"privateKey,omitempty"`
	// a passphrase to decrypt the given private key
	Passphrase *string `json:"passphrase,omitempty"`
	// the http username for authenticated http repos, defaults to apiKey for github
	Username *string `json:"username,omitempty"`
	// the http password for http authenticated repos
	Password *string `json:"password,omitempty"`
	// a manually supplied https path for non standard git setups.  This is auto-inferred in many cases
	HTTPSPath *string `json:"httpsPath,omitempty"`
	// similar to https_path, a manually supplied url format for custom git.  Should be something like {url}/tree/{ref}/{folder}
	URLFormat *string `json:"urlFormat,omitempty"`
	// id of a scm connection to use for authentication
	ConnectionID *string `json:"connectionId,omitempty"`
	// whether to run plural crypto on this repo
	Decrypt *bool `json:"decrypt,omitempty"`
}

// a file fetched from a git repository, eg a docs .md file
type GitFile struct {
	Path    string `json:"path"`
	Content string `json:"content"`
}

// a representation of where to pull manifests from git
type GitRef struct {
	// a general git ref, either a branch name or commit sha understandable by `git checkout <ref>`
	Ref string `json:"ref"`
	// the folder manifests live under
	Folder string `json:"folder"`
	// a list of individual files to include as well
	Files []string `json:"files,omitempty"`
}

type GitRefAttributes struct {
	// the git reference to use
	Ref string `json:"ref"`
	// the subdirectory in the git repository to use
	Folder string `json:"folder"`
	// the files to include in the tarball
	Files []string `json:"files,omitempty"`
}

// a git repository available for deployments
type GitRepository struct {
	// internal id of this repository
	ID string `json:"id"`
	// the git url of the repository, either https or ssh supported
	URL string `json:"url"`
	// whether its a http or ssh url
	AuthMethod *AuthMethod `json:"authMethod,omitempty"`
	// whether we can currently pull this repo with the provided credentials
	Health *GitHealth `json:"health,omitempty"`
	// the last successsful git pull timestamp
	PulledAt *string `json:"pulledAt,omitempty"`
	// the error message if there were any pull errors
	Error *string `json:"error,omitempty"`
	// the https url for this git repo
	HTTPSPath *string `json:"httpsPath,omitempty"`
	// a format string to get the http url for a subfolder in a git repo
	URLFormat *string `json:"urlFormat,omitempty"`
	// whether to run plural crypto unlock on this repo
	Decrypt *bool `json:"decrypt,omitempty"`
	// named refs like branches/tags for a repository
	Refs []string `json:"refs,omitempty"`
	// whether the current user can edit this repo
	Editable   *bool   `json:"editable,omitempty"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

type GitRepositoryConnection struct {
	PageInfo PageInfo             `json:"pageInfo"`
	Edges    []*GitRepositoryEdge `json:"edges,omitempty"`
}

type GitRepositoryEdge struct {
	Node   *GitRepository `json:"node,omitempty"`
	Cursor *string        `json:"cursor,omitempty"`
}

type GitStatus struct {
	Cloned *bool   `json:"cloned,omitempty"`
	Output *string `json:"output,omitempty"`
}

// Requirements to perform Github App authentication
type GithubAppAttributes struct {
	// Github App ID
	AppID string `json:"appId"`
	// ID of this github app installation
	InstallationID string `json:"installationId"`
	// PEM-encoded private key for this app
	PrivateKey string `json:"privateKey"`
}

// a rules based mechanism to redeploy a service across a fleet of clusters
type GlobalService struct {
	// internal id of this global service
	ID string `json:"id"`
	// a human readable name for this global service
	Name string `json:"name"`
	// a set of tags to select clusters for this global service
	Tags []*Tag `json:"tags,omitempty"`
	// the kubernetes distribution to target with this global service
	Distro *ClusterDistro `json:"distro,omitempty"`
	// whether to include management clusters in the target set
	Mgmt *bool `json:"mgmt,omitempty"`
	// whether you want to reparent existing plural services under this global service
	Reparent *bool `json:"reparent,omitempty"`
	// behavior for all owned resources when this global service is deleted
	Cascade *Cascade `json:"cascade,omitempty"`
	// the service which created this global service
	Parent *ServiceDeployment `json:"parent,omitempty"`
	// a project this global service is bound to
	Project *Project `json:"project,omitempty"`
	// the service template used to spawn services
	Template *ServiceTemplate `json:"template,omitempty"`
	// the service to replicate across clusters
	Service *ServiceDeployment `json:"service,omitempty"`
	// whether to only apply to clusters with this provider
	Provider *ClusterProvider `json:"provider,omitempty"`
	// additional context used to template service metadata during global service reconciliation
	Context    *TemplateContext             `json:"context,omitempty"`
	Services   *ServiceDeploymentConnection `json:"services,omitempty"`
	InsertedAt *string                      `json:"insertedAt,omitempty"`
	UpdatedAt  *string                      `json:"updatedAt,omitempty"`
}

// A reference for a globalized service, which targets clusters based on the configured criteria
type GlobalServiceAttributes struct {
	// name for this global service
	Name string `json:"name"`
	// the cluster tags to target
	Tags []*TagAttributes `json:"tags,omitempty"`
	// kubernetes distribution to target
	Distro *ClusterDistro `json:"distro,omitempty"`
	// whether to include management clusters in the target set
	Mgmt *bool `json:"mgmt,omitempty"`
	// cluster api provider to target
	ProviderID *string `json:"providerId,omitempty"`
	// a project this global service will sync across
	ProjectID *string `json:"projectId,omitempty"`
	// the id of the service creating this
	ParentID *string `json:"parentId,omitempty"`
	// whether you want the global service to take ownership of existing plural services
	Reparent *bool                      `json:"reparent,omitempty"`
	Template *ServiceTemplateAttributes `json:"template,omitempty"`
	// behavior for all owned resources when this global service is deleted
	Cascade *CascadeAttributes `json:"cascade,omitempty"`
	// additional context used to template service metadata during global service reconciliation
	Context *TemplateContextAttributes `json:"context,omitempty"`
}

type GlobalServiceConnection struct {
	PageInfo PageInfo             `json:"pageInfo"`
	Edges    []*GlobalServiceEdge `json:"edges,omitempty"`
}

type GlobalServiceEdge struct {
	Node   *GlobalService `json:"node,omitempty"`
	Cursor *string        `json:"cursor,omitempty"`
}

// The webhook configuration for a pr governance controller
type GovernanceWebhook struct {
	URL string `json:"url"`
}

// The settings for configuring a pr governance controller
type GovernanceWebhookAttributes struct {
	// the url to send webhooks to
	URL string `json:"url"`
}

type GraphStoreAttributes struct {
	Enabled *bool                              `json:"enabled,omitempty"`
	Store   *VectorStore                       `json:"store,omitempty"`
	Elastic *ElasticsearchConnectionAttributes `json:"elastic,omitempty"`
}

type Group struct {
	ID          string  `json:"id"`
	Name        string  `json:"name"`
	Description *string `json:"description,omitempty"`
	// automatically adds all users in the system to this group
	Global     *bool   `json:"global,omitempty"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

type GroupAttributes struct {
	Name        string  `json:"name"`
	Description *string `json:"description,omitempty"`
	Global      *bool   `json:"global,omitempty"`
}

type GroupConnection struct {
	PageInfo PageInfo     `json:"pageInfo"`
	Edges    []*GroupEdge `json:"edges,omitempty"`
}

type GroupEdge struct {
	Node   *Group  `json:"node,omitempty"`
	Cursor *string `json:"cursor,omitempty"`
}

type GroupMember struct {
	ID         string  `json:"id"`
	User       *User   `json:"user,omitempty"`
	Group      *Group  `json:"group,omitempty"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

type GroupMemberConnection struct {
	PageInfo PageInfo           `json:"pageInfo"`
	Edges    []*GroupMemberEdge `json:"edges,omitempty"`
}

type GroupMemberEdge struct {
	Node   *GroupMember `json:"node,omitempty"`
	Cursor *string      `json:"cursor,omitempty"`
}

type HealthRange struct {
	Min *int64 `json:"min,omitempty"`
	Max *int64 `json:"max,omitempty"`
}

type HelmAuthAttributes struct {
	Basic  *HelmBasicAuthAttributes  `json:"basic,omitempty"`
	Bearer *HelmBearerAuthAttributes `json:"bearer,omitempty"`
	AWS    *HelmAWSAuthAttributes    `json:"aws,omitempty"`
	Azure  *HelmAzureAuthAttributes  `json:"azure,omitempty"`
	GCP    *HelmGCPAuthAttributes    `json:"gcp,omitempty"`
}

type HelmAWSAuthAttributes struct {
	AccessKey       *string `json:"accessKey,omitempty"`
	SecretAccessKey *string `json:"secretAccessKey,omitempty"`
	AssumeRoleArn   *string `json:"assumeRoleArn,omitempty"`
}

type HelmAzureAuthAttributes struct {
	ClientID       *string `json:"clientId,omitempty"`
	ClientSecret   *string `json:"clientSecret,omitempty"`
	TenantID       *string `json:"tenantId,omitempty"`
	SubscriptionID *string `json:"subscriptionId,omitempty"`
}

type HelmBasicAuthAttributes struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

type HelmBearerAuthAttributes struct {
	Token string `json:"token"`
}

// a chart manifest entry, including all versions
type HelmChartEntry struct {
	// the name of the chart
	Name *string `json:"name,omitempty"`
	// all found versions of the chart
	Versions []*HelmChartVersion `json:"versions,omitempty"`
}

// a chart version contained within a helm repository manifest
type HelmChartVersion struct {
	// the version of the app contained w/in this chart
	AppVersion *string `json:"appVersion,omitempty"`
	// the version of the chart itself
	Version *string `json:"version,omitempty"`
	// the name of the chart
	Name *string `json:"name,omitempty"`
	Type *string `json:"type,omitempty"`
	// sha digest of this chart's contents
	Digest *string `json:"digest,omitempty"`
}

type HelmConfigAttributes struct {
	Values      *string              `json:"values,omitempty"`
	ValuesFiles []*string            `json:"valuesFiles,omitempty"`
	Chart       *string              `json:"chart,omitempty"`
	Version     *string              `json:"version,omitempty"`
	Release     *string              `json:"release,omitempty"`
	URL         *string              `json:"url,omitempty"`
	IgnoreHooks *bool                `json:"ignoreHooks,omitempty"`
	IgnoreCrds  *bool                `json:"ignoreCrds,omitempty"`
	LuaScript   *string              `json:"luaScript,omitempty"`
	LuaFile     *string              `json:"luaFile,omitempty"`
	Set         *HelmValueAttributes `json:"set,omitempty"`
	Repository  *NamespacedName      `json:"repository,omitempty"`
	Git         *GitRefAttributes    `json:"git,omitempty"`
	// pointer to a Plural GitRepository
	RepositoryID *string `json:"repositoryId,omitempty"`
}

type HelmGCPAuthAttributes struct {
	ApplicationCredentials *string `json:"applicationCredentials,omitempty"`
}

type HelmMinimal struct {
	// a helm values file to use when rendering this helm chart
	Values *string `json:"values,omitempty"`
	// a list of relative paths to values files to use for helm chart templating
	ValuesFiles []*string `json:"valuesFiles,omitempty"`
	// the helm release name to use when rendering this helm chart
	Release *string `json:"release,omitempty"`
}

type HelmMinimalAttributes struct {
	// a helm values file to use when rendering this helm chart
	Values *string `json:"values,omitempty"`
	// a list of relative paths to values files to use for helm chart templating
	ValuesFiles []*string `json:"valuesFiles,omitempty"`
	// the helm release name to use when rendering this helm chart
	Release *string `json:"release,omitempty"`
}

// A direct Plural representation of a Helm repository
type HelmRepository struct {
	ID         string            `json:"id"`
	URL        string            `json:"url"`
	Health     *GitHealth        `json:"health,omitempty"`
	Error      *string           `json:"error,omitempty"`
	Provider   *HelmAuthProvider `json:"provider,omitempty"`
	PulledAt   *string           `json:"pulledAt,omitempty"`
	InsertedAt *string           `json:"insertedAt,omitempty"`
	UpdatedAt  *string           `json:"updatedAt,omitempty"`
}

type HelmRepositoryAttributes struct {
	Provider *HelmAuthProvider   `json:"provider,omitempty"`
	Auth     *HelmAuthAttributes `json:"auth,omitempty"`
}

type HelmRepositoryConnection struct {
	PageInfo PageInfo              `json:"pageInfo"`
	Edges    []*HelmRepositoryEdge `json:"edges,omitempty"`
}

type HelmRepositoryEdge struct {
	Node   *HelmRepository `json:"node,omitempty"`
	Cursor *string         `json:"cursor,omitempty"`
}

// a specification of how a helm repository is fetched
type HelmRepositorySpec struct {
	Provider *string `json:"provider,omitempty"`
	URL      string  `json:"url"`
	Type     *string `json:"type,omitempty"`
}

// the state of this helm repository
type HelmRepositoryStatus struct {
	Ready   *bool   `json:"ready,omitempty"`
	Message *string `json:"message,omitempty"`
}

type HelmSpec struct {
	// the name of the chart this service is using
	Chart *string `json:"chart,omitempty"`
	// the helm repository url to use
	URL *string `json:"url,omitempty"`
	// a helm values file to use with this service, requires auth and so is heavy to query
	Values      *string `json:"values,omitempty"`
	Release     *string `json:"release,omitempty"`
	IgnoreHooks *bool   `json:"ignoreHooks,omitempty"`
	IgnoreCrds  *bool   `json:"ignoreCrds,omitempty"`
	// spec of where to find the chart in git
	Git *GitRef `json:"git,omitempty"`
	// a git repository in Plural to use as a source
	RepositoryID *string `json:"repositoryId,omitempty"`
	// pointer to the flux helm repository resource used for this chart
	Repository *ObjectReference `json:"repository,omitempty"`
	// the chart version in use currently
	Version *string `json:"version,omitempty"`
	// a list of helm name/value pairs to precisely set individual values
	Set []*HelmValue `json:"set,omitempty"`
	// a list of relative paths to values files to use for helm applies
	ValuesFiles []*string `json:"valuesFiles,omitempty"`
	// a lua script to use for helm applies
	LuaScript *string `json:"luaScript,omitempty"`
	// a lua file to use for helm applies
	LuaFile *string `json:"luaFile,omitempty"`
}

// a (possibly nested) helm value pair
type HelmValue struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

type HelmValueAttributes struct {
	// helm value name, can be deeply nested via dot like `image.tag`
	Name *string `json:"name,omitempty"`
	// value of the attribute
	Value *string `json:"value,omitempty"`
}

// the details of how to connect to a http service like prometheus
type HTTPConnection struct {
	Host string `json:"host"`
	// user to connect w/ for basic auth
	User *string `json:"user,omitempty"`
}

type HTTPConnectionAttributes struct {
	Host string `json:"host"`
	// user to connect w/ for basic auth
	User *string `json:"user,omitempty"`
	// password to connect w/ for basic auth
	Password *string `json:"password,omitempty"`
}

type HTTPIngressRule struct {
	Paths []*IngressPath `json:"paths,omitempty"`
}

type InfrastructureStack struct {
	ID *string `json:"id,omitempty"`
	// the name of the stack
	Name string `json:"name"`
	// A type for the stack, specifies the tool to use to apply it
	Type StackType `json:"type"`
	// reference w/in the repository where the IaC lives
	Git GitRef `json:"git"`
	// whether the stack is actively tracking changes in git
	Paused *bool `json:"paused,omitempty"`
	// The status of the last run of the stack
	Status StackStatus `json:"status"`
	// optional k8s job configuration for the job that will apply this stack
	JobSpec      *JobGateSpec  `json:"jobSpec,omitempty"`
	PolicyEngine *PolicyEngine `json:"policyEngine,omitempty"`
	// the agent id this stack is associated with
	AgentID *string `json:"agentId,omitempty"`
	// version/image config for the tool you're using
	Configuration StackConfiguration `json:"configuration"`
	// whether to require approval
	Approval *bool `json:"approval,omitempty"`
	// whether this stack was previously deleted and is pending cleanup
	DeletedAt *string `json:"deletedAt,omitempty"`
	// why this run was cancelled
	CancellationReason *string `json:"cancellationReason,omitempty"`
	// the subdirectory you want to run the stack's commands w/in
	Workdir *string `json:"workdir,omitempty"`
	// whether you want Plural to manage the state of this stack
	ManageState *bool `json:"manageState,omitempty"`
	// Arbitrary variables to add to a stack run
	Variables    map[string]any         `json:"variables,omitempty"`
	Runs         *StackRunConnection    `json:"runs,omitempty"`
	PullRequests *PullRequestConnection `json:"pullRequests,omitempty"`
	// files bound to a run of this stack
	Files []*StackFile `json:"files,omitempty"`
	// environment variables for this stack
	Environment []*StackEnvironment `json:"environment,omitempty"`
	// a list of metrics to poll to determine if a stack run should be cancelled
	ObservableMetrics []*ObservableMetric `json:"observableMetrics,omitempty"`
	// the run that physically destroys the stack
	DeleteRun *StackRun `json:"deleteRun,omitempty"`
	// the most recent output for this stack
	Output []*StackOutput `json:"output,omitempty"`
	// the most recent state of this stack
	State *StackState `json:"state,omitempty"`
	// The project this stack belongs to
	Project *Project `json:"project,omitempty"`
	// the cluster this stack runs on
	Cluster *Cluster `json:"cluster,omitempty"`
	// the git repository you're sourcing IaC from
	Repository *GitRepository `json:"repository,omitempty"`
	// the stack definition in-use by this stack
	Definition *StackDefinition `json:"definition,omitempty"`
	// a cron to spawn runs for this stack
	Cron *StackCron `json:"cron,omitempty"`
	// the service this stack was created w/in
	Parent *ServiceDeployment `json:"parent,omitempty"`
	// an insight explaining the state of this stack
	Insight *AiInsight `json:"insight,omitempty"`
	// the actor of this stack (defaults to root console user)
	Actor           *User                     `json:"actor,omitempty"`
	CustomStackRuns *CustomStackRunConnection `json:"customStackRuns,omitempty"`
	// key/value tags to filter stacks
	Tags          []*Tag           `json:"tags,omitempty"`
	ReadBindings  []*PolicyBinding `json:"readBindings,omitempty"`
	WriteBindings []*PolicyBinding `json:"writeBindings,omitempty"`
	InsertedAt    *string          `json:"insertedAt,omitempty"`
	UpdatedAt     *string          `json:"updatedAt,omitempty"`
}

type InfrastructureStackConnection struct {
	PageInfo PageInfo                   `json:"pageInfo"`
	Edges    []*InfrastructureStackEdge `json:"edges,omitempty"`
}

type InfrastructureStackEdge struct {
	Node   *InfrastructureStack `json:"node,omitempty"`
	Cursor *string              `json:"cursor,omitempty"`
}

type Ingress struct {
	Metadata     Metadata       `json:"metadata"`
	Status       ServiceStatus  `json:"status"`
	Spec         IngressSpec    `json:"spec"`
	Certificates []*Certificate `json:"certificates,omitempty"`
	Raw          string         `json:"raw"`
	Events       []*Event       `json:"events,omitempty"`
}

type IngressBackend struct {
	ServiceName *string `json:"serviceName,omitempty"`
	ServicePort *string `json:"servicePort,omitempty"`
}

type IngressPath struct {
	Backend *IngressBackend `json:"backend,omitempty"`
	Path    *string         `json:"path,omitempty"`
}

type IngressRule struct {
	Host *string          `json:"host,omitempty"`
	HTTP *HTTPIngressRule `json:"http,omitempty"`
}

type IngressSpec struct {
	IngressClassName *string        `json:"ingressClassName,omitempty"`
	Rules            []*IngressRule `json:"rules,omitempty"`
	TLS              []*IngressTLS  `json:"tls,omitempty"`
}

type IngressTLS struct {
	Hosts []*string `json:"hosts,omitempty"`
}

type InsightClientInfo struct {
	UserAgent     *string `json:"userAgent,omitempty"`
	Count         *string `json:"count,omitempty"`
	LastRequestAt *string `json:"lastRequestAt,omitempty"`
}

type InsightClientInfoAttributes struct {
	UserAgent     *string `json:"userAgent,omitempty"`
	Count         *string `json:"count,omitempty"`
	LastRequestAt *string `json:"lastRequestAt,omitempty"`
}

type Invite struct {
	SecureID string  `json:"secureId"`
	Email    *string `json:"email,omitempty"`
}

type InviteAttributes struct {
	Email *string `json:"email,omitempty"`
}

type IssuerRef struct {
	Group *string `json:"group,omitempty"`
	Kind  *string `json:"kind,omitempty"`
	Name  *string `json:"name,omitempty"`
}

type Job struct {
	Metadata Metadata  `json:"metadata"`
	Status   JobStatus `json:"status"`
	Spec     JobSpec   `json:"spec"`
	Raw      string    `json:"raw"`
	Events   []*Event  `json:"events,omitempty"`
	Pods     []*Pod    `json:"pods,omitempty"`
	Logs     []*string `json:"logs,omitempty"`
}

// the full specification of a job gate
type JobGateSpec struct {
	// the namespace the job will run in
	Namespace string `json:"namespace"`
	// a raw kubernetes job resource, overrides any other configuration
	Raw *string `json:"raw,omitempty"`
	// list of containers to run in this job
	Containers []*ContainerSpec `json:"containers,omitempty"`
	// any pod labels to apply
	Labels map[string]any `json:"labels,omitempty"`
	// any pod annotations to apply
	Annotations map[string]any `json:"annotations,omitempty"`
	// the service account the pod will use
	ServiceAccount *string `json:"serviceAccount,omitempty"`
	// equivalent to resources, present for backwards compatibility
	Requests *ContainerResources `json:"requests,omitempty"`
	// requests overrides for cases where direct container configuration is unnecessary
	Resources *ContainerResources `json:"resources,omitempty"`
}

type JobReference struct {
	Name      string `json:"name"`
	Namespace string `json:"namespace"`
}

type JobSpec struct {
	BackoffLimit          *int64 `json:"backoffLimit,omitempty"`
	Parallelism           *int64 `json:"parallelism,omitempty"`
	ActiveDeadlineSeconds *int64 `json:"activeDeadlineSeconds,omitempty"`
}

type JobStatus struct {
	Active         *int64  `json:"active,omitempty"`
	CompletionTime *string `json:"completionTime,omitempty"`
	StartTime      *string `json:"startTime,omitempty"`
	Succeeded      *int64  `json:"succeeded,omitempty"`
	Failed         *int64  `json:"failed,omitempty"`
}

type KnowledgeEvidence struct {
	Name         *string   `json:"name,omitempty"`
	Type         *string   `json:"type,omitempty"`
	Observations []*string `json:"observations,omitempty"`
}

type KubeconfigAttributes struct {
	Raw *string `json:"raw,omitempty"`
}

type KubernetesUnstructured struct {
	Group    *string        `json:"group,omitempty"`
	Version  string         `json:"version"`
	Kind     string         `json:"kind"`
	Raw      map[string]any `json:"raw,omitempty"`
	Metadata Metadata       `json:"metadata"`
	Events   []*Event       `json:"events,omitempty"`
}

// metadata needed for configuring kustomize
type Kustomize struct {
	// the path to the kustomization file to use
	Path string `json:"path"`
	// if the kustomization will need to inflate a helm chart
	EnableHelm *bool `json:"enableHelm,omitempty"`
}

type KustomizeAttributes struct {
	// the path to the kustomization file to use
	Path string `json:"path"`
	// if the kustomization will need to inflate a helm chart
	EnableHelm *bool `json:"enableHelm,omitempty"`
}

type LabelInput struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

type LabelPair struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

type LoadBalancerIngressStatus struct {
	Hostname *string `json:"hostname,omitempty"`
	IP       *string `json:"ip,omitempty"`
}

type LoadBalancerStatus struct {
	Ingress []*LoadBalancerIngressStatus `json:"ingress,omitempty"`
}

type LogFacet struct {
	Key   string  `json:"key"`
	Value *string `json:"value,omitempty"`
}

type LogFacetInput struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type LogLine struct {
	Timestamp *string     `json:"timestamp,omitempty"`
	Log       *string     `json:"log,omitempty"`
	Facets    []*LogFacet `json:"facets,omitempty"`
}

type LogStream struct {
	Stream map[string]any  `json:"stream,omitempty"`
	Values []*MetricResult `json:"values,omitempty"`
}

type LogTimeRange struct {
	Before   *string `json:"before,omitempty"`
	After    *string `json:"after,omitempty"`
	Duration *string `json:"duration,omitempty"`
	Reverse  *bool   `json:"reverse,omitempty"`
}

// Settings for configuring log aggregation throughout Plural
type LoggingSettings struct {
	Enabled *bool `json:"enabled,omitempty"`
	// the type of log aggregation solution you wish to use
	Driver *LogDriver `json:"driver,omitempty"`
	// configures a connection to victoria metrics
	Victoria *HTTPConnection `json:"victoria,omitempty"`
	// configures a connection to elasticsearch for logging
	Elastic *ElasticsearchConnection `json:"elastic,omitempty"`
	// configures a connection to aws opensearch for logging
	Opensearch *OpensearchConnection `json:"opensearch,omitempty"`
}

type LoggingSettingsAttributes struct {
	Enabled    *bool                              `json:"enabled,omitempty"`
	Driver     *LogDriver                         `json:"driver,omitempty"`
	Victoria   *HTTPConnectionAttributes          `json:"victoria,omitempty"`
	Elastic    *ElasticsearchConnectionAttributes `json:"elastic,omitempty"`
	Opensearch *OpensearchConnectionAttributes    `json:"opensearch,omitempty"`
}

type LoginInfo struct {
	OidcURI  *string `json:"oidcUri,omitempty"`
	External *bool   `json:"external,omitempty"`
	OidcName *string `json:"oidcName,omitempty"`
}

type LoginRequest struct {
	RequestedScope []*string `json:"requestedScope,omitempty"`
	Subject        *string   `json:"subject,omitempty"`
}

type LogsEvidence struct {
	ServiceID *string    `json:"serviceId,omitempty"`
	ClusterID *string    `json:"clusterId,omitempty"`
	Line      *string    `json:"line,omitempty"`
	Lines     []*LogLine `json:"lines,omitempty"`
}

type LokiLabelFilter struct {
	Name  string `json:"name"`
	Value string `json:"value"`
	// whether to apply a regex match for this label
	Regex *bool `json:"regex,omitempty"`
}

type LokiLineFilter struct {
	// the string to filter for (eg what is put in our search ui)
	Text *string `json:"text,omitempty"`
	// whether to treat this string as a regex match
	Regex *bool `json:"regex,omitempty"`
}

type LokiQuery struct {
	Labels []*LokiLabelFilter `json:"labels,omitempty"`
	Filter *LokiLineFilter    `json:"filter,omitempty"`
}

// A representation of a managed namespace, which is k8s namespace configuration + a service spec to define a namespace runtime
type ManagedNamespace struct {
	ID string `json:"id"`
	// the name of this namespace once its placed on a cluster
	Name string `json:"name"`
	// override the name of the kubernetes namespace if `name` is not usable
	Namespace *string `json:"namespace,omitempty"`
	// A short description of the purpose of this namespace
	Description *string `json:"description,omitempty"`
	// labels for this namespace
	Labels map[string]any `json:"labels,omitempty"`
	// annotations for this namespace
	Annotations map[string]any `json:"annotations,omitempty"`
	// a list of pull secrets to attach to this namespace
	PullSecrets []*string `json:"pullSecrets,omitempty"`
	// The targeting criteria to select clusters this namespace is bound to
	Target *ClusterTarget `json:"target,omitempty"`
	// the timestamp this namespace was deleted at, indicating it's currently draining
	DeletedAt *string `json:"deletedAt,omitempty"`
	// behavior for all owned resources when this global service is deleted
	Cascade *Cascade `json:"cascade,omitempty"`
	// the service which created this managed namespace
	Parent *ServiceDeployment `json:"parent,omitempty"`
	// a project this global service is bound to
	Project *Project `json:"project,omitempty"`
	// A template for creating the core service for this namespace
	Service    *ServiceTemplate             `json:"service,omitempty"`
	Services   *ServiceDeploymentConnection `json:"services,omitempty"`
	InsertedAt *string                      `json:"insertedAt,omitempty"`
	UpdatedAt  *string                      `json:"updatedAt,omitempty"`
}

// Attributes for configuring a managed namespace
type ManagedNamespaceAttributes struct {
	// the name of this managed namespace (globally unique)
	Name string `json:"name"`
	// the name of the namespace if `name` doesn't align
	Namespace *string `json:"namespace,omitempty"`
	// A short description of the purpose of this namespace
	Description *string `json:"description,omitempty"`
	// labels for this namespace
	Labels *string `json:"labels,omitempty"`
	// annotations for this namespace
	Annotations *string `json:"annotations,omitempty"`
	// a list of pull secrets to attach to this namespace
	PullSecrets []*string `json:"pullSecrets,omitempty"`
	// a project this managed namespace will sync across
	ProjectID *string `json:"projectId,omitempty"`
	// the id of the service creating this
	ParentID *string                    `json:"parentId,omitempty"`
	Service  *ServiceTemplateAttributes `json:"service,omitempty"`
	Target   *ClusterTargetAttributes   `json:"target,omitempty"`
	// behavior for all owned resources when this global service is deleted
	Cascade *CascadeAttributes `json:"cascade,omitempty"`
}

type ManagedNamespaceConnection struct {
	PageInfo PageInfo                `json:"pageInfo"`
	Edges    []*ManagedNamespaceEdge `json:"edges,omitempty"`
}

type ManagedNamespaceEdge struct {
	Node   *ManagedNamespace `json:"node,omitempty"`
	Cursor *string           `json:"cursor,omitempty"`
}

type ManifestNetwork struct {
	PluralDNS *bool   `json:"pluralDns,omitempty"`
	Subdomain *string `json:"subdomain,omitempty"`
}

type McpHeaderAttributes struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

type McpServer struct {
	ID string `json:"id"`
	// the name for this server
	Name string `json:"name"`
	// the HTTP url the server is hosted on
	URL string `json:"url"`
	// authentication specs for this server
	Authentication *McpServerAuthentication `json:"authentication,omitempty"`
	// whether a tool call against this server should require user confirmation
	Confirm *bool `json:"confirm,omitempty"`
	// read policy for this mcp server
	ReadBindings []*PolicyBinding `json:"readBindings,omitempty"`
	// write policy for this mcp server
	WriteBindings []*PolicyBinding          `json:"writeBindings,omitempty"`
	Audits        *McpServerAuditConnection `json:"audits,omitempty"`
	InsertedAt    *string                   `json:"insertedAt,omitempty"`
	UpdatedAt     *string                   `json:"updatedAt,omitempty"`
}

type McpServerAssociationAttributes struct {
	ServerID *string `json:"serverId,omitempty"`
}

// Input attributes for creating an mcp server
type McpServerAttributes struct {
	Name string `json:"name"`
	URL  string `json:"url"`
	// whether tool calls against this server should require a confirmation
	Confirm        *bool                              `json:"confirm,omitempty"`
	Authentication *McpServerAuthenticationAttributes `json:"authentication,omitempty"`
	ReadBindings   []*PolicyBindingAttributes         `json:"readBindings,omitempty"`
	WriteBindings  []*PolicyBindingAttributes         `json:"writeBindings,omitempty"`
}

type McpServerAudit struct {
	ID         string         `json:"id"`
	Tool       string         `json:"tool"`
	Arguments  map[string]any `json:"arguments,omitempty"`
	Server     *McpServer     `json:"server,omitempty"`
	Actor      *User          `json:"actor,omitempty"`
	InsertedAt *string        `json:"insertedAt,omitempty"`
	UpdatedAt  *string        `json:"updatedAt,omitempty"`
}

type McpServerAuditConnection struct {
	PageInfo PageInfo              `json:"pageInfo"`
	Edges    []*McpServerAuditEdge `json:"edges,omitempty"`
}

type McpServerAuditEdge struct {
	Node   *McpServerAudit `json:"node,omitempty"`
	Cursor *string         `json:"cursor,omitempty"`
}

type McpServerAuthentication struct {
	// built-in Plural JWT authentication
	Plural *bool `json:"plural,omitempty"`
	// any custom HTTP headers needed for authentication
	Headers []*McpServerHeader `json:"headers,omitempty"`
}

type McpServerAuthenticationAttributes struct {
	// whether to use Plural's built-in JWT authentication
	Plural  *bool                  `json:"plural,omitempty"`
	Headers []*McpHeaderAttributes `json:"headers,omitempty"`
}

type McpServerConnection struct {
	PageInfo PageInfo         `json:"pageInfo"`
	Edges    []*McpServerEdge `json:"edges,omitempty"`
}

type McpServerEdge struct {
	Node   *McpServer `json:"node,omitempty"`
	Cursor *string    `json:"cursor,omitempty"`
}

type McpServerHeader struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

// A tool related to an mcp server
type McpServerTool struct {
	Server *McpServer `json:"server,omitempty"`
	Tool   *McpTool   `json:"tool,omitempty"`
}

// The description of a tool extracted from its MCP server
type McpTool struct {
	Name        string         `json:"name"`
	Description *string        `json:"description,omitempty"`
	InputSchema map[string]any `json:"inputSchema,omitempty"`
}

type Metadata struct {
	Labels            []*LabelPair `json:"labels,omitempty"`
	Annotations       []*LabelPair `json:"annotations,omitempty"`
	Name              string       `json:"name"`
	Namespace         *string      `json:"namespace,omitempty"`
	CreationTimestamp *string      `json:"creationTimestamp,omitempty"`
	UID               *string      `json:"uid,omitempty"`
}

type MetadataAttributes struct {
	Labels      *string `json:"labels,omitempty"`
	Annotations *string `json:"annotations,omitempty"`
}

type MetricPointResponse struct {
	Metric map[string]any `json:"metric,omitempty"`
	Value  *MetricResult  `json:"value,omitempty"`
}

type MetricResponse struct {
	Metric map[string]any  `json:"metric,omitempty"`
	Values []*MetricResult `json:"values,omitempty"`
}

type MetricResult struct {
	Timestamp *string `json:"timestamp,omitempty"`
	Value     *string `json:"value,omitempty"`
}

type Namespace struct {
	Status   NamespaceStatus `json:"status"`
	Spec     NamespaceSpec   `json:"spec"`
	Metadata Metadata        `json:"metadata"`
	Raw      string          `json:"raw"`
	Events   []*Event        `json:"events,omitempty"`
}

// metadata fields for created namespaces
type NamespaceMetadata struct {
	Labels      map[string]any `json:"labels,omitempty"`
	Annotations map[string]any `json:"annotations,omitempty"`
}

type NamespaceSpec struct {
	Finalizers []*string `json:"finalizers,omitempty"`
}

type NamespaceStatus struct {
	Phase *string `json:"phase,omitempty"`
}

type NamespaceVuln struct {
	Namespace string `json:"namespace"`
}

type NamespaceVulnAttributes struct {
	Namespace string `json:"namespace"`
}

type NamespacedName struct {
	Name      string `json:"name"`
	Namespace string `json:"namespace"`
}

// An edge representing traffic statistics between two workloads in a service mesh
type NetworkMeshEdge struct {
	ID         string                `json:"id"`
	From       NetworkMeshWorkload   `json:"from"`
	To         NetworkMeshWorkload   `json:"to"`
	Statistics NetworkMeshStatistics `json:"statistics"`
}

// The relevant statistics for traffic within a service mesh
type NetworkMeshStatistics struct {
	Bytes             *float64 `json:"bytes,omitempty"`
	Connections       *float64 `json:"connections,omitempty"`
	Packets           *float64 `json:"packets,omitempty"`
	HTTP200           *float64 `json:"http200,omitempty"`
	HTTP400           *float64 `json:"http400,omitempty"`
	HTTP500           *float64 `json:"http500,omitempty"`
	HTTPClientLatency *float64 `json:"httpClientLatency,omitempty"`
}

// An abstract workload discovered by querying statistics on a service mesh
type NetworkMeshWorkload struct {
	ID        string  `json:"id"`
	Name      string  `json:"name"`
	Namespace *string `json:"namespace,omitempty"`
	Service   *string `json:"service,omitempty"`
}

type NewRelicCredentialsAttributes struct {
	APIKey string `json:"apiKey"`
}

type Node struct {
	Status   NodeStatus `json:"status"`
	Spec     NodeSpec   `json:"spec"`
	Metadata Metadata   `json:"metadata"`
	Raw      string     `json:"raw"`
	Pods     []*Pod     `json:"pods,omitempty"`
	Events   []*Event   `json:"events,omitempty"`
}

// cloud specific settings for a node pool
type NodeCloudSettings struct {
	AWS *AWSCloud `json:"aws,omitempty"`
}

type NodeCondition struct {
	Message *string `json:"message,omitempty"`
	Reason  *string `json:"reason,omitempty"`
	Status  *string `json:"status,omitempty"`
	Type    *string `json:"type,omitempty"`
}

type NodeMetric struct {
	Metadata  Metadata   `json:"metadata"`
	Timestamp *string    `json:"timestamp,omitempty"`
	Window    *string    `json:"window,omitempty"`
	Usage     *NodeUsage `json:"usage,omitempty"`
}

// a specification for a node pool to be created in this cluster
type NodePool struct {
	// internal id for this node pool
	ID string `json:"id"`
	// name of this node pool (must be unique)
	Name string `json:"name"`
	// minimum number of instances in this node pool
	MinSize int64 `json:"minSize"`
	// maximum number of instances in this node pool
	MaxSize int64 `json:"maxSize"`
	// the type of node to use (usually cloud-specific)
	InstanceType string `json:"instanceType"`
	// whether this is a spot pool or not
	Spot *bool `json:"spot,omitempty"`
	// kubernetes labels to apply to the nodes in this pool, useful for node selectors
	Labels map[string]any `json:"labels,omitempty"`
	// any taints you'd want to apply to a node, for eg preventing scheduling on spot instances
	Taints []*Taint `json:"taints,omitempty"`
	// cloud specific settings for the node groups
	CloudSettings *NodeCloudSettings `json:"cloudSettings,omitempty"`
	InsertedAt    *string            `json:"insertedAt,omitempty"`
	UpdatedAt     *string            `json:"updatedAt,omitempty"`
}

type NodePoolAttributes struct {
	Name          string                   `json:"name"`
	MinSize       int64                    `json:"minSize"`
	MaxSize       int64                    `json:"maxSize"`
	InstanceType  string                   `json:"instanceType"`
	Labels        *string                  `json:"labels,omitempty"`
	Taints        []*TaintAttributes       `json:"taints,omitempty"`
	CloudSettings *NodePoolCloudAttributes `json:"cloudSettings,omitempty"`
}

type NodePoolCloudAttributes struct {
	AWS *AWSNodeCloudAttributes `json:"aws,omitempty"`
}

type NodeSpec struct {
	PodCidr       *string `json:"podCidr,omitempty"`
	ProviderID    *string `json:"providerId,omitempty"`
	Unschedulable *bool   `json:"unschedulable,omitempty"`
}

// A representation of node health within a cluster
type NodeStatistic struct {
	ID          string               `json:"id"`
	Name        string               `json:"name"`
	PendingPods *int64               `json:"pendingPods,omitempty"`
	Health      *NodeStatisticHealth `json:"health,omitempty"`
	Cluster     *Cluster             `json:"cluster,omitempty"`
	InsertedAt  *string              `json:"insertedAt,omitempty"`
	UpdatedAt   *string              `json:"updatedAt,omitempty"`
}

type NodeStatisticAttributes struct {
	Name        *string              `json:"name,omitempty"`
	PendingPods *int64               `json:"pendingPods,omitempty"`
	Health      *NodeStatisticHealth `json:"health,omitempty"`
}

type NodeStatus struct {
	Allocatable map[string]any   `json:"allocatable,omitempty"`
	Capacity    map[string]any   `json:"capacity,omitempty"`
	Phase       *string          `json:"phase,omitempty"`
	Conditions  []*NodeCondition `json:"conditions,omitempty"`
}

type NodeUsage struct {
	CPU    *string `json:"cpu,omitempty"`
	Memory *string `json:"memory,omitempty"`
}

type Notification struct {
	ID          string              `json:"id"`
	Title       string              `json:"title"`
	Description *string             `json:"description,omitempty"`
	Fingerprint string              `json:"fingerprint"`
	Status      *NotificationStatus `json:"status,omitempty"`
	Labels      map[string]any      `json:"labels,omitempty"`
	Annotations map[string]any      `json:"annotations,omitempty"`
	Repository  string              `json:"repository"`
	SeenAt      *string             `json:"seenAt,omitempty"`
	Severity    *Severity           `json:"severity,omitempty"`
	InsertedAt  *string             `json:"insertedAt,omitempty"`
	UpdatedAt   *string             `json:"updatedAt,omitempty"`
}

type NotificationConnection struct {
	PageInfo PageInfo            `json:"pageInfo"`
	Edges    []*NotificationEdge `json:"edges,omitempty"`
}

type NotificationDelta struct {
	Delta   *Delta        `json:"delta,omitempty"`
	Payload *Notification `json:"payload,omitempty"`
}

type NotificationEdge struct {
	Node   *Notification `json:"node,omitempty"`
	Cursor *string       `json:"cursor,omitempty"`
}

type NotificationFilter struct {
	ID       string             `json:"id"`
	Regex    *string            `json:"regex,omitempty"`
	Service  *ServiceDeployment `json:"service,omitempty"`
	Cluster  *Cluster           `json:"cluster,omitempty"`
	Pipeline *Pipeline          `json:"pipeline,omitempty"`
}

type NotificationRouter struct {
	ID string `json:"id"`
	// name of this router
	Name string `json:"name"`
	// events this router subscribes to, use * for all
	Events []string `json:"events,omitempty"`
	// resource-based filters to select events for services, clusters, pipelines
	Filters []*NotificationFilter `json:"filters,omitempty"`
	// sinks to deliver notifications to
	Sinks      []*NotificationSink `json:"sinks,omitempty"`
	InsertedAt *string             `json:"insertedAt,omitempty"`
	UpdatedAt  *string             `json:"updatedAt,omitempty"`
}

type NotificationRouterAttributes struct {
	// the name of this router
	Name string `json:"name"`
	// the events to trigger, or use * for any
	Events []string `json:"events,omitempty"`
	// filters by object type
	Filters []*RouterFilterAttributes `json:"filters,omitempty"`
	// sinks to deliver notifications to
	RouterSinks []*RouterSinkAttributes `json:"routerSinks,omitempty"`
}

type NotificationRouterConnection struct {
	PageInfo PageInfo                  `json:"pageInfo"`
	Edges    []*NotificationRouterEdge `json:"edges,omitempty"`
}

type NotificationRouterEdge struct {
	Node   *NotificationRouter `json:"node,omitempty"`
	Cursor *string             `json:"cursor,omitempty"`
}

type NotificationSink struct {
	ID string `json:"id"`
	// the name of the sink
	Name string `json:"name"`
	// the channel type of the sink, eg slack or teams
	Type SinkType `json:"type"`
	// the users/groups an in-app notification can be delivered to
	NotificationBindings []*PolicyBinding `json:"notificationBindings,omitempty"`
	// type specific sink configuration
	Configuration SinkConfiguration `json:"configuration"`
	InsertedAt    *string           `json:"insertedAt,omitempty"`
	UpdatedAt     *string           `json:"updatedAt,omitempty"`
}

type NotificationSinkAttributes struct {
	// the name of this sink
	Name string `json:"name"`
	// the channel type of this sink
	Type SinkType `json:"type"`
	// configuration for the specific type
	Configuration SinkConfigurationAttributes `json:"configuration"`
	// the users/groups you want this sink to deliver to if it's PLURAL type
	NotificationBindings []*PolicyBindingAttributes `json:"notificationBindings,omitempty"`
}

type NotificationSinkConnection struct {
	PageInfo PageInfo                `json:"pageInfo"`
	Edges    []*NotificationSinkEdge `json:"edges,omitempty"`
}

type NotificationSinkEdge struct {
	Node   *NotificationSink `json:"node,omitempty"`
	Cursor *string           `json:"cursor,omitempty"`
}

type OauthResponse struct {
	RedirectTo string `json:"redirectTo"`
}

type ObjectReference struct {
	Name      *string `json:"name,omitempty"`
	Namespace *string `json:"namespace,omitempty"`
}

type ObjectStore struct {
	ID         string      `json:"id"`
	Name       string      `json:"name"`
	S3         *S3Store    `json:"s3,omitempty"`
	Gcs        *GcsStore   `json:"gcs,omitempty"`
	Azure      *AzureStore `json:"azure,omitempty"`
	InsertedAt *string     `json:"insertedAt,omitempty"`
	UpdatedAt  *string     `json:"updatedAt,omitempty"`
}

type ObjectStoreAttributes struct {
	Name  string                `json:"name"`
	S3    *S3StoreAttributes    `json:"s3,omitempty"`
	Gcs   *GcsStoreAttributes   `json:"gcs,omitempty"`
	Azure *AzureStoreAttributes `json:"azure,omitempty"`
}

type ObjectStoreConnection struct {
	PageInfo PageInfo           `json:"pageInfo"`
	Edges    []*ObjectStoreEdge `json:"edges,omitempty"`
}

type ObjectStoreEdge struct {
	Node   *ObjectStore `json:"node,omitempty"`
	Cursor *string      `json:"cursor,omitempty"`
}

type ObservabilityProvider struct {
	ID         string                    `json:"id"`
	Type       ObservabilityProviderType `json:"type"`
	Name       string                    `json:"name"`
	InsertedAt *string                   `json:"insertedAt,omitempty"`
	UpdatedAt  *string                   `json:"updatedAt,omitempty"`
}

type ObservabilityProviderAttributes struct {
	Type        ObservabilityProviderType                  `json:"type"`
	Name        string                                     `json:"name"`
	Credentials ObservabilityProviderCredentialsAttributes `json:"credentials"`
}

type ObservabilityProviderConnection struct {
	PageInfo PageInfo                     `json:"pageInfo"`
	Edges    []*ObservabilityProviderEdge `json:"edges,omitempty"`
}

type ObservabilityProviderCredentialsAttributes struct {
	Datadog  *DatadogCredentialsAttributes  `json:"datadog,omitempty"`
	Newrelic *NewRelicCredentialsAttributes `json:"newrelic,omitempty"`
}

type ObservabilityProviderEdge struct {
	Node   *ObservabilityProvider `json:"node,omitempty"`
	Cursor *string                `json:"cursor,omitempty"`
}

// A webhook receiver for an observability provider like grafana or datadog
type ObservabilityWebhook struct {
	ID   string                   `json:"id"`
	Type ObservabilityWebhookType `json:"type"`
	Name string                   `json:"name"`
	// the url for this specific webhook
	URL        string  `json:"url"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

// input data to persist a webhook receiver for an observability provider like grafana or datadog
type ObservabilityWebhookAttributes struct {
	Type   ObservabilityWebhookType `json:"type"`
	Name   string                   `json:"name"`
	Secret *string                  `json:"secret,omitempty"`
}

type ObservabilityWebhookConnection struct {
	PageInfo PageInfo                    `json:"pageInfo"`
	Edges    []*ObservabilityWebhookEdge `json:"edges,omitempty"`
}

type ObservabilityWebhookEdge struct {
	Node   *ObservabilityWebhook `json:"node,omitempty"`
	Cursor *string               `json:"cursor,omitempty"`
}

type ObservableMetric struct {
	ID         string                 `json:"id"`
	Identifier string                 `json:"identifier"`
	Provider   *ObservabilityProvider `json:"provider,omitempty"`
	InsertedAt *string                `json:"insertedAt,omitempty"`
	UpdatedAt  *string                `json:"updatedAt,omitempty"`
}

type ObservableMetricAttributes struct {
	Identifier string `json:"identifier"`
	ProviderID string `json:"providerId"`
}

// An observer is a mechanism to poll an external helm, oci or other datasources and perform a list of actions in response
type Observer struct {
	ID         string            `json:"id"`
	Name       string            `json:"name"`
	Status     ObserverStatus    `json:"status"`
	Crontab    string            `json:"crontab"`
	LastValue  *string           `json:"lastValue,omitempty"`
	LastRunAt  string            `json:"lastRunAt"`
	NextRunAt  string            `json:"nextRunAt"`
	Target     ObserverTarget    `json:"target"`
	Actions    []*ObserverAction `json:"actions,omitempty"`
	Project    *Project          `json:"project,omitempty"`
	Errors     []*ServiceError   `json:"errors,omitempty"`
	InsertedAt *string           `json:"insertedAt,omitempty"`
	UpdatedAt  *string           `json:"updatedAt,omitempty"`
}

// A spec of an action that can be taken in response to an observed entity
type ObserverAction struct {
	Type          ObserverActionType          `json:"type"`
	Configuration ObserverActionConfiguration `json:"configuration"`
}

// A spec of an action that can be taken in response to an observed entity
type ObserverActionAttributes struct {
	Type          ObserverActionType                    `json:"type"`
	Configuration ObserverActionConfigurationAttributes `json:"configuration"`
}

// configuration for an observer action
type ObserverActionConfiguration struct {
	Pr       *ObserverPrAction       `json:"pr,omitempty"`
	Pipeline *ObserverPipelineAction `json:"pipeline,omitempty"`
}

// configuration for an observer action
type ObserverActionConfigurationAttributes struct {
	Pr       *ObserverPrActionAttributes       `json:"pr,omitempty"`
	Pipeline *ObserverPipelineActionAttributes `json:"pipeline,omitempty"`
}

// The settings for configuring add-on scraping
type ObserverAddonAttributes struct {
	Name               string   `json:"name"`
	KubernetesVersion  *string  `json:"kubernetesVersion,omitempty"`
	KubernetesVersions []string `json:"kubernetesVersions,omitempty"`
}

// An observer is a mechanism to poll an external helm, oci or other datasources and perform a list of actions in response
type ObserverAttributes struct {
	Name      string                      `json:"name"`
	Crontab   string                      `json:"crontab"`
	Target    ObserverTargetAttributes    `json:"target"`
	Actions   []*ObserverActionAttributes `json:"actions,omitempty"`
	Initial   *string                     `json:"initial,omitempty"`
	ProjectID *string                     `json:"projectId,omitempty"`
}

type ObserverConnection struct {
	PageInfo PageInfo        `json:"pageInfo"`
	Edges    []*ObserverEdge `json:"edges,omitempty"`
}

type ObserverEdge struct {
	Node   *Observer `json:"node,omitempty"`
	Cursor *string   `json:"cursor,omitempty"`
}

type ObserverGitAttributes struct {
	RepositoryID string                `json:"repositoryId"`
	Type         ObserverGitTargetType `json:"type"`
}

// a spec for polling a git repository for recent updates
type ObserverGitRepo struct {
	RepositoryID string `json:"repositoryId"`
	// the resource within the git repository you want to poll
	Type ObserverGitTargetType `json:"type"`
}

// a spec for querying a helm repository in an observer
type ObserverHelmAttributes struct {
	URL      string              `json:"url"`
	Chart    string              `json:"chart"`
	Provider *HelmAuthProvider   `json:"provider,omitempty"`
	Auth     *HelmAuthAttributes `json:"auth,omitempty"`
}

// a spec for querying a helm in an observer
type ObserverHelmRepo struct {
	URL      string            `json:"url"`
	Chart    string            `json:"chart"`
	Provider *HelmAuthProvider `json:"provider,omitempty"`
}

// a spec for querying a helm repository in an observer
type ObserverOciAttributes struct {
	URL      string              `json:"url"`
	Provider *HelmAuthProvider   `json:"provider,omitempty"`
	Auth     *HelmAuthAttributes `json:"auth,omitempty"`
}

// a spec for querying a oci repository in an observer
type ObserverOciRepo struct {
	URL      string            `json:"url"`
	Provider *HelmAuthProvider `json:"provider,omitempty"`
}

// Configuration for setting a pipeline context in an observer
type ObserverPipelineAction struct {
	PipelineID string `json:"pipelineId"`
	// the context to apply, use $value to interject the observed value
	Context map[string]any `json:"context"`
}

// Configuration for setting a pipeline context in an observer
type ObserverPipelineActionAttributes struct {
	PipelineID string `json:"pipelineId"`
	// the context to apply, use $value to interject the observed value
	Context string `json:"context"`
}

// Configuration for sending a pr in response to an observer
type ObserverPrAction struct {
	AutomationID string  `json:"automationId"`
	Repository   *string `json:"repository,omitempty"`
	// a template to use for the created branch, use $value to interject the observed value
	BranchTemplate *string `json:"branchTemplate,omitempty"`
	// the context to apply, use $value to interject the observed value
	Context map[string]any `json:"context"`
}

// Configuration for sending a pr in response to an observer
type ObserverPrActionAttributes struct {
	AutomationID string  `json:"automationId"`
	Repository   *string `json:"repository,omitempty"`
	// a template to use for the created branch, use $value to interject the observed value
	BranchTemplate *string `json:"branchTemplate,omitempty"`
	// the context to apply, use $value to interject the observed value
	Context string `json:"context"`
}

// Resets the current value of the observer
type ObserverResetAttributes struct {
	LastValue string `json:"lastValue"`
}

// A spec for a target to poll
type ObserverTarget struct {
	Type ObserverTargetType `json:"type"`
	// present for backwards compat, use `type` instead
	Target ObserverTargetType `json:"target"`
	// a regex for extracting the target value, useful in cases where a semver is nested
	// in a larger release string.  The first capture group is the substring that is used for the value.
	Format *string `json:"format,omitempty"`
	// the order in which polled results are applied, defaults to SEMVER
	Order ObserverTargetOrder `json:"order"`
	Helm  *ObserverHelmRepo   `json:"helm,omitempty"`
	Oci   *ObserverOciRepo    `json:"oci,omitempty"`
	Git   *ObserverGitRepo    `json:"git,omitempty"`
}

// A spec for a target to poll
type ObserverTargetAttributes struct {
	Type *ObserverTargetType `json:"type,omitempty"`
	// present for backwards compat
	Target   *ObserverTargetType      `json:"target,omitempty"`
	Format   *string                  `json:"format,omitempty"`
	Order    ObserverTargetOrder      `json:"order"`
	Helm     *ObserverHelmAttributes  `json:"helm,omitempty"`
	Oci      *ObserverOciAttributes   `json:"oci,omitempty"`
	Git      *ObserverGitAttributes   `json:"git,omitempty"`
	Addon    *ObserverAddonAttributes `json:"addon,omitempty"`
	EksAddon *ObserverAddonAttributes `json:"eksAddon,omitempty"`
}

// A representation of a created OIDC provider client
type OidcProvider struct {
	ID          string          `json:"id"`
	Name        string          `json:"name"`
	Description *string         `json:"description,omitempty"`
	AuthMethod  *OidcAuthMethod `json:"authMethod,omitempty"`
	// the redirect uris oidc is whitelisted to use
	RedirectUris []*string `json:"redirectUris,omitempty"`
	// the generated client ID used in configuring OAuth clients
	ClientID string `json:"clientId"`
	// the generated client secret, used in configuring an OAuth client
	ClientSecret string `json:"clientSecret"`
	// bindings determining if a user can login with this oidc client
	Bindings []*PolicyBinding `json:"bindings,omitempty"`
	// bindings determining if a user can edit this oidc client
	WriteBindings []*PolicyBinding `json:"writeBindings,omitempty"`
}

// Configuration settings for creating a new OIDC provider client
type OidcProviderAttributes struct {
	Name        string          `json:"name"`
	AuthMethod  *OidcAuthMethod `json:"authMethod,omitempty"`
	Description *string         `json:"description,omitempty"`
	// users and groups able to utilize this provider
	Bindings []*PolicyBindingAttributes `json:"bindings,omitempty"`
	// users and groups able to utilize this provider
	WriteBindings []*PolicyBindingAttributes `json:"writeBindings,omitempty"`
	// the redirect uris oidc is whitelisted to use
	RedirectUris []*string `json:"redirectUris,omitempty"`
}

type OidcProviderConnection struct {
	PageInfo PageInfo            `json:"pageInfo"`
	Edges    []*OidcProviderEdge `json:"edges,omitempty"`
}

type OidcProviderEdge struct {
	Node   *OidcProvider `json:"node,omitempty"`
	Cursor *string       `json:"cursor,omitempty"`
}

type OidcStepResponse struct {
	Login   *LoginRequest   `json:"login,omitempty"`
	Consent *ConsentRequest `json:"consent,omitempty"`
}

type OllamaAttributes struct {
	Model string `json:"model"`
	// the model to use for tool calls, which are less frequent and require more complex reasoning
	ToolModel *string `json:"toolModel,omitempty"`
	// the model to use for vector embeddings
	EmbeddingModel *string `json:"embeddingModel,omitempty"`
	URL            string  `json:"url"`
	// An http authorization header to use on calls to the Ollama api
	Authorization *string `json:"authorization,omitempty"`
}

// Settings for a self-hosted ollama-based LLM deployment
type OllamaSettings struct {
	Model string `json:"model"`
	// the model to use for tool calls, which are less frequent and require more complex reasoning
	ToolModel *string `json:"toolModel,omitempty"`
	// the url your ollama deployment is hosted on
	URL string `json:"url"`
}

// OpenAI connection information
type OpenaiSettings struct {
	// the base url to use when querying an OpenAI compatible API, leave blank for OpenAI
	BaseURL *string `json:"baseUrl,omitempty"`
	// the openai model version to use
	Model *string `json:"model,omitempty"`
	// the model to use for tool calls, which are less frequent and require more complex reasoning
	ToolModel *string `json:"toolModel,omitempty"`
}

type OpenaiSettingsAttributes struct {
	BaseURL     *string `json:"baseUrl,omitempty"`
	AccessToken *string `json:"accessToken,omitempty"`
	Model       *string `json:"model,omitempty"`
	// the model to use for tool calls, which are less frequent and require more complex reasoning
	ToolModel *string `json:"toolModel,omitempty"`
	// the model to use for vector embeddings
	EmbeddingModel *string `json:"embeddingModel,omitempty"`
}

type OpensearchConnection struct {
	Host string `json:"host"`
	// the index to query for log data
	Index          string  `json:"index"`
	AWSAccessKeyID *string `json:"awsAccessKeyId,omitempty"`
	AWSRegion      *string `json:"awsRegion,omitempty"`
}

type OpensearchConnectionAttributes struct {
	Host               string  `json:"host"`
	Index              string  `json:"index"`
	AWSAccessKeyID     *string `json:"awsAccessKeyId,omitempty"`
	AWSSecretAccessKey *string `json:"awsSecretAccessKey,omitempty"`
	AWSRegion          *string `json:"awsRegion,omitempty"`
}

// a high level description of the setup of common resources in a cluster
type OperationalLayout struct {
	ServiceMesh *ServiceMesh `json:"serviceMesh,omitempty"`
}

type OperationalLayoutAttributes struct {
	ServiceMesh *ServiceMesh                 `json:"serviceMesh,omitempty"`
	Namespaces  *ClusterNamespacesAttributes `json:"namespaces,omitempty"`
}

type PageInfo struct {
	// When paginating backwards, are there more items?
	HasPreviousPage bool `json:"hasPreviousPage"`
	// When paginating forwards, are there more items?
	HasNextPage bool `json:"hasNextPage"`
	// When paginating backwards, the cursor to continue.
	StartCursor *string `json:"startCursor,omitempty"`
	// When paginating forwards, the cursor to continue.
	EndCursor *string `json:"endCursor,omitempty"`
}

type PauseCondition struct {
	Reason    *string `json:"reason,omitempty"`
	StartTime *string `json:"startTime,omitempty"`
}

type Persona struct {
	ID string `json:"id"`
	// the name for this persona
	Name string `json:"name"`
	// longform description of this persona
	Description *string `json:"description,omitempty"`
	// the role of this persona
	Role *PersonaRole `json:"role,omitempty"`
	// the ui configuration for this persona (additive across personas)
	Configuration *PersonaConfiguration `json:"configuration,omitempty"`
	// the group bindings for this persona
	Bindings   []*PolicyBinding `json:"bindings,omitempty"`
	InsertedAt *string          `json:"insertedAt,omitempty"`
	UpdatedAt  *string          `json:"updatedAt,omitempty"`
}

type PersonaAttributes struct {
	Name *string `json:"name,omitempty"`
	// longform description of this persona
	Description   *string                         `json:"description,omitempty"`
	Configuration *PersonaConfigurationAttributes `json:"configuration,omitempty"`
	// the role of this persona, controls the behavior of the homepage
	Role     *PersonaRole         `json:"role,omitempty"`
	Bindings []*BindingAttributes `json:"bindings,omitempty"`
}

type PersonaConfiguration struct {
	// enable full ui for this persona
	All *bool `json:"all,omitempty"`
	// settings for the home page for this persona
	Home *PersonaHome `json:"home,omitempty"`
	// enable individual parts of the deployments views
	Deployments *PersonaDeployment `json:"deployments,omitempty"`
	// enable individual aspects of the sidebar
	Sidebar *PersonaSidebar `json:"sidebar,omitempty"`
	// enable individual parts of the services views
	Services *PersonaServices `json:"services,omitempty"`
}

type PersonaConfigurationAttributes struct {
	// enable full ui for this persona
	All *bool `json:"all,omitempty"`
	// configuration for the homepage for the given persona
	Home *PersonaHomeAttributes `json:"home,omitempty"`
	// enable individual parts of the deployments views
	Deployments *PersonaDeploymentAttributes `json:"deployments,omitempty"`
	// enable individual aspects of the sidebar
	Sidebar *PersonaSidebarAttributes `json:"sidebar,omitempty"`
	// enable individual parts of the services views
	Services *PersonaServicesAttributes `json:"services,omitempty"`
}

type PersonaConnection struct {
	PageInfo PageInfo       `json:"pageInfo"`
	Edges    []*PersonaEdge `json:"edges,omitempty"`
}

type PersonaDeployment struct {
	Clusters     *bool `json:"clusters,omitempty"`
	Deployments  *bool `json:"deployments,omitempty"`
	Repositories *bool `json:"repositories,omitempty"`
	Services     *bool `json:"services,omitempty"`
	Pipelines    *bool `json:"pipelines,omitempty"`
	Providers    *bool `json:"providers,omitempty"`
	AddOns       *bool `json:"addOns,omitempty"`
}

type PersonaDeploymentAttributes struct {
	Clusters     *bool `json:"clusters,omitempty"`
	Deployments  *bool `json:"deployments,omitempty"`
	Repositories *bool `json:"repositories,omitempty"`
	Services     *bool `json:"services,omitempty"`
	Pipelines    *bool `json:"pipelines,omitempty"`
	Providers    *bool `json:"providers,omitempty"`
	AddOns       *bool `json:"addOns,omitempty"`
}

type PersonaEdge struct {
	Node   *Persona `json:"node,omitempty"`
	Cursor *string  `json:"cursor,omitempty"`
}

type PersonaHome struct {
	Manager  *bool `json:"manager,omitempty"`
	Security *bool `json:"security,omitempty"`
}

type PersonaHomeAttributes struct {
	Manager  *bool `json:"manager,omitempty"`
	Security *bool `json:"security,omitempty"`
}

type PersonaServices struct {
	Secrets       *bool `json:"secrets,omitempty"`
	Configuration *bool `json:"configuration,omitempty"`
}

type PersonaServicesAttributes struct {
	Secrets       *bool `json:"secrets,omitempty"`
	Configuration *bool `json:"configuration,omitempty"`
}

type PersonaSidebar struct {
	Audits       *bool `json:"audits,omitempty"`
	Kubernetes   *bool `json:"kubernetes,omitempty"`
	PullRequests *bool `json:"pullRequests,omitempty"`
	Settings     *bool `json:"settings,omitempty"`
	Backups      *bool `json:"backups,omitempty"`
	Stacks       *bool `json:"stacks,omitempty"`
	Security     *bool `json:"security,omitempty"`
	Cost         *bool `json:"cost,omitempty"`
}

type PersonaSidebarAttributes struct {
	Audits       *bool `json:"audits,omitempty"`
	Kubernetes   *bool `json:"kubernetes,omitempty"`
	PullRequests *bool `json:"pullRequests,omitempty"`
	Settings     *bool `json:"settings,omitempty"`
	Backups      *bool `json:"backups,omitempty"`
	Stacks       *bool `json:"stacks,omitempty"`
	Security     *bool `json:"security,omitempty"`
	Cost         *bool `json:"cost,omitempty"`
}

// A reference to a custom resource you want to be displayed in the k8s dashboard
type PinnedCustomResource struct {
	ID          string   `json:"id"`
	Name        string   `json:"name"`
	DisplayName string   `json:"displayName"`
	Group       string   `json:"group"`
	Version     string   `json:"version"`
	Kind        string   `json:"kind"`
	Namespaced  *bool    `json:"namespaced,omitempty"`
	Cluster     *Cluster `json:"cluster,omitempty"`
}

type PinnedCustomResourceAttributes struct {
	Name        string  `json:"name"`
	DisplayName string  `json:"displayName"`
	Group       string  `json:"group"`
	Version     string  `json:"version"`
	Kind        string  `json:"kind"`
	Namespaced  *bool   `json:"namespaced,omitempty"`
	ClusterID   *string `json:"clusterId,omitempty"`
}

// a release pipeline, composed of multiple stages each with potentially multiple services
type Pipeline struct {
	ID string `json:"id"`
	// the name of the pipeline
	Name string `json:"name"`
	// the stages of this pipeline
	Stages []*PipelineStage `json:"stages,omitempty"`
	Status *PipelineStatus  `json:"status,omitempty"`
	// the project this pipeline belongs to
	Project *Project `json:"project,omitempty"`
	// the flow this pipeline belongs to
	Flow *Flow `json:"flow,omitempty"`
	// read policy for this pipeline
	ReadBindings []*PolicyBinding `json:"readBindings,omitempty"`
	// write policy of this pipeline
	WriteBindings []*PolicyBinding `json:"writeBindings,omitempty"`
	// edges linking two stages w/in the pipeline in a full DAG
	Edges []*PipelineStageEdge `json:"edges,omitempty"`
	// lists the contexts applied to a pipeline
	Contexts   *PipelineContextConnection `json:"contexts,omitempty"`
	InsertedAt *string                    `json:"insertedAt,omitempty"`
	UpdatedAt  *string                    `json:"updatedAt,omitempty"`
}

// the top level input object for creating/deleting pipelines
type PipelineAttributes struct {
	ProjectID     *string                    `json:"projectId,omitempty"`
	FlowID        *string                    `json:"flowId,omitempty"`
	Stages        []*PipelineStageAttributes `json:"stages,omitempty"`
	Edges         []*PipelineEdgeAttributes  `json:"edges,omitempty"`
	ReadBindings  []*PolicyBindingAttributes `json:"readBindings,omitempty"`
	WriteBindings []*PolicyBindingAttributes `json:"writeBindings,omitempty"`
}

type PipelineConnection struct {
	PageInfo PageInfo        `json:"pageInfo"`
	Edges    []*PipelineEdge `json:"edges,omitempty"`
}

// A variable context that can be used to generate pull requests as a pipeline progresses
type PipelineContext struct {
	ID string `json:"id"`
	// the context map that will be passed to the pipeline
	Context  map[string]any `json:"context"`
	Pipeline *Pipeline      `json:"pipeline,omitempty"`
	// a history of pull requests created by this context thus far
	PullRequests []*PullRequest `json:"pullRequests,omitempty"`
	// a list of pipeline-specific PRs for this context
	PipelinePullRequests []*PipelinePullRequest `json:"pipelinePullRequests,omitempty"`
	InsertedAt           *string                `json:"insertedAt,omitempty"`
	UpdatedAt            *string                `json:"updatedAt,omitempty"`
}

// attributes needed to create a new pipeline context
type PipelineContextAttributes struct {
	Context string `json:"context"`
}

type PipelineContextConnection struct {
	PageInfo PageInfo               `json:"pageInfo"`
	Edges    []*PipelineContextEdge `json:"edges,omitempty"`
}

type PipelineContextEdge struct {
	Node   *PipelineContext `json:"node,omitempty"`
	Cursor *string          `json:"cursor,omitempty"`
}

// A record of a prior pipeline context attached to a stage
type PipelineContextHistory struct {
	ID         string           `json:"id"`
	Stage      *PipelineStage   `json:"stage,omitempty"`
	Context    *PipelineContext `json:"context,omitempty"`
	InsertedAt *string          `json:"insertedAt,omitempty"`
	UpdatedAt  *string          `json:"updatedAt,omitempty"`
}

type PipelineContextHistoryConnection struct {
	PageInfo PageInfo                      `json:"pageInfo"`
	Edges    []*PipelineContextHistoryEdge `json:"edges,omitempty"`
}

type PipelineContextHistoryEdge struct {
	Node   *PipelineContextHistory `json:"node,omitempty"`
	Cursor *string                 `json:"cursor,omitempty"`
}

type PipelineEdge struct {
	Node   *Pipeline `json:"node,omitempty"`
	Cursor *string   `json:"cursor,omitempty"`
}

// specification of an edge between two pipeline stages
type PipelineEdgeAttributes struct {
	// stage id the edge is from, can also be specified by name
	FromID *string `json:"fromId,omitempty"`
	// stage id the edge is to, can also be specified by name
	ToID *string `json:"toId,omitempty"`
	// the name of the pipeline stage this edge emits from
	From *string `json:"from,omitempty"`
	// the name of the pipeline stage this edge points to
	To *string `json:"to,omitempty"`
	// any optional promotion gates you wish to configure
	Gates []*PipelineGateAttributes `json:"gates,omitempty"`
}

// A gate blocking promotion along a release pipeline
type PipelineGate struct {
	ID string `json:"id"`
	// the name of this gate as seen in the UI
	Name string `json:"name"`
	// the type of gate this is
	Type GateType `json:"type"`
	// the current state of this gate
	State GateState `json:"state"`
	// more detailed specification for complex gates
	Spec *GateSpec `json:"spec,omitempty"`
	// state related to the current status of this job
	Status *GateStatus `json:"status,omitempty"`
	// the kubernetes job running this gate (should only be fetched lazily as this is a heavy operation)
	Job *Job `json:"job,omitempty"`
	// the edge this gate lives on
	Edge *PipelineStageEdge `json:"edge,omitempty"`
	// the cluster this gate can run on
	Cluster *Cluster `json:"cluster,omitempty"`
	// the last user to approve this gate
	Approver   *User   `json:"approver,omitempty"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

// will configure a promotion gate for a pipeline
type PipelineGateAttributes struct {
	// the name of this gate
	Name string `json:"name"`
	// the type of gate this is
	Type GateType `json:"type"`
	// the handle of a cluster this gate will execute on
	Cluster *string `json:"cluster,omitempty"`
	// the id of the cluster this gate will execute on
	ClusterID *string `json:"clusterId,omitempty"`
	// a specification for more complex gate types
	Spec *GateSpecAttributes `json:"spec,omitempty"`
}

type PipelineGateConnection struct {
	PageInfo PageInfo            `json:"pageInfo"`
	Edges    []*PipelineGateEdge `json:"edges,omitempty"`
}

type PipelineGateEdge struct {
	Node   *PipelineGate `json:"node,omitempty"`
	Cursor *string       `json:"cursor,omitempty"`
}

// a representation of an individual pipeline promotion, which is a list of services/revisions and timestamps to determine promotion status
type PipelinePromotion struct {
	ID string `json:"id"`
	// the last time this promotion was updated
	RevisedAt *string `json:"revisedAt,omitempty"`
	// the last time this promotion was fully promoted, it's no longer pending if promoted_at > revised_at
	PromotedAt *string `json:"promotedAt,omitempty"`
	// the services included in this promotion
	Services   []*PromotionService `json:"services,omitempty"`
	InsertedAt *string             `json:"insertedAt,omitempty"`
	UpdatedAt  *string             `json:"updatedAt,omitempty"`
}

// A pull request created in the course of executing a pipeline
type PipelinePullRequest struct {
	ID          string             `json:"id"`
	Service     *ServiceDeployment `json:"service,omitempty"`
	PullRequest *PullRequest       `json:"pullRequest,omitempty"`
	Stage       *PipelineStage     `json:"stage,omitempty"`
}

// a pipeline stage, has a list of services and potentially a promotion which might be pending
type PipelineStage struct {
	ID string `json:"id"`
	// the name of this stage (eg dev, prod, staging)
	Name string `json:"name"`
	// the errors for this stage
	Errors []*ServiceError `json:"errors,omitempty"`
	// the services within this stage
	Services []*StageService `json:"services,omitempty"`
	// the context that is to be applied to this stage for PR promotions
	Context *PipelineContext `json:"context,omitempty"`
	// a promotion which might be outstanding for this stage
	Promotion      *PipelinePromotion                `json:"promotion,omitempty"`
	ContextHistory *PipelineContextHistoryConnection `json:"contextHistory,omitempty"`
	InsertedAt     *string                           `json:"insertedAt,omitempty"`
	UpdatedAt      *string                           `json:"updatedAt,omitempty"`
}

// specification of a stage of a pipeline
type PipelineStageAttributes struct {
	Name     string                    `json:"name"`
	Services []*StageServiceAttributes `json:"services,omitempty"`
}

// an edge in the pipeline DAG
type PipelineStageEdge struct {
	ID string `json:"id"`
	// when the edge was last promoted, if greater than the promotion objects revised at, was successfully promoted
	PromotedAt *string         `json:"promotedAt,omitempty"`
	From       PipelineStage   `json:"from"`
	To         PipelineStage   `json:"to"`
	Gates      []*PipelineGate `json:"gates,omitempty"`
	Pipeline   *Pipeline       `json:"pipeline,omitempty"`
	InsertedAt *string         `json:"insertedAt,omitempty"`
	UpdatedAt  *string         `json:"updatedAt,omitempty"`
}

// a report of gate statuses within a pipeline to gauge its health
type PipelineStatus struct {
	// if > 0, consider the pipeline pending
	Pending *int64 `json:"pending,omitempty"`
	// if > 0, consider the pipeline stopped
	Closed *int64 `json:"closed,omitempty"`
	// if > 0, consider the pipeline runnning
	Running *int64 `json:"running,omitempty"`
}

type Plan struct {
	ID     *string `json:"id,omitempty"`
	Name   *string `json:"name,omitempty"`
	Period *string `json:"period,omitempty"`
}

type PluralCluster struct {
	Status    PluralObjectStatus `json:"status"`
	Metadata  Metadata           `json:"metadata"`
	Reference *Cluster           `json:"reference,omitempty"`
	Raw       string             `json:"raw"`
	Events    []*Event           `json:"events,omitempty"`
}

// temporary credentials for the user attached to this stack
type PluralCreds struct {
	// authentication token to use for gql requests
	Token *string `json:"token,omitempty"`
	// the api url of this instance
	URL *string `json:"url,omitempty"`
}

type PluralGitRepository struct {
	Status    PluralObjectStatus `json:"status"`
	Metadata  Metadata           `json:"metadata"`
	Reference *GitRepository     `json:"reference,omitempty"`
	Raw       string             `json:"raw"`
	Events    []*Event           `json:"events,omitempty"`
}

type PluralManifest struct {
	Network      *ManifestNetwork `json:"network,omitempty"`
	BucketPrefix *string          `json:"bucketPrefix,omitempty"`
	Cluster      *string          `json:"cluster,omitempty"`
}

type PluralObjectStatus struct {
	ID         *string            `json:"id,omitempty"`
	Conditions []*StatusCondition `json:"conditions,omitempty"`
}

type PluralServiceDeployment struct {
	Status    PluralObjectStatus `json:"status"`
	Metadata  Metadata           `json:"metadata"`
	Reference *ServiceDeployment `json:"reference,omitempty"`
	Raw       string             `json:"raw"`
	Events    []*Event           `json:"events,omitempty"`
}

type PluralSinkAttributes struct {
	Priority NotificationPriority `json:"priority"`
	// whether to immediately deliver the derived notification via SMTP
	Urgent *bool `json:"urgent,omitempty"`
}

type PluralSinkConfiguration struct {
	Priority NotificationPriority `json:"priority"`
	// whether to immediately deliver the derived notification via SMTP
	Urgent *bool `json:"urgent,omitempty"`
}

type PluralSubscription struct {
	ID   *string `json:"id,omitempty"`
	Plan *Plan   `json:"plan,omitempty"`
}

type Pod struct {
	Status   PodStatus `json:"status"`
	Spec     PodSpec   `json:"spec"`
	Metadata Metadata  `json:"metadata"`
	Raw      string    `json:"raw"`
	Logs     []*string `json:"logs,omitempty"`
	Events   []*Event  `json:"events,omitempty"`
}

type PodCondition struct {
	LastProbeTime      *string `json:"lastProbeTime,omitempty"`
	LastTransitionTime *string `json:"lastTransitionTime,omitempty"`
	Message            *string `json:"message,omitempty"`
	Reason             *string `json:"reason,omitempty"`
	Status             *string `json:"status,omitempty"`
	Type               *string `json:"type,omitempty"`
}

type PodConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []*PodEdge `json:"edges,omitempty"`
}

type PodDelta struct {
	Delta   *Delta `json:"delta,omitempty"`
	Payload *Pod   `json:"payload,omitempty"`
}

type PodEdge struct {
	Node   *Pod    `json:"node,omitempty"`
	Cursor *string `json:"cursor,omitempty"`
}

type PodSpec struct {
	ServiceAccountName *string      `json:"serviceAccountName,omitempty"`
	NodeName           *string      `json:"nodeName,omitempty"`
	Containers         []*Container `json:"containers,omitempty"`
	InitContainers     []*Container `json:"initContainers,omitempty"`
}

type PodStatus struct {
	Message               *string            `json:"message,omitempty"`
	Phase                 *string            `json:"phase,omitempty"`
	HostIP                *string            `json:"hostIp,omitempty"`
	PodIP                 *string            `json:"podIp,omitempty"`
	Reason                *string            `json:"reason,omitempty"`
	Conditions            []*PodCondition    `json:"conditions,omitempty"`
	ContainerStatuses     []*ContainerStatus `json:"containerStatuses,omitempty"`
	InitContainerStatuses []*ContainerStatus `json:"initContainerStatuses,omitempty"`
}

type PolicyBinding struct {
	ID    *string `json:"id,omitempty"`
	User  *User   `json:"user,omitempty"`
	Group *Group  `json:"group,omitempty"`
}

type PolicyBindingAttributes struct {
	ID      *string `json:"id,omitempty"`
	UserID  *string `json:"userId,omitempty"`
	GroupID *string `json:"groupId,omitempty"`
}

// A OPA Gatekeeper Constraint reference
type PolicyConstraint struct {
	ID             string                 `json:"id"`
	Name           string                 `json:"name"`
	Description    *string                `json:"description,omitempty"`
	Recommendation *string                `json:"recommendation,omitempty"`
	ViolationCount *int64                 `json:"violationCount,omitempty"`
	Enforcement    *ConstraintEnforcement `json:"enforcement,omitempty"`
	// Fetches the live constraint object from K8s, this is an expensive query and should not be done in list endpoints
	Object *KubernetesUnstructured `json:"object,omitempty"`
	// pointer to the kubernetes resource itself
	Ref        *ConstraintRef `json:"ref,omitempty"`
	Cluster    *Cluster       `json:"cluster,omitempty"`
	Violations []*Violation   `json:"violations,omitempty"`
	InsertedAt *string        `json:"insertedAt,omitempty"`
	UpdatedAt  *string        `json:"updatedAt,omitempty"`
}

// inputs to add constraint data from an OPA gatekeeper constraint CRD
type PolicyConstraintAttributes struct {
	Name           string  `json:"name"`
	Description    *string `json:"description,omitempty"`
	Recommendation *string `json:"recommendation,omitempty"`
	ViolationCount *int64  `json:"violationCount,omitempty"`
	// pointer to the group/name for the CR
	Ref         *ConstraintRefAttributes `json:"ref,omitempty"`
	Violations  []*ViolationAttributes   `json:"violations,omitempty"`
	Enforcement *ConstraintEnforcement   `json:"enforcement,omitempty"`
}

type PolicyConstraintConnection struct {
	PageInfo PageInfo                `json:"pageInfo"`
	Edges    []*PolicyConstraintEdge `json:"edges,omitempty"`
}

type PolicyConstraintEdge struct {
	Node   *PolicyConstraint `json:"node,omitempty"`
	Cursor *string           `json:"cursor,omitempty"`
}

// Configuration for applying policy enforcement to a stack
type PolicyEngine struct {
	// the policy engine to use with this stack
	Type PolicyEngineType `json:"type"`
	// the maximum allowed severity without failing the stack run
	MaxSeverity *VulnSeverity `json:"maxSeverity,omitempty"`
}

type PolicyEngineAttributes struct {
	// the policy engine to use with this stack
	Type PolicyEngineType `json:"type"`
	// the maximum allowed severity without failing the stack run
	MaxSeverity *VulnSeverity `json:"maxSeverity,omitempty"`
}

// Aggregate statistics for policies across your fleet
type PolicyStatistic struct {
	// the field you're computing this statistic on
	Aggregate *string `json:"aggregate,omitempty"`
	// the count for this aggregate
	Count *int64 `json:"count,omitempty"`
}

type Port struct {
	HostPort      *int64  `json:"hostPort,omitempty"`
	ContainerPort *int64  `json:"containerPort,omitempty"`
	Protocol      *string `json:"protocol,omitempty"`
}

// a description of how to generate a pr, which can either modify existing files or generate new ones w/in a repo
type PrAutomation struct {
	ID string `json:"id"`
	// string id for a repository, eg for github, this is {organization}/{repository-name}
	Identifier *string `json:"identifier,omitempty"`
	// the name for this automation
	Name string `json:"name"`
	// An enum describing the high-level responsibility of this pr, eg creating a cluster or service, or upgrading a cluster
	Role          *PrRole       `json:"role,omitempty"`
	Documentation *string       `json:"documentation,omitempty"`
	Title         string        `json:"title"`
	Message       string        `json:"message"`
	Updates       *PrUpdateSpec `json:"updates,omitempty"`
	Creates       *PrCreateSpec `json:"creates,omitempty"`
	Deletes       *PrDeleteSpec `json:"deletes,omitempty"`
	// an icon url to use for this catalog
	Icon *string `json:"icon,omitempty"`
	// a darkmode icon url to use for this catalog
	DarkIcon      *string            `json:"darkIcon,omitempty"`
	Configuration []*PrConfiguration `json:"configuration,omitempty"`
	// optional confirmation block to express prerequisites for this PR
	Confirmation *PrConfirmation `json:"confirmation,omitempty"`
	// write policy for this pr automation, also propagates to the notifications list for any created PRs
	WriteBindings []*PolicyBinding `json:"writeBindings,omitempty"`
	// users who can generate prs with this automation
	CreateBindings []*PolicyBinding `json:"createBindings,omitempty"`
	// link to an add-on name if this can update it
	Addon *string `json:"addon,omitempty"`
	// the git repository to use for sourcing external templates
	Repository *GitRepository `json:"repository,omitempty"`
	// the catalog this pr automation belongs to
	Catalog *Catalog `json:"catalog,omitempty"`
	// the project this automation lives w/in
	Project *Project `json:"project,omitempty"`
	// link to a cluster if this is to perform an upgrade
	Cluster *Cluster `json:"cluster,omitempty"`
	// link to a service if this can update its configuration
	Service *ServiceDeployment `json:"service,omitempty"`
	// the scm connection to use for pr generation
	Connection *ScmConnection `json:"connection,omitempty"`
	InsertedAt *string        `json:"insertedAt,omitempty"`
	UpdatedAt  *string        `json:"updatedAt,omitempty"`
}

// A way to create a self-service means of generating PRs against an IaC repo
type PrAutomationAttributes struct {
	Name *string `json:"name,omitempty"`
	Role *PrRole `json:"role,omitempty"`
	// string id for a repository, eg for github, this is {organization}/{repository-name}
	Identifier    *string `json:"identifier,omitempty"`
	Documentation *string `json:"documentation,omitempty"`
	Title         *string `json:"title,omitempty"`
	Message       *string `json:"message,omitempty"`
	Branch        *string `json:"branch,omitempty"`
	// whether to generate a patch for this pr instead of a full pr
	Patch   *bool                             `json:"patch,omitempty"`
	Updates *PrAutomationUpdateSpecAttributes `json:"updates,omitempty"`
	Creates *PrAutomationCreateSpecAttributes `json:"creates,omitempty"`
	Deletes *PrAutomationDeleteSpecAttributes `json:"deletes,omitempty"`
	// an icon url to use for this catalog
	Icon *string `json:"icon,omitempty"`
	// a darkmode icon url to use for this catalog
	DarkIcon *string `json:"darkIcon,omitempty"`
	// link to an add-on name if this can update it
	Addon *string `json:"addon,omitempty"`
	// link to a cluster if this is to perform an upgrade
	ClusterID *string `json:"clusterId,omitempty"`
	// link to a service if this can modify its configuration
	ServiceID *string `json:"serviceId,omitempty"`
	// the scm connection to use for pr generation
	ConnectionID *string `json:"connectionId,omitempty"`
	// the catalog this automation will belong to
	CatalogID *string `json:"catalogId,omitempty"`
	// the project this automation lives in
	ProjectID *string `json:"projectId,omitempty"`
	// a git repository to use for create mode prs
	RepositoryID *string `json:"repositoryId,omitempty"`
	// the governance controller to use for this pr
	GovernanceID  *string                      `json:"governanceId,omitempty"`
	Configuration []*PrConfigurationAttributes `json:"configuration,omitempty"`
	Confirmation  *PrConfirmationAttributes    `json:"confirmation,omitempty"`
	// users who can update this automation
	WriteBindings []*PolicyBindingAttributes `json:"writeBindings,omitempty"`
	// users who can create prs with this automation
	CreateBindings []*PolicyBindingAttributes `json:"createBindings,omitempty"`
}

type PrAutomationConnection struct {
	PageInfo PageInfo            `json:"pageInfo"`
	Edges    []*PrAutomationEdge `json:"edges,omitempty"`
}

// Operations to create new templated files within this pr
type PrAutomationCreateSpecAttributes struct {
	Git       *GitRefAttributes                 `json:"git,omitempty"`
	Templates []*PrAutomationTemplateAttributes `json:"templates,omitempty"`
}

// Operations to delete files within this pr
type PrAutomationDeleteSpecAttributes struct {
	Files   []string `json:"files,omitempty"`
	Folders []string `json:"folders,omitempty"`
}

type PrAutomationEdge struct {
	Node   *PrAutomation `json:"node,omitempty"`
	Cursor *string       `json:"cursor,omitempty"`
}

// templates to apply in this pr
type PrAutomationTemplateAttributes struct {
	Source      string  `json:"source"`
	Destination string  `json:"destination"`
	Context     *string `json:"context,omitempty"`
	Condition   *string `json:"condition,omitempty"`
	// whether the source template is sourced from an external git repo bound to this automation
	External bool `json:"external"`
}

// The operations to be performed on the files w/in the pr
type PrAutomationUpdateSpecAttributes struct {
	Regexes []*string `json:"regexes,omitempty"`
	// list of regex scope replacement templates, useful for ANY strategies
	RegexReplacements []*RegexReplacementAttributes `json:"regexReplacements,omitempty"`
	// list of yaml overlay operations to apply to a file
	YamlOverlays    []*YamlOverlayAttributes `json:"yamlOverlays,omitempty"`
	Files           []*string                `json:"files,omitempty"`
	ReplaceTemplate *string                  `json:"replaceTemplate,omitempty"`
	Yq              *string                  `json:"yq,omitempty"`
	MatchStrategy   *MatchStrategy           `json:"matchStrategy,omitempty"`
}

// Additional attributes for describing a pr call tool call that derived this chat message
type PrCallAttributes struct {
	Context map[string]any `json:"context,omitempty"`
}

// a checkbox item to render before creating a pr
type PrChecklist struct {
	// the label for the checkbox
	Label string `json:"label"`
}

// a checkbox item to render before creating a pr
type PrChecklistAttributes struct {
	// the label for the checkbox
	Label string `json:"label"`
}

// the a configuration item for creating a new pr, used for templating the ultimate code changes made
type PrConfiguration struct {
	Type          ConfigurationType         `json:"type"`
	Name          string                    `json:"name"`
	Default       *string                   `json:"default,omitempty"`
	Documentation *string                   `json:"documentation,omitempty"`
	Longform      *string                   `json:"longform,omitempty"`
	Placeholder   *string                   `json:"placeholder,omitempty"`
	DisplayName   *string                   `json:"displayName,omitempty"`
	Optional      *bool                     `json:"optional,omitempty"`
	Values        []*string                 `json:"values,omitempty"`
	Condition     *PrConfigurationCondition `json:"condition,omitempty"`
}

// the a configuration item for creating a new pr
type PrConfigurationAttributes struct {
	Type          ConfigurationType                  `json:"type"`
	Name          string                             `json:"name"`
	Default       *string                            `json:"default,omitempty"`
	Documentation *string                            `json:"documentation,omitempty"`
	Longform      *string                            `json:"longform,omitempty"`
	DisplayName   *string                            `json:"displayName,omitempty"`
	Placeholder   *string                            `json:"placeholder,omitempty"`
	Optional      *bool                              `json:"optional,omitempty"`
	Condition     *ConditionAttributes               `json:"condition,omitempty"`
	Validation    *ConfigurationValidationAttributes `json:"validation,omitempty"`
	Values        []*string                          `json:"values,omitempty"`
}

// declaritive spec for whether a config item is relevant given prior config
type PrConfigurationCondition struct {
	// a boolean operation to apply
	Operation Operation `json:"operation"`
	// the prior field to check
	Field string `json:"field"`
	// a fixed value to check against if its a binary operation
	Value *string `json:"value,omitempty"`
}

// Additional details to verify all prerequisites are satisfied before generating this pr
type PrConfirmation struct {
	// optional markdown text to present before pr create
	Text *string `json:"text,omitempty"`
	// itemized checklist to complete before pr create
	Checklist []*PrChecklist `json:"checklist,omitempty"`
}

// Additional details to verify all prerequisites are satisfied before generating this pr
type PrConfirmationAttributes struct {
	// optional markdown text to present before pr create
	Text *string `json:"text,omitempty"`
	// itemized checklist to complete before pr create
	Checklist []*PrChecklistAttributes `json:"checklist,omitempty"`
}

// templated files used to add new files to a given pr
type PrCreateSpec struct {
	// pointer within an external git repository to source templates from
	Git       *GitRef           `json:"git,omitempty"`
	Templates []*PrTemplateSpec `json:"templates,omitempty"`
}

// Files or folders you want to delete in this pr
type PrDeleteSpec struct {
	Files   []string `json:"files,omitempty"`
	Folders []string `json:"folders,omitempty"`
}

// A governance controller is a mechanism to enforce a set of rules on a set of PRs
type PrGovernance struct {
	ID            string                     `json:"id"`
	Name          string                     `json:"name"`
	Connection    *ScmConnection             `json:"connection,omitempty"`
	Configuration *PrGovernanceConfiguration `json:"configuration,omitempty"`
	InsertedAt    *string                    `json:"insertedAt,omitempty"`
	UpdatedAt     *string                    `json:"updatedAt,omitempty"`
}

// The settings for configuring a pr governance controller
type PrGovernanceAttributes struct {
	Name string `json:"name"`
	// the scm connection to use for pr generation
	ConnectionID  string                               `json:"connectionId"`
	Configuration *PrGovernanceConfigurationAttributes `json:"configuration,omitempty"`
}

// The configuration for a pr governance controller
type PrGovernanceConfiguration struct {
	Webhook *GovernanceWebhook `json:"webhook,omitempty"`
}

// The settings for configuring a pr governance controller
type PrGovernanceConfigurationAttributes struct {
	Webhook *GovernanceWebhookAttributes `json:"webhook,omitempty"`
}

// the details of where to find and place a templated file
type PrTemplateSpec struct {
	Source      string         `json:"source"`
	Destination string         `json:"destination"`
	Context     map[string]any `json:"context,omitempty"`
	External    bool           `json:"external"`
	Condition   *string        `json:"condition,omitempty"`
}

// existing file updates that can be performed in a PR
type PrUpdateSpec struct {
	Regexes           []*string           `json:"regexes,omitempty"`
	RegexReplacements []*RegexReplacement `json:"regexReplacements,omitempty"`
	YamlOverlays      []*YamlOverlay      `json:"yamlOverlays,omitempty"`
	Files             []*string           `json:"files,omitempty"`
	ReplaceTemplate   *string             `json:"replaceTemplate,omitempty"`
	Yq                *string             `json:"yq,omitempty"`
	MatchStrategy     *MatchStrategy      `json:"matchStrategy,omitempty"`
}

// An instance of a preview environment template
type PreviewEnvironmentInstance struct {
	ID          string                      `json:"id"`
	Service     *ServiceDeployment          `json:"service,omitempty"`
	PullRequest *PullRequest                `json:"pullRequest,omitempty"`
	Template    *PreviewEnvironmentTemplate `json:"template,omitempty"`
	InsertedAt  *string                     `json:"insertedAt,omitempty"`
	UpdatedAt   *string                     `json:"updatedAt,omitempty"`
}

type PreviewEnvironmentInstanceConnection struct {
	PageInfo PageInfo                          `json:"pageInfo"`
	Edges    []*PreviewEnvironmentInstanceEdge `json:"edges,omitempty"`
}

type PreviewEnvironmentInstanceEdge struct {
	Node   *PreviewEnvironmentInstance `json:"node,omitempty"`
	Cursor *string                     `json:"cursor,omitempty"`
}

// A template for generating preview environments
type PreviewEnvironmentTemplate struct {
	ID               string             `json:"id"`
	Name             string             `json:"name"`
	CommentTemplate  *string            `json:"commentTemplate,omitempty"`
	Flow             *Flow              `json:"flow,omitempty"`
	ReferenceService *ServiceDeployment `json:"referenceService,omitempty"`
	Template         *ServiceTemplate   `json:"template,omitempty"`
	Connection       *ScmConnection     `json:"connection,omitempty"`
	InsertedAt       *string            `json:"insertedAt,omitempty"`
	UpdatedAt        *string            `json:"updatedAt,omitempty"`
}

type PreviewEnvironmentTemplateAttributes struct {
	// the name of the preview environment template
	Name string `json:"name"`
	// a liquid template for custom information in the PR comment
	CommentTemplate *string `json:"commentTemplate,omitempty"`
	// the flow that will own the preview environment
	FlowID string `json:"flowId"`
	// the service that will be cloned to create the preview environment
	ReferenceServiceID string `json:"referenceServiceId"`
	// a set of service configuration overrides to use while cloning
	Template ServiceTemplateAttributes `json:"template"`
	// an scm connection id to use for PR preview comment generation
	ConnectionID *string `json:"connectionId,omitempty"`
}

type PreviewEnvironmentTemplateConnection struct {
	PageInfo PageInfo                          `json:"pageInfo"`
	Edges    []*PreviewEnvironmentTemplateEdge `json:"edges,omitempty"`
}

type PreviewEnvironmentTemplateEdge struct {
	Node   *PreviewEnvironmentTemplate `json:"node,omitempty"`
	Cursor *string                     `json:"cursor,omitempty"`
}

// A unit of organization to control permissions for a set of objects within your Console instance
type Project struct {
	ID          string  `json:"id"`
	Name        string  `json:"name"`
	Description *string `json:"description,omitempty"`
	Default     *bool   `json:"default,omitempty"`
	// list all alerts discovered for this project
	Alerts *AlertConnection `json:"alerts,omitempty"`
	// read policy across this project
	ReadBindings []*PolicyBinding `json:"readBindings,omitempty"`
	// write policy across this project
	WriteBindings []*PolicyBinding `json:"writeBindings,omitempty"`
	InsertedAt    *string          `json:"insertedAt,omitempty"`
	UpdatedAt     *string          `json:"updatedAt,omitempty"`
}

type ProjectAttributes struct {
	Name          string                     `json:"name"`
	Description   *string                    `json:"description,omitempty"`
	ReadBindings  []*PolicyBindingAttributes `json:"readBindings,omitempty"`
	WriteBindings []*PolicyBindingAttributes `json:"writeBindings,omitempty"`
}

type ProjectConnection struct {
	PageInfo PageInfo       `json:"pageInfo"`
	Edges    []*ProjectEdge `json:"edges,omitempty"`
}

type ProjectEdge struct {
	Node   *Project `json:"node,omitempty"`
	Cursor *string  `json:"cursor,omitempty"`
}

type ProjectUsageHistory struct {
	Timestamp        string   `json:"timestamp"`
	CPU              *float64 `json:"cpu,omitempty"`
	Memory           *float64 `json:"memory,omitempty"`
	Gpu              *float64 `json:"gpu,omitempty"`
	CPUCost          *float64 `json:"cpuCost,omitempty"`
	MemoryCost       *float64 `json:"memoryCost,omitempty"`
	GpuCost          *float64 `json:"gpuCost,omitempty"`
	IngressCost      *float64 `json:"ingressCost,omitempty"`
	LoadBalancerCost *float64 `json:"loadBalancerCost,omitempty"`
	EgressCost       *float64 `json:"egressCost,omitempty"`
	NodeCost         *float64 `json:"nodeCost,omitempty"`
	StorageCost      *float64 `json:"storageCost,omitempty"`
	ControlPlaneCost *float64 `json:"controlPlaneCost,omitempty"`
	ProjectID        *string  `json:"projectId,omitempty"`
}

type ProjectUsageHistoryConnection struct {
	PageInfo PageInfo                   `json:"pageInfo"`
	Edges    []*ProjectUsageHistoryEdge `json:"edges,omitempty"`
}

type ProjectUsageHistoryEdge struct {
	Node   *ProjectUsageHistory `json:"node,omitempty"`
	Cursor *string              `json:"cursor,omitempty"`
}

// how a promotion for a service will be performed
type PromotionCriteria struct {
	ID string `json:"id"`
	// overrides the repository slug for the referenced pr automation
	Repository *string `json:"repository,omitempty"`
	// the source service in a prior stage to promote settings from
	Source *ServiceDeployment `json:"source,omitempty"`
	// whether you want to copy any configuration values from the source service
	Secrets    []*string `json:"secrets,omitempty"`
	InsertedAt *string   `json:"insertedAt,omitempty"`
	UpdatedAt  *string   `json:"updatedAt,omitempty"`
}

// actions to perform if this stage service were promoted
type PromotionCriteriaAttributes struct {
	// the handle of the cluster for the source service
	Handle *string `json:"handle,omitempty"`
	// the name of the source service
	Name *string `json:"name,omitempty"`
	// the id of the service to promote from
	SourceID *string `json:"sourceId,omitempty"`
	// the id of a pr automation to update this service
	PrAutomationID *string `json:"prAutomationId,omitempty"`
	// overrides the repository slug for the referenced pr automation
	Repository *string `json:"repository,omitempty"`
	// the secrets to copy over in a promotion
	Secrets []*string `json:"secrets,omitempty"`
}

// a service to be potentially promoted
type PromotionService struct {
	ID string `json:"id"`
	// a service to promote
	Service *ServiceDeployment `json:"service,omitempty"`
	// the revision of the service to promote
	Revision   *Revision `json:"revision,omitempty"`
	InsertedAt *string   `json:"insertedAt,omitempty"`
	UpdatedAt  *string   `json:"updatedAt,omitempty"`
}

// a cloud credential that can be used while creating new clusters
type ProviderCredential struct {
	ID         string  `json:"id"`
	Name       string  `json:"name"`
	Namespace  string  `json:"namespace"`
	Kind       string  `json:"kind"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

type ProviderCredentialAttributes struct {
	Namespace *string `json:"namespace,omitempty"`
	Name      string  `json:"name"`
	Kind      *string `json:"kind,omitempty"`
}

// A reference to a pull request for your kubernetes related IaC
type PullRequest struct {
	ID      string    `json:"id"`
	Status  *PrStatus `json:"status,omitempty"`
	URL     string    `json:"url"`
	Title   *string   `json:"title,omitempty"`
	Creator *string   `json:"creator,omitempty"`
	Labels  []*string `json:"labels,omitempty"`
	// the patch for this pr, if it is a patch.  This is in place of generating a full pr
	Patch *string `json:"patch,omitempty"`
	// the flow this pr is meant to modify
	Flow *Flow `json:"flow,omitempty"`
	// the cluster this pr is meant to modify
	Cluster *Cluster `json:"cluster,omitempty"`
	// the service this pr is meant to modify
	Service    *ServiceDeployment `json:"service,omitempty"`
	InsertedAt *string            `json:"insertedAt,omitempty"`
	UpdatedAt  *string            `json:"updatedAt,omitempty"`
}

// attributes for a pull request pointer record
type PullRequestAttributes struct {
	URL       string          `json:"url"`
	Title     string          `json:"title"`
	Creator   *string         `json:"creator,omitempty"`
	Labels    []*string       `json:"labels,omitempty"`
	ServiceID *string         `json:"serviceId,omitempty"`
	ClusterID *string         `json:"clusterId,omitempty"`
	Service   *NamespacedName `json:"service,omitempty"`
	Cluster   *NamespacedName `json:"cluster,omitempty"`
}

type PullRequestConnection struct {
	PageInfo PageInfo           `json:"pageInfo"`
	Edges    []*PullRequestEdge `json:"edges,omitempty"`
}

type PullRequestEdge struct {
	Node   *PullRequest `json:"node,omitempty"`
	Cursor *string      `json:"cursor,omitempty"`
}

type PullRequestEvidence struct {
	URL      *string `json:"url,omitempty"`
	Title    *string `json:"title,omitempty"`
	Repo     *string `json:"repo,omitempty"`
	Sha      *string `json:"sha,omitempty"`
	Filename *string `json:"filename,omitempty"`
	Contents *string `json:"contents,omitempty"`
	Patch    *string `json:"patch,omitempty"`
}

// attributes for a pull request pointer record
type PullRequestUpdateAttributes struct {
	Title     string          `json:"title"`
	Labels    []*string       `json:"labels,omitempty"`
	Status    PrStatus        `json:"status"`
	ServiceID *string         `json:"serviceId,omitempty"`
	ClusterID *string         `json:"clusterId,omitempty"`
	Service   *NamespacedName `json:"service,omitempty"`
	Cluster   *NamespacedName `json:"cluster,omitempty"`
}

type RbacAttributes struct {
	ReadBindings  []*PolicyBindingAttributes `json:"readBindings,omitempty"`
	WriteBindings []*PolicyBindingAttributes `json:"writeBindings,omitempty"`
}

type Recommendation struct {
	ContainerRecommendations []*ContainerRecommendation `json:"containerRecommendations,omitempty"`
}

type RefreshToken struct {
	ID string `json:"id"`
	// the token to use to request a refresh
	Token      string  `json:"token"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

type RefreshTokenConnection struct {
	PageInfo PageInfo            `json:"pageInfo"`
	Edges    []*RefreshTokenEdge `json:"edges,omitempty"`
}

type RefreshTokenEdge struct {
	Node   *RefreshToken `json:"node,omitempty"`
	Cursor *string       `json:"cursor,omitempty"`
}

// a fully specified regex/replace flow
type RegexReplacement struct {
	Regex string `json:"regex"`
	// the file to apply this replacement on
	File string `json:"file"`
	// template string to replace any match with
	Replacement string `json:"replacement"`
	// Whether to apply liquid templating before compiling this regex
	Templated *bool `json:"templated,omitempty"`
}

// a fully specified regex/replace flow
type RegexReplacementAttributes struct {
	Regex       string `json:"regex"`
	Replacement string `json:"replacement"`
	// the filename to apply this regex on
	File string `json:"file"`
	// whether you want to apply liquid templating on the regex before compiling
	Templated *bool `json:"templated,omitempty"`
}

type Renderer struct {
	Path string       `json:"path"`
	Type RendererType `json:"type"`
	Helm *HelmMinimal `json:"helm,omitempty"`
}

type RendererAttributes struct {
	Path string                 `json:"path"`
	Type RendererType           `json:"type"`
	Helm *HelmMinimalAttributes `json:"helm,omitempty"`
}

type ReplicaSet struct {
	Metadata Metadata         `json:"metadata"`
	Spec     ReplicaSetSpec   `json:"spec"`
	Status   ReplicaSetStatus `json:"status"`
	Pods     []*Pod           `json:"pods,omitempty"`
	Raw      string           `json:"raw"`
}

type ReplicaSetSpec struct {
	Replicas *int64 `json:"replicas,omitempty"`
}

type ReplicaSetStatus struct {
	AvailableReplicas    *int64             `json:"availableReplicas,omitempty"`
	Conditions           []*StatusCondition `json:"conditions,omitempty"`
	Replicas             *int64             `json:"replicas,omitempty"`
	ReadyReplicas        *int64             `json:"readyReplicas,omitempty"`
	FullyLabeledReplicas *int64             `json:"fullyLabeledReplicas,omitempty"`
}

// an edge representing mapping from kubernetes object metadata.uid -> metadata.uid
type ResourceEdge struct {
	From string `json:"from"`
	To   string `json:"to"`
}

// A kubernetes pod container resource request spec
type ResourceRequest struct {
	CPU    *string `json:"cpu,omitempty"`
	Memory *string `json:"memory,omitempty"`
}

type ResourceRequestAttributes struct {
	CPU    *string `json:"cpu,omitempty"`
	Memory *string `json:"memory,omitempty"`
}

type ResourceSelector struct {
	Included []*string `json:"included,omitempty"`
	Excluded []*string `json:"excluded,omitempty"`
}

type ResourceSelectorAttributes struct {
	Included []*string `json:"included,omitempty"`
	Excluded []*string `json:"excluded,omitempty"`
}

type ResourceSpec struct {
	CPU    *string `json:"cpu,omitempty"`
	Memory *string `json:"memory,omitempty"`
}

type Resources struct {
	Limits   *ResourceSpec `json:"limits,omitempty"`
	Requests *ResourceSpec `json:"requests,omitempty"`
}

type RestoreAttributes struct {
	Status RestoreStatus `json:"status"`
}

// a representation of a past revision of a service
type Revision struct {
	// id of this revision
	ID string `json:"id"`
	// the service's semver
	Version string `json:"version"`
	// git spec of the prior revision
	Git *GitRef `json:"git,omitempty"`
	// description of how helm charts should be applied
	Helm *HelmSpec `json:"helm,omitempty"`
	// the sha this service was pulled from
	Sha *string `json:"sha,omitempty"`
	// the commit message for this revision
	Message    *string `json:"message,omitempty"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

type RevisionConnection struct {
	PageInfo PageInfo        `json:"pageInfo"`
	Edges    []*RevisionEdge `json:"edges,omitempty"`
}

type RevisionEdge struct {
	Node   *Revision `json:"node,omitempty"`
	Cursor *string   `json:"cursor,omitempty"`
}

type Role struct {
	ID           string         `json:"id"`
	Name         string         `json:"name"`
	Description  *string        `json:"description,omitempty"`
	Repositories []*string      `json:"repositories,omitempty"`
	Permissions  []*Permission  `json:"permissions,omitempty"`
	RoleBindings []*RoleBinding `json:"roleBindings,omitempty"`
	InsertedAt   *string        `json:"insertedAt,omitempty"`
	UpdatedAt    *string        `json:"updatedAt,omitempty"`
}

type RoleAttributes struct {
	Name         *string              `json:"name,omitempty"`
	Description  *string              `json:"description,omitempty"`
	Repositories []*string            `json:"repositories,omitempty"`
	RoleBindings []*BindingAttributes `json:"roleBindings,omitempty"`
	Permissions  []*Permission        `json:"permissions,omitempty"`
}

type RoleBinding struct {
	ID         string  `json:"id"`
	User       *User   `json:"user,omitempty"`
	Group      *Group  `json:"group,omitempty"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

type RoleConnection struct {
	PageInfo PageInfo    `json:"pageInfo"`
	Edges    []*RoleEdge `json:"edges,omitempty"`
}

type RoleEdge struct {
	Node   *Role   `json:"node,omitempty"`
	Cursor *string `json:"cursor,omitempty"`
}

type RollingUpdate struct {
	MaxSurge       *int64 `json:"maxSurge,omitempty"`
	MaxUnavailable *int64 `json:"maxUnavailable,omitempty"`
}

type RootMutationType struct {
}

type RootQueryType struct {
}

type RootSubscriptionType struct {
}

type RouterFilterAttributes struct {
	// a regex for filtering by things like pr url
	Regex *string `json:"regex,omitempty"`
	// whether to enable delivery for events associated with this service
	ServiceID *string `json:"serviceId,omitempty"`
	// whether to enable delivery for events associated with this cluster
	ClusterID *string `json:"clusterId,omitempty"`
	// whether to enable delivery for events associated with this pipeline
	PipelineID *string `json:"pipelineId,omitempty"`
}

type RouterSinkAttributes struct {
	SinkID string `json:"sinkId"`
}

type RunLogAttributes struct {
	Logs string `json:"logs"`
}

type RunLogs struct {
	ID         string  `json:"id"`
	Logs       string  `json:"logs"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

type RunLogsDelta struct {
	Delta   *Delta   `json:"delta,omitempty"`
	Payload *RunLogs `json:"payload,omitempty"`
}

type RunStep struct {
	ID              string     `json:"id"`
	Status          StepStatus `json:"status"`
	Stage           StepStage  `json:"stage"`
	Name            string     `json:"name"`
	Cmd             string     `json:"cmd"`
	Args            []string   `json:"args,omitempty"`
	RequireApproval *bool      `json:"requireApproval,omitempty"`
	Index           int64      `json:"index"`
	Logs            []*RunLogs `json:"logs,omitempty"`
	InsertedAt      *string    `json:"insertedAt,omitempty"`
	UpdatedAt       *string    `json:"updatedAt,omitempty"`
}

type RunStepAttributes struct {
	Status StepStatus `json:"status"`
}

type RunningState struct {
	StartedAt *string `json:"startedAt,omitempty"`
}

// a full specification of a kubernetes runtime component's requirements
type RuntimeAddon struct {
	// an icon to identify this runtime add-on
	Icon *string `json:"icon,omitempty"`
	// the url to the add-ons git repository
	GitURL *string `json:"gitUrl,omitempty"`
	// the add-on's readme, this is a heavy operation that should not be performed w/in lists
	Readme *string `json:"readme,omitempty"`
	// the release page for a runtime service at a version, this is a heavy operation not suitable for lists
	ReleaseURL *string         `json:"releaseUrl,omitempty"`
	Versions   []*AddonVersion `json:"versions,omitempty"`
}

// a service encapsulating a controller like istio/ingress-nginx/etc that is meant to extend the kubernetes api
type RuntimeService struct {
	ID string `json:"id"`
	// add-on name
	Name string `json:"name"`
	// add-on version, should be semver formatted
	Version string `json:"version"`
	// the number of instances of this service we've detected
	InstanceCount *int64 `json:"instanceCount,omitempty"`
	// the full specification of this kubernetes add-on
	Addon *RuntimeAddon `json:"addon,omitempty"`
	// the version of the add-on you've currently deployed
	AddonVersion *AddonVersion `json:"addonVersion,omitempty"`
	// the plural service it came from
	Service    *ServiceDeployment `json:"service,omitempty"`
	InsertedAt *string            `json:"insertedAt,omitempty"`
	UpdatedAt  *string            `json:"updatedAt,omitempty"`
}

type RuntimeServiceAttributes struct {
	Name    string `json:"name"`
	Version string `json:"version"`
	// the number of instances of this service we've found
	InstanceCount *int64 `json:"instanceCount,omitempty"`
}

type S3Store struct {
	Bucket      string  `json:"bucket"`
	Region      *string `json:"region,omitempty"`
	Endpoint    *string `json:"endpoint,omitempty"`
	AccessKeyID string  `json:"accessKeyId"`
}

type S3StoreAttributes struct {
	Bucket          string  `json:"bucket"`
	Region          *string `json:"region,omitempty"`
	Endpoint        *string `json:"endpoint,omitempty"`
	AccessKeyID     string  `json:"accessKeyId"`
	SecretAccessKey string  `json:"secretAccessKey"`
}

// an object representing the means to connect to SCM apis
type ScmConnection struct {
	ID       string  `json:"id"`
	Name     string  `json:"name"`
	Type     ScmType `json:"type"`
	Default  *bool   `json:"default,omitempty"`
	Username *string `json:"username,omitempty"`
	// base url for git clones for self-hosted versions
	BaseURL *string `json:"baseUrl,omitempty"`
	// base url for HTTP apis for self-hosted versions if different from base url
	APIURL     *string `json:"apiUrl,omitempty"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

// an object representing a means to authenticate to a source control provider like Github
type ScmConnectionAttributes struct {
	Name string  `json:"name"`
	Type ScmType `json:"type"`
	// the owning entity in this scm provider, eg a github organization
	Owner    *string              `json:"owner,omitempty"`
	Username *string              `json:"username,omitempty"`
	Token    *string              `json:"token,omitempty"`
	BaseURL  *string              `json:"baseUrl,omitempty"`
	APIURL   *string              `json:"apiUrl,omitempty"`
	Github   *GithubAppAttributes `json:"github,omitempty"`
	Default  *bool                `json:"default,omitempty"`
	// a ssh private key to be used for commit signing
	SigningPrivateKey *string `json:"signingPrivateKey,omitempty"`
}

type ScmConnectionConnection struct {
	PageInfo PageInfo             `json:"pageInfo"`
	Edges    []*ScmConnectionEdge `json:"edges,omitempty"`
}

type ScmConnectionEdge struct {
	Node   *ScmConnection `json:"node,omitempty"`
	Cursor *string        `json:"cursor,omitempty"`
}

type ScmWebhook struct {
	ID    string  `json:"id"`
	Type  ScmType `json:"type"`
	Owner string  `json:"owner"`
	// the url for this specific webhook
	URL string `json:"url"`
	// the name in your SCM provider for this webhook
	Name       string  `json:"name"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

// The attributes to configure a new webhook for a SCM provider
type ScmWebhookAttributes struct {
	// the secret token for authenticating this webhook via hmac signature
	Hmac string `json:"hmac"`
	// the type of webhook to create
	Type ScmType `json:"type"`
	// the owner for this webhook in your SCM, eg a github org or gitlab group
	Owner string `json:"owner"`
}

type ScmWebhookConnection struct {
	PageInfo PageInfo          `json:"pageInfo"`
	Edges    []*ScmWebhookEdge `json:"edges,omitempty"`
}

type ScmWebhookEdge struct {
	Node   *ScmWebhook `json:"node,omitempty"`
	Cursor *string     `json:"cursor,omitempty"`
}

type ScopeAttributes struct {
	API        *string  `json:"api,omitempty"`
	Apis       []string `json:"apis,omitempty"`
	Identifier *string  `json:"identifier,omitempty"`
	Ids        []string `json:"ids,omitempty"`
}

type Secret struct {
	Metadata Metadata       `json:"metadata"`
	Type     *string        `json:"type,omitempty"`
	Data     map[string]any `json:"data"`
}

type Service struct {
	Metadata Metadata      `json:"metadata"`
	Status   ServiceStatus `json:"status"`
	Spec     ServiceSpec   `json:"spec"`
	Pods     []*Pod        `json:"pods,omitempty"`
	Raw      string        `json:"raw"`
	Events   []*Event      `json:"events,omitempty"`
}

type ServiceAccountAttributes struct {
	Name           *string                    `json:"name,omitempty"`
	Email          *string                    `json:"email,omitempty"`
	Roles          *UserRoleAttributes        `json:"roles,omitempty"`
	AssumeBindings []*PolicyBindingAttributes `json:"assumeBindings,omitempty"`
}

type ServiceCloneAttributes struct {
	Name          string              `json:"name"`
	Namespace     *string             `json:"namespace,omitempty"`
	Configuration []*ConfigAttributes `json:"configuration,omitempty"`
}

// representation of a kubernetes component deployed by a service
type ServiceComponent struct {
	// internal id
	ID string `json:"id"`
	// kubernetes component health enum
	State *ComponentState `json:"state,omitempty"`
	// whether this component has been applied to the k8s api
	Synced bool `json:"synced"`
	// api group of this resource
	Group *string `json:"group,omitempty"`
	// api version of this resource
	Version *string `json:"version,omitempty"`
	// api kind of this resource
	Kind string `json:"kind"`
	// kubernetes namespace of this resource
	Namespace *string `json:"namespace,omitempty"`
	// kubernetes name of this resource
	Name string `json:"name"`
	// kubernetes uid of this resource
	UID *string `json:"uid,omitempty"`
	// an insight explaining the state of this component
	Insight *AiInsight `json:"insight,omitempty"`
	// the live and desired states of this service component
	Content *ComponentContent `json:"content,omitempty"`
	// the service this component belongs to
	Service *ServiceDeployment `json:"service,omitempty"`
	// any api deprecations discovered from this component
	APIDeprecations []*APIDeprecation `json:"apiDeprecations,omitempty"`
	// any kubernetes objects created as a descendent of this component
	Children   []*ServiceComponentChild `json:"children,omitempty"`
	InsertedAt *string                  `json:"insertedAt,omitempty"`
	UpdatedAt  *string                  `json:"updatedAt,omitempty"`
}

// a kubernetes object that was created as a descendent of this service component
type ServiceComponentChild struct {
	ID        string          `json:"id"`
	UID       string          `json:"uid"`
	State     *ComponentState `json:"state,omitempty"`
	ParentUID *string         `json:"parentUid,omitempty"`
	Name      string          `json:"name"`
	Namespace *string         `json:"namespace,omitempty"`
	Group     *string         `json:"group,omitempty"`
	Version   string          `json:"version"`
	Kind      string          `json:"kind"`
	// an insight explaining the state of this component
	Insight    *AiInsight `json:"insight,omitempty"`
	InsertedAt *string    `json:"insertedAt,omitempty"`
	UpdatedAt  *string    `json:"updatedAt,omitempty"`
}

type ServiceComponentMetrics struct {
	CPU    []*MetricResponse `json:"cpu,omitempty"`
	Mem    []*MetricResponse `json:"mem,omitempty"`
	PodCPU []*MetricResponse `json:"podCpu,omitempty"`
	PodMem []*MetricResponse `json:"podMem,omitempty"`
}

// a configuration item k/v pair
type ServiceConfiguration struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

// A reusable bundle of configuration designed to make it easy to communicate between tools like tf/pulumi and k8s
type ServiceContext struct {
	ID            string                  `json:"id"`
	Name          string                  `json:"name"`
	Configuration map[string]any          `json:"configuration,omitempty"`
	Secrets       []*ServiceConfiguration `json:"secrets,omitempty"`
	// the project this context belongs to
	Project    *Project `json:"project,omitempty"`
	InsertedAt *string  `json:"insertedAt,omitempty"`
	UpdatedAt  *string  `json:"updatedAt,omitempty"`
}

// A reusable configuration context, useful for plumbing data from external tools like terraform/pulumi/etc
type ServiceContextAttributes struct {
	// the project this context belongs to
	ProjectID     *string             `json:"projectId,omitempty"`
	Configuration *string             `json:"configuration,omitempty"`
	Secrets       []*ConfigAttributes `json:"secrets,omitempty"`
}

// A dependency of a service, the service will not actualize until all dependencies are ready
type ServiceDependency struct {
	ID         string                   `json:"id"`
	Status     *ServiceDeploymentStatus `json:"status,omitempty"`
	Name       string                   `json:"name"`
	InsertedAt *string                  `json:"insertedAt,omitempty"`
	UpdatedAt  *string                  `json:"updatedAt,omitempty"`
}

// A named depedency of a service, will prevent applying any manifests until the dependency has become ready
type ServiceDependencyAttributes struct {
	Name string `json:"name"`
}

// a reference to a service deployed from a git repo into a cluster
type ServiceDeployment struct {
	// internal id of this service
	ID string `json:"id"`
	// human readable name of this service, must be unique per cluster
	Name string `json:"name"`
	// kubernetes namespace this service will be deployed to
	Namespace string `json:"namespace"`
	// A summary status enum for the health of this service
	Status ServiceDeploymentStatus `json:"status"`
	// semver of this service
	Version string `json:"version"`
	// the desired sync interval for this service
	Interval *string `json:"interval,omitempty"`
	// description on where in git the service's manifests should be fetched
	Git *GitRef `json:"git,omitempty"`
	// description of how helm charts should be applied
	Helm *HelmSpec `json:"helm,omitempty"`
	// the agent id this service is associated with
	AgentID *string `json:"agentId,omitempty"`
	// how you'd like to perform a canary promotion
	Promotion *ServicePromotion `json:"promotion,omitempty"`
	// if you should apply liquid templating to raw yaml files, defaults to true
	Templated *bool `json:"templated,omitempty"`
	// if true, deletion of this service is not allowed
	Protect *bool `json:"protect,omitempty"`
	// latest git sha we pulled from
	Sha *string `json:"sha,omitempty"`
	// https url to fetch the latest tarball of kubernetes manifests
	Tarball *string `json:"tarball,omitempty"`
	// a n / m representation of the number of healthy components of this service
	ComponentStatus *string `json:"componentStatus,omitempty"`
	// settings for advanced tuning of the sync process
	SyncConfig *SyncConfig `json:"syncConfig,omitempty"`
	// kustomize related service metadata
	Kustomize *Kustomize `json:"kustomize,omitempty"`
	// the commit message currently in use
	Message *string `json:"message,omitempty"`
	// the time this service was scheduled for deletion
	DeletedAt *string `json:"deletedAt,omitempty"`
	// whether this service should not actively reconcile state and instead simply report pending changes
	DryRun *bool `json:"dryRun,omitempty"`
	// the sources of this service
	Sources []*ServiceSource `json:"sources,omitempty"`
	// the renderers of this service
	Renderers []*Renderer `json:"renderers,omitempty"`
	// fetches the /docs directory within this services git tree.  This is a heavy operation and should NOT be used in list queries
	Docs []*GitFile `json:"docs,omitempty"`
	// the git repo of this service
	Repository     *GitRepository      `json:"repository,omitempty"`
	HelmRepository *FluxHelmRepository `json:"helmRepository,omitempty"`
	// Queries logs for a service out of loki
	Logs []*LogStream `json:"logs,omitempty"`
	// authorizes the given component or nested child id and returns the raw kubernetes resource it points to
	RawResource *KubernetesUnstructured `json:"rawResource,omitempty"`
	// read policy for this service
	ReadBindings []*PolicyBinding `json:"readBindings,omitempty"`
	// write policy of this service
	WriteBindings []*PolicyBinding `json:"writeBindings,omitempty"`
	// the service that owns this service in a service-of-services setup
	Parent *ServiceDeployment `json:"parent,omitempty"`
	// a list of errors generated by the deployment operator
	Errors []*ServiceError `json:"errors,omitempty"`
	// the cluster this service is deployed into
	Cluster *Cluster `json:"cluster,omitempty"`
	// the current revision of this service
	Revision *Revision `json:"revision,omitempty"`
	// possibly secret configuration used to template the manifests of this service
	Configuration []*ServiceConfiguration `json:"configuration,omitempty"`
	// the kubernetes component of a service
	Components []*ServiceComponent `json:"components,omitempty"`
	// the global service this service is the source for
	GlobalService *GlobalService `json:"globalService,omitempty"`
	// whether this service is controlled by a global service
	Owner *GlobalService `json:"owner,omitempty"`
	// bound contexts for this service
	Contexts []*ServiceContext `json:"contexts,omitempty"`
	// the dependencies of this service, actualization will not happen until all are HEALTHY
	Dependencies []*ServiceDependency `json:"dependencies,omitempty"`
	// imports from stack outputs
	Imports []*ServiceImport `json:"imports,omitempty"`
	// an insight explaining the state of this service
	Insight *AiInsight `json:"insight,omitempty"`
	// sideload detected vulnerabilities for this service
	Vulns *ServiceVuln `json:"vulns,omitempty"`
	// the flow this service belongs to
	Flow         *Flow              `json:"flow,omitempty"`
	NetworkGraph []*NetworkMeshEdge `json:"networkGraph,omitempty"`
	// a relay connection of all revisions of this service, these are periodically pruned up to a history limit
	Revisions *RevisionConnection `json:"revisions,omitempty"`
	// list all alerts discovered for this service
	Alerts                 *AlertConnection                `json:"alerts,omitempty"`
	ScalingRecommendations []*ClusterScalingRecommendation `json:"scalingRecommendations,omitempty"`
	ComponentMetrics       *ServiceComponentMetrics        `json:"componentMetrics,omitempty"`
	// A pod-level set of utilization metrics for this cluster for rendering a heat map
	HeatMap *UtilizationHeatMap `json:"heatMap,omitempty"`
	// whether this service is editable
	Editable   *bool   `json:"editable,omitempty"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

type ServiceDeploymentAttributes struct {
	Name         string                `json:"name"`
	Namespace    string                `json:"namespace"`
	Version      *string               `json:"version,omitempty"`
	DocsPath     *string               `json:"docsPath,omitempty"`
	SyncConfig   *SyncConfigAttributes `json:"syncConfig,omitempty"`
	Protect      *bool                 `json:"protect,omitempty"`
	RepositoryID *string               `json:"repositoryId,omitempty"`
	DryRun       *bool                 `json:"dryRun,omitempty"`
	Interval     *string               `json:"interval,omitempty"`
	// if you should apply liquid templating to raw yaml files, defaults to true
	Templated       *bool                          `json:"templated,omitempty"`
	Git             *GitRefAttributes              `json:"git,omitempty"`
	Helm            *HelmConfigAttributes          `json:"helm,omitempty"`
	Kustomize       *KustomizeAttributes           `json:"kustomize,omitempty"`
	ParentID        *string                        `json:"parentId,omitempty"`
	AgentID         *string                        `json:"agentId,omitempty"`
	FlowID          *string                        `json:"flowId,omitempty"`
	Configuration   []*ConfigAttributes            `json:"configuration,omitempty"`
	Dependencies    []*ServiceDependencyAttributes `json:"dependencies,omitempty"`
	ReadBindings    []*PolicyBindingAttributes     `json:"readBindings,omitempty"`
	WriteBindings   []*PolicyBindingAttributes     `json:"writeBindings,omitempty"`
	ContextBindings []*ContextBindingAttributes    `json:"contextBindings,omitempty"`
	Imports         []*ServiceImportAttributes     `json:"imports,omitempty"`
	Sources         []*ServiceSourceAttributes     `json:"sources,omitempty"`
	Renderers       []*RendererAttributes          `json:"renderers,omitempty"`
}

type ServiceDeploymentConnection struct {
	PageInfo PageInfo                 `json:"pageInfo"`
	Edges    []*ServiceDeploymentEdge `json:"edges,omitempty"`
}

type ServiceDeploymentEdge struct {
	Node   *ServiceDeployment `json:"node,omitempty"`
	Cursor *string            `json:"cursor,omitempty"`
}

// an error sent from the deploy operator about sync progress
type ServiceError struct {
	Source  string `json:"source"`
	Message string `json:"message"`
}

type ServiceErrorAttributes struct {
	Source  string `json:"source"`
	Message string `json:"message"`
}

// Import of stack data into a service's context
type ServiceImport struct {
	ID string `json:"id"`
	// The stack you're importing from
	Stack *InfrastructureStack `json:"stack,omitempty"`
	// The outputs of that stack
	Outputs    []*StackOutput `json:"outputs,omitempty"`
	InsertedAt *string        `json:"insertedAt,omitempty"`
	UpdatedAt  *string        `json:"updatedAt,omitempty"`
}

type ServiceImportAttributes struct {
	StackID string `json:"stackId"`
}

type ServicePort struct {
	Name       *string `json:"name,omitempty"`
	Protocol   *string `json:"protocol,omitempty"`
	Port       *int64  `json:"port,omitempty"`
	TargetPort *string `json:"targetPort,omitempty"`
}

type ServiceSource struct {
	// the subdirectory in the git repository to use
	Path *string `json:"path,omitempty"`
	// the id of the git repository to source from
	RepositoryID *string `json:"repositoryId,omitempty"`
	// the git reference to use
	Git *GitRef `json:"git,omitempty"`
}

type ServiceSourceAttributes struct {
	// the subdirectory this source will live in the final tarball
	Path *string `json:"path,omitempty"`
	// the id of the git repository to source from
	RepositoryID *string `json:"repositoryId,omitempty"`
	// the location in git to use
	Git *GitRefAttributes `json:"git,omitempty"`
}

type ServiceSpec struct {
	Type      *string        `json:"type,omitempty"`
	ClusterIP *string        `json:"clusterIp,omitempty"`
	Selector  map[string]any `json:"selector,omitempty"`
	Ports     []*ServicePort `json:"ports,omitempty"`
}

type ServiceStatus struct {
	LoadBalancer *LoadBalancerStatus `json:"loadBalancer,omitempty"`
	Conditions   []*StatusCondition  `json:"conditions,omitempty"`
}

// a rollup count of the statuses of services in a query
type ServiceStatusCount struct {
	Status ServiceDeploymentStatus `json:"status"`
	Count  int64                   `json:"count"`
}

// Attributes for configuring a service in something like a managed namespace
type ServiceTemplate struct {
	// the name for this service (optional for managed namespaces)
	Name *string `json:"name,omitempty"`
	// the namespace for this service (optional for managed namespaces)
	Namespace *string `json:"namespace,omitempty"`
	Templated *bool   `json:"templated,omitempty"`
	// the id of a repository to source manifests for this service
	RepositoryID *string `json:"repositoryId,omitempty"`
	// a list of context names to add to this service
	Contexts     []*string            `json:"contexts,omitempty"`
	Repository   *GitRepository       `json:"repository,omitempty"`
	Dependencies []*ServiceDependency `json:"dependencies,omitempty"`
	// a list of sources to source manifests for the created service
	Sources []*ServiceSource `json:"sources,omitempty"`
	// a list of renderers to render manifests for the created service
	Renderers []*Renderer `json:"renderers,omitempty"`
	// possibly secret configuration for all spawned services, don't query this in list endpoints
	Configuration []*ServiceConfiguration `json:"configuration,omitempty"`
	// settings to configure git for a service
	Git *GitRef `json:"git,omitempty"`
	// settings to configure helm for a service
	Helm *HelmSpec `json:"helm,omitempty"`
	// settings for service kustomization
	Kustomize *Kustomize `json:"kustomize,omitempty"`
	// specification of how the templated service will be synced
	SyncConfig *SyncConfig `json:"syncConfig,omitempty"`
}

// Attributes for configuring a service in something like a managed namespace
type ServiceTemplateAttributes struct {
	// the name for this service (optional for managed namespaces)
	Name *string `json:"name,omitempty"`
	// the namespace for this service (optional for managed namespaces)
	Namespace *string `json:"namespace,omitempty"`
	Templated *bool   `json:"templated,omitempty"`
	// whether to protect this templated service from deletion
	Protect *bool `json:"protect,omitempty"`
	// the id of a repository to source manifests for this service
	RepositoryID *string `json:"repositoryId,omitempty"`
	// a list of context names to add to this service
	Contexts []*string `json:"contexts,omitempty"`
	// a list of secure configuration that will be added to any services created by this template
	Configuration []*ConfigAttributes `json:"configuration,omitempty"`
	// dependencies for the service to be spawned
	Dependencies []*ServiceDependencyAttributes `json:"dependencies,omitempty"`
	// settings to configure git for a service
	Git *GitRefAttributes `json:"git,omitempty"`
	// settings to configure helm for a service
	Helm *HelmConfigAttributes `json:"helm,omitempty"`
	// settings for service kustomization
	Kustomize *KustomizeAttributes `json:"kustomize,omitempty"`
	// attributes to configure sync settings for this service
	SyncConfig *SyncConfigAttributes `json:"syncConfig,omitempty"`
	// a list of sources to source manifests for this service
	Sources []*ServiceSourceAttributes `json:"sources,omitempty"`
	// a list of renderers to render manifests for this service
	Renderers []*RendererAttributes `json:"renderers,omitempty"`
}

type ServiceUpdateAttributes struct {
	Version    *string               `json:"version,omitempty"`
	Protect    *bool                 `json:"protect,omitempty"`
	DryRun     *bool                 `json:"dryRun,omitempty"`
	Interval   *string               `json:"interval,omitempty"`
	SyncConfig *SyncConfigAttributes `json:"syncConfig,omitempty"`
	// if you should apply liquid templating to raw yaml files, defaults to true
	Templated       *bool                          `json:"templated,omitempty"`
	Git             *GitRefAttributes              `json:"git,omitempty"`
	Helm            *HelmConfigAttributes          `json:"helm,omitempty"`
	Configuration   []*ConfigAttributes            `json:"configuration,omitempty"`
	Kustomize       *KustomizeAttributes           `json:"kustomize,omitempty"`
	ParentID        *string                        `json:"parentId,omitempty"`
	FlowID          *string                        `json:"flowId,omitempty"`
	AgentID         *string                        `json:"agentId,omitempty"`
	Dependencies    []*ServiceDependencyAttributes `json:"dependencies,omitempty"`
	ReadBindings    []*PolicyBindingAttributes     `json:"readBindings,omitempty"`
	WriteBindings   []*PolicyBindingAttributes     `json:"writeBindings,omitempty"`
	ContextBindings []*ContextBindingAttributes    `json:"contextBindings,omitempty"`
	Imports         []*ServiceImportAttributes     `json:"imports,omitempty"`
	Sources         []*ServiceSourceAttributes     `json:"sources,omitempty"`
	Renderers       []*RendererAttributes          `json:"renderers,omitempty"`
}

type ServiceVuln struct {
	Service *ServiceDeployment `json:"service,omitempty"`
}

type ServiceVulnAttributes struct {
	ServiceID string `json:"serviceId"`
}

type SharedSecret struct {
	Name       string  `json:"name"`
	Handle     string  `json:"handle"`
	Secret     string  `json:"secret"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

type SharedSecretAttributes struct {
	Name   string `json:"name"`
	Secret string `json:"secret"`
	// the users/groups you want this secret to be delivered to
	NotificationBindings []*PolicyBindingAttributes `json:"notificationBindings,omitempty"`
}

type SinkConfiguration struct {
	ID     string                   `json:"id"`
	Slack  *URLSinkConfiguration    `json:"slack,omitempty"`
	Teams  *URLSinkConfiguration    `json:"teams,omitempty"`
	Plural *PluralSinkConfiguration `json:"plural,omitempty"`
}

type SinkConfigurationAttributes struct {
	Slack  *URLSinkAttributes    `json:"slack,omitempty"`
	Teams  *URLSinkAttributes    `json:"teams,omitempty"`
	Plural *PluralSinkAttributes `json:"plural,omitempty"`
}

// SMTP server configuration for email notifications
type SMTPSettings struct {
	Server string `json:"server"`
	Port   int64  `json:"port"`
	Sender string `json:"sender"`
	User   string `json:"user"`
	Ssl    bool   `json:"ssl"`
}

type SMTPSettingsAttributes struct {
	Server   string `json:"server"`
	Port     int64  `json:"port"`
	Sender   string `json:"sender"`
	User     string `json:"user"`
	Password string `json:"password"`
	Ssl      bool   `json:"ssl"`
}

type StackAttributes struct {
	// the name of the stack
	Name string `json:"name"`
	// A type for the stack, specifies the tool to use to apply it
	Type StackType `json:"type"`
	// The repository to source IaC from
	RepositoryID string `json:"repositoryId"`
	// The cluster on which the terraform will be applied
	ClusterID string `json:"clusterId"`
	// reference w/in the repository where the IaC lives
	Git GitRefAttributes `json:"git"`
	// optional k8s job configuration for the job that will apply this stack
	JobSpec *GateJobAttributes `json:"jobSpec,omitempty"`
	// version/image config for the tool you're using
	Configuration *StackConfigurationAttributes `json:"configuration,omitempty"`
	// whether to require approval
	Approval *bool `json:"approval,omitempty"`
	// whether you want Plural to manage your terraform state for this stack
	ManageState *bool `json:"manageState,omitempty"`
	// the subdirectory you want to run the stack's commands w/in
	Workdir *string `json:"workdir,omitempty"`
	// user id to use for default Plural authentication in this stack
	ActorID *string `json:"actorId,omitempty"`
	// the project id this stack will belong to
	ProjectID *string `json:"projectId,omitempty"`
	// the parent service this stack was created w/in
	ParentID *string `json:"parentId,omitempty"`
	// id of an scm connection to use for pr callbacks
	ConnectionID *string `json:"connectionId,omitempty"`
	// the id of a stack definition to use
	DefinitionID *string `json:"definitionId,omitempty"`
	// a cron to spawn runs for this stack
	Cron *StackCronAttributes `json:"cron,omitempty"`
	// arbitrary variables to pass into the stack
	Variables    *string                 `json:"variables,omitempty"`
	PolicyEngine *PolicyEngineAttributes `json:"policyEngine,omitempty"`
	// the agent id this stack is associated with
	AgentID           *string                       `json:"agentId,omitempty"`
	ReadBindings      []*PolicyBindingAttributes    `json:"readBindings,omitempty"`
	WriteBindings     []*PolicyBindingAttributes    `json:"writeBindings,omitempty"`
	Tags              []*TagAttributes              `json:"tags,omitempty"`
	Files             []*StackFileAttributes        `json:"files,omitempty"`
	Environment       []*StackEnvironmentAttributes `json:"environment,omitempty"`
	ObservableMetrics []*ObservableMetricAttributes `json:"observableMetrics,omitempty"`
}

type StackCommand struct {
	// the executable to call
	Cmd string `json:"cmd"`
	// cli args to pass
	Args []*string `json:"args,omitempty"`
	// working directory for this command (not required)
	Dir *string `json:"dir,omitempty"`
}

type StackConfiguration struct {
	// optional custom image you might want to use
	Image *string `json:"image,omitempty"`
	// the semver of the tool you wish to use
	Version *string `json:"version,omitempty"`
	// the docker image tag you wish to use if you're customizing the version
	Tag *string `json:"tag,omitempty"`
	// the hooks to customize execution for this stack
	Hooks []*StackHook `json:"hooks,omitempty"`
	// the terraform configuration for this stack
	Terraform *TerraformConfiguration `json:"terraform,omitempty"`
}

type StackConfigurationAttributes struct {
	// optional custom image you might want to use
	Image *string `json:"image,omitempty"`
	// the semver of the tool you wish to use
	Version *string `json:"version,omitempty"`
	// the docker image tag you wish to use if you're customizing the version
	Tag *string `json:"tag,omitempty"`
	// the hooks to customize execution for this stack
	Hooks []*StackHookAttributes `json:"hooks,omitempty"`
	// the terraform configuration for this stack
	Terraform *TerraformConfigurationAttributes `json:"terraform,omitempty"`
}

type StackCron struct {
	// the crontab used to independently spawn runs for this stack
	Crontab string `json:"crontab"`
	// whether you want any cron-derived runs to automatically approve changes
	AutoApprove *bool `json:"autoApprove,omitempty"`
	// configuration overrides for the cron run
	Overrides *StackOverrides `json:"overrides,omitempty"`
}

type StackCronAttributes struct {
	// the crontab to use for spawning stack runs
	Crontab string `json:"crontab"`
	// whether you want to auto approve any changes spawned by the cron worker
	AutoApprove *bool `json:"autoApprove,omitempty"`
	// configuration overrides for the cron run
	Overrides *StackOverridesAttributes `json:"overrides,omitempty"`
}

type StackDefinition struct {
	ID            string             `json:"id"`
	Name          string             `json:"name"`
	Description   *string            `json:"description,omitempty"`
	Configuration StackConfiguration `json:"configuration"`
	Steps         []*CustomRunStep   `json:"steps,omitempty"`
	InsertedAt    *string            `json:"insertedAt,omitempty"`
	UpdatedAt     *string            `json:"updatedAt,omitempty"`
}

type StackDefinitionAttributes struct {
	Name          string                        `json:"name"`
	Description   *string                       `json:"description,omitempty"`
	Steps         []*CustomStepAttributes       `json:"steps,omitempty"`
	Configuration *StackConfigurationAttributes `json:"configuration,omitempty"`
}

type StackDefinitionConnection struct {
	PageInfo PageInfo               `json:"pageInfo"`
	Edges    []*StackDefinitionEdge `json:"edges,omitempty"`
}

type StackDefinitionEdge struct {
	Node   *StackDefinition `json:"node,omitempty"`
	Cursor *string          `json:"cursor,omitempty"`
}

type StackEnvironment struct {
	Name   string `json:"name"`
	Value  string `json:"value"`
	Secret *bool  `json:"secret,omitempty"`
}

type StackEnvironmentAttributes struct {
	Name   string `json:"name"`
	Value  string `json:"value"`
	Secret *bool  `json:"secret,omitempty"`
}

type StackFile struct {
	Path    string `json:"path"`
	Content string `json:"content"`
}

type StackFileAttributes struct {
	Path    string `json:"path"`
	Content string `json:"content"`
}

type StackHook struct {
	// a script hook to run at a stage
	Cmd string `json:"cmd"`
	// args for `cmd`
	Args []*string `json:"args,omitempty"`
	// the stage to run this hook before
	AfterStage StepStage `json:"afterStage"`
}

type StackHookAttributes struct {
	// a script hook to run at a stage
	Cmd string `json:"cmd"`
	// args for `cmd`
	Args []*string `json:"args,omitempty"`
	// the stage to run this hook before
	AfterStage StepStage `json:"afterStage"`
}

type StackOutput struct {
	Name   string `json:"name"`
	Value  string `json:"value"`
	Secret *bool  `json:"secret,omitempty"`
}

type StackOutputAttributes struct {
	Name   string `json:"name"`
	Value  string `json:"value"`
	Secret *bool  `json:"secret,omitempty"`
}

// Configuration overrides for a stack cron run
type StackOverrides struct {
	// the terraform configuration for this stack
	Terraform *TerraformConfiguration `json:"terraform,omitempty"`
}

type StackOverridesAttributes struct {
	// the terraform configuration for this stack
	Terraform *TerraformConfigurationAttributes `json:"terraform,omitempty"`
}

type StackPolicyViolation struct {
	ID           string       `json:"id"`
	Severity     VulnSeverity `json:"severity"`
	PolicyID     string       `json:"policyId"`
	PolicyURL    *string      `json:"policyUrl,omitempty"`
	PolicyModule *string      `json:"policyModule,omitempty"`
	Title        string       `json:"title"`
	Description  *string      `json:"description,omitempty"`
	Resolution   *string      `json:"resolution,omitempty"`
	// the causes of this violation line-by-line in code
	Causes     []*StackViolationCause `json:"causes,omitempty"`
	InsertedAt *string                `json:"insertedAt,omitempty"`
	UpdatedAt  *string                `json:"updatedAt,omitempty"`
}

type StackPolicyViolationAttributes struct {
	Severity     VulnSeverity                     `json:"severity"`
	PolicyID     string                           `json:"policyId"`
	PolicyURL    *string                          `json:"policyUrl,omitempty"`
	PolicyModule *string                          `json:"policyModule,omitempty"`
	Title        string                           `json:"title"`
	Description  *string                          `json:"description,omitempty"`
	Resolution   *string                          `json:"resolution,omitempty"`
	Causes       []*StackViolationCauseAttributes `json:"causes,omitempty"`
}

type StackRun struct {
	ID string `json:"id"`
	// The status of this run
	Status StackStatus `json:"status"`
	// A type for the stack, specifies the tool to use to apply it
	Type StackType `json:"type"`
	// reference w/in the repository where the IaC lives
	Git GitRef `json:"git"`
	// whether this run is a dry run
	DryRun bool `json:"dryRun"`
	// optional k8s job configuration for the job that will apply this stack
	JobSpec      *JobGateSpec  `json:"jobSpec,omitempty"`
	PolicyEngine *PolicyEngine `json:"policyEngine,omitempty"`
	// version/image config for the tool you're using
	Configuration StackConfiguration `json:"configuration"`
	// whether to require approval
	Approval *bool `json:"approval,omitempty"`
	// the commit message
	Message *string `json:"message,omitempty"`
	// when this run was approved
	ApprovedAt *string `json:"approvedAt,omitempty"`
	// the subdirectory you want to run the stack's commands w/in
	Workdir *string `json:"workdir,omitempty"`
	// whether you want Plural to manage the state of this stack
	ManageState *bool `json:"manageState,omitempty"`
	// Arbitrary variables to add to a stack run
	Variables map[string]any `json:"variables,omitempty"`
	// explanation for why this run was cancelled
	CancellationReason *string    `json:"cancellationReason,omitempty"`
	StateUrls          *StateUrls `json:"stateUrls,omitempty"`
	// the kubernetes job for this run (useful for debugging if issues arise)
	Job *Job `json:"job,omitempty"`
	// temporary plural creds usable for terraform authentication
	PluralCreds *PluralCreds `json:"pluralCreds,omitempty"`
	// https url to fetch the latest tarball of stack IaC
	Tarball string `json:"tarball"`
	// the pull request this stack belongs to
	PullRequest *PullRequest `json:"pullRequest,omitempty"`
	// the approver of this job
	Approver *User `json:"approver,omitempty"`
	// the actor of this run (defaults to root console user)
	Actor *User `json:"actor,omitempty"`
	// The steps to perform when running this stack
	Steps []*RunStep `json:"steps,omitempty"`
	// files bound to a run of this stack
	Files []*StackFile `json:"files,omitempty"`
	// environment variables for this stack
	Environment []*StackEnvironment `json:"environment,omitempty"`
	// the stack attached to this run
	Stack *InfrastructureStack `json:"stack,omitempty"`
	// the most recent output for this stack
	Output []*StackOutput `json:"output,omitempty"`
	// the most recent state of this stack
	State *StackState `json:"state,omitempty"`
	// a list of errors generated by the deployment operator
	Errors []*ServiceError `json:"errors,omitempty"`
	// an insight explaining the state of this stack run
	Insight *AiInsight `json:"insight,omitempty"`
	// the cluster this stack runs on
	Cluster *Cluster `json:"cluster,omitempty"`
	// the git repository you're sourcing IaC from
	Repository *GitRepository `json:"repository,omitempty"`
	// policy violations for this stack
	Violations []*StackPolicyViolation `json:"violations,omitempty"`
	InsertedAt *string                 `json:"insertedAt,omitempty"`
	UpdatedAt  *string                 `json:"updatedAt,omitempty"`
}

type StackRunAttributes struct {
	// The status of this run
	Status StackStatus `json:"status"`
	// the reference to the k8s job running this stack
	JobRef *NamespacedName `json:"jobRef,omitempty"`
	// The state from this runs plan or apply
	State *StackStateAttributes `json:"state,omitempty"`
	// Output generated by this run
	Output []*StackOutputAttributes `json:"output,omitempty"`
	// Any errors detected when trying to run this stack
	Errors []*ServiceErrorAttributes `json:"errors,omitempty"`
	// Why you decided to cancel this run
	CancellationReason *string `json:"cancellationReason,omitempty"`
	// the violations detected by the policy engine
	Violations []*StackPolicyViolationAttributes `json:"violations,omitempty"`
}

type StackRunConnection struct {
	PageInfo PageInfo        `json:"pageInfo"`
	Edges    []*StackRunEdge `json:"edges,omitempty"`
}

type StackRunEdge struct {
	Node   *StackRun `json:"node,omitempty"`
	Cursor *string   `json:"cursor,omitempty"`
}

type StackSettings struct {
	JobSpec      *JobGateSpec `json:"jobSpec,omitempty"`
	ConnectionID *string      `json:"connectionId,omitempty"`
}

type StackSettingsAttributes struct {
	JobSpec      *GateJobAttributes `json:"jobSpec,omitempty"`
	ConnectionID *string            `json:"connectionId,omitempty"`
}

type StackState struct {
	ID    string                `json:"id"`
	Plan  *string               `json:"plan,omitempty"`
	State []*StackStateResource `json:"state,omitempty"`
	// an insight explaining the state of this stack state, eg the terraform plan it represents
	Insight    *AiInsight `json:"insight,omitempty"`
	InsertedAt *string    `json:"insertedAt,omitempty"`
	UpdatedAt  *string    `json:"updatedAt,omitempty"`
}

type StackStateAttributes struct {
	Plan  *string                         `json:"plan,omitempty"`
	State []*StackStateResourceAttributes `json:"state,omitempty"`
}

type StackStateResource struct {
	// a string identifier for this resource, different tools will have different conventions
	Identifier string `json:"identifier"`
	// a string name of the resource type
	Resource string `json:"resource"`
	// the name of the resource within that type
	Name string `json:"name"`
	// arbitrary configuration used to create the resource
	Configuration map[string]any `json:"configuration,omitempty"`
	// identifiers this resource is linked to for graphing in the UI
	Links []*string `json:"links,omitempty"`
}

type StackStateResourceAttributes struct {
	// a string identifier for this resource, different tools will have different conventions
	Identifier string `json:"identifier"`
	// a string name of the resource type
	Resource string `json:"resource"`
	// the name of the resource within that type
	Name string `json:"name"`
	// arbitrary configuration used to create the resource
	Configuration *string `json:"configuration,omitempty"`
	// identifiers this resource is linked to for graphing in the UI
	Links []*string `json:"links,omitempty"`
}

type StackViolationCause struct {
	Resource string                     `json:"resource"`
	Start    int64                      `json:"start"`
	End      int64                      `json:"end"`
	Filename *string                    `json:"filename,omitempty"`
	Lines    []*StackViolationCauseLine `json:"lines,omitempty"`
}

type StackViolationCauseAttributes struct {
	Resource string                               `json:"resource"`
	Start    int64                                `json:"start"`
	End      int64                                `json:"end"`
	Filename *string                              `json:"filename,omitempty"`
	Lines    []*StackViolationCauseLineAttributes `json:"lines,omitempty"`
}

type StackViolationCauseLine struct {
	Content string `json:"content"`
	Line    int64  `json:"line"`
	First   *bool  `json:"first,omitempty"`
	Last    *bool  `json:"last,omitempty"`
}

type StackViolationCauseLineAttributes struct {
	Content string `json:"content"`
	Line    int64  `json:"line"`
	First   *bool  `json:"first,omitempty"`
	Last    *bool  `json:"last,omitempty"`
}

// the configuration of a service within a pipeline stage, including optional promotion criteria
type StageService struct {
	ID string `json:"id"`
	// a pointer to a service
	Service *ServiceDeployment `json:"service,omitempty"`
	// criteria for how a promotion of this service shall be performed
	Criteria   *PromotionCriteria `json:"criteria,omitempty"`
	InsertedAt *string            `json:"insertedAt,omitempty"`
	UpdatedAt  *string            `json:"updatedAt,omitempty"`
}

// the attributes of a service w/in a specific stage
type StageServiceAttributes struct {
	// the cluster handle of this service
	Handle *string `json:"handle,omitempty"`
	// the name of this service
	Name *string `json:"name,omitempty"`
	// the name of this service
	ServiceID *string                      `json:"serviceId,omitempty"`
	Criteria  *PromotionCriteriaAttributes `json:"criteria,omitempty"`
}

// grab-bag of state configuration urls for supported tools
type StateUrls struct {
	Terraform *TerraformStateUrls `json:"terraform,omitempty"`
}

type StatefulSet struct {
	Metadata Metadata          `json:"metadata"`
	Status   StatefulSetStatus `json:"status"`
	Spec     StatefulSetSpec   `json:"spec"`
	Pods     []*Pod            `json:"pods,omitempty"`
	Raw      string            `json:"raw"`
	Events   []*Event          `json:"events,omitempty"`
}

type StatefulSetSpec struct {
	Replicas    *int64  `json:"replicas,omitempty"`
	ServiceName *string `json:"serviceName,omitempty"`
}

type StatefulSetStatus struct {
	CurrentReplicas *int64             `json:"currentReplicas,omitempty"`
	Replicas        *int64             `json:"replicas,omitempty"`
	ReadyReplicas   *int64             `json:"readyReplicas,omitempty"`
	UpdatedReplicas *int64             `json:"updatedReplicas,omitempty"`
	Conditions      []*StatusCondition `json:"conditions,omitempty"`
}

type StatusCondition struct {
	Message string `json:"message"`
	Reason  string `json:"reason"`
	Status  string `json:"status"`
	Type    string `json:"type"`
}

// Advanced configuration of how to sync resources
type SyncConfig struct {
	// whether the agent should auto-create the namespace for this service
	CreateNamespace *bool `json:"createNamespace,omitempty"`
	// Whether to require all resources are placed in the same namespace
	EnforceNamespace  *bool              `json:"enforceNamespace,omitempty"`
	NamespaceMetadata *NamespaceMetadata `json:"namespaceMetadata,omitempty"`
}

type SyncConfigAttributes struct {
	CreateNamespace   *bool               `json:"createNamespace,omitempty"`
	EnforceNamespace  *bool               `json:"enforceNamespace,omitempty"`
	NamespaceMetadata *MetadataAttributes `json:"namespaceMetadata,omitempty"`
}

type Tag struct {
	ID    string `json:"id"`
	Name  string `json:"name"`
	Value string `json:"value"`
}

type TagAttributes struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

type TagConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []*TagEdge `json:"edges,omitempty"`
}

type TagEdge struct {
	Node   *Tag    `json:"node,omitempty"`
	Cursor *string `json:"cursor,omitempty"`
}

type TagInput struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

type TagQuery struct {
	Op   Conjunction `json:"op"`
	Tags []*TagInput `json:"tags,omitempty"`
}

// a kubernetes node taint
type Taint struct {
	Key    string `json:"key"`
	Value  string `json:"value"`
	Effect string `json:"effect"`
}

type TaintAttributes struct {
	Key    string `json:"key"`
	Value  string `json:"value"`
	Effect string `json:"effect"`
}

type TargetRef struct {
	APIVersion *string `json:"apiVersion,omitempty"`
	Kind       *string `json:"kind,omitempty"`
	Name       *string `json:"name,omitempty"`
}

// Additional context used to template service metadata during global service reconciliation
type TemplateContext struct {
	Raw map[string]any `json:"raw,omitempty"`
}

// Additional context used to template service metadata during global service reconciliation
type TemplateContextAttributes struct {
	Raw *string `json:"raw,omitempty"`
}

type TerminatedState struct {
	ExitCode   *int64  `json:"exitCode,omitempty"`
	FinishedAt *string `json:"finishedAt,omitempty"`
	StartedAt  *string `json:"startedAt,omitempty"`
	Message    *string `json:"message,omitempty"`
	Reason     *string `json:"reason,omitempty"`
}

type TerraformConfiguration struct {
	// equivalent to the -parallelism flag in terraform
	Parallelism *int64 `json:"parallelism,omitempty"`
	// equivalent to the -refresh flag in terraform
	Refresh *bool `json:"refresh,omitempty"`
}

type TerraformConfigurationAttributes struct {
	// equivalent to the -parallelism flag in terraform
	Parallelism *int64 `json:"parallelism,omitempty"`
	// equivalent to the -refresh flag in terraform
	Refresh *bool `json:"refresh,omitempty"`
}

// Urls for configuring terraform HTTP remote state
type TerraformStateUrls struct {
	// GET and POST urls for uploadnig state
	Address *string `json:"address,omitempty"`
	// POST url to lock state
	Lock *string `json:"lock,omitempty"`
	// POST url to unlock state
	Unlock *string `json:"unlock,omitempty"`
}

type ToolConfigAttributes struct {
	CreatePr *CreatePrConfigAttributes `json:"createPr,omitempty"`
}

// How to enforce uniqueness for a field
type UniqByAttributes struct {
	// the scope this name is uniq w/in
	Scope ValidationUniqScope `json:"scope"`
}

type UpgradeInsight struct {
	ID   string `json:"id"`
	Name string `json:"name"`
	// the k8s version this insight applies to
	Version *string `json:"version,omitempty"`
	// longform description of this insight
	Description    *string                 `json:"description,omitempty"`
	Status         *UpgradeInsightStatus   `json:"status,omitempty"`
	RefreshedAt    *string                 `json:"refreshedAt,omitempty"`
	TransitionedAt *string                 `json:"transitionedAt,omitempty"`
	Details        []*UpgradeInsightDetail `json:"details,omitempty"`
	InsertedAt     *string                 `json:"insertedAt,omitempty"`
	UpdatedAt      *string                 `json:"updatedAt,omitempty"`
}

type UpgradeInsightAttributes struct {
	Name string `json:"name"`
	// the k8s version this insight applies to
	Version *string `json:"version,omitempty"`
	// longform description of this insight
	Description    *string                           `json:"description,omitempty"`
	Status         *UpgradeInsightStatus             `json:"status,omitempty"`
	RefreshedAt    *string                           `json:"refreshedAt,omitempty"`
	TransitionedAt *string                           `json:"transitionedAt,omitempty"`
	Details        []*UpgradeInsightDetailAttributes `json:"details,omitempty"`
}

type UpgradeInsightDetail struct {
	ID     string                `json:"id"`
	Status *UpgradeInsightStatus `json:"status,omitempty"`
	// a possibly deprecated API
	Used *string `json:"used,omitempty"`
	// the replacement for this API
	Replacement *string `json:"replacement,omitempty"`
	// information about the HTTP clients triggering this insight
	ClientInfo []*InsightClientInfo `json:"clientInfo,omitempty"`
	ReplacedIn *string              `json:"replacedIn,omitempty"`
	RemovedIn  *string              `json:"removedIn,omitempty"`
	LastUsedAt *string              `json:"lastUsedAt,omitempty"`
	InsertedAt *string              `json:"insertedAt,omitempty"`
	UpdatedAt  *string              `json:"updatedAt,omitempty"`
}

type UpgradeInsightDetailAttributes struct {
	Status *UpgradeInsightStatus `json:"status,omitempty"`
	// a possibly deprecated API
	Used *string `json:"used,omitempty"`
	// the replacement for this API
	Replacement *string `json:"replacement,omitempty"`
	// descriptions of the HTTP clients triggering this insight
	ClientInfo []*InsightClientInfoAttributes `json:"clientInfo,omitempty"`
	ReplacedIn *string                        `json:"replacedIn,omitempty"`
	RemovedIn  *string                        `json:"removedIn,omitempty"`
	// the latest timestamp this insight has been observed
	LastUsedAt *string `json:"lastUsedAt,omitempty"`
}

type UpgradePlan struct {
	Metadata Metadata          `json:"metadata"`
	Status   UpgradePlanStatus `json:"status"`
	Spec     UpgradePlanSpec   `json:"spec"`
	Pods     []*Pod            `json:"pods,omitempty"`
	Raw      string            `json:"raw"`
	Events   []*Event          `json:"events,omitempty"`
}

type UpgradePlanAttributes struct {
	// whether all compatibilities for a cluster upgrade have been cleared
	Compatibilities *bool `json:"compatibilities,omitempty"`
	// whether all incompatibilities w/in runtime components have been cleared
	Incompatibilities *bool `json:"incompatibilities,omitempty"`
	// whether all deprecated apis for a cluster have been cleared
	Deprecations *bool `json:"deprecations,omitempty"`
}

type UpgradePlanSpec struct {
	Version     *string `json:"version,omitempty"`
	Cordon      *bool   `json:"cordon,omitempty"`
	Concurrency *int64  `json:"concurrency,omitempty"`
}

type UpgradePlanStatus struct {
	Conditions []*StatusCondition `json:"conditions,omitempty"`
}

// Summary statistics of the upgradeability of your fleet
type UpgradeStatistics struct {
	// total number of clusters
	Count *int64 `json:"count,omitempty"`
	// the number of clusters currently upgradeable
	Upgradeable *int64 `json:"upgradeable,omitempty"`
	// the number of clusters currently at the latest version
	Latest *int64 `json:"latest,omitempty"`
	// the number of clusters compliant w/ your versioning policy
	Compliant *int64 `json:"compliant,omitempty"`
}

type URLSinkAttributes struct {
	URL string `json:"url"`
}

// A notification sink based off slack incoming webhook urls
type URLSinkConfiguration struct {
	// incoming webhook url to deliver to
	URL string `json:"url"`
}

type User struct {
	ID                  string           `json:"id"`
	Name                string           `json:"name"`
	Email               string           `json:"email"`
	DeletedAt           *string          `json:"deletedAt,omitempty"`
	Profile             *string          `json:"profile,omitempty"`
	PluralID            *string          `json:"pluralId,omitempty"`
	Roles               *UserRoles       `json:"roles,omitempty"`
	EmailSettings       *EmailSettings   `json:"emailSettings,omitempty"`
	ReadTimestamp       *string          `json:"readTimestamp,omitempty"`
	BuildTimestamp      *string          `json:"buildTimestamp,omitempty"`
	RefreshToken        *RefreshToken    `json:"refreshToken,omitempty"`
	AssumeBindings      []*PolicyBinding `json:"assumeBindings,omitempty"`
	Groups              []*Group         `json:"groups,omitempty"`
	Personas            []*Persona       `json:"personas,omitempty"`
	BoundRoles          []*Role          `json:"boundRoles,omitempty"`
	Jwt                 *string          `json:"jwt,omitempty"`
	UnreadNotifications *int64           `json:"unreadNotifications,omitempty"`
	BackgroundColor     *string          `json:"backgroundColor,omitempty"`
	InsertedAt          *string          `json:"insertedAt,omitempty"`
	UpdatedAt           *string          `json:"updatedAt,omitempty"`
}

type UserAttributes struct {
	Name              *string                  `json:"name,omitempty"`
	Email             *string                  `json:"email,omitempty"`
	Password          *string                  `json:"password,omitempty"`
	Roles             *UserRoleAttributes      `json:"roles,omitempty"`
	EmailSettings     *EmailSettingsAttributes `json:"emailSettings,omitempty"`
	SigningPrivateKey *string                  `json:"signingPrivateKey,omitempty"`
}

type UserConnection struct {
	PageInfo PageInfo    `json:"pageInfo"`
	Edges    []*UserEdge `json:"edges,omitempty"`
}

type UserEdge struct {
	Node   *User   `json:"node,omitempty"`
	Cursor *string `json:"cursor,omitempty"`
}

type UserRoleAttributes struct {
	Admin *bool `json:"admin,omitempty"`
}

type UserRoles struct {
	Admin *bool `json:"admin,omitempty"`
}

// A representation of the metrics to render a utilization heat map
type UtilizationHeatMap struct {
	CPU    []*MetricPointResponse `json:"cpu,omitempty"`
	Memory []*MetricPointResponse `json:"memory,omitempty"`
}

type VectorStoreAttributes struct {
	Enabled    *bool                              `json:"enabled,omitempty"`
	Store      *VectorStore                       `json:"store,omitempty"`
	Elastic    *ElasticsearchConnectionAttributes `json:"elastic,omitempty"`
	Opensearch *OpensearchConnectionAttributes    `json:"opensearch,omitempty"`
}

// a shortform reference to an addon by version
type VersionReference struct {
	Name    string `json:"name"`
	Version string `json:"version"`
}

type VertexAiAttributes struct {
	// the vertex model id to use
	Model *string `json:"model,omitempty"`
	// the model to use for tool calls, which are less frequent and require more complex reasoning
	ToolModel *string `json:"toolModel,omitempty"`
	// the model to use for vector embeddings
	EmbeddingModel *string `json:"embeddingModel,omitempty"`
	// optional service account json to auth to the GCP vertex apis
	ServiceAccountJSON *string `json:"serviceAccountJson,omitempty"`
	// custom vertexai endpoint if for dedicated customer deployments
	Endpoint *string `json:"endpoint,omitempty"`
	// the gcp project id to use
	Project string `json:"project"`
	// the gcp region the model is hosted in
	Location string `json:"location"`
}

// Settings for usage of GCP VertexAI for LLMs
type VertexAiSettings struct {
	// the vertex ai model to use
	Model *string `json:"model,omitempty"`
	// the model to use for tool calls, which are less frequent and require more complex reasoning
	ToolModel *string `json:"toolModel,omitempty"`
	// the gcp project id to use
	Project string `json:"project"`
	// the gcp region the model
	Location string `json:"location"`
}

type VerticalPodAutoscaler struct {
	Metadata Metadata                     `json:"metadata"`
	Spec     VerticalPodAutoscalerSpec    `json:"spec"`
	Status   *VerticalPodAutoscalerStatus `json:"status,omitempty"`
}

type VerticalPodAutoscalerSpec struct {
	TargetRef    CrossVersionResourceTarget        `json:"targetRef"`
	UpdatePolicy VerticalPodAutoscalerUpdatePolicy `json:"updatePolicy"`
}

type VerticalPodAutoscalerStatus struct {
	Recommendation *Recommendation `json:"recommendation,omitempty"`
}

type VerticalPodAutoscalerUpdatePolicy struct {
	UpdateMode *string `json:"updateMode,omitempty"`
}

// A violation of a given OPA Gatekeeper constraint
type Violation struct {
	ID         string  `json:"id"`
	Group      *string `json:"group,omitempty"`
	Version    *string `json:"version,omitempty"`
	Kind       *string `json:"kind,omitempty"`
	Namespace  *string `json:"namespace,omitempty"`
	Name       *string `json:"name,omitempty"`
	Message    *string `json:"message,omitempty"`
	InsertedAt *string `json:"insertedAt,omitempty"`
	UpdatedAt  *string `json:"updatedAt,omitempty"`
}

type ViolationAttributes struct {
	Group     *string `json:"group,omitempty"`
	Version   *string `json:"version,omitempty"`
	Kind      *string `json:"kind,omitempty"`
	Namespace *string `json:"namespace,omitempty"`
	Name      *string `json:"name,omitempty"`
	Message   *string `json:"message,omitempty"`
}

// A summary of statistics for violations w/in a specific column
type ViolationStatistic struct {
	// the value of this field being aggregated
	Value *string `json:"value,omitempty"`
	// the total number of violations found
	Violations *int64 `json:"violations,omitempty"`
	// the total number of policy constraints
	Count *int64 `json:"count,omitempty"`
}

type VulnArtifact struct {
	Registry   *string `json:"registry,omitempty"`
	Repository *string `json:"repository,omitempty"`
	Digest     *string `json:"digest,omitempty"`
	Tag        *string `json:"tag,omitempty"`
	Mime       *string `json:"mime,omitempty"`
}

type VulnArtifactAttributes struct {
	Registry   *string `json:"registry,omitempty"`
	Repository *string `json:"repository,omitempty"`
	Digest     *string `json:"digest,omitempty"`
	Tag        *string `json:"tag,omitempty"`
	Mime       *string `json:"mime,omitempty"`
}

type VulnOs struct {
	Eosl   *bool   `json:"eosl,omitempty"`
	Family *string `json:"family,omitempty"`
	Name   *string `json:"name,omitempty"`
}

type VulnOsAttributes struct {
	Eosl   *bool   `json:"eosl,omitempty"`
	Family *string `json:"family,omitempty"`
	Name   *string `json:"name,omitempty"`
}

type VulnSummary struct {
	CriticalCount *int64 `json:"criticalCount,omitempty"`
	HighCount     *int64 `json:"highCount,omitempty"`
	MediumCount   *int64 `json:"mediumCount,omitempty"`
	LowCount      *int64 `json:"lowCount,omitempty"`
	UnknownCount  *int64 `json:"unknownCount,omitempty"`
	NoneCount     *int64 `json:"noneCount,omitempty"`
}

type VulnSummaryAttributes struct {
	CriticalCount *int64 `json:"criticalCount,omitempty"`
	HighCount     *int64 `json:"highCount,omitempty"`
	MediumCount   *int64 `json:"mediumCount,omitempty"`
	LowCount      *int64 `json:"lowCount,omitempty"`
	UnknownCount  *int64 `json:"unknownCount,omitempty"`
	NoneCount     *int64 `json:"noneCount,omitempty"`
}

type Vulnerability struct {
	ID               string        `json:"id"`
	Resource         *string       `json:"resource,omitempty"`
	FixedVersion     *string       `json:"fixedVersion,omitempty"`
	InstalledVersion *string       `json:"installedVersion,omitempty"`
	Severity         *VulnSeverity `json:"severity,omitempty"`
	Score            *float64      `json:"score,omitempty"`
	Title            *string       `json:"title,omitempty"`
	Description      *string       `json:"description,omitempty"`
	CvssSource       *string       `json:"cvssSource,omitempty"`
	PrimaryLink      *string       `json:"primaryLink,omitempty"`
	Links            []*string     `json:"links,omitempty"`
	Target           *string       `json:"target,omitempty"`
	Class            *string       `json:"class,omitempty"`
	PackageType      *string       `json:"packageType,omitempty"`
	PkgPath          *string       `json:"pkgPath,omitempty"`
	VulnID           *string       `json:"vulnId,omitempty"`
	PublishedDate    *string       `json:"publishedDate,omitempty"`
	LastModifiedDate *string       `json:"lastModifiedDate,omitempty"`
	Cvss             *CvssBundle   `json:"cvss,omitempty"`
	InsertedAt       *string       `json:"insertedAt,omitempty"`
	UpdatedAt        *string       `json:"updatedAt,omitempty"`
}

type VulnerabilityAttributes struct {
	Resource         *string               `json:"resource,omitempty"`
	FixedVersion     *string               `json:"fixedVersion,omitempty"`
	InstalledVersion *string               `json:"installedVersion,omitempty"`
	Severity         *VulnSeverity         `json:"severity,omitempty"`
	Score            *float64              `json:"score,omitempty"`
	Title            *string               `json:"title,omitempty"`
	Description      *string               `json:"description,omitempty"`
	CvssSource       *string               `json:"cvssSource,omitempty"`
	PrimaryLink      *string               `json:"primaryLink,omitempty"`
	Links            []*string             `json:"links,omitempty"`
	Target           *string               `json:"target,omitempty"`
	Class            *string               `json:"class,omitempty"`
	PackageType      *string               `json:"packageType,omitempty"`
	PkgPath          *string               `json:"pkgPath,omitempty"`
	VulnID           *string               `json:"vulnId,omitempty"`
	PublishedDate    *string               `json:"publishedDate,omitempty"`
	LastModifiedDate *string               `json:"lastModifiedDate,omitempty"`
	Cvss             *CvssBundleAttributes `json:"cvss,omitempty"`
}

type VulnerabilityReport struct {
	ID              string           `json:"id"`
	ArtifactURL     *string          `json:"artifactUrl,omitempty"`
	Os              *VulnOs          `json:"os,omitempty"`
	Summary         *VulnSummary     `json:"summary,omitempty"`
	Artifact        *VulnArtifact    `json:"artifact,omitempty"`
	Grade           *VulnReportGrade `json:"grade,omitempty"`
	Vulnerabilities []*Vulnerability `json:"vulnerabilities,omitempty"`
	Services        []*ServiceVuln   `json:"services,omitempty"`
	Namespaces      []*NamespaceVuln `json:"namespaces,omitempty"`
	InsertedAt      *string          `json:"insertedAt,omitempty"`
	UpdatedAt       *string          `json:"updatedAt,omitempty"`
}

type VulnerabilityReportAttributes struct {
	ArtifactURL     *string                    `json:"artifactUrl,omitempty"`
	Os              *VulnOsAttributes          `json:"os,omitempty"`
	Summary         *VulnSummaryAttributes     `json:"summary,omitempty"`
	Artifact        *VulnArtifactAttributes    `json:"artifact,omitempty"`
	Vulnerabilities []*VulnerabilityAttributes `json:"vulnerabilities,omitempty"`
	Services        []*ServiceVulnAttributes   `json:"services,omitempty"`
	Namespaces      []*NamespaceVulnAttributes `json:"namespaces,omitempty"`
}

type VulnerabilityReportConnection struct {
	PageInfo PageInfo                   `json:"pageInfo"`
	Edges    []*VulnerabilityReportEdge `json:"edges,omitempty"`
}

type VulnerabilityReportEdge struct {
	Node   *VulnerabilityReport `json:"node,omitempty"`
	Cursor *string              `json:"cursor,omitempty"`
}

type VulnerabilityStatistic struct {
	Grade VulnReportGrade `json:"grade"`
	Count int64           `json:"count"`
}

type WaitingState struct {
	Message *string `json:"message,omitempty"`
	Reason  *string `json:"reason,omitempty"`
}

// a description of a yaml-merge operation on a file
type YamlOverlay struct {
	Yaml string `json:"yaml"`
	// the filename to apply this yaml overlay on
	File string `json:"file"`
	// whether you want to apply liquid templating on the yaml before compiling
	Templated *bool `json:"templated,omitempty"`
	// configure how list merge should be performed
	ListMerge *ListMerge `json:"listMerge,omitempty"`
}

// a description of a yaml-merge operation on a file
type YamlOverlayAttributes struct {
	// the filename to apply this yaml overlay on
	File string `json:"file"`
	Yaml string `json:"yaml"`
	// configure how list merge should be performed
	ListMerge *ListMerge `json:"listMerge,omitempty"`
	// whether you want to apply liquid templating on the yaml before compiling
	Templated *bool `json:"templated,omitempty"`
}

type AiProvider string

const (
	AiProviderOpenai    AiProvider = "OPENAI"
	AiProviderAnthropic AiProvider = "ANTHROPIC"
	AiProviderOllama    AiProvider = "OLLAMA"
	AiProviderAzure     AiProvider = "AZURE"
	AiProviderBedrock   AiProvider = "BEDROCK"
	AiProviderVertex    AiProvider = "VERTEX"
)

var AllAiProvider = []AiProvider{
	AiProviderOpenai,
	AiProviderAnthropic,
	AiProviderOllama,
	AiProviderAzure,
	AiProviderBedrock,
	AiProviderVertex,
}

func (e AiProvider) IsValid() bool {
	switch e {
	case AiProviderOpenai, AiProviderAnthropic, AiProviderOllama, AiProviderAzure, AiProviderBedrock, AiProviderVertex:
		return true
	}
	return false
}

func (e AiProvider) String() string {
	return string(e)
}

func (e *AiProvider) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AiProvider(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AiProvider", str)
	}
	return nil
}

func (e AiProvider) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// A role to pass to an LLM, modeled after OpenAI's chat api roles
type AiRole string

const (
	AiRoleSystem    AiRole = "SYSTEM"
	AiRoleAssistant AiRole = "ASSISTANT"
	AiRoleUser      AiRole = "USER"
)

var AllAiRole = []AiRole{
	AiRoleSystem,
	AiRoleAssistant,
	AiRoleUser,
}

func (e AiRole) IsValid() bool {
	switch e {
	case AiRoleSystem, AiRoleAssistant, AiRoleUser:
		return true
	}
	return false
}

func (e AiRole) String() string {
	return string(e)
}

func (e *AiRole) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AiRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AiRole", str)
	}
	return nil
}

func (e AiRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AlertSeverity string

const (
	AlertSeverityLow       AlertSeverity = "LOW"
	AlertSeverityMedium    AlertSeverity = "MEDIUM"
	AlertSeverityHigh      AlertSeverity = "HIGH"
	AlertSeverityCritical  AlertSeverity = "CRITICAL"
	AlertSeverityUndefined AlertSeverity = "UNDEFINED"
)

var AllAlertSeverity = []AlertSeverity{
	AlertSeverityLow,
	AlertSeverityMedium,
	AlertSeverityHigh,
	AlertSeverityCritical,
	AlertSeverityUndefined,
}

func (e AlertSeverity) IsValid() bool {
	switch e {
	case AlertSeverityLow, AlertSeverityMedium, AlertSeverityHigh, AlertSeverityCritical, AlertSeverityUndefined:
		return true
	}
	return false
}

func (e AlertSeverity) String() string {
	return string(e)
}

func (e *AlertSeverity) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlertSeverity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlertSeverity", str)
	}
	return nil
}

func (e AlertSeverity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AlertState string

const (
	AlertStateFiring   AlertState = "FIRING"
	AlertStateResolved AlertState = "RESOLVED"
)

var AllAlertState = []AlertState{
	AlertStateFiring,
	AlertStateResolved,
}

func (e AlertState) IsValid() bool {
	switch e {
	case AlertStateFiring, AlertStateResolved:
		return true
	}
	return false
}

func (e AlertState) String() string {
	return string(e)
}

func (e *AlertState) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlertState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlertState", str)
	}
	return nil
}

func (e AlertState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AuditAction string

const (
	AuditActionCreate  AuditAction = "CREATE"
	AuditActionUpdate  AuditAction = "UPDATE"
	AuditActionDelete  AuditAction = "DELETE"
	AuditActionApprove AuditAction = "APPROVE"
	AuditActionCancel  AuditAction = "CANCEL"
)

var AllAuditAction = []AuditAction{
	AuditActionCreate,
	AuditActionUpdate,
	AuditActionDelete,
	AuditActionApprove,
	AuditActionCancel,
}

func (e AuditAction) IsValid() bool {
	switch e {
	case AuditActionCreate, AuditActionUpdate, AuditActionDelete, AuditActionApprove, AuditActionCancel:
		return true
	}
	return false
}

func (e AuditAction) String() string {
	return string(e)
}

func (e *AuditAction) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuditAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuditAction", str)
	}
	return nil
}

func (e AuditAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AuditType string

const (
	AuditTypeBuild              AuditType = "BUILD"
	AuditTypePod                AuditType = "POD"
	AuditTypeConfiguration      AuditType = "CONFIGURATION"
	AuditTypeUser               AuditType = "USER"
	AuditTypeGroup              AuditType = "GROUP"
	AuditTypeRole               AuditType = "ROLE"
	AuditTypeGroupMember        AuditType = "GROUP_MEMBER"
	AuditTypePolicy             AuditType = "POLICY"
	AuditTypeTempToken          AuditType = "TEMP_TOKEN"
	AuditTypeService            AuditType = "SERVICE"
	AuditTypeCluster            AuditType = "CLUSTER"
	AuditTypeClusterProvider    AuditType = "CLUSTER_PROVIDER"
	AuditTypeGitRepository      AuditType = "GIT_REPOSITORY"
	AuditTypeDeploymentSettings AuditType = "DEPLOYMENT_SETTINGS"
	AuditTypeProviderCredential AuditType = "PROVIDER_CREDENTIAL"
	AuditTypePipeline           AuditType = "PIPELINE"
	AuditTypeGlobal             AuditType = "GLOBAL"
	AuditTypeObjectStore        AuditType = "OBJECT_STORE"
	AuditTypeClusterRestore     AuditType = "CLUSTER_RESTORE"
)

var AllAuditType = []AuditType{
	AuditTypeBuild,
	AuditTypePod,
	AuditTypeConfiguration,
	AuditTypeUser,
	AuditTypeGroup,
	AuditTypeRole,
	AuditTypeGroupMember,
	AuditTypePolicy,
	AuditTypeTempToken,
	AuditTypeService,
	AuditTypeCluster,
	AuditTypeClusterProvider,
	AuditTypeGitRepository,
	AuditTypeDeploymentSettings,
	AuditTypeProviderCredential,
	AuditTypePipeline,
	AuditTypeGlobal,
	AuditTypeObjectStore,
	AuditTypeClusterRestore,
}

func (e AuditType) IsValid() bool {
	switch e {
	case AuditTypeBuild, AuditTypePod, AuditTypeConfiguration, AuditTypeUser, AuditTypeGroup, AuditTypeRole, AuditTypeGroupMember, AuditTypePolicy, AuditTypeTempToken, AuditTypeService, AuditTypeCluster, AuditTypeClusterProvider, AuditTypeGitRepository, AuditTypeDeploymentSettings, AuditTypeProviderCredential, AuditTypePipeline, AuditTypeGlobal, AuditTypeObjectStore, AuditTypeClusterRestore:
		return true
	}
	return false
}

func (e AuditType) String() string {
	return string(e)
}

func (e *AuditType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuditType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuditType", str)
	}
	return nil
}

func (e AuditType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AuthMethod string

const (
	AuthMethodBasic AuthMethod = "BASIC"
	AuthMethodSSH   AuthMethod = "SSH"
)

var AllAuthMethod = []AuthMethod{
	AuthMethodBasic,
	AuthMethodSSH,
}

func (e AuthMethod) IsValid() bool {
	switch e {
	case AuthMethodBasic, AuthMethodSSH:
		return true
	}
	return false
}

func (e AuthMethod) String() string {
	return string(e)
}

func (e *AuthMethod) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuthMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuthMethod", str)
	}
	return nil
}

func (e AuthMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AutoscalingTarget string

const (
	AutoscalingTargetStatefulset AutoscalingTarget = "STATEFULSET"
	AutoscalingTargetDeployment  AutoscalingTarget = "DEPLOYMENT"
)

var AllAutoscalingTarget = []AutoscalingTarget{
	AutoscalingTargetStatefulset,
	AutoscalingTargetDeployment,
}

func (e AutoscalingTarget) IsValid() bool {
	switch e {
	case AutoscalingTargetStatefulset, AutoscalingTargetDeployment:
		return true
	}
	return false
}

func (e AutoscalingTarget) String() string {
	return string(e)
}

func (e *AutoscalingTarget) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AutoscalingTarget(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AutoscalingTarget", str)
	}
	return nil
}

func (e AutoscalingTarget) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ChatType string

const (
	ChatTypeText               ChatType = "TEXT"
	ChatTypeFile               ChatType = "FILE"
	ChatTypeTool               ChatType = "TOOL"
	ChatTypeError              ChatType = "ERROR"
	ChatTypeImplementationPlan ChatType = "IMPLEMENTATION_PLAN"
	ChatTypePrCall             ChatType = "PR_CALL"
)

var AllChatType = []ChatType{
	ChatTypeText,
	ChatTypeFile,
	ChatTypeTool,
	ChatTypeError,
	ChatTypeImplementationPlan,
	ChatTypePrCall,
}

func (e ChatType) IsValid() bool {
	switch e {
	case ChatTypeText, ChatTypeFile, ChatTypeTool, ChatTypeError, ChatTypeImplementationPlan, ChatTypePrCall:
		return true
	}
	return false
}

func (e ChatType) String() string {
	return string(e)
}

func (e *ChatType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChatType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChatType", str)
	}
	return nil
}

func (e ChatType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ClusterDistro string

const (
	ClusterDistroGeneric ClusterDistro = "GENERIC"
	ClusterDistroEks     ClusterDistro = "EKS"
	ClusterDistroAks     ClusterDistro = "AKS"
	ClusterDistroGke     ClusterDistro = "GKE"
	ClusterDistroRke     ClusterDistro = "RKE"
	ClusterDistroK3s     ClusterDistro = "K3S"
)

var AllClusterDistro = []ClusterDistro{
	ClusterDistroGeneric,
	ClusterDistroEks,
	ClusterDistroAks,
	ClusterDistroGke,
	ClusterDistroRke,
	ClusterDistroK3s,
}

func (e ClusterDistro) IsValid() bool {
	switch e {
	case ClusterDistroGeneric, ClusterDistroEks, ClusterDistroAks, ClusterDistroGke, ClusterDistroRke, ClusterDistroK3s:
		return true
	}
	return false
}

func (e ClusterDistro) String() string {
	return string(e)
}

func (e *ClusterDistro) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ClusterDistro(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ClusterDistro", str)
	}
	return nil
}

func (e ClusterDistro) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ComplianceReportFormat string

const (
	ComplianceReportFormatCSV  ComplianceReportFormat = "CSV"
	ComplianceReportFormatJSON ComplianceReportFormat = "JSON"
)

var AllComplianceReportFormat = []ComplianceReportFormat{
	ComplianceReportFormatCSV,
	ComplianceReportFormatJSON,
}

func (e ComplianceReportFormat) IsValid() bool {
	switch e {
	case ComplianceReportFormatCSV, ComplianceReportFormatJSON:
		return true
	}
	return false
}

func (e ComplianceReportFormat) String() string {
	return string(e)
}

func (e *ComplianceReportFormat) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ComplianceReportFormat(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ComplianceReportFormat", str)
	}
	return nil
}

func (e ComplianceReportFormat) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ComponentState string

const (
	ComponentStateRunning ComponentState = "RUNNING"
	ComponentStatePending ComponentState = "PENDING"
	ComponentStateFailed  ComponentState = "FAILED"
	ComponentStatePaused  ComponentState = "PAUSED"
)

var AllComponentState = []ComponentState{
	ComponentStateRunning,
	ComponentStatePending,
	ComponentStateFailed,
	ComponentStatePaused,
}

func (e ComponentState) IsValid() bool {
	switch e {
	case ComponentStateRunning, ComponentStatePending, ComponentStateFailed, ComponentStatePaused:
		return true
	}
	return false
}

func (e ComponentState) String() string {
	return string(e)
}

func (e *ComponentState) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ComponentState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ComponentState", str)
	}
	return nil
}

func (e ComponentState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ConfigurationType string

const (
	ConfigurationTypeString   ConfigurationType = "STRING"
	ConfigurationTypeInt      ConfigurationType = "INT"
	ConfigurationTypeBool     ConfigurationType = "BOOL"
	ConfigurationTypeDomain   ConfigurationType = "DOMAIN"
	ConfigurationTypeBucket   ConfigurationType = "BUCKET"
	ConfigurationTypeFile     ConfigurationType = "FILE"
	ConfigurationTypeFunction ConfigurationType = "FUNCTION"
	ConfigurationTypePassword ConfigurationType = "PASSWORD"
	ConfigurationTypeEnum     ConfigurationType = "ENUM"
	ConfigurationTypeCluster  ConfigurationType = "CLUSTER"
	ConfigurationTypeProject  ConfigurationType = "PROJECT"
	ConfigurationTypeGroup    ConfigurationType = "GROUP"
	ConfigurationTypeUser     ConfigurationType = "USER"
	ConfigurationTypeFlow     ConfigurationType = "FLOW"
)

var AllConfigurationType = []ConfigurationType{
	ConfigurationTypeString,
	ConfigurationTypeInt,
	ConfigurationTypeBool,
	ConfigurationTypeDomain,
	ConfigurationTypeBucket,
	ConfigurationTypeFile,
	ConfigurationTypeFunction,
	ConfigurationTypePassword,
	ConfigurationTypeEnum,
	ConfigurationTypeCluster,
	ConfigurationTypeProject,
	ConfigurationTypeGroup,
	ConfigurationTypeUser,
	ConfigurationTypeFlow,
}

func (e ConfigurationType) IsValid() bool {
	switch e {
	case ConfigurationTypeString, ConfigurationTypeInt, ConfigurationTypeBool, ConfigurationTypeDomain, ConfigurationTypeBucket, ConfigurationTypeFile, ConfigurationTypeFunction, ConfigurationTypePassword, ConfigurationTypeEnum, ConfigurationTypeCluster, ConfigurationTypeProject, ConfigurationTypeGroup, ConfigurationTypeUser, ConfigurationTypeFlow:
		return true
	}
	return false
}

func (e ConfigurationType) String() string {
	return string(e)
}

func (e *ConfigurationType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConfigurationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConfigurationType", str)
	}
	return nil
}

func (e ConfigurationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Conjunction string

const (
	ConjunctionAnd Conjunction = "AND"
	ConjunctionOr  Conjunction = "OR"
)

var AllConjunction = []Conjunction{
	ConjunctionAnd,
	ConjunctionOr,
}

func (e Conjunction) IsValid() bool {
	switch e {
	case ConjunctionAnd, ConjunctionOr:
		return true
	}
	return false
}

func (e Conjunction) String() string {
	return string(e)
}

func (e *Conjunction) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Conjunction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Conjunction", str)
	}
	return nil
}

func (e Conjunction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ConstraintEnforcement string

const (
	ConstraintEnforcementWarn   ConstraintEnforcement = "WARN"
	ConstraintEnforcementDeny   ConstraintEnforcement = "DENY"
	ConstraintEnforcementDryRun ConstraintEnforcement = "DRY_RUN"
)

var AllConstraintEnforcement = []ConstraintEnforcement{
	ConstraintEnforcementWarn,
	ConstraintEnforcementDeny,
	ConstraintEnforcementDryRun,
}

func (e ConstraintEnforcement) IsValid() bool {
	switch e {
	case ConstraintEnforcementWarn, ConstraintEnforcementDeny, ConstraintEnforcementDryRun:
		return true
	}
	return false
}

func (e ConstraintEnforcement) String() string {
	return string(e)
}

func (e *ConstraintEnforcement) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConstraintEnforcement(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConstraintEnforcement", str)
	}
	return nil
}

func (e ConstraintEnforcement) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ConstraintViolationField string

const (
	ConstraintViolationFieldNamespace ConstraintViolationField = "NAMESPACE"
	ConstraintViolationFieldKind      ConstraintViolationField = "KIND"
)

var AllConstraintViolationField = []ConstraintViolationField{
	ConstraintViolationFieldNamespace,
	ConstraintViolationFieldKind,
}

func (e ConstraintViolationField) IsValid() bool {
	switch e {
	case ConstraintViolationFieldNamespace, ConstraintViolationFieldKind:
		return true
	}
	return false
}

func (e ConstraintViolationField) String() string {
	return string(e)
}

func (e *ConstraintViolationField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConstraintViolationField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConstraintViolationField", str)
	}
	return nil
}

func (e ConstraintViolationField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The source of additional context to send to a thread
type ContextSource string

const (
	ContextSourceService ContextSource = "SERVICE"
	ContextSourceStack   ContextSource = "STACK"
)

var AllContextSource = []ContextSource{
	ContextSourceService,
	ContextSourceStack,
}

func (e ContextSource) IsValid() bool {
	switch e {
	case ContextSourceService, ContextSourceStack:
		return true
	}
	return false
}

func (e ContextSource) String() string {
	return string(e)
}

func (e *ContextSource) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContextSource(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContextSource", str)
	}
	return nil
}

func (e ContextSource) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Delta string

const (
	DeltaCreate Delta = "CREATE"
	DeltaUpdate Delta = "UPDATE"
	DeltaDelete Delta = "DELETE"
)

var AllDelta = []Delta{
	DeltaCreate,
	DeltaUpdate,
	DeltaDelete,
}

func (e Delta) IsValid() bool {
	switch e {
	case DeltaCreate, DeltaUpdate, DeltaDelete:
		return true
	}
	return false
}

func (e Delta) String() string {
	return string(e)
}

func (e *Delta) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Delta(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Delta", str)
	}
	return nil
}

func (e Delta) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EvidenceType string

const (
	EvidenceTypeLog       EvidenceType = "LOG"
	EvidenceTypePr        EvidenceType = "PR"
	EvidenceTypeAlert     EvidenceType = "ALERT"
	EvidenceTypeKnowledge EvidenceType = "KNOWLEDGE"
)

var AllEvidenceType = []EvidenceType{
	EvidenceTypeLog,
	EvidenceTypePr,
	EvidenceTypeAlert,
	EvidenceTypeKnowledge,
}

func (e EvidenceType) IsValid() bool {
	switch e {
	case EvidenceTypeLog, EvidenceTypePr, EvidenceTypeAlert, EvidenceTypeKnowledge:
		return true
	}
	return false
}

func (e EvidenceType) String() string {
	return string(e)
}

func (e *EvidenceType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EvidenceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EvidenceType", str)
	}
	return nil
}

func (e EvidenceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GateState string

const (
	GateStatePending GateState = "PENDING"
	GateStateOpen    GateState = "OPEN"
	GateStateClosed  GateState = "CLOSED"
	GateStateRunning GateState = "RUNNING"
)

var AllGateState = []GateState{
	GateStatePending,
	GateStateOpen,
	GateStateClosed,
	GateStateRunning,
}

func (e GateState) IsValid() bool {
	switch e {
	case GateStatePending, GateStateOpen, GateStateClosed, GateStateRunning:
		return true
	}
	return false
}

func (e GateState) String() string {
	return string(e)
}

func (e *GateState) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GateState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GateState", str)
	}
	return nil
}

func (e GateState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GateType string

const (
	GateTypeApproval GateType = "APPROVAL"
	GateTypeWindow   GateType = "WINDOW"
	GateTypeJob      GateType = "JOB"
)

var AllGateType = []GateType{
	GateTypeApproval,
	GateTypeWindow,
	GateTypeJob,
}

func (e GateType) IsValid() bool {
	switch e {
	case GateTypeApproval, GateTypeWindow, GateTypeJob:
		return true
	}
	return false
}

func (e GateType) String() string {
	return string(e)
}

func (e *GateType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GateType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GateType", str)
	}
	return nil
}

func (e GateType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GitHealth string

const (
	GitHealthPullable GitHealth = "PULLABLE"
	GitHealthFailed   GitHealth = "FAILED"
)

var AllGitHealth = []GitHealth{
	GitHealthPullable,
	GitHealthFailed,
}

func (e GitHealth) IsValid() bool {
	switch e {
	case GitHealthPullable, GitHealthFailed:
		return true
	}
	return false
}

func (e GitHealth) String() string {
	return string(e)
}

func (e *GitHealth) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GitHealth(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GitHealth", str)
	}
	return nil
}

func (e GitHealth) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HeatMapFlavor string

const (
	HeatMapFlavorPod       HeatMapFlavor = "POD"
	HeatMapFlavorNamespace HeatMapFlavor = "NAMESPACE"
	HeatMapFlavorNode      HeatMapFlavor = "NODE"
)

var AllHeatMapFlavor = []HeatMapFlavor{
	HeatMapFlavorPod,
	HeatMapFlavorNamespace,
	HeatMapFlavorNode,
}

func (e HeatMapFlavor) IsValid() bool {
	switch e {
	case HeatMapFlavorPod, HeatMapFlavorNamespace, HeatMapFlavorNode:
		return true
	}
	return false
}

func (e HeatMapFlavor) String() string {
	return string(e)
}

func (e *HeatMapFlavor) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HeatMapFlavor(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HeatMapFlavor", str)
	}
	return nil
}

func (e HeatMapFlavor) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HelmAuthProvider string

const (
	HelmAuthProviderBasic  HelmAuthProvider = "BASIC"
	HelmAuthProviderBearer HelmAuthProvider = "BEARER"
	HelmAuthProviderGCP    HelmAuthProvider = "GCP"
	HelmAuthProviderAzure  HelmAuthProvider = "AZURE"
	HelmAuthProviderAWS    HelmAuthProvider = "AWS"
)

var AllHelmAuthProvider = []HelmAuthProvider{
	HelmAuthProviderBasic,
	HelmAuthProviderBearer,
	HelmAuthProviderGCP,
	HelmAuthProviderAzure,
	HelmAuthProviderAWS,
}

func (e HelmAuthProvider) IsValid() bool {
	switch e {
	case HelmAuthProviderBasic, HelmAuthProviderBearer, HelmAuthProviderGCP, HelmAuthProviderAzure, HelmAuthProviderAWS:
		return true
	}
	return false
}

func (e HelmAuthProvider) String() string {
	return string(e)
}

func (e *HelmAuthProvider) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HelmAuthProvider(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HelmAuthProvider", str)
	}
	return nil
}

func (e HelmAuthProvider) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InsightComponentPriority string

const (
	InsightComponentPriorityLow      InsightComponentPriority = "LOW"
	InsightComponentPriorityMedium   InsightComponentPriority = "MEDIUM"
	InsightComponentPriorityHigh     InsightComponentPriority = "HIGH"
	InsightComponentPriorityCritical InsightComponentPriority = "CRITICAL"
)

var AllInsightComponentPriority = []InsightComponentPriority{
	InsightComponentPriorityLow,
	InsightComponentPriorityMedium,
	InsightComponentPriorityHigh,
	InsightComponentPriorityCritical,
}

func (e InsightComponentPriority) IsValid() bool {
	switch e {
	case InsightComponentPriorityLow, InsightComponentPriorityMedium, InsightComponentPriorityHigh, InsightComponentPriorityCritical:
		return true
	}
	return false
}

func (e InsightComponentPriority) String() string {
	return string(e)
}

func (e *InsightComponentPriority) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InsightComponentPriority(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InsightComponentPriority", str)
	}
	return nil
}

func (e InsightComponentPriority) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// enumerable to describe the recency of this insight
type InsightFreshness string

const (
	InsightFreshnessFresh   InsightFreshness = "FRESH"
	InsightFreshnessStale   InsightFreshness = "STALE"
	InsightFreshnessExpired InsightFreshness = "EXPIRED"
)

var AllInsightFreshness = []InsightFreshness{
	InsightFreshnessFresh,
	InsightFreshnessStale,
	InsightFreshnessExpired,
}

func (e InsightFreshness) IsValid() bool {
	switch e {
	case InsightFreshnessFresh, InsightFreshnessStale, InsightFreshnessExpired:
		return true
	}
	return false
}

func (e InsightFreshness) String() string {
	return string(e)
}

func (e *InsightFreshness) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InsightFreshness(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InsightFreshness", str)
	}
	return nil
}

func (e InsightFreshness) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ListMerge string

const (
	ListMergeOverwrite ListMerge = "OVERWRITE"
	ListMergeAppend    ListMerge = "APPEND"
)

var AllListMerge = []ListMerge{
	ListMergeOverwrite,
	ListMergeAppend,
}

func (e ListMerge) IsValid() bool {
	switch e {
	case ListMergeOverwrite, ListMergeAppend:
		return true
	}
	return false
}

func (e ListMerge) String() string {
	return string(e)
}

func (e *ListMerge) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ListMerge(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ListMerge", str)
	}
	return nil
}

func (e ListMerge) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LogDriver string

const (
	LogDriverVictoria   LogDriver = "VICTORIA"
	LogDriverElastic    LogDriver = "ELASTIC"
	LogDriverOpensearch LogDriver = "OPENSEARCH"
)

var AllLogDriver = []LogDriver{
	LogDriverVictoria,
	LogDriverElastic,
	LogDriverOpensearch,
}

func (e LogDriver) IsValid() bool {
	switch e {
	case LogDriverVictoria, LogDriverElastic, LogDriverOpensearch:
		return true
	}
	return false
}

func (e LogDriver) String() string {
	return string(e)
}

func (e *LogDriver) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LogDriver(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LogDriver", str)
	}
	return nil
}

func (e LogDriver) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MatchStrategy string

const (
	MatchStrategyAny       MatchStrategy = "ANY"
	MatchStrategyAll       MatchStrategy = "ALL"
	MatchStrategyRecursive MatchStrategy = "RECURSIVE"
)

var AllMatchStrategy = []MatchStrategy{
	MatchStrategyAny,
	MatchStrategyAll,
	MatchStrategyRecursive,
}

func (e MatchStrategy) IsValid() bool {
	switch e {
	case MatchStrategyAny, MatchStrategyAll, MatchStrategyRecursive:
		return true
	}
	return false
}

func (e MatchStrategy) String() string {
	return string(e)
}

func (e *MatchStrategy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MatchStrategy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MatchStrategy", str)
	}
	return nil
}

func (e MatchStrategy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NodeStatisticHealth string

const (
	NodeStatisticHealthHealthy NodeStatisticHealth = "HEALTHY"
	NodeStatisticHealthWarning NodeStatisticHealth = "WARNING"
	NodeStatisticHealthFailed  NodeStatisticHealth = "FAILED"
)

var AllNodeStatisticHealth = []NodeStatisticHealth{
	NodeStatisticHealthHealthy,
	NodeStatisticHealthWarning,
	NodeStatisticHealthFailed,
}

func (e NodeStatisticHealth) IsValid() bool {
	switch e {
	case NodeStatisticHealthHealthy, NodeStatisticHealthWarning, NodeStatisticHealthFailed:
		return true
	}
	return false
}

func (e NodeStatisticHealth) String() string {
	return string(e)
}

func (e *NodeStatisticHealth) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeStatisticHealth(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeStatisticHealth", str)
	}
	return nil
}

func (e NodeStatisticHealth) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NotificationPriority string

const (
	NotificationPriorityLow    NotificationPriority = "LOW"
	NotificationPriorityMedium NotificationPriority = "MEDIUM"
	NotificationPriorityHigh   NotificationPriority = "HIGH"
)

var AllNotificationPriority = []NotificationPriority{
	NotificationPriorityLow,
	NotificationPriorityMedium,
	NotificationPriorityHigh,
}

func (e NotificationPriority) IsValid() bool {
	switch e {
	case NotificationPriorityLow, NotificationPriorityMedium, NotificationPriorityHigh:
		return true
	}
	return false
}

func (e NotificationPriority) String() string {
	return string(e)
}

func (e *NotificationPriority) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationPriority(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotificationPriority", str)
	}
	return nil
}

func (e NotificationPriority) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NotificationStatus string

const (
	NotificationStatusFiring   NotificationStatus = "FIRING"
	NotificationStatusResolved NotificationStatus = "RESOLVED"
)

var AllNotificationStatus = []NotificationStatus{
	NotificationStatusFiring,
	NotificationStatusResolved,
}

func (e NotificationStatus) IsValid() bool {
	switch e {
	case NotificationStatusFiring, NotificationStatusResolved:
		return true
	}
	return false
}

func (e NotificationStatus) String() string {
	return string(e)
}

func (e *NotificationStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotificationStatus", str)
	}
	return nil
}

func (e NotificationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ObservabilityProviderType string

const (
	ObservabilityProviderTypeDatadog  ObservabilityProviderType = "DATADOG"
	ObservabilityProviderTypeNewrelic ObservabilityProviderType = "NEWRELIC"
)

var AllObservabilityProviderType = []ObservabilityProviderType{
	ObservabilityProviderTypeDatadog,
	ObservabilityProviderTypeNewrelic,
}

func (e ObservabilityProviderType) IsValid() bool {
	switch e {
	case ObservabilityProviderTypeDatadog, ObservabilityProviderTypeNewrelic:
		return true
	}
	return false
}

func (e ObservabilityProviderType) String() string {
	return string(e)
}

func (e *ObservabilityProviderType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ObservabilityProviderType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ObservabilityProviderType", str)
	}
	return nil
}

func (e ObservabilityProviderType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ObservabilityWebhookType string

const (
	ObservabilityWebhookTypeGrafana   ObservabilityWebhookType = "GRAFANA"
	ObservabilityWebhookTypeDatadog   ObservabilityWebhookType = "DATADOG"
	ObservabilityWebhookTypePagerduty ObservabilityWebhookType = "PAGERDUTY"
	ObservabilityWebhookTypeNewrelic  ObservabilityWebhookType = "NEWRELIC"
)

var AllObservabilityWebhookType = []ObservabilityWebhookType{
	ObservabilityWebhookTypeGrafana,
	ObservabilityWebhookTypeDatadog,
	ObservabilityWebhookTypePagerduty,
	ObservabilityWebhookTypeNewrelic,
}

func (e ObservabilityWebhookType) IsValid() bool {
	switch e {
	case ObservabilityWebhookTypeGrafana, ObservabilityWebhookTypeDatadog, ObservabilityWebhookTypePagerduty, ObservabilityWebhookTypeNewrelic:
		return true
	}
	return false
}

func (e ObservabilityWebhookType) String() string {
	return string(e)
}

func (e *ObservabilityWebhookType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ObservabilityWebhookType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ObservabilityWebhookType", str)
	}
	return nil
}

func (e ObservabilityWebhookType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ObserverActionType string

const (
	ObserverActionTypePipeline ObserverActionType = "PIPELINE"
	ObserverActionTypePr       ObserverActionType = "PR"
)

var AllObserverActionType = []ObserverActionType{
	ObserverActionTypePipeline,
	ObserverActionTypePr,
}

func (e ObserverActionType) IsValid() bool {
	switch e {
	case ObserverActionTypePipeline, ObserverActionTypePr:
		return true
	}
	return false
}

func (e ObserverActionType) String() string {
	return string(e)
}

func (e *ObserverActionType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ObserverActionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ObserverActionType", str)
	}
	return nil
}

func (e ObserverActionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ObserverGitTargetType string

const (
	ObserverGitTargetTypeTags ObserverGitTargetType = "TAGS"
)

var AllObserverGitTargetType = []ObserverGitTargetType{
	ObserverGitTargetTypeTags,
}

func (e ObserverGitTargetType) IsValid() bool {
	switch e {
	case ObserverGitTargetTypeTags:
		return true
	}
	return false
}

func (e ObserverGitTargetType) String() string {
	return string(e)
}

func (e *ObserverGitTargetType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ObserverGitTargetType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ObserverGitTargetType", str)
	}
	return nil
}

func (e ObserverGitTargetType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ObserverStatus string

const (
	ObserverStatusHealthy ObserverStatus = "HEALTHY"
	ObserverStatusFailed  ObserverStatus = "FAILED"
)

var AllObserverStatus = []ObserverStatus{
	ObserverStatusHealthy,
	ObserverStatusFailed,
}

func (e ObserverStatus) IsValid() bool {
	switch e {
	case ObserverStatusHealthy, ObserverStatusFailed:
		return true
	}
	return false
}

func (e ObserverStatus) String() string {
	return string(e)
}

func (e *ObserverStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ObserverStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ObserverStatus", str)
	}
	return nil
}

func (e ObserverStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ObserverTargetOrder string

const (
	ObserverTargetOrderSemver ObserverTargetOrder = "SEMVER"
	ObserverTargetOrderLatest ObserverTargetOrder = "LATEST"
)

var AllObserverTargetOrder = []ObserverTargetOrder{
	ObserverTargetOrderSemver,
	ObserverTargetOrderLatest,
}

func (e ObserverTargetOrder) IsValid() bool {
	switch e {
	case ObserverTargetOrderSemver, ObserverTargetOrderLatest:
		return true
	}
	return false
}

func (e ObserverTargetOrder) String() string {
	return string(e)
}

func (e *ObserverTargetOrder) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ObserverTargetOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ObserverTargetOrder", str)
	}
	return nil
}

func (e ObserverTargetOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ObserverTargetType string

const (
	ObserverTargetTypeOci      ObserverTargetType = "OCI"
	ObserverTargetTypeHelm     ObserverTargetType = "HELM"
	ObserverTargetTypeGit      ObserverTargetType = "GIT"
	ObserverTargetTypeEksAddon ObserverTargetType = "EKS_ADDON"
	ObserverTargetTypeAddon    ObserverTargetType = "ADDON"
)

var AllObserverTargetType = []ObserverTargetType{
	ObserverTargetTypeOci,
	ObserverTargetTypeHelm,
	ObserverTargetTypeGit,
	ObserverTargetTypeEksAddon,
	ObserverTargetTypeAddon,
}

func (e ObserverTargetType) IsValid() bool {
	switch e {
	case ObserverTargetTypeOci, ObserverTargetTypeHelm, ObserverTargetTypeGit, ObserverTargetTypeEksAddon, ObserverTargetTypeAddon:
		return true
	}
	return false
}

func (e ObserverTargetType) String() string {
	return string(e)
}

func (e *ObserverTargetType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ObserverTargetType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ObserverTargetType", str)
	}
	return nil
}

func (e ObserverTargetType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Supported methods for fetching an OIDC auth token
type OidcAuthMethod string

const (
	OidcAuthMethodPost  OidcAuthMethod = "POST"
	OidcAuthMethodBasic OidcAuthMethod = "BASIC"
)

var AllOidcAuthMethod = []OidcAuthMethod{
	OidcAuthMethodPost,
	OidcAuthMethodBasic,
}

func (e OidcAuthMethod) IsValid() bool {
	switch e {
	case OidcAuthMethodPost, OidcAuthMethodBasic:
		return true
	}
	return false
}

func (e OidcAuthMethod) String() string {
	return string(e)
}

func (e *OidcAuthMethod) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OidcAuthMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OidcAuthMethod", str)
	}
	return nil
}

func (e OidcAuthMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Supported OIDC-compatible Auth Providers
type OidcProviderType string

const (
	OidcProviderTypePlural  OidcProviderType = "PLURAL"
	OidcProviderTypeConsole OidcProviderType = "CONSOLE"
)

var AllOidcProviderType = []OidcProviderType{
	OidcProviderTypePlural,
	OidcProviderTypeConsole,
}

func (e OidcProviderType) IsValid() bool {
	switch e {
	case OidcProviderTypePlural, OidcProviderTypeConsole:
		return true
	}
	return false
}

func (e OidcProviderType) String() string {
	return string(e)
}

func (e *OidcProviderType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OidcProviderType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OidcProviderType", str)
	}
	return nil
}

func (e OidcProviderType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Operation string

const (
	OperationNot    Operation = "NOT"
	OperationGt     Operation = "GT"
	OperationLt     Operation = "LT"
	OperationEq     Operation = "EQ"
	OperationGte    Operation = "GTE"
	OperationLte    Operation = "LTE"
	OperationPrefix Operation = "PREFIX"
	OperationSuffix Operation = "SUFFIX"
)

var AllOperation = []Operation{
	OperationNot,
	OperationGt,
	OperationLt,
	OperationEq,
	OperationGte,
	OperationLte,
	OperationPrefix,
	OperationSuffix,
}

func (e Operation) IsValid() bool {
	switch e {
	case OperationNot, OperationGt, OperationLt, OperationEq, OperationGte, OperationLte, OperationPrefix, OperationSuffix:
		return true
	}
	return false
}

func (e Operation) String() string {
	return string(e)
}

func (e *Operation) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Operation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Operation", str)
	}
	return nil
}

func (e Operation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Permission string

const (
	PermissionRead      Permission = "READ"
	PermissionConfigure Permission = "CONFIGURE"
	PermissionDeploy    Permission = "DEPLOY"
	PermissionOperate   Permission = "OPERATE"
)

var AllPermission = []Permission{
	PermissionRead,
	PermissionConfigure,
	PermissionDeploy,
	PermissionOperate,
}

func (e Permission) IsValid() bool {
	switch e {
	case PermissionRead, PermissionConfigure, PermissionDeploy, PermissionOperate:
		return true
	}
	return false
}

func (e Permission) String() string {
	return string(e)
}

func (e *Permission) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Permission(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Permission", str)
	}
	return nil
}

func (e Permission) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PersonaRole string

const (
	PersonaRolePlatform   PersonaRole = "PLATFORM"
	PersonaRoleDeveloper  PersonaRole = "DEVELOPER"
	PersonaRoleSecurity   PersonaRole = "SECURITY"
	PersonaRoleFinops     PersonaRole = "FINOPS"
	PersonaRoleManagement PersonaRole = "MANAGEMENT"
)

var AllPersonaRole = []PersonaRole{
	PersonaRolePlatform,
	PersonaRoleDeveloper,
	PersonaRoleSecurity,
	PersonaRoleFinops,
	PersonaRoleManagement,
}

func (e PersonaRole) IsValid() bool {
	switch e {
	case PersonaRolePlatform, PersonaRoleDeveloper, PersonaRoleSecurity, PersonaRoleFinops, PersonaRoleManagement:
		return true
	}
	return false
}

func (e PersonaRole) String() string {
	return string(e)
}

func (e *PersonaRole) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PersonaRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PersonaRole", str)
	}
	return nil
}

func (e PersonaRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PolicyAggregate string

const (
	PolicyAggregateCluster     PolicyAggregate = "CLUSTER"
	PolicyAggregateEnforcement PolicyAggregate = "ENFORCEMENT"
	PolicyAggregateInstalled   PolicyAggregate = "INSTALLED"
)

var AllPolicyAggregate = []PolicyAggregate{
	PolicyAggregateCluster,
	PolicyAggregateEnforcement,
	PolicyAggregateInstalled,
}

func (e PolicyAggregate) IsValid() bool {
	switch e {
	case PolicyAggregateCluster, PolicyAggregateEnforcement, PolicyAggregateInstalled:
		return true
	}
	return false
}

func (e PolicyAggregate) String() string {
	return string(e)
}

func (e *PolicyAggregate) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicyAggregate(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicyAggregate", str)
	}
	return nil
}

func (e PolicyAggregate) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PolicyEngineType string

const (
	PolicyEngineTypeTrivy PolicyEngineType = "TRIVY"
)

var AllPolicyEngineType = []PolicyEngineType{
	PolicyEngineTypeTrivy,
}

func (e PolicyEngineType) IsValid() bool {
	switch e {
	case PolicyEngineTypeTrivy:
		return true
	}
	return false
}

func (e PolicyEngineType) String() string {
	return string(e)
}

func (e *PolicyEngineType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PolicyEngineType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PolicyEngineType", str)
	}
	return nil
}

func (e PolicyEngineType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PrRole string

const (
	PrRoleCluster  PrRole = "CLUSTER"
	PrRoleService  PrRole = "SERVICE"
	PrRolePipeline PrRole = "PIPELINE"
	PrRoleUpdate   PrRole = "UPDATE"
	PrRoleUpgrade  PrRole = "UPGRADE"
	PrRoleCost     PrRole = "COST"
)

var AllPrRole = []PrRole{
	PrRoleCluster,
	PrRoleService,
	PrRolePipeline,
	PrRoleUpdate,
	PrRoleUpgrade,
	PrRoleCost,
}

func (e PrRole) IsValid() bool {
	switch e {
	case PrRoleCluster, PrRoleService, PrRolePipeline, PrRoleUpdate, PrRoleUpgrade, PrRoleCost:
		return true
	}
	return false
}

func (e PrRole) String() string {
	return string(e)
}

func (e *PrRole) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PrRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PrRole", str)
	}
	return nil
}

func (e PrRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PrStatus string

const (
	PrStatusOpen   PrStatus = "OPEN"
	PrStatusMerged PrStatus = "MERGED"
	PrStatusClosed PrStatus = "CLOSED"
)

var AllPrStatus = []PrStatus{
	PrStatusOpen,
	PrStatusMerged,
	PrStatusClosed,
}

func (e PrStatus) IsValid() bool {
	switch e {
	case PrStatusOpen, PrStatusMerged, PrStatusClosed:
		return true
	}
	return false
}

func (e PrStatus) String() string {
	return string(e)
}

func (e *PrStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PrStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PrStatus", str)
	}
	return nil
}

func (e PrStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Provider string

const (
	ProviderAWS   Provider = "AWS"
	ProviderGCP   Provider = "GCP"
	ProviderAzure Provider = "AZURE"
)

var AllProvider = []Provider{
	ProviderAWS,
	ProviderGCP,
	ProviderAzure,
}

func (e Provider) IsValid() bool {
	switch e {
	case ProviderAWS, ProviderGCP, ProviderAzure:
		return true
	}
	return false
}

func (e Provider) String() string {
	return string(e)
}

func (e *Provider) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Provider(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Provider", str)
	}
	return nil
}

func (e Provider) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ReadType string

const (
	ReadTypeNotification ReadType = "NOTIFICATION"
	ReadTypeBuild        ReadType = "BUILD"
)

var AllReadType = []ReadType{
	ReadTypeNotification,
	ReadTypeBuild,
}

func (e ReadType) IsValid() bool {
	switch e {
	case ReadTypeNotification, ReadTypeBuild:
		return true
	}
	return false
}

func (e ReadType) String() string {
	return string(e)
}

func (e *ReadType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReadType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReadType", str)
	}
	return nil
}

func (e ReadType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RendererType string

const (
	RendererTypeAuto      RendererType = "AUTO"
	RendererTypeRaw       RendererType = "RAW"
	RendererTypeHelm      RendererType = "HELM"
	RendererTypeKustomize RendererType = "KUSTOMIZE"
)

var AllRendererType = []RendererType{
	RendererTypeAuto,
	RendererTypeRaw,
	RendererTypeHelm,
	RendererTypeKustomize,
}

func (e RendererType) IsValid() bool {
	switch e {
	case RendererTypeAuto, RendererTypeRaw, RendererTypeHelm, RendererTypeKustomize:
		return true
	}
	return false
}

func (e RendererType) String() string {
	return string(e)
}

func (e *RendererType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RendererType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RendererType", str)
	}
	return nil
}

func (e RendererType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RestoreStatus string

const (
	RestoreStatusCreated    RestoreStatus = "CREATED"
	RestoreStatusPending    RestoreStatus = "PENDING"
	RestoreStatusSuccessful RestoreStatus = "SUCCESSFUL"
	RestoreStatusFailed     RestoreStatus = "FAILED"
)

var AllRestoreStatus = []RestoreStatus{
	RestoreStatusCreated,
	RestoreStatusPending,
	RestoreStatusSuccessful,
	RestoreStatusFailed,
}

func (e RestoreStatus) IsValid() bool {
	switch e {
	case RestoreStatusCreated, RestoreStatusPending, RestoreStatusSuccessful, RestoreStatusFailed:
		return true
	}
	return false
}

func (e RestoreStatus) String() string {
	return string(e)
}

func (e *RestoreStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RestoreStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RestoreStatus", str)
	}
	return nil
}

func (e RestoreStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ScalingRecommendationType string

const (
	ScalingRecommendationTypeDeployment  ScalingRecommendationType = "DEPLOYMENT"
	ScalingRecommendationTypeStatefulset ScalingRecommendationType = "STATEFULSET"
	ScalingRecommendationTypeDaemonset   ScalingRecommendationType = "DAEMONSET"
	ScalingRecommendationTypeRollout     ScalingRecommendationType = "ROLLOUT"
)

var AllScalingRecommendationType = []ScalingRecommendationType{
	ScalingRecommendationTypeDeployment,
	ScalingRecommendationTypeStatefulset,
	ScalingRecommendationTypeDaemonset,
	ScalingRecommendationTypeRollout,
}

func (e ScalingRecommendationType) IsValid() bool {
	switch e {
	case ScalingRecommendationTypeDeployment, ScalingRecommendationTypeStatefulset, ScalingRecommendationTypeDaemonset, ScalingRecommendationTypeRollout:
		return true
	}
	return false
}

func (e ScalingRecommendationType) String() string {
	return string(e)
}

func (e *ScalingRecommendationType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScalingRecommendationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ScalingRecommendationType", str)
	}
	return nil
}

func (e ScalingRecommendationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ScmType string

const (
	ScmTypeGithub    ScmType = "GITHUB"
	ScmTypeGitlab    ScmType = "GITLAB"
	ScmTypeBitbucket ScmType = "BITBUCKET"
)

var AllScmType = []ScmType{
	ScmTypeGithub,
	ScmTypeGitlab,
	ScmTypeBitbucket,
}

func (e ScmType) IsValid() bool {
	switch e {
	case ScmTypeGithub, ScmTypeGitlab, ScmTypeBitbucket:
		return true
	}
	return false
}

func (e ScmType) String() string {
	return string(e)
}

func (e *ScmType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScmType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ScmType", str)
	}
	return nil
}

func (e ScmType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ServiceDeploymentStatus string

const (
	ServiceDeploymentStatusStale   ServiceDeploymentStatus = "STALE"
	ServiceDeploymentStatusSynced  ServiceDeploymentStatus = "SYNCED"
	ServiceDeploymentStatusHealthy ServiceDeploymentStatus = "HEALTHY"
	ServiceDeploymentStatusFailed  ServiceDeploymentStatus = "FAILED"
	ServiceDeploymentStatusPaused  ServiceDeploymentStatus = "PAUSED"
)

var AllServiceDeploymentStatus = []ServiceDeploymentStatus{
	ServiceDeploymentStatusStale,
	ServiceDeploymentStatusSynced,
	ServiceDeploymentStatusHealthy,
	ServiceDeploymentStatusFailed,
	ServiceDeploymentStatusPaused,
}

func (e ServiceDeploymentStatus) IsValid() bool {
	switch e {
	case ServiceDeploymentStatusStale, ServiceDeploymentStatusSynced, ServiceDeploymentStatusHealthy, ServiceDeploymentStatusFailed, ServiceDeploymentStatusPaused:
		return true
	}
	return false
}

func (e ServiceDeploymentStatus) String() string {
	return string(e)
}

func (e *ServiceDeploymentStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServiceDeploymentStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServiceDeploymentStatus", str)
	}
	return nil
}

func (e ServiceDeploymentStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ServiceMesh string

const (
	ServiceMeshLinkerd ServiceMesh = "LINKERD"
	ServiceMeshIstio   ServiceMesh = "ISTIO"
	ServiceMeshCilium  ServiceMesh = "CILIUM"
	ServiceMeshEbpf    ServiceMesh = "EBPF"
)

var AllServiceMesh = []ServiceMesh{
	ServiceMeshLinkerd,
	ServiceMeshIstio,
	ServiceMeshCilium,
	ServiceMeshEbpf,
}

func (e ServiceMesh) IsValid() bool {
	switch e {
	case ServiceMeshLinkerd, ServiceMeshIstio, ServiceMeshCilium, ServiceMeshEbpf:
		return true
	}
	return false
}

func (e ServiceMesh) String() string {
	return string(e)
}

func (e *ServiceMesh) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServiceMesh(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServiceMesh", str)
	}
	return nil
}

func (e ServiceMesh) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ServicePromotion string

const (
	ServicePromotionIgnore   ServicePromotion = "IGNORE"
	ServicePromotionProceed  ServicePromotion = "PROCEED"
	ServicePromotionRollback ServicePromotion = "ROLLBACK"
)

var AllServicePromotion = []ServicePromotion{
	ServicePromotionIgnore,
	ServicePromotionProceed,
	ServicePromotionRollback,
}

func (e ServicePromotion) IsValid() bool {
	switch e {
	case ServicePromotionIgnore, ServicePromotionProceed, ServicePromotionRollback:
		return true
	}
	return false
}

func (e ServicePromotion) String() string {
	return string(e)
}

func (e *ServicePromotion) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServicePromotion(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServicePromotion", str)
	}
	return nil
}

func (e ServicePromotion) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Severity string

const (
	SeverityNone     Severity = "NONE"
	SeverityLow      Severity = "LOW"
	SeverityMedium   Severity = "MEDIUM"
	SeverityHigh     Severity = "HIGH"
	SeverityCritical Severity = "CRITICAL"
)

var AllSeverity = []Severity{
	SeverityNone,
	SeverityLow,
	SeverityMedium,
	SeverityHigh,
	SeverityCritical,
}

func (e Severity) IsValid() bool {
	switch e {
	case SeverityNone, SeverityLow, SeverityMedium, SeverityHigh, SeverityCritical:
		return true
	}
	return false
}

func (e Severity) String() string {
	return string(e)
}

func (e *Severity) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Severity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Severity", str)
	}
	return nil
}

func (e Severity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SinkType string

const (
	SinkTypeSLACk  SinkType = "SLACK"
	SinkTypeTeams  SinkType = "TEAMS"
	SinkTypePlural SinkType = "PLURAL"
)

var AllSinkType = []SinkType{
	SinkTypeSLACk,
	SinkTypeTeams,
	SinkTypePlural,
}

func (e SinkType) IsValid() bool {
	switch e {
	case SinkTypeSLACk, SinkTypeTeams, SinkTypePlural:
		return true
	}
	return false
}

func (e SinkType) String() string {
	return string(e)
}

func (e *SinkType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SinkType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SinkType", str)
	}
	return nil
}

func (e SinkType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StackStatus string

const (
	StackStatusQueued          StackStatus = "QUEUED"
	StackStatusPending         StackStatus = "PENDING"
	StackStatusRunning         StackStatus = "RUNNING"
	StackStatusSuccessful      StackStatus = "SUCCESSFUL"
	StackStatusFailed          StackStatus = "FAILED"
	StackStatusCancelled       StackStatus = "CANCELLED"
	StackStatusPendingApproval StackStatus = "PENDING_APPROVAL"
)

var AllStackStatus = []StackStatus{
	StackStatusQueued,
	StackStatusPending,
	StackStatusRunning,
	StackStatusSuccessful,
	StackStatusFailed,
	StackStatusCancelled,
	StackStatusPendingApproval,
}

func (e StackStatus) IsValid() bool {
	switch e {
	case StackStatusQueued, StackStatusPending, StackStatusRunning, StackStatusSuccessful, StackStatusFailed, StackStatusCancelled, StackStatusPendingApproval:
		return true
	}
	return false
}

func (e StackStatus) String() string {
	return string(e)
}

func (e *StackStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StackStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StackStatus", str)
	}
	return nil
}

func (e StackStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StackType string

const (
	StackTypeTerraform StackType = "TERRAFORM"
	StackTypeAnsible   StackType = "ANSIBLE"
	StackTypeCustom    StackType = "CUSTOM"
)

var AllStackType = []StackType{
	StackTypeTerraform,
	StackTypeAnsible,
	StackTypeCustom,
}

func (e StackType) IsValid() bool {
	switch e {
	case StackTypeTerraform, StackTypeAnsible, StackTypeCustom:
		return true
	}
	return false
}

func (e StackType) String() string {
	return string(e)
}

func (e *StackType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StackType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StackType", str)
	}
	return nil
}

func (e StackType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StepStage string

const (
	StepStagePlan    StepStage = "PLAN"
	StepStageVerify  StepStage = "VERIFY"
	StepStageApply   StepStage = "APPLY"
	StepStageInit    StepStage = "INIT"
	StepStageDestroy StepStage = "DESTROY"
)

var AllStepStage = []StepStage{
	StepStagePlan,
	StepStageVerify,
	StepStageApply,
	StepStageInit,
	StepStageDestroy,
}

func (e StepStage) IsValid() bool {
	switch e {
	case StepStagePlan, StepStageVerify, StepStageApply, StepStageInit, StepStageDestroy:
		return true
	}
	return false
}

func (e StepStage) String() string {
	return string(e)
}

func (e *StepStage) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StepStage(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StepStage", str)
	}
	return nil
}

func (e StepStage) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StepStatus string

const (
	StepStatusPending    StepStatus = "PENDING"
	StepStatusRunning    StepStatus = "RUNNING"
	StepStatusSuccessful StepStatus = "SUCCESSFUL"
	StepStatusFailed     StepStatus = "FAILED"
)

var AllStepStatus = []StepStatus{
	StepStatusPending,
	StepStatusRunning,
	StepStatusSuccessful,
	StepStatusFailed,
}

func (e StepStatus) IsValid() bool {
	switch e {
	case StepStatusPending, StepStatusRunning, StepStatusSuccessful, StepStatusFailed:
		return true
	}
	return false
}

func (e StepStatus) String() string {
	return string(e)
}

func (e *StepStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StepStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StepStatus", str)
	}
	return nil
}

func (e StepStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TagType string

const (
	TagTypeCluster TagType = "CLUSTER"
	TagTypeStack   TagType = "STACK"
)

var AllTagType = []TagType{
	TagTypeCluster,
	TagTypeStack,
}

func (e TagType) IsValid() bool {
	switch e {
	case TagTypeCluster, TagTypeStack:
		return true
	}
	return false
}

func (e TagType) String() string {
	return string(e)
}

func (e *TagType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TagType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TagType", str)
	}
	return nil
}

func (e TagType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UpgradeInsightStatus string

const (
	UpgradeInsightStatusPassing UpgradeInsightStatus = "PASSING"
	UpgradeInsightStatusFailed  UpgradeInsightStatus = "FAILED"
	UpgradeInsightStatusUnknown UpgradeInsightStatus = "UNKNOWN"
	UpgradeInsightStatusWarning UpgradeInsightStatus = "WARNING"
)

var AllUpgradeInsightStatus = []UpgradeInsightStatus{
	UpgradeInsightStatusPassing,
	UpgradeInsightStatusFailed,
	UpgradeInsightStatusUnknown,
	UpgradeInsightStatusWarning,
}

func (e UpgradeInsightStatus) IsValid() bool {
	switch e {
	case UpgradeInsightStatusPassing, UpgradeInsightStatusFailed, UpgradeInsightStatusUnknown, UpgradeInsightStatusWarning:
		return true
	}
	return false
}

func (e UpgradeInsightStatus) String() string {
	return string(e)
}

func (e *UpgradeInsightStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpgradeInsightStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpgradeInsightStatus", str)
	}
	return nil
}

func (e UpgradeInsightStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ValidationUniqScope string

const (
	ValidationUniqScopeProject ValidationUniqScope = "PROJECT"
	ValidationUniqScopeCluster ValidationUniqScope = "CLUSTER"
)

var AllValidationUniqScope = []ValidationUniqScope{
	ValidationUniqScopeProject,
	ValidationUniqScopeCluster,
}

func (e ValidationUniqScope) IsValid() bool {
	switch e {
	case ValidationUniqScopeProject, ValidationUniqScopeCluster:
		return true
	}
	return false
}

func (e ValidationUniqScope) String() string {
	return string(e)
}

func (e *ValidationUniqScope) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ValidationUniqScope(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ValidationUniqScope", str)
	}
	return nil
}

func (e ValidationUniqScope) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VectorStore string

const (
	VectorStoreElastic    VectorStore = "ELASTIC"
	VectorStoreOpensearch VectorStore = "OPENSEARCH"
)

var AllVectorStore = []VectorStore{
	VectorStoreElastic,
	VectorStoreOpensearch,
}

func (e VectorStore) IsValid() bool {
	switch e {
	case VectorStoreElastic, VectorStoreOpensearch:
		return true
	}
	return false
}

func (e VectorStore) String() string {
	return string(e)
}

func (e *VectorStore) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VectorStore(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VectorStore", str)
	}
	return nil
}

func (e VectorStore) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VersionCompliance string

const (
	VersionComplianceLatest    VersionCompliance = "LATEST"
	VersionComplianceCompliant VersionCompliance = "COMPLIANT"
	VersionComplianceOutdated  VersionCompliance = "OUTDATED"
)

var AllVersionCompliance = []VersionCompliance{
	VersionComplianceLatest,
	VersionComplianceCompliant,
	VersionComplianceOutdated,
}

func (e VersionCompliance) IsValid() bool {
	switch e {
	case VersionComplianceLatest, VersionComplianceCompliant, VersionComplianceOutdated:
		return true
	}
	return false
}

func (e VersionCompliance) String() string {
	return string(e)
}

func (e *VersionCompliance) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VersionCompliance(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VersionCompliance", str)
	}
	return nil
}

func (e VersionCompliance) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VulnAttackVector string

const (
	VulnAttackVectorNetwork  VulnAttackVector = "NETWORK"
	VulnAttackVectorAdjacent VulnAttackVector = "ADJACENT"
	VulnAttackVectorLocal    VulnAttackVector = "LOCAL"
	VulnAttackVectorPhysical VulnAttackVector = "PHYSICAL"
)

var AllVulnAttackVector = []VulnAttackVector{
	VulnAttackVectorNetwork,
	VulnAttackVectorAdjacent,
	VulnAttackVectorLocal,
	VulnAttackVectorPhysical,
}

func (e VulnAttackVector) IsValid() bool {
	switch e {
	case VulnAttackVectorNetwork, VulnAttackVectorAdjacent, VulnAttackVectorLocal, VulnAttackVectorPhysical:
		return true
	}
	return false
}

func (e VulnAttackVector) String() string {
	return string(e)
}

func (e *VulnAttackVector) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VulnAttackVector(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VulnAttackVector", str)
	}
	return nil
}

func (e VulnAttackVector) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VulnReportGrade string

const (
	VulnReportGradeA VulnReportGrade = "A"
	VulnReportGradeB VulnReportGrade = "B"
	VulnReportGradeC VulnReportGrade = "C"
	VulnReportGradeD VulnReportGrade = "D"
	VulnReportGradeF VulnReportGrade = "F"
)

var AllVulnReportGrade = []VulnReportGrade{
	VulnReportGradeA,
	VulnReportGradeB,
	VulnReportGradeC,
	VulnReportGradeD,
	VulnReportGradeF,
}

func (e VulnReportGrade) IsValid() bool {
	switch e {
	case VulnReportGradeA, VulnReportGradeB, VulnReportGradeC, VulnReportGradeD, VulnReportGradeF:
		return true
	}
	return false
}

func (e VulnReportGrade) String() string {
	return string(e)
}

func (e *VulnReportGrade) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VulnReportGrade(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VulnReportGrade", str)
	}
	return nil
}

func (e VulnReportGrade) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VulnSeverity string

const (
	VulnSeverityUnknown  VulnSeverity = "UNKNOWN"
	VulnSeverityLow      VulnSeverity = "LOW"
	VulnSeverityMedium   VulnSeverity = "MEDIUM"
	VulnSeverityHigh     VulnSeverity = "HIGH"
	VulnSeverityCritical VulnSeverity = "CRITICAL"
	VulnSeverityNone     VulnSeverity = "NONE"
)

var AllVulnSeverity = []VulnSeverity{
	VulnSeverityUnknown,
	VulnSeverityLow,
	VulnSeverityMedium,
	VulnSeverityHigh,
	VulnSeverityCritical,
	VulnSeverityNone,
}

func (e VulnSeverity) IsValid() bool {
	switch e {
	case VulnSeverityUnknown, VulnSeverityLow, VulnSeverityMedium, VulnSeverityHigh, VulnSeverityCritical, VulnSeverityNone:
		return true
	}
	return false
}

func (e VulnSeverity) String() string {
	return string(e)
}

func (e *VulnSeverity) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VulnSeverity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VulnSeverity", str)
	}
	return nil
}

func (e VulnSeverity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VulnUserInteraction string

const (
	VulnUserInteractionNone     VulnUserInteraction = "NONE"
	VulnUserInteractionRequired VulnUserInteraction = "REQUIRED"
)

var AllVulnUserInteraction = []VulnUserInteraction{
	VulnUserInteractionNone,
	VulnUserInteractionRequired,
}

func (e VulnUserInteraction) IsValid() bool {
	switch e {
	case VulnUserInteractionNone, VulnUserInteractionRequired:
		return true
	}
	return false
}

func (e VulnUserInteraction) String() string {
	return string(e)
}

func (e *VulnUserInteraction) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VulnUserInteraction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VulnUserInteraction", str)
	}
	return nil
}

func (e VulnUserInteraction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
